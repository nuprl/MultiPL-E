name: HumanEval_128_prod_signs
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = ans * i;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppvfw79re.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppvfw79re.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppvfw79re.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppvfw79re.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvfw79re.cpp:2:\n/tmp/tmppvfw79re.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppvfw79re.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppvfw79re.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppvfw79re.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppvfw79re.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvfw79re.cpp:2:\n/tmp/tmppvfw79re.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sign = 1;\n    for (auto i : arr)\n        sign *=\
    \ i;\n    return sign * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppnr___qc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppnr___qc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppnr___qc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppnr___qc.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppnr___qc.cpp:2:\n/tmp/tmppnr___qc.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppnr___qc.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppnr___qc.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppnr___qc.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppnr___qc.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppnr___qc.cpp:2:\n/tmp/tmppnr___qc.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (long i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp91ekazha.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp91ekazha.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp91ekazha.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp91ekazha.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp91ekazha.cpp:2:\n/tmp/tmp91ekazha.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp91ekazha.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp91ekazha.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp91ekazha.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp91ekazha.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp91ekazha.cpp:2:\n/tmp/tmp91ekazha.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long res = 0;\n    for (auto i : arr)\n        res += i\
    \ * prod;\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpuqfs8kei.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpuqfs8kei.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpuqfs8kei.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpuqfs8kei.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuqfs8kei.cpp:2:\n/tmp/tmpuqfs8kei.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpuqfs8kei.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpuqfs8kei.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpuqfs8kei.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpuqfs8kei.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuqfs8kei.cpp:2:\n/tmp/tmpuqfs8kei.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long res = 0;\n    for (auto i : arr)\n        res += i\
    \ * prod;\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_58ckzhq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_58ckzhq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_58ckzhq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_58ckzhq.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_58ckzhq.cpp:2:\n/tmp/tmp_58ckzhq.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_58ckzhq.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_58ckzhq.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_58ckzhq.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_58ckzhq.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_58ckzhq.cpp:2:\n/tmp/tmp_58ckzhq.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) {\n   \
    \     ans = std::max(ans, i * std::signbit(i));\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgs2jmbbl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgs2jmbbl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgs2jmbbl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgs2jmbbl.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgs2jmbbl.cpp:2:\n/tmp/tmpgs2jmbbl.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgs2jmbbl.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgs2jmbbl.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgs2jmbbl.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgs2jmbbl.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgs2jmbbl.cpp:2:\n/tmp/tmpgs2jmbbl.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (long i : arr) {\n   \
    \     ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppja9c5_f.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppja9c5_f.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppja9c5_f.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppja9c5_f.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppja9c5_f.cpp:2:\n/tmp/tmppja9c5_f.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppja9c5_f.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppja9c5_f.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppja9c5_f.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppja9c5_f.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppja9c5_f.cpp:2:\n/tmp/tmppja9c5_f.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr) {\n   \
    \     ans *= i;\n        if (i < 0) ans *= -1;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptow6du_4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptow6du_4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptow6du_4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptow6du_4.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptow6du_4.cpp:2:\n/tmp/tmptow6du_4.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptow6du_4.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptow6du_4.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptow6du_4.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptow6du_4.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptow6du_4.cpp:2:\n/tmp/tmptow6du_4.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long res = 0;\n    for (auto i : arr)\n        res += i\
    \ * prod;\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_bb6j2fq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_bb6j2fq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_bb6j2fq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_bb6j2fq.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_bb6j2fq.cpp:2:\n/tmp/tmp_bb6j2fq.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_bb6j2fq.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_bb6j2fq.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_bb6j2fq.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_bb6j2fq.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_bb6j2fq.cpp:2:\n/tmp/tmp_bb6j2fq.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n \
    \       ans += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps46emvhj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmps46emvhj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmps46emvhj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmps46emvhj.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps46emvhj.cpp:2:\n/tmp/tmps46emvhj.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmps46emvhj.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmps46emvhj.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmps46emvhj.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmps46emvhj.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps46emvhj.cpp:2:\n/tmp/tmps46emvhj.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr80mgg2k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpr80mgg2k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpr80mgg2k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpr80mgg2k.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr80mgg2k.cpp:2:\n/tmp/tmpr80mgg2k.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpr80mgg2k.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpr80mgg2k.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpr80mgg2k.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpr80mgg2k.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr80mgg2k.cpp:2:\n/tmp/tmpr80mgg2k.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (auto i : arr)\n\
    \        ans = std::max(ans, i * ans);\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfz94h01g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfz94h01g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfz94h01g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfz94h01g.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfz94h01g.cpp:2:\n/tmp/tmpfz94h01g.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfz94h01g.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfz94h01g.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfz94h01g.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfz94h01g.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfz94h01g.cpp:2:\n/tmp/tmpfz94h01g.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxj2boj7u.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxj2boj7u.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxj2boj7u.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxj2boj7u.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxj2boj7u.cpp:2:\n/tmp/tmpxj2boj7u.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxj2boj7u.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxj2boj7u.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxj2boj7u.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxj2boj7u.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxj2boj7u.cpp:2:\n/tmp/tmpxj2boj7u.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 1;\n    for (auto i : arr) {\n        ans\
    \ *= i;\n        ans *= (i != 0);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqu3oztx_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqu3oztx_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqu3oztx_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqu3oztx_.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqu3oztx_.cpp:2:\n/tmp/tmpqu3oztx_.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqu3oztx_.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqu3oztx_.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqu3oztx_.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqu3oztx_.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqu3oztx_.cpp:2:\n/tmp/tmpqu3oztx_.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (long i : arr)\
    \ {\n        ans += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjuas7u68.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjuas7u68.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjuas7u68.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjuas7u68.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjuas7u68.cpp:2:\n/tmp/tmpjuas7u68.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjuas7u68.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjuas7u68.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjuas7u68.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjuas7u68.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjuas7u68.cpp:2:\n/tmp/tmpjuas7u68.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprqk89l_m.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprqk89l_m.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprqk89l_m.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprqk89l_m.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprqk89l_m.cpp:2:\n/tmp/tmprqk89l_m.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprqk89l_m.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprqk89l_m.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprqk89l_m.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprqk89l_m.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprqk89l_m.cpp:2:\n/tmp/tmprqk89l_m.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n        sum\
    \ += std::abs(i);\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpravak3wv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpravak3wv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpravak3wv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpravak3wv.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpravak3wv.cpp:2:\n/tmp/tmpravak3wv.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpravak3wv.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpravak3wv.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpravak3wv.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpravak3wv.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpravak3wv.cpp:2:\n/tmp/tmpravak3wv.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbp95o14w.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbp95o14w.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbp95o14w.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbp95o14w.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbp95o14w.cpp:2:\n/tmp/tmpbp95o14w.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbp95o14w.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbp95o14w.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbp95o14w.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbp95o14w.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbp95o14w.cpp:2:\n/tmp/tmpbp95o14w.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (long i : arr) {\n \
    \       res += std::abs(i) * std::sign(i);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy9x7fvaa.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpy9x7fvaa.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpy9x7fvaa.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpy9x7fvaa.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy9x7fvaa.cpp:2:\n/tmp/tmpy9x7fvaa.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpy9x7fvaa.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpy9x7fvaa.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpy9x7fvaa.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpy9x7fvaa.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy9x7fvaa.cpp:2:\n/tmp/tmpy9x7fvaa.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sign = 1;\n    for (auto i : arr) {\n        sign\
    \ *= i;\n    }\n    return prod * sign;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcjbyshxo.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcjbyshxo.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcjbyshxo.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcjbyshxo.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcjbyshxo.cpp:2:\n/tmp/tmpcjbyshxo.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcjbyshxo.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcjbyshxo.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcjbyshxo.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcjbyshxo.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcjbyshxo.cpp:2:\n/tmp/tmpcjbyshxo.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 1;\n    for (long i : arr)\n   \
    \     ans *= i;\n    long sign = 1;\n    for (long i : arr)\n        sign *= i;\n\
    \    return ans * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplgr93dy8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplgr93dy8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplgr93dy8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplgr93dy8.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplgr93dy8.cpp:2:\n/tmp/tmplgr93dy8.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplgr93dy8.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplgr93dy8.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplgr93dy8.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplgr93dy8.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplgr93dy8.cpp:2:\n/tmp/tmplgr93dy8.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 1;\n    for (auto i : arr) {\n        ans\
    \ *= i;\n        if (i < 0) ans *= -1;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprkzs9hwy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprkzs9hwy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprkzs9hwy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprkzs9hwy.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprkzs9hwy.cpp:2:\n/tmp/tmprkzs9hwy.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprkzs9hwy.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprkzs9hwy.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprkzs9hwy.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprkzs9hwy.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprkzs9hwy.cpp:2:\n/tmp/tmprkzs9hwy.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sign = 1;\n    for (auto i : arr) {\n        sign\
    \ *= i;\n    }\n    return sign * prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcd2w3xjx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcd2w3xjx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcd2w3xjx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcd2w3xjx.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcd2w3xjx.cpp:2:\n/tmp/tmpcd2w3xjx.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcd2w3xjx.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcd2w3xjx.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcd2w3xjx.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcd2w3xjx.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcd2w3xjx.cpp:2:\n/tmp/tmpcd2w3xjx.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n        sum\
    \ += std::abs(i);\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvy3r1poj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvy3r1poj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvy3r1poj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvy3r1poj.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvy3r1poj.cpp:2:\n/tmp/tmpvy3r1poj.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvy3r1poj.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvy3r1poj.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvy3r1poj.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvy3r1poj.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvy3r1poj.cpp:2:\n/tmp/tmpvy3r1poj.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ijt00_v.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9ijt00_v.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9ijt00_v.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9ijt00_v.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ijt00_v.cpp:2:\n/tmp/tmp9ijt00_v.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9ijt00_v.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9ijt00_v.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9ijt00_v.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9ijt00_v.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ijt00_v.cpp:2:\n/tmp/tmp9ijt00_v.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long prod = 1;\n  for (long i : arr)\n    prod *=\
    \ i;\n  long sum = 0;\n  for (long i : arr)\n    sum += std::abs(i);\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu7x2o1pc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu7x2o1pc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu7x2o1pc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu7x2o1pc.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu7x2o1pc.cpp:2:\n/tmp/tmpu7x2o1pc.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu7x2o1pc.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu7x2o1pc.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu7x2o1pc.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu7x2o1pc.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu7x2o1pc.cpp:2:\n/tmp/tmpu7x2o1pc.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\
    \ {\n        ans *= i;\n        ans *= (i < 0) ? -1 : 1;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfmcz78sb.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfmcz78sb.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfmcz78sb.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfmcz78sb.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfmcz78sb.cpp:2:\n/tmp/tmpfmcz78sb.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfmcz78sb.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfmcz78sb.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfmcz78sb.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfmcz78sb.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfmcz78sb.cpp:2:\n/tmp/tmpfmcz78sb.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\
    \ {\n        ans = std::max(ans, i * std::signbit(i));\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcryym0gp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcryym0gp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcryym0gp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcryym0gp.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcryym0gp.cpp:2:\n/tmp/tmpcryym0gp.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcryym0gp.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcryym0gp.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcryym0gp.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcryym0gp.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcryym0gp.cpp:2:\n/tmp/tmpcryym0gp.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr) {\n   \
    \     ans *= i;\n        ans *= (i >> 31);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt07dwjg1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpt07dwjg1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpt07dwjg1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpt07dwjg1.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt07dwjg1.cpp:2:\n/tmp/tmpt07dwjg1.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpt07dwjg1.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpt07dwjg1.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpt07dwjg1.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpt07dwjg1.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt07dwjg1.cpp:2:\n/tmp/tmpt07dwjg1.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 1;\n    for (long long i :\
    \ arr)\n        ans *= i;\n    for (long long i : arr)\n        ans *= (i & 1);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1fo2z2en.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1fo2z2en.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1fo2z2en.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1fo2z2en.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1fo2z2en.cpp:2:\n/tmp/tmp1fo2z2en.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1fo2z2en.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1fo2z2en.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1fo2z2en.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1fo2z2en.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1fo2z2en.cpp:2:\n/tmp/tmp1fo2z2en.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sign = 1;\n    for (auto i : arr)\n        sign *=\
    \ i;\n    return sign * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpdn_w9p2x.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdn_w9p2x.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdn_w9p2x.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdn_w9p2x.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdn_w9p2x.cpp:2:\n/tmp/tmpdn_w9p2x.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdn_w9p2x.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdn_w9p2x.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdn_w9p2x.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdn_w9p2x.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdn_w9p2x.cpp:2:\n/tmp/tmpdn_w9p2x.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa6h_fjp9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa6h_fjp9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa6h_fjp9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa6h_fjp9.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa6h_fjp9.cpp:2:\n/tmp/tmpa6h_fjp9.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa6h_fjp9.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa6h_fjp9.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa6h_fjp9.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa6h_fjp9.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa6h_fjp9.cpp:2:\n/tmp/tmpa6h_fjp9.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = std::max(ans, i * std::signbit(i));\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwr1qf5f7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwr1qf5f7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwr1qf5f7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwr1qf5f7.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwr1qf5f7.cpp:2:\n/tmp/tmpwr1qf5f7.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwr1qf5f7.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwr1qf5f7.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwr1qf5f7.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwr1qf5f7.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwr1qf5f7.cpp:2:\n/tmp/tmpwr1qf5f7.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0vz3n6ws.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0vz3n6ws.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0vz3n6ws.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0vz3n6ws.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0vz3n6ws.cpp:2:\n/tmp/tmp0vz3n6ws.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0vz3n6ws.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0vz3n6ws.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0vz3n6ws.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0vz3n6ws.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0vz3n6ws.cpp:2:\n/tmp/tmp0vz3n6ws.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long res = 0;\n    for (auto i : arr) {\n        res\
    \ += abs(i) * prod;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4fi1oqw2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4fi1oqw2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4fi1oqw2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4fi1oqw2.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4fi1oqw2.cpp:2:\n/tmp/tmp4fi1oqw2.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4fi1oqw2.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4fi1oqw2.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4fi1oqw2.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4fi1oqw2.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4fi1oqw2.cpp:2:\n/tmp/tmp4fi1oqw2.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (long i : arr) {\n \
    \       res += std::abs(i);\n    }\n    for (long i : arr) {\n        res *= std::signbit(i);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmphtjl_d4g.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphtjl_d4g.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphtjl_d4g.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphtjl_d4g.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphtjl_d4g.cpp:2:\n/tmp/tmphtjl_d4g.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphtjl_d4g.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphtjl_d4g.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphtjl_d4g.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphtjl_d4g.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphtjl_d4g.cpp:2:\n/tmp/tmphtjl_d4g.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_vt31rwb.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_vt31rwb.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_vt31rwb.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_vt31rwb.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vt31rwb.cpp:2:\n/tmp/tmp_vt31rwb.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_vt31rwb.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_vt31rwb.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_vt31rwb.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_vt31rwb.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_vt31rwb.cpp:2:\n/tmp/tmp_vt31rwb.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long res = 0;\n    for (auto i : arr) {\n        res\
    \ += i * prod;\n    }\n    return res;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvhievnon.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvhievnon.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvhievnon.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvhievnon.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvhievnon.cpp:2:\n/tmp/tmpvhievnon.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvhievnon.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvhievnon.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvhievnon.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvhievnon.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvhievnon.cpp:2:\n/tmp/tmpvhievnon.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp86tl8i1x.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp86tl8i1x.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp86tl8i1x.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp86tl8i1x.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp86tl8i1x.cpp:2:\n/tmp/tmp86tl8i1x.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp86tl8i1x.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp86tl8i1x.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp86tl8i1x.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp86tl8i1x.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp86tl8i1x.cpp:2:\n/tmp/tmp86tl8i1x.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sign = 1;\n    for (auto i : arr)\n        sign *=\
    \ i;\n    return sign * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpr8p6nep9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpr8p6nep9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpr8p6nep9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpr8p6nep9.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr8p6nep9.cpp:2:\n/tmp/tmpr8p6nep9.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpr8p6nep9.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpr8p6nep9.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpr8p6nep9.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpr8p6nep9.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr8p6nep9.cpp:2:\n/tmp/tmpr8p6nep9.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long prod = 1;\n  for (auto i : arr)\n    prod *=\
    \ i;\n  long res = 0;\n  for (auto i : arr)\n    res += std::abs(i) * prod;\n\
    \  return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpimdv5cs3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpimdv5cs3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpimdv5cs3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpimdv5cs3.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpimdv5cs3.cpp:2:\n/tmp/tmpimdv5cs3.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpimdv5cs3.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpimdv5cs3.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpimdv5cs3.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpimdv5cs3.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpimdv5cs3.cpp:2:\n/tmp/tmpimdv5cs3.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = arr[0];\n    for (auto i :\
    \ arr)\n        ans = ans * i;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfwrf7fys.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfwrf7fys.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfwrf7fys.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfwrf7fys.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfwrf7fys.cpp:2:\n/tmp/tmpfwrf7fys.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfwrf7fys.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfwrf7fys.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfwrf7fys.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfwrf7fys.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfwrf7fys.cpp:2:\n/tmp/tmpfwrf7fys.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm6ylgw89.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpm6ylgw89.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpm6ylgw89.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpm6ylgw89.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm6ylgw89.cpp:2:\n/tmp/tmpm6ylgw89.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpm6ylgw89.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpm6ylgw89.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpm6ylgw89.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpm6ylgw89.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm6ylgw89.cpp:2:\n/tmp/tmpm6ylgw89.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n \
    \       res += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0z7cmjlp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0z7cmjlp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0z7cmjlp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0z7cmjlp.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0z7cmjlp.cpp:2:\n/tmp/tmp0z7cmjlp.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0z7cmjlp.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0z7cmjlp.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0z7cmjlp.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0z7cmjlp.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0z7cmjlp.cpp:2:\n/tmp/tmp0z7cmjlp.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr)\n\
    \        ans *= i;\n    long long sign = 1;\n    for (auto i : arr)\n        sign\
    \ *= i;\n    return ans * sign;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpp_zy9k3s.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp_zy9k3s.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp_zy9k3s.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp_zy9k3s.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp_zy9k3s.cpp:2:\n/tmp/tmpp_zy9k3s.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp_zy9k3s.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp_zy9k3s.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp_zy9k3s.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp_zy9k3s.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp_zy9k3s.cpp:2:\n/tmp/tmpp_zy9k3s.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n        res\
    \ += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp2z0l72by.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2z0l72by.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2z0l72by.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2z0l72by.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2z0l72by.cpp:2:\n/tmp/tmp2z0l72by.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2z0l72by.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2z0l72by.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2z0l72by.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2z0l72by.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2z0l72by.cpp:2:\n/tmp/tmp2z0l72by.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long res = 0;\n  for (int i = 0; i < arr.size(); i++) {\n \
    \   res += arr[i] * (arr[i] < 0 ? -1 : 1);\n  }\n  return res;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwwrd0iib.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwwrd0iib.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwwrd0iib.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwwrd0iib.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwwrd0iib.cpp:2:\n/tmp/tmpwwrd0iib.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwwrd0iib.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwwrd0iib.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwwrd0iib.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwwrd0iib.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwwrd0iib.cpp:2:\n/tmp/tmpwwrd0iib.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2le9nyoc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2le9nyoc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2le9nyoc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2le9nyoc.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2le9nyoc.cpp:2:\n/tmp/tmp2le9nyoc.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2le9nyoc.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2le9nyoc.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2le9nyoc.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2le9nyoc.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2le9nyoc.cpp:2:\n/tmp/tmp2le9nyoc.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqy0fvo_a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqy0fvo_a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqy0fvo_a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqy0fvo_a.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqy0fvo_a.cpp:2:\n/tmp/tmpqy0fvo_a.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqy0fvo_a.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqy0fvo_a.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqy0fvo_a.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqy0fvo_a.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqy0fvo_a.cpp:2:\n/tmp/tmpqy0fvo_a.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnxqpaixc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnxqpaixc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnxqpaixc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnxqpaixc.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnxqpaixc.cpp:2:\n/tmp/tmpnxqpaixc.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnxqpaixc.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnxqpaixc.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnxqpaixc.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnxqpaixc.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnxqpaixc.cpp:2:\n/tmp/tmpnxqpaixc.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i);\n\
    \    return std::optional<long>(prod * sum);\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5rqla91t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5rqla91t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5rqla91t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5rqla91t.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5rqla91t.cpp:2:\n/tmp/tmp5rqla91t.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5rqla91t.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5rqla91t.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5rqla91t.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5rqla91t.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5rqla91t.cpp:2:\n/tmp/tmp5rqla91t.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long ans = arr[0];\n  for (int i = 1; i < arr.size(); ++i)\
    \ {\n    ans = ans * arr[i];\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4c3asurh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4c3asurh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4c3asurh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4c3asurh.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4c3asurh.cpp:2:\n/tmp/tmp4c3asurh.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4c3asurh.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4c3asurh.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4c3asurh.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4c3asurh.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4c3asurh.cpp:2:\n/tmp/tmp4c3asurh.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i);\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0_qpald6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0_qpald6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0_qpald6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0_qpald6.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0_qpald6.cpp:2:\n/tmp/tmp0_qpald6.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0_qpald6.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0_qpald6.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0_qpald6.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0_qpald6.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0_qpald6.cpp:2:\n/tmp/tmp0_qpald6.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i)\
    \ * std::signbit(i);\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpywte_967.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpywte_967.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpywte_967.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpywte_967.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpywte_967.cpp:2:\n/tmp/tmpywte_967.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpywte_967.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpywte_967.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpywte_967.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpywte_967.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpywte_967.cpp:2:\n/tmp/tmpywte_967.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long res = 0;\n    for (auto i : arr)\n        res += i\
    \ * prod;\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprrhiiejd.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprrhiiejd.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprrhiiejd.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprrhiiejd.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprrhiiejd.cpp:2:\n/tmp/tmprrhiiejd.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprrhiiejd.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprrhiiejd.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprrhiiejd.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprrhiiejd.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprrhiiejd.cpp:2:\n/tmp/tmprrhiiejd.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (auto i : arr)\n   \
    \     ans += i * std::signbit(i);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgi4e3fso.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgi4e3fso.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgi4e3fso.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgi4e3fso.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgi4e3fso.cpp:2:\n/tmp/tmpgi4e3fso.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgi4e3fso.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgi4e3fso.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgi4e3fso.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgi4e3fso.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgi4e3fso.cpp:2:\n/tmp/tmpgi4e3fso.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n        res\
    \ += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpl6mv2xx9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl6mv2xx9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl6mv2xx9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl6mv2xx9.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl6mv2xx9.cpp:2:\n/tmp/tmpl6mv2xx9.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl6mv2xx9.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl6mv2xx9.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl6mv2xx9.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl6mv2xx9.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl6mv2xx9.cpp:2:\n/tmp/tmpl6mv2xx9.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans = ans\
    \ * i;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnypjio_q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnypjio_q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnypjio_q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnypjio_q.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnypjio_q.cpp:2:\n/tmp/tmpnypjio_q.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnypjio_q.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnypjio_q.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnypjio_q.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnypjio_q.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnypjio_q.cpp:2:\n/tmp/tmpnypjio_q.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcfm8wies.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcfm8wies.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcfm8wies.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcfm8wies.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcfm8wies.cpp:2:\n/tmp/tmpcfm8wies.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcfm8wies.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcfm8wies.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcfm8wies.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcfm8wies.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcfm8wies.cpp:2:\n/tmp/tmpcfm8wies.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppvemmbrn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppvemmbrn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppvemmbrn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppvemmbrn.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvemmbrn.cpp:2:\n/tmp/tmppvemmbrn.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppvemmbrn.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppvemmbrn.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppvemmbrn.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppvemmbrn.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvemmbrn.cpp:2:\n/tmp/tmppvemmbrn.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (auto i : arr) {\n        ans\
    \ += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptyzmzbro.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptyzmzbro.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptyzmzbro.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptyzmzbro.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptyzmzbro.cpp:2:\n/tmp/tmptyzmzbro.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptyzmzbro.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptyzmzbro.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptyzmzbro.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptyzmzbro.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptyzmzbro.cpp:2:\n/tmp/tmptyzmzbro.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (long i : arr) {\n   \
    \     ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiyj0sw4n.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpiyj0sw4n.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpiyj0sw4n.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpiyj0sw4n.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiyj0sw4n.cpp:2:\n/tmp/tmpiyj0sw4n.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpiyj0sw4n.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpiyj0sw4n.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpiyj0sw4n.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpiyj0sw4n.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiyj0sw4n.cpp:2:\n/tmp/tmpiyj0sw4n.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long product = 1;\n    for (auto i : arr)\n\
    \        product *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum\
    \ += std::abs(i);\n    return sum * product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptz9vqt34.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptz9vqt34.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptz9vqt34.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptz9vqt34.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptz9vqt34.cpp:2:\n/tmp/tmptz9vqt34.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptz9vqt34.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptz9vqt34.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptz9vqt34.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptz9vqt34.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptz9vqt34.cpp:2:\n/tmp/tmptz9vqt34.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans *=\
    \ i;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp02j6wk9p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp02j6wk9p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp02j6wk9p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp02j6wk9p.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp02j6wk9p.cpp:2:\n/tmp/tmp02j6wk9p.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp02j6wk9p.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp02j6wk9p.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp02j6wk9p.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp02j6wk9p.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp02j6wk9p.cpp:2:\n/tmp/tmp02j6wk9p.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long product = 1;\n    long sign = 1;\n   \
    \ for (long i : arr) {\n        product *= i;\n        sign *= (i < 0) ? -1 :\
    \ 1;\n    }\n    return std::make_optional(sign * product);\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2nhvmah9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2nhvmah9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2nhvmah9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2nhvmah9.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2nhvmah9.cpp:2:\n/tmp/tmp2nhvmah9.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2nhvmah9.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2nhvmah9.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2nhvmah9.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2nhvmah9.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2nhvmah9.cpp:2:\n/tmp/tmp2nhvmah9.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 0;\n    for (long i : arr) {\n        res\
    \ += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7aclbp3s.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7aclbp3s.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7aclbp3s.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7aclbp3s.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7aclbp3s.cpp:2:\n/tmp/tmp7aclbp3s.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7aclbp3s.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7aclbp3s.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7aclbp3s.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7aclbp3s.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7aclbp3s.cpp:2:\n/tmp/tmp7aclbp3s.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans *=\
    \ i;\n    for (long i : arr) ans *= (i != 0? 1: -1);\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaz56xf8k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpaz56xf8k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpaz56xf8k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpaz56xf8k.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaz56xf8k.cpp:2:\n/tmp/tmpaz56xf8k.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpaz56xf8k.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpaz56xf8k.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpaz56xf8k.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpaz56xf8k.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaz56xf8k.cpp:2:\n/tmp/tmpaz56xf8k.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i);\n    }\n    return product * sum;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjb0yebbq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjb0yebbq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjb0yebbq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjb0yebbq.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjb0yebbq.cpp:2:\n/tmp/tmpjb0yebbq.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjb0yebbq.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjb0yebbq.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjb0yebbq.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjb0yebbq.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjb0yebbq.cpp:2:\n/tmp/tmpjb0yebbq.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2h1grbiu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2h1grbiu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2h1grbiu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2h1grbiu.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2h1grbiu.cpp:2:\n/tmp/tmp2h1grbiu.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2h1grbiu.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2h1grbiu.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2h1grbiu.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2h1grbiu.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2h1grbiu.cpp:2:\n/tmp/tmp2h1grbiu.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sign = 1;\n    for (auto i : arr)\n        sign *=\
    \ i;\n    return sign * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprj8usk3l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprj8usk3l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprj8usk3l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprj8usk3l.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprj8usk3l.cpp:2:\n/tmp/tmprj8usk3l.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprj8usk3l.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprj8usk3l.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprj8usk3l.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprj8usk3l.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprj8usk3l.cpp:2:\n/tmp/tmprj8usk3l.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) prod *= i;\n\
    \    long sign = 1;\n    for (auto i : arr) sign *= i;\n    return sign * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6o1hmopq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6o1hmopq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6o1hmopq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6o1hmopq.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6o1hmopq.cpp:2:\n/tmp/tmp6o1hmopq.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6o1hmopq.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6o1hmopq.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6o1hmopq.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6o1hmopq.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6o1hmopq.cpp:2:\n/tmp/tmp6o1hmopq.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr)\
    \ {\n        ans *= i;\n        ans *= (i >> 31);\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpby6dwlen.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpby6dwlen.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpby6dwlen.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpby6dwlen.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpby6dwlen.cpp:2:\n/tmp/tmpby6dwlen.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpby6dwlen.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpby6dwlen.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpby6dwlen.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpby6dwlen.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpby6dwlen.cpp:2:\n/tmp/tmpby6dwlen.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (long i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (long i : arr) {\n     \
    \   sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjrqdvhft.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjrqdvhft.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjrqdvhft.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjrqdvhft.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjrqdvhft.cpp:2:\n/tmp/tmpjrqdvhft.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjrqdvhft.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjrqdvhft.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjrqdvhft.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjrqdvhft.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjrqdvhft.cpp:2:\n/tmp/tmpjrqdvhft.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0 ? -1 : 1);\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl5d6tila.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl5d6tila.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl5d6tila.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl5d6tila.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl5d6tila.cpp:2:\n/tmp/tmpl5d6tila.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl5d6tila.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl5d6tila.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl5d6tila.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl5d6tila.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl5d6tila.cpp:2:\n/tmp/tmpl5d6tila.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (auto i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5h7p5ykd.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5h7p5ykd.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5h7p5ykd.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5h7p5ykd.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5h7p5ykd.cpp:2:\n/tmp/tmp5h7p5ykd.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5h7p5ykd.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5h7p5ykd.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5h7p5ykd.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5h7p5ykd.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5h7p5ykd.cpp:2:\n/tmp/tmp5h7p5ykd.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = std::max(ans, i * std::signbit(i));\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjv8g4fkh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjv8g4fkh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjv8g4fkh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjv8g4fkh.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjv8g4fkh.cpp:2:\n/tmp/tmpjv8g4fkh.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjv8g4fkh.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjv8g4fkh.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjv8g4fkh.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjv8g4fkh.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjv8g4fkh.cpp:2:\n/tmp/tmpjv8g4fkh.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n \
    \       ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprzt4_ypa.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprzt4_ypa.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprzt4_ypa.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprzt4_ypa.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprzt4_ypa.cpp:2:\n/tmp/tmprzt4_ypa.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprzt4_ypa.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprzt4_ypa.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprzt4_ypa.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprzt4_ypa.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprzt4_ypa.cpp:2:\n/tmp/tmprzt4_ypa.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (long i : arr) {\n   \
    \     ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgoiw8itt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgoiw8itt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgoiw8itt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgoiw8itt.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgoiw8itt.cpp:2:\n/tmp/tmpgoiw8itt.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgoiw8itt.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgoiw8itt.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgoiw8itt.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgoiw8itt.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgoiw8itt.cpp:2:\n/tmp/tmpgoiw8itt.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long ans = arr[0];\n  for (long i : arr) ans = std::max(ans,\
    \ i * std::signbit(i));\n  return ans;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpt975qth2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpt975qth2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpt975qth2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpt975qth2.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt975qth2.cpp:2:\n/tmp/tmpt975qth2.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpt975qth2.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpt975qth2.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpt975qth2.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpt975qth2.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt975qth2.cpp:2:\n/tmp/tmpt975qth2.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 1;\n    for (auto i : arr) {\n        ans\
    \ *= i;\n        ans *= (i != 0);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8y_qkqfk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp8y_qkqfk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp8y_qkqfk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp8y_qkqfk.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8y_qkqfk.cpp:2:\n/tmp/tmp8y_qkqfk.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp8y_qkqfk.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp8y_qkqfk.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp8y_qkqfk.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp8y_qkqfk.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8y_qkqfk.cpp:2:\n/tmp/tmp8y_qkqfk.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n\
    \        product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n \
    \       sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaqqr2_fr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpaqqr2_fr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpaqqr2_fr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpaqqr2_fr.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaqqr2_fr.cpp:2:\n/tmp/tmpaqqr2_fr.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpaqqr2_fr.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpaqqr2_fr.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpaqqr2_fr.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpaqqr2_fr.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaqqr2_fr.cpp:2:\n/tmp/tmpaqqr2_fr.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long long ans = 0;\n  for (long long i : arr) {\n\
    \    ans += i * std::signbit(i);\n  }\n  return ans;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpigjj534x.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpigjj534x.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpigjj534x.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpigjj534x.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpigjj534x.cpp:2:\n/tmp/tmpigjj534x.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpigjj534x.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpigjj534x.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpigjj534x.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpigjj534x.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpigjj534x.cpp:2:\n/tmp/tmpigjj534x.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n \
    \       res = res * i;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpdfhycyih.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdfhycyih.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdfhycyih.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdfhycyih.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdfhycyih.cpp:2:\n/tmp/tmpdfhycyih.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdfhycyih.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdfhycyih.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdfhycyih.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdfhycyih.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdfhycyih.cpp:2:\n/tmp/tmpdfhycyih.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr) {\n   \
    \     ans += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps7qa1sht.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmps7qa1sht.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmps7qa1sht.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmps7qa1sht.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps7qa1sht.cpp:2:\n/tmp/tmps7qa1sht.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmps7qa1sht.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmps7qa1sht.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmps7qa1sht.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmps7qa1sht.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps7qa1sht.cpp:2:\n/tmp/tmps7qa1sht.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpncdsbwya.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpncdsbwya.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpncdsbwya.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpncdsbwya.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpncdsbwya.cpp:2:\n/tmp/tmpncdsbwya.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpncdsbwya.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpncdsbwya.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpncdsbwya.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpncdsbwya.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpncdsbwya.cpp:2:\n/tmp/tmpncdsbwya.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sign = 1;\n    for (auto i : arr)\n        sign *=\
    \ i;\n    return sign * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp37xkdmzp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp37xkdmzp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp37xkdmzp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp37xkdmzp.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp37xkdmzp.cpp:2:\n/tmp/tmp37xkdmzp.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp37xkdmzp.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp37xkdmzp.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp37xkdmzp.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp37xkdmzp.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp37xkdmzp.cpp:2:\n/tmp/tmp37xkdmzp.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans = std::max(ans,\
    \ i * std::signbit(i));\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6nezab6r.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6nezab6r.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6nezab6r.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6nezab6r.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6nezab6r.cpp:2:\n/tmp/tmp6nezab6r.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6nezab6r.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6nezab6r.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6nezab6r.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6nezab6r.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6nezab6r.cpp:2:\n/tmp/tmp6nezab6r.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans *=\
    \ i;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpukuw_x7l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpukuw_x7l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpukuw_x7l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpukuw_x7l.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpukuw_x7l.cpp:2:\n/tmp/tmpukuw_x7l.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpukuw_x7l.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpukuw_x7l.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpukuw_x7l.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpukuw_x7l.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpukuw_x7l.cpp:2:\n/tmp/tmpukuw_x7l.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpacmht4ca.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpacmht4ca.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpacmht4ca.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpacmht4ca.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpacmht4ca.cpp:2:\n/tmp/tmpacmht4ca.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpacmht4ca.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpacmht4ca.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpacmht4ca.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpacmht4ca.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpacmht4ca.cpp:2:\n/tmp/tmpacmht4ca.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n \
    \       res += std::abs(i) * std::sign(i);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqj5bbxs0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqj5bbxs0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqj5bbxs0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqj5bbxs0.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqj5bbxs0.cpp:2:\n/tmp/tmpqj5bbxs0.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqj5bbxs0.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqj5bbxs0.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqj5bbxs0.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqj5bbxs0.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqj5bbxs0.cpp:2:\n/tmp/tmpqj5bbxs0.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (long i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphxr0a8t0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphxr0a8t0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphxr0a8t0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphxr0a8t0.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphxr0a8t0.cpp:2:\n/tmp/tmphxr0a8t0.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphxr0a8t0.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphxr0a8t0.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphxr0a8t0.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphxr0a8t0.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphxr0a8t0.cpp:2:\n/tmp/tmphxr0a8t0.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv4m73r00.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpv4m73r00.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpv4m73r00.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpv4m73r00.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv4m73r00.cpp:2:\n/tmp/tmpv4m73r00.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpv4m73r00.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpv4m73r00.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpv4m73r00.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpv4m73r00.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv4m73r00.cpp:2:\n/tmp/tmpv4m73r00.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans *=\
    \ i;\n    for (long i : arr) ans *= (i < 0) ? -1 : 1;\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1e8fk8h2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1e8fk8h2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1e8fk8h2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1e8fk8h2.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1e8fk8h2.cpp:2:\n/tmp/tmp1e8fk8h2.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1e8fk8h2.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1e8fk8h2.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1e8fk8h2.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1e8fk8h2.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1e8fk8h2.cpp:2:\n/tmp/tmp1e8fk8h2.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n \
    \       ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbdwnd0na.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbdwnd0na.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbdwnd0na.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbdwnd0na.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbdwnd0na.cpp:2:\n/tmp/tmpbdwnd0na.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbdwnd0na.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbdwnd0na.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbdwnd0na.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbdwnd0na.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbdwnd0na.cpp:2:\n/tmp/tmpbdwnd0na.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n \
    \       res += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps31s_1_p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmps31s_1_p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmps31s_1_p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmps31s_1_p.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps31s_1_p.cpp:2:\n/tmp/tmps31s_1_p.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmps31s_1_p.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmps31s_1_p.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmps31s_1_p.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmps31s_1_p.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps31s_1_p.cpp:2:\n/tmp/tmps31s_1_p.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjyr__jdn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjyr__jdn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjyr__jdn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjyr__jdn.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjyr__jdn.cpp:2:\n/tmp/tmpjyr__jdn.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjyr__jdn.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjyr__jdn.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjyr__jdn.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjyr__jdn.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjyr__jdn.cpp:2:\n/tmp/tmpjyr__jdn.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n\
    \        product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n \
    \       sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzf1z1ea9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzf1z1ea9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzf1z1ea9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzf1z1ea9.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzf1z1ea9.cpp:2:\n/tmp/tmpzf1z1ea9.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzf1z1ea9.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzf1z1ea9.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzf1z1ea9.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzf1z1ea9.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzf1z1ea9.cpp:2:\n/tmp/tmpzf1z1ea9.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 1;\n    for (auto i : arr) {\n        ans\
    \ *= i;\n        ans *= (i < 0) ? -1 : 1;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkmfod4ob.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkmfod4ob.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkmfod4ob.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkmfod4ob.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkmfod4ob.cpp:2:\n/tmp/tmpkmfod4ob.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkmfod4ob.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkmfod4ob.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkmfod4ob.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkmfod4ob.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkmfod4ob.cpp:2:\n/tmp/tmpkmfod4ob.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\
    \ {\n        ans = std::max(ans, i * std::abs(i));\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1nm6nfex.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1nm6nfex.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1nm6nfex.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1nm6nfex.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1nm6nfex.cpp:2:\n/tmp/tmp1nm6nfex.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1nm6nfex.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1nm6nfex.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1nm6nfex.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1nm6nfex.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1nm6nfex.cpp:2:\n/tmp/tmp1nm6nfex.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\
    \ {\n        ans = ans * i;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1u8kx1o2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1u8kx1o2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1u8kx1o2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1u8kx1o2.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1u8kx1o2.cpp:2:\n/tmp/tmp1u8kx1o2.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1u8kx1o2.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1u8kx1o2.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1u8kx1o2.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1u8kx1o2.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1u8kx1o2.cpp:2:\n/tmp/tmp1u8kx1o2.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnz0v65tx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnz0v65tx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnz0v65tx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnz0v65tx.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnz0v65tx.cpp:2:\n/tmp/tmpnz0v65tx.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnz0v65tx.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnz0v65tx.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnz0v65tx.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnz0v65tx.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnz0v65tx.cpp:2:\n/tmp/tmpnz0v65tx.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (long i : arr) {\n \
    \       res += std::abs(i) * std::sign(i);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj89s23wh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpj89s23wh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpj89s23wh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpj89s23wh.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj89s23wh.cpp:2:\n/tmp/tmpj89s23wh.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpj89s23wh.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpj89s23wh.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpj89s23wh.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpj89s23wh.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj89s23wh.cpp:2:\n/tmp/tmpj89s23wh.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = std::max(ans, i * std::signbit(i));\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5xekcpo5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5xekcpo5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5xekcpo5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5xekcpo5.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5xekcpo5.cpp:2:\n/tmp/tmp5xekcpo5.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5xekcpo5.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5xekcpo5.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5xekcpo5.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5xekcpo5.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5xekcpo5.cpp:2:\n/tmp/tmp5xekcpo5.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (auto i : arr)\n\
    \        ans *= i;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_ph7_f36.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_ph7_f36.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_ph7_f36.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_ph7_f36.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_ph7_f36.cpp:2:\n/tmp/tmp_ph7_f36.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_ph7_f36.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_ph7_f36.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_ph7_f36.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_ph7_f36.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_ph7_f36.cpp:2:\n/tmp/tmp_ph7_f36.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr)\n        ans += sign * i;\n    sign *= -1;\n    for (auto i : arr)\n  \
    \      ans *= sign;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmphcaohv3l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphcaohv3l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphcaohv3l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphcaohv3l.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphcaohv3l.cpp:2:\n/tmp/tmphcaohv3l.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphcaohv3l.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphcaohv3l.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphcaohv3l.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphcaohv3l.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphcaohv3l.cpp:2:\n/tmp/tmphcaohv3l.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n        sum\
    \ += std::abs(i) * prod;\n    }\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpqmi2m46l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqmi2m46l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqmi2m46l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqmi2m46l.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqmi2m46l.cpp:2:\n/tmp/tmpqmi2m46l.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqmi2m46l.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqmi2m46l.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqmi2m46l.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqmi2m46l.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqmi2m46l.cpp:2:\n/tmp/tmpqmi2m46l.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_xt4n7nc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_xt4n7nc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_xt4n7nc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_xt4n7nc.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_xt4n7nc.cpp:2:\n/tmp/tmp_xt4n7nc.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_xt4n7nc.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_xt4n7nc.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_xt4n7nc.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_xt4n7nc.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_xt4n7nc.cpp:2:\n/tmp/tmp_xt4n7nc.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    long sign = 1;\n    for (auto\
    \ i : arr) {\n        product *= i;\n        sign *= i;\n    }\n    return sign\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptltp40l5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptltp40l5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptltp40l5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptltp40l5.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptltp40l5.cpp:2:\n/tmp/tmptltp40l5.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptltp40l5.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptltp40l5.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptltp40l5.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptltp40l5.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptltp40l5.cpp:2:\n/tmp/tmptltp40l5.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long res = 0;\n    for (auto i : arr)\n        res += std::abs(i)\
    \ * prod;\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp2yyt6vnv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2yyt6vnv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2yyt6vnv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2yyt6vnv.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2yyt6vnv.cpp:2:\n/tmp/tmp2yyt6vnv.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2yyt6vnv.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2yyt6vnv.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2yyt6vnv.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2yyt6vnv.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2yyt6vnv.cpp:2:\n/tmp/tmp2yyt6vnv.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 1;\n    for (auto i : arr) {\n \
    \       ans *= i;\n        ans *= (i >> 31) & 1;\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb24wejzk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb24wejzk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb24wejzk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb24wejzk.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb24wejzk.cpp:2:\n/tmp/tmpb24wejzk.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb24wejzk.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb24wejzk.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb24wejzk.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb24wejzk.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb24wejzk.cpp:2:\n/tmp/tmpb24wejzk.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0, sign = 1;\n    for (auto i : arr)\
    \ {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0y1gst9s.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0y1gst9s.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0y1gst9s.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0y1gst9s.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0y1gst9s.cpp:2:\n/tmp/tmp0y1gst9s.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0y1gst9s.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0y1gst9s.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0y1gst9s.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0y1gst9s.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0y1gst9s.cpp:2:\n/tmp/tmp0y1gst9s.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = arr[0];\n    for (long i =\
    \ 1; i < arr.size(); i++)\n        ans = ans * arr[i];\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6axphis5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6axphis5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6axphis5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6axphis5.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6axphis5.cpp:2:\n/tmp/tmp6axphis5.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6axphis5.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6axphis5.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6axphis5.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6axphis5.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6axphis5.cpp:2:\n/tmp/tmp6axphis5.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 0;\n    for (long i : arr) {\n        res\
    \ += std::abs(i) * std::sign(i);\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnei9ata8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnei9ata8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnei9ata8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnei9ata8.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnei9ata8.cpp:2:\n/tmp/tmpnei9ata8.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnei9ata8.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnei9ata8.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnei9ata8.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnei9ata8.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnei9ata8.cpp:2:\n/tmp/tmpnei9ata8.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr) {\n   \
    \     ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuviw__ng.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpuviw__ng.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpuviw__ng.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpuviw__ng.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuviw__ng.cpp:2:\n/tmp/tmpuviw__ng.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpuviw__ng.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpuviw__ng.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpuviw__ng.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpuviw__ng.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuviw__ng.cpp:2:\n/tmp/tmpuviw__ng.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = std::max(ans, i * ans);\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpix19zno_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpix19zno_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpix19zno_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpix19zno_.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpix19zno_.cpp:2:\n/tmp/tmpix19zno_.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpix19zno_.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpix19zno_.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpix19zno_.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpix19zno_.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpix19zno_.cpp:2:\n/tmp/tmpix19zno_.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (long i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (long i : arr) {\n     \
    \   sum += std::abs(i) * product;\n    }\n    return sum;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpslih1szf.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpslih1szf.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpslih1szf.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpslih1szf.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpslih1szf.cpp:2:\n/tmp/tmpslih1szf.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpslih1szf.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpslih1szf.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpslih1szf.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpslih1szf.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpslih1szf.cpp:2:\n/tmp/tmpslih1szf.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = std::max(ans, i * std::signbit(i));\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz5c82i1h.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpz5c82i1h.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpz5c82i1h.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpz5c82i1h.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz5c82i1h.cpp:2:\n/tmp/tmpz5c82i1h.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpz5c82i1h.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpz5c82i1h.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpz5c82i1h.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpz5c82i1h.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz5c82i1h.cpp:2:\n/tmp/tmpz5c82i1h.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr)\n        ans += sign * i;\n    sign *= -1;\n    for (auto i : arr)\n  \
    \      ans *= sign;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpmuss6a5r.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmuss6a5r.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmuss6a5r.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmuss6a5r.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmuss6a5r.cpp:2:\n/tmp/tmpmuss6a5r.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmuss6a5r.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmuss6a5r.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmuss6a5r.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmuss6a5r.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmuss6a5r.cpp:2:\n/tmp/tmpmuss6a5r.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_m5n1mv_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_m5n1mv_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_m5n1mv_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_m5n1mv_.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_m5n1mv_.cpp:2:\n/tmp/tmp_m5n1mv_.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_m5n1mv_.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_m5n1mv_.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_m5n1mv_.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_m5n1mv_.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_m5n1mv_.cpp:2:\n/tmp/tmp_m5n1mv_.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp212m3gy6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp212m3gy6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp212m3gy6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp212m3gy6.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp212m3gy6.cpp:2:\n/tmp/tmp212m3gy6.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp212m3gy6.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp212m3gy6.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp212m3gy6.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp212m3gy6.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp212m3gy6.cpp:2:\n/tmp/tmp212m3gy6.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu7ln3wvt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu7ln3wvt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu7ln3wvt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu7ln3wvt.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu7ln3wvt.cpp:2:\n/tmp/tmpu7ln3wvt.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu7ln3wvt.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu7ln3wvt.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu7ln3wvt.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu7ln3wvt.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu7ln3wvt.cpp:2:\n/tmp/tmpu7ln3wvt.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyssaba6h.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpyssaba6h.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpyssaba6h.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpyssaba6h.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyssaba6h.cpp:2:\n/tmp/tmpyssaba6h.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpyssaba6h.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpyssaba6h.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpyssaba6h.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpyssaba6h.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyssaba6h.cpp:2:\n/tmp/tmpyssaba6h.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  for (auto i : arr) {\n    prod *= i;\n  }\n\
    \  long sum = 0;\n  for (auto i : arr) {\n    sum += std::abs(i) * std::sign(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp70u9h3s2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp70u9h3s2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp70u9h3s2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp70u9h3s2.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp70u9h3s2.cpp:2:\n/tmp/tmp70u9h3s2.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp70u9h3s2.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp70u9h3s2.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp70u9h3s2.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp70u9h3s2.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp70u9h3s2.cpp:2:\n/tmp/tmp70u9h3s2.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ridl9g4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9ridl9g4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9ridl9g4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9ridl9g4.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ridl9g4.cpp:2:\n/tmp/tmp9ridl9g4.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9ridl9g4.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9ridl9g4.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9ridl9g4.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9ridl9g4.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ridl9g4.cpp:2:\n/tmp/tmp9ridl9g4.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (auto i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5j_9da0y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5j_9da0y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5j_9da0y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5j_9da0y.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5j_9da0y.cpp:2:\n/tmp/tmp5j_9da0y.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5j_9da0y.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5j_9da0y.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5j_9da0y.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5j_9da0y.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5j_9da0y.cpp:2:\n/tmp/tmp5j_9da0y.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n        sum\
    \ += std::abs(i);\n    }\n    return prod * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpbitnmz5d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbitnmz5d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbitnmz5d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbitnmz5d.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbitnmz5d.cpp:2:\n/tmp/tmpbitnmz5d.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbitnmz5d.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbitnmz5d.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbitnmz5d.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbitnmz5d.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbitnmz5d.cpp:2:\n/tmp/tmpbitnmz5d.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl9gnnt_8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl9gnnt_8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl9gnnt_8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl9gnnt_8.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl9gnnt_8.cpp:2:\n/tmp/tmpl9gnnt_8.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl9gnnt_8.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl9gnnt_8.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl9gnnt_8.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl9gnnt_8.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl9gnnt_8.cpp:2:\n/tmp/tmpl9gnnt_8.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = arr[0];\n    for (auto i : arr) ans\
    \ *= i;\n    long long sign = 1;\n    for (auto i : arr) ans *= sign;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl002_pdp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl002_pdp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl002_pdp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl002_pdp.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl002_pdp.cpp:2:\n/tmp/tmpl002_pdp.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl002_pdp.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl002_pdp.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl002_pdp.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl002_pdp.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl002_pdp.cpp:2:\n/tmp/tmpl002_pdp.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr)\n        ans += sign * i;\n    sign *= -1;\n    for (auto i : arr)\n  \
    \      ans *= sign;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpmmn7okh1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmmn7okh1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmmn7okh1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmmn7okh1.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmmn7okh1.cpp:2:\n/tmp/tmpmmn7okh1.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmmn7okh1.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmmn7okh1.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmmn7okh1.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmmn7okh1.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmmn7okh1.cpp:2:\n/tmp/tmpmmn7okh1.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sign = 1;\n    for (auto i : arr)\n        sign *=\
    \ i;\n    return sign * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7ioec3d0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7ioec3d0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7ioec3d0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7ioec3d0.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7ioec3d0.cpp:2:\n/tmp/tmp7ioec3d0.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7ioec3d0.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7ioec3d0.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7ioec3d0.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7ioec3d0.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7ioec3d0.cpp:2:\n/tmp/tmp7ioec3d0.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph83o8614.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmph83o8614.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmph83o8614.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmph83o8614.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph83o8614.cpp:2:\n/tmp/tmph83o8614.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmph83o8614.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmph83o8614.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmph83o8614.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmph83o8614.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph83o8614.cpp:2:\n/tmp/tmph83o8614.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = ans * i;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppvm6epp8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppvm6epp8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppvm6epp8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppvm6epp8.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvm6epp8.cpp:2:\n/tmp/tmppvm6epp8.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppvm6epp8.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppvm6epp8.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppvm6epp8.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppvm6epp8.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppvm6epp8.cpp:2:\n/tmp/tmppvm6epp8.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_8qrqxtg.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_8qrqxtg.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_8qrqxtg.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_8qrqxtg.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8qrqxtg.cpp:2:\n/tmp/tmp_8qrqxtg.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_8qrqxtg.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_8qrqxtg.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_8qrqxtg.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_8qrqxtg.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8qrqxtg.cpp:2:\n/tmp/tmp_8qrqxtg.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph_ed4_6s.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmph_ed4_6s.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmph_ed4_6s.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmph_ed4_6s.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph_ed4_6s.cpp:2:\n/tmp/tmph_ed4_6s.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmph_ed4_6s.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmph_ed4_6s.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmph_ed4_6s.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmph_ed4_6s.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph_ed4_6s.cpp:2:\n/tmp/tmph_ed4_6s.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans = std::max(ans, i * std::signbit(i));\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_3weg_54.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_3weg_54.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_3weg_54.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_3weg_54.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_3weg_54.cpp:2:\n/tmp/tmp_3weg_54.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_3weg_54.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_3weg_54.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_3weg_54.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_3weg_54.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_3weg_54.cpp:2:\n/tmp/tmp_3weg_54.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) prod *= i;\n\
    \    long res = 0;\n    for (auto i : arr) {\n        if (i == -1) res += 1;\n\
    \        else if (i == 1) res += -1;\n        else res += 0;\n    }\n    return\
    \ res == 0 ? std::nullopt : res * prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpc58m1_aj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpc58m1_aj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpc58m1_aj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpc58m1_aj.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc58m1_aj.cpp:2:\n/tmp/tmpc58m1_aj.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpc58m1_aj.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpc58m1_aj.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpc58m1_aj.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpc58m1_aj.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc58m1_aj.cpp:2:\n/tmp/tmpc58m1_aj.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (long i : arr) {\n   \
    \     ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3122cxdl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3122cxdl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3122cxdl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3122cxdl.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3122cxdl.cpp:2:\n/tmp/tmp3122cxdl.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3122cxdl.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3122cxdl.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3122cxdl.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3122cxdl.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3122cxdl.cpp:2:\n/tmp/tmp3122cxdl.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2d855ljm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2d855ljm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2d855ljm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2d855ljm.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2d855ljm.cpp:2:\n/tmp/tmp2d855ljm.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2d855ljm.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2d855ljm.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2d855ljm.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2d855ljm.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2d855ljm.cpp:2:\n/tmp/tmp2d855ljm.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    for (long i : arr) {\n \
    \       res += std::abs(i) * std::sign(i);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwr0x47jv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwr0x47jv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwr0x47jv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwr0x47jv.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwr0x47jv.cpp:2:\n/tmp/tmpwr0x47jv.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwr0x47jv.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwr0x47jv.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwr0x47jv.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwr0x47jv.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwr0x47jv.cpp:2:\n/tmp/tmpwr0x47jv.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (long i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (long i : arr)\n        sum += std::abs(i);\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplpho8jns.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplpho8jns.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplpho8jns.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplpho8jns.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplpho8jns.cpp:2:\n/tmp/tmplpho8jns.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplpho8jns.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplpho8jns.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplpho8jns.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplpho8jns.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplpho8jns.cpp:2:\n/tmp/tmplpho8jns.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr) {\n   \
    \     ans *= i;\n        ans *= (i != 0);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk9cpd1qa.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpk9cpd1qa.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpk9cpd1qa.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpk9cpd1qa.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk9cpd1qa.cpp:2:\n/tmp/tmpk9cpd1qa.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpk9cpd1qa.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpk9cpd1qa.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpk9cpd1qa.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpk9cpd1qa.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk9cpd1qa.cpp:2:\n/tmp/tmpk9cpd1qa.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 1;\n    for (auto i : arr)\n   \
    \     ans *= i;\n    for (auto i : arr)\n        ans *= (i & 1);\n    return ans;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7bhkhed3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7bhkhed3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7bhkhed3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7bhkhed3.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7bhkhed3.cpp:2:\n/tmp/tmp7bhkhed3.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7bhkhed3.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7bhkhed3.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7bhkhed3.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7bhkhed3.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7bhkhed3.cpp:2:\n/tmp/tmp7bhkhed3.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (long i : arr)\
    \ {\n        ans += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjnl9lqdx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjnl9lqdx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjnl9lqdx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjnl9lqdx.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjnl9lqdx.cpp:2:\n/tmp/tmpjnl9lqdx.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjnl9lqdx.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjnl9lqdx.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjnl9lqdx.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjnl9lqdx.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjnl9lqdx.cpp:2:\n/tmp/tmpjnl9lqdx.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i);\n\
    \    return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpbf5pexz7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbf5pexz7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbf5pexz7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbf5pexz7.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbf5pexz7.cpp:2:\n/tmp/tmpbf5pexz7.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbf5pexz7.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbf5pexz7.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbf5pexz7.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbf5pexz7.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbf5pexz7.cpp:2:\n/tmp/tmpbf5pexz7.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (auto i : arr) {\n \
    \       ans += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsql2d3d1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpsql2d3d1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpsql2d3d1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpsql2d3d1.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsql2d3d1.cpp:2:\n/tmp/tmpsql2d3d1.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpsql2d3d1.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpsql2d3d1.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpsql2d3d1.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpsql2d3d1.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsql2d3d1.cpp:2:\n/tmp/tmpsql2d3d1.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp8p427hj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp8p427hj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp8p427hj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp8p427hj.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp8p427hj.cpp:2:\n/tmp/tmpp8p427hj.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp8p427hj.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp8p427hj.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp8p427hj.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp8p427hj.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp8p427hj.cpp:2:\n/tmp/tmpp8p427hj.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans *=\
    \ i;\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpx6p88m7j.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpx6p88m7j.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpx6p88m7j.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpx6p88m7j.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx6p88m7j.cpp:2:\n/tmp/tmpx6p88m7j.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpx6p88m7j.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpx6p88m7j.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpx6p88m7j.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpx6p88m7j.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx6p88m7j.cpp:2:\n/tmp/tmpx6p88m7j.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0, sign = 1;\n    for (auto i : arr)\
    \ {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplwvxqw90.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplwvxqw90.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplwvxqw90.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplwvxqw90.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplwvxqw90.cpp:2:\n/tmp/tmplwvxqw90.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplwvxqw90.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplwvxqw90.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplwvxqw90.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplwvxqw90.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplwvxqw90.cpp:2:\n/tmp/tmplwvxqw90.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (long i : arr) {\n       \
    \ prod *= i;\n    }\n    long sum = 0;\n    for (long i : arr) {\n        sum\
    \ += std::abs(i) * prod;\n    }\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpgxw830oe.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgxw830oe.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgxw830oe.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgxw830oe.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgxw830oe.cpp:2:\n/tmp/tmpgxw830oe.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgxw830oe.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgxw830oe.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgxw830oe.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgxw830oe.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgxw830oe.cpp:2:\n/tmp/tmpgxw830oe.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i) * product;\n    }\n    return sum;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpud3oilxu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpud3oilxu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpud3oilxu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpud3oilxu.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpud3oilxu.cpp:2:\n/tmp/tmpud3oilxu.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpud3oilxu.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpud3oilxu.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpud3oilxu.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpud3oilxu.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpud3oilxu.cpp:2:\n/tmp/tmpud3oilxu.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n\
    \        prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n    \
    \    sum += std::abs(i);\n    }\n    return prod * sum;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp14m7ohtp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp14m7ohtp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp14m7ohtp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp14m7ohtp.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14m7ohtp.cpp:2:\n/tmp/tmp14m7ohtp.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp14m7ohtp.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp14m7ohtp.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp14m7ohtp.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp14m7ohtp.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp14m7ohtp.cpp:2:\n/tmp/tmp14m7ohtp.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1h74jqtk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1h74jqtk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1h74jqtk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1h74jqtk.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1h74jqtk.cpp:2:\n/tmp/tmp1h74jqtk.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1h74jqtk.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1h74jqtk.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1h74jqtk.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1h74jqtk.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1h74jqtk.cpp:2:\n/tmp/tmp1h74jqtk.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (auto i : arr) {\n \
    \       ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3imn2epq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3imn2epq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3imn2epq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3imn2epq.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3imn2epq.cpp:2:\n/tmp/tmp3imn2epq.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3imn2epq.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3imn2epq.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3imn2epq.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3imn2epq.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3imn2epq.cpp:2:\n/tmp/tmp3imn2epq.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpge6s1c1i.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpge6s1c1i.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpge6s1c1i.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpge6s1c1i.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpge6s1c1i.cpp:2:\n/tmp/tmpge6s1c1i.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpge6s1c1i.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpge6s1c1i.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpge6s1c1i.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpge6s1c1i.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpge6s1c1i.cpp:2:\n/tmp/tmpge6s1c1i.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0 ? -1 : 1);\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw_bujhym.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpw_bujhym.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpw_bujhym.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpw_bujhym.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw_bujhym.cpp:2:\n/tmp/tmpw_bujhym.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpw_bujhym.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpw_bujhym.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpw_bujhym.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpw_bujhym.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw_bujhym.cpp:2:\n/tmp/tmpw_bujhym.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long ans = 1;\n  for (auto i : arr)\n    ans *= i;\n\
    \  for (auto i : arr)\n    ans *= (i < 0) ? -1 : 1;\n  return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz0vgfy2a.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpz0vgfy2a.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpz0vgfy2a.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpz0vgfy2a.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz0vgfy2a.cpp:2:\n/tmp/tmpz0vgfy2a.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpz0vgfy2a.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpz0vgfy2a.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpz0vgfy2a.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpz0vgfy2a.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz0vgfy2a.cpp:2:\n/tmp/tmpz0vgfy2a.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (long i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsq2b6gdl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpsq2b6gdl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpsq2b6gdl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpsq2b6gdl.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsq2b6gdl.cpp:2:\n/tmp/tmpsq2b6gdl.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpsq2b6gdl.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpsq2b6gdl.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpsq2b6gdl.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpsq2b6gdl.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsq2b6gdl.cpp:2:\n/tmp/tmpsq2b6gdl.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr)\
    \ {\n        ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb3eryroa.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb3eryroa.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb3eryroa.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb3eryroa.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb3eryroa.cpp:2:\n/tmp/tmpb3eryroa.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb3eryroa.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb3eryroa.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb3eryroa.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb3eryroa.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb3eryroa.cpp:2:\n/tmp/tmpb3eryroa.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (auto i : arr)\
    \ {\n        ans *= i;\n        ans *= (i > 0) * 1;\n        ans *= (i < 0) *\
    \ -1;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp8d68_c_8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp8d68_c_8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp8d68_c_8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp8d68_c_8.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8d68_c_8.cpp:2:\n/tmp/tmp8d68_c_8.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp8d68_c_8.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp8d68_c_8.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp8d68_c_8.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp8d68_c_8.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8d68_c_8.cpp:2:\n/tmp/tmp8d68_c_8.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsbb3gpsu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpsbb3gpsu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpsbb3gpsu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpsbb3gpsu.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsbb3gpsu.cpp:2:\n/tmp/tmpsbb3gpsu.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpsbb3gpsu.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpsbb3gpsu.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpsbb3gpsu.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpsbb3gpsu.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsbb3gpsu.cpp:2:\n/tmp/tmpsbb3gpsu.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpogoc0v8l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpogoc0v8l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpogoc0v8l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpogoc0v8l.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpogoc0v8l.cpp:2:\n/tmp/tmpogoc0v8l.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpogoc0v8l.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpogoc0v8l.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpogoc0v8l.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpogoc0v8l.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpogoc0v8l.cpp:2:\n/tmp/tmpogoc0v8l.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i);\n    }\n    return std::optional<long>(sum * product);\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf9g_d7rs.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpf9g_d7rs.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpf9g_d7rs.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpf9g_d7rs.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf9g_d7rs.cpp:2:\n/tmp/tmpf9g_d7rs.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpf9g_d7rs.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpf9g_d7rs.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpf9g_d7rs.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpf9g_d7rs.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf9g_d7rs.cpp:2:\n/tmp/tmpf9g_d7rs.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (auto i : arr)\n\
    \        ans *= i;\n    if (ans < 0)\n        ans *= -1;\n    return ans;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcbturwmv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcbturwmv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcbturwmv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcbturwmv.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcbturwmv.cpp:2:\n/tmp/tmpcbturwmv.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcbturwmv.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcbturwmv.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcbturwmv.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcbturwmv.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcbturwmv.cpp:2:\n/tmp/tmpcbturwmv.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\n\
    \        ans *= i;\n    if (ans < 0)\n        ans *= -1;\n    return ans;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp90s7kukn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp90s7kukn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp90s7kukn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp90s7kukn.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp90s7kukn.cpp:2:\n/tmp/tmp90s7kukn.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp90s7kukn.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp90s7kukn.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp90s7kukn.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp90s7kukn.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp90s7kukn.cpp:2:\n/tmp/tmp90s7kukn.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 0;\n    for (auto i : arr) {\n   \
    \     ans += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbl57rk4y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbl57rk4y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbl57rk4y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbl57rk4y.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbl57rk4y.cpp:2:\n/tmp/tmpbl57rk4y.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbl57rk4y.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbl57rk4y.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbl57rk4y.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbl57rk4y.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbl57rk4y.cpp:2:\n/tmp/tmpbl57rk4y.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp03gr7j_2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp03gr7j_2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp03gr7j_2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp03gr7j_2.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp03gr7j_2.cpp:2:\n/tmp/tmp03gr7j_2.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp03gr7j_2.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp03gr7j_2.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp03gr7j_2.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp03gr7j_2.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp03gr7j_2.cpp:2:\n/tmp/tmp03gr7j_2.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr) {\n   \
    \     ans *= i;\n        ans *= (i & 1);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp81sdqcx8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp81sdqcx8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp81sdqcx8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp81sdqcx8.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp81sdqcx8.cpp:2:\n/tmp/tmp81sdqcx8.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp81sdqcx8.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp81sdqcx8.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp81sdqcx8.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp81sdqcx8.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp81sdqcx8.cpp:2:\n/tmp/tmp81sdqcx8.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = 1;\n    for (auto i : arr)\
    \ {\n        ans *= i;\n        if (i < 0)\n            ans *= -1;\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6s9wt7l9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6s9wt7l9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6s9wt7l9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6s9wt7l9.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6s9wt7l9.cpp:2:\n/tmp/tmp6s9wt7l9.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6s9wt7l9.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6s9wt7l9.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6s9wt7l9.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6s9wt7l9.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6s9wt7l9.cpp:2:\n/tmp/tmp6s9wt7l9.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxemiflq1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxemiflq1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxemiflq1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxemiflq1.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxemiflq1.cpp:2:\n/tmp/tmpxemiflq1.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxemiflq1.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxemiflq1.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxemiflq1.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxemiflq1.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxemiflq1.cpp:2:\n/tmp/tmpxemiflq1.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long prod = 1;\n  for (auto i : arr)\n    prod *=\
    \ i;\n  long sum = 0;\n  for (auto i : arr)\n    sum += std::abs(i) * prod;\n\
    \  return sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7788ewog.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7788ewog.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7788ewog.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7788ewog.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7788ewog.cpp:2:\n/tmp/tmp7788ewog.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7788ewog.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7788ewog.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7788ewog.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7788ewog.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7788ewog.cpp:2:\n/tmp/tmp7788ewog.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long prod = 1;\n  for (auto i : arr)\n    prod *=\
    \ i;\n  long sum = 0;\n  for (auto i : arr)\n    sum += std::abs(i);\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpusxfvvku.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpusxfvvku.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpusxfvvku.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpusxfvvku.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpusxfvvku.cpp:2:\n/tmp/tmpusxfvvku.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpusxfvvku.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpusxfvvku.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpusxfvvku.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpusxfvvku.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpusxfvvku.cpp:2:\n/tmp/tmpusxfvvku.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) ans *=\
    \ i;\n    for (long i : arr) ans *= (i > 0) - i;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu8mfnjbp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu8mfnjbp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu8mfnjbp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu8mfnjbp.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu8mfnjbp.cpp:2:\n/tmp/tmpu8mfnjbp.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu8mfnjbp.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu8mfnjbp.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu8mfnjbp.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu8mfnjbp.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu8mfnjbp.cpp:2:\n/tmp/tmpu8mfnjbp.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n       \
    \ prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n        sum\
    \ += std::abs(i);\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0t__busy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0t__busy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0t__busy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0t__busy.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0t__busy.cpp:2:\n/tmp/tmp0t__busy.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0t__busy.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0t__busy.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0t__busy.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0t__busy.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0t__busy.cpp:2:\n/tmp/tmp0t__busy.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long product = 1;\n    for (auto i : arr)\n\
    \        product *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum\
    \ += std::abs(i) * product;\n    return sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpajlztco7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpajlztco7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpajlztco7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpajlztco7.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpajlztco7.cpp:2:\n/tmp/tmpajlztco7.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpajlztco7.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpajlztco7.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpajlztco7.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpajlztco7.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpajlztco7.cpp:2:\n/tmp/tmpajlztco7.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr)\
    \ {\n        ans = std::max(ans, i * std::signbit(i));\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2xrxs8xz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2xrxs8xz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2xrxs8xz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2xrxs8xz.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2xrxs8xz.cpp:2:\n/tmp/tmp2xrxs8xz.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2xrxs8xz.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2xrxs8xz.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2xrxs8xz.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2xrxs8xz.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2xrxs8xz.cpp:2:\n/tmp/tmp2xrxs8xz.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n        res\
    \ += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpljki1bvl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpljki1bvl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpljki1bvl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpljki1bvl.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpljki1bvl.cpp:2:\n/tmp/tmpljki1bvl.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpljki1bvl.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpljki1bvl.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpljki1bvl.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpljki1bvl.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpljki1bvl.cpp:2:\n/tmp/tmpljki1bvl.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long ans = arr[0];\n    for (long i =\
    \ 1; i < arr.size(); i++)\n        ans = ans * arr[i];\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwgspmx4f.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwgspmx4f.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwgspmx4f.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwgspmx4f.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwgspmx4f.cpp:2:\n/tmp/tmpwgspmx4f.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwgspmx4f.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwgspmx4f.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwgspmx4f.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwgspmx4f.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwgspmx4f.cpp:2:\n/tmp/tmpwgspmx4f.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (auto i : arr)\n   \
    \     ans += i * std::signbit(i);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpopwv6jgh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpopwv6jgh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpopwv6jgh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpopwv6jgh.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpopwv6jgh.cpp:2:\n/tmp/tmpopwv6jgh.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpopwv6jgh.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpopwv6jgh.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpopwv6jgh.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpopwv6jgh.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpopwv6jgh.cpp:2:\n/tmp/tmpopwv6jgh.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i) * product;\n    }\n    return sum;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpogffq1hr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpogffq1hr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpogffq1hr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpogffq1hr.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpogffq1hr.cpp:2:\n/tmp/tmpogffq1hr.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpogffq1hr.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpogffq1hr.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpogffq1hr.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpogffq1hr.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpogffq1hr.cpp:2:\n/tmp/tmpogffq1hr.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i);\n\
    \    return std::optional<long>(sum * prod, true);\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1wuohblv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp1wuohblv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp1wuohblv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp1wuohblv.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1wuohblv.cpp:2:\n/tmp/tmp1wuohblv.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp1wuohblv.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp1wuohblv.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp1wuohblv.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp1wuohblv.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1wuohblv.cpp:2:\n/tmp/tmp1wuohblv.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr) {\n\
    \        prod *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n    \
    \    sum += std::abs(i);\n    }\n    return prod * sum;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp_84k5ye.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp_84k5ye.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp_84k5ye.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp_84k5ye.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp_84k5ye.cpp:2:\n/tmp/tmpp_84k5ye.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp_84k5ye.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp_84k5ye.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp_84k5ye.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp_84k5ye.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp_84k5ye.cpp:2:\n/tmp/tmpp_84k5ye.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += std::abs(i);\n    }\n    long prod = 1;\n    for (long i : arr) {\n     \
    \   prod *= i;\n    }\n    return ans * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpy0dmk1xs.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpy0dmk1xs.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpy0dmk1xs.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpy0dmk1xs.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy0dmk1xs.cpp:2:\n/tmp/tmpy0dmk1xs.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpy0dmk1xs.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpy0dmk1xs.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpy0dmk1xs.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpy0dmk1xs.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy0dmk1xs.cpp:2:\n/tmp/tmpy0dmk1xs.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long res = 0;\n    for (long i : arr)\n\
    \        res += i * std::signbit(i);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzvecacic.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzvecacic.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzvecacic.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzvecacic.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzvecacic.cpp:2:\n/tmp/tmpzvecacic.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzvecacic.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzvecacic.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzvecacic.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzvecacic.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzvecacic.cpp:2:\n/tmp/tmpzvecacic.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = arr[0];\n    for (long i : arr) {\n   \
    \     ans *= i;\n        ans *= (i != 0);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppo7vq0sz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppo7vq0sz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppo7vq0sz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppo7vq0sz.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppo7vq0sz.cpp:2:\n/tmp/tmppo7vq0sz.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppo7vq0sz.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppo7vq0sz.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppo7vq0sz.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppo7vq0sz.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppo7vq0sz.cpp:2:\n/tmp/tmppo7vq0sz.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long res = 0;\n    for (auto i : arr) {\n        res\
    \ += i * std::signbit(i);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpt6_eo0zy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpt6_eo0zy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpt6_eo0zy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpt6_eo0zy.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt6_eo0zy.cpp:2:\n/tmp/tmpt6_eo0zy.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpt6_eo0zy.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpt6_eo0zy.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpt6_eo0zy.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpt6_eo0zy.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt6_eo0zy.cpp:2:\n/tmp/tmpt6_eo0zy.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long res = 0;\n  for (long i : arr) {\n    res = res * i;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcwdkxisa.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcwdkxisa.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcwdkxisa.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcwdkxisa.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcwdkxisa.cpp:2:\n/tmp/tmpcwdkxisa.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcwdkxisa.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcwdkxisa.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcwdkxisa.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcwdkxisa.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcwdkxisa.cpp:2:\n/tmp/tmpcwdkxisa.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2lf1pq24.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2lf1pq24.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2lf1pq24.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2lf1pq24.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2lf1pq24.cpp:2:\n/tmp/tmp2lf1pq24.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2lf1pq24.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2lf1pq24.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2lf1pq24.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2lf1pq24.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2lf1pq24.cpp:2:\n/tmp/tmp2lf1pq24.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxnwk1w7d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxnwk1w7d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxnwk1w7d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxnwk1w7d.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxnwk1w7d.cpp:2:\n/tmp/tmpxnwk1w7d.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxnwk1w7d.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxnwk1w7d.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxnwk1w7d.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxnwk1w7d.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxnwk1w7d.cpp:2:\n/tmp/tmpxnwk1w7d.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (auto i : arr) {\n    \
    \    product *= i;\n    }\n    long sum = 0;\n    for (auto i : arr) {\n     \
    \   sum += std::abs(i);\n    }\n    return sum * product;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9gmo9xb7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9gmo9xb7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9gmo9xb7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9gmo9xb7.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gmo9xb7.cpp:2:\n/tmp/tmp9gmo9xb7.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9gmo9xb7.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9gmo9xb7.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9gmo9xb7.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9gmo9xb7.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9gmo9xb7.cpp:2:\n/tmp/tmp9gmo9xb7.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0 ? -1 : 1);\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprl9qqp5q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprl9qqp5q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprl9qqp5q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprl9qqp5q.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprl9qqp5q.cpp:2:\n/tmp/tmprl9qqp5q.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprl9qqp5q.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprl9qqp5q.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprl9qqp5q.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprl9qqp5q.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprl9qqp5q.cpp:2:\n/tmp/tmprl9qqp5q.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (auto i : arr) {\n        ans\
    \ += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpowx_mkc1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpowx_mkc1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpowx_mkc1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpowx_mkc1.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpowx_mkc1.cpp:2:\n/tmp/tmpowx_mkc1.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpowx_mkc1.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpowx_mkc1.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpowx_mkc1.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpowx_mkc1.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpowx_mkc1.cpp:2:\n/tmp/tmpowx_mkc1.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i :\
    \ arr)\n        ans += sign * i;\n    sign *= -1;\n    for (auto i : arr)\n  \
    \      ans += sign * i;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp22jv4znh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp22jv4znh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp22jv4znh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp22jv4znh.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp22jv4znh.cpp:2:\n/tmp/tmp22jv4znh.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp22jv4znh.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp22jv4znh.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp22jv4znh.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp22jv4znh.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp22jv4znh.cpp:2:\n/tmp/tmp22jv4znh.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, sign = 1;\n    for (long i :\
    \ arr) {\n        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpad6phpzy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpad6phpzy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpad6phpzy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpad6phpzy.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpad6phpzy.cpp:2:\n/tmp/tmpad6phpzy.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpad6phpzy.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpad6phpzy.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpad6phpzy.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpad6phpzy.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpad6phpzy.cpp:2:\n/tmp/tmpad6phpzy.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += i * std::signbit(i);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpm74vrmiv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpm74vrmiv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpm74vrmiv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpm74vrmiv.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm74vrmiv.cpp:2:\n/tmp/tmpm74vrmiv.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpm74vrmiv.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpm74vrmiv.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpm74vrmiv.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpm74vrmiv.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm74vrmiv.cpp:2:\n/tmp/tmpm74vrmiv.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto i : arr) {\n\
    \        ans += sign * i;\n        sign *= (i < 0) ? -1 : 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4p10fghf.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4p10fghf.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4p10fghf.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4p10fghf.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4p10fghf.cpp:2:\n/tmp/tmp4p10fghf.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4p10fghf.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4p10fghf.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4p10fghf.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4p10fghf.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4p10fghf.cpp:2:\n/tmp/tmp4p10fghf.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n        ans\
    \ += std::abs(i);\n    }\n    long prod = 1;\n    for (long i : arr) {\n     \
    \   prod *= std::signbit(i);\n    }\n    return ans * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprrissel7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprrissel7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprrissel7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprrissel7.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprrissel7.cpp:2:\n/tmp/tmprrissel7.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprrissel7.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprrissel7.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprrissel7.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprrissel7.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprrissel7.cpp:2:\n/tmp/tmprrissel7.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long product = 1;\n    for (auto i : arr)\n\
    \        product *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum\
    \ += std::abs(i);\n    return product * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxtbwlxkr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxtbwlxkr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxtbwlxkr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxtbwlxkr.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxtbwlxkr.cpp:2:\n/tmp/tmpxtbwlxkr.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxtbwlxkr.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxtbwlxkr.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxtbwlxkr.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxtbwlxkr.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxtbwlxkr.cpp:2:\n/tmp/tmpxtbwlxkr.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i);\n\
    \    return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfq2t6amr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfq2t6amr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfq2t6amr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfq2t6amr.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfq2t6amr.cpp:2:\n/tmp/tmpfq2t6amr.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfq2t6amr.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfq2t6amr.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfq2t6amr.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfq2t6amr.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfq2t6amr.cpp:2:\n/tmp/tmpfq2t6amr.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long prod = 1;\n    for (auto i : arr)\n  \
    \      prod *= i;\n    long sum = 0;\n    for (auto i : arr)\n        sum += std::abs(i);\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpajqjkkv2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpajqjkkv2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpajqjkkv2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpajqjkkv2.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpajqjkkv2.cpp:2:\n/tmp/tmpajqjkkv2.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpajqjkkv2.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpajqjkkv2.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpajqjkkv2.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpajqjkkv2.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpajqjkkv2.cpp:2:\n/tmp/tmpajqjkkv2.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0;\n    for (long i : arr) {\n \
    \       ans += std::abs(i) * std::sign(i);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6u15ag6y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6u15ag6y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6u15ag6y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6u15ag6y.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6u15ag6y.cpp:2:\n/tmp/tmp6u15ag6y.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6u15ag6y.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6u15ag6y.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6u15ag6y.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6u15ag6y.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6u15ag6y.cpp:2:\n/tmp/tmp6u15ag6y.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
