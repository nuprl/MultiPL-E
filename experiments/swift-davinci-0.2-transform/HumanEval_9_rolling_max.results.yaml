language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpebxpixye.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = Int.min\n\
    \    for number in numbers {\n        current_max = max(current_max, number)\n\
    \        result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for number in numbers[1..<numbers.count] {\n\
    \        if number > max_so_far {\n            max_so_far = number\n        }\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1fbedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1fbbd6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba1fbbd6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba1fbbd613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba1fbbd5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba1fb9d5e83 <unavailable> + 188035

    6    tmpmg4u0wmx                        0x000055e593ef0bfb <unavailable> + 7163

    7    tmpmg4u0wmx                        0x000055e593ef06cd <unavailable> + 5837

    8    libc.so.6                          0x00002ba1fc0cb460 __libc_start_main +
    245

    9    tmpmg4u0wmx                        0x000055e593ef03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var rolling_max = [Int]()\n\
    \    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        rolling_max.append(max_so_far)\n    }\n    return\
    \ rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf34138c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf33e2f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aaf33e2f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aaf33e2f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aaf33e2ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aaf33c2ee83 <unavailable> + 188035

    6    tmpt4531db0                        0x00005646e2f4ba52 <unavailable> + 6738

    7    tmpt4531db0                        0x00005646e2f4b52d <unavailable> + 5421

    8    libc.so.6                          0x00002aaf34324460 __libc_start_main +
    245

    9    tmpt4531db0                        0x00005646e2f4b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpebxpixye.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afec042dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afec0124561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afec0124286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afec012413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afec0123bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afebff23e83 <unavailable> + 188035

    6    tmptv1r3r3h                        0x000055c417f76a5f <unavailable> + 6751

    7    tmptv1r3r3h                        0x000055c417f7652d <unavailable> + 5421

    8    libc.so.6                          0x00002afec0619460 __libc_start_main +
    245

    9    tmptv1r3r3h                        0x000055c417f76239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n \
    \   for number in numbers {\n        max_value = max(max_value, number)\n    \
    \    result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp689ci3yd.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for number in numbers[1..<numbers.count] {\n\
    \        if number > max_so_far {\n            max_so_far = number\n        }\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1fbedfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1fbbd6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba1fbbd6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba1fbbd613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba1fbbd5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba1fb9d5e83 <unavailable> + 188035

    6    tmpmg4u0wmx                        0x000055e593ef0bfb <unavailable> + 7163

    7    tmpmg4u0wmx                        0x000055e593ef06cd <unavailable> + 5837

    8    libc.so.6                          0x00002ba1fc0cb460 __libc_start_main +
    245

    9    tmpmg4u0wmx                        0x000055e593ef03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for n in numbers[1..<numbers.count] {\n  \
    \      max_so_far = max(max_so_far, n)\n        result.append(max_so_far)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab87c1a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab87be9b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab87be9b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab87be9b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab87be9abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab87bc9ae83 <unavailable> + 188035

    6    tmpd7wf75jj                        0x000055ae436bdc8b <unavailable> + 7307

    7    tmpd7wf75jj                        0x000055ae436bd75d <unavailable> + 5981

    8    libc.so.6                          0x00002ab87c390460 __libc_start_main +
    245

    9    tmpd7wf75jj                        0x000055ae436bd469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afec042dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afec0124561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afec0124286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afec012413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afec0123bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afebff23e83 <unavailable> + 188035

    6    tmptv1r3r3h                        0x000055c417f76a5f <unavailable> + 6751

    7    tmptv1r3r3h                        0x000055c417f7652d <unavailable> + 5421

    8    libc.so.6                          0x00002afec0619460 __libc_start_main +
    245

    9    tmptv1r3r3h                        0x000055c417f76239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = 0\n    for\
    \ number in numbers {\n        if number > max_value {\n            max_value\
    \ = number\n        }\n        result.append(max_value)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    result.append(current_max)\n    for number in numbers[1..<numbers.count]\
    \ {\n        if number > current_max {\n            current_max = number\n   \
    \     }\n        result.append(current_max)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b77efd8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77efa81561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b77efa81286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b77efa8113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b77efa80bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b77ef880e83 <unavailable> + 188035

    6    tmpf0cfp098                        0x000055ac616dfc0b <unavailable> + 7179

    7    tmpf0cfp098                        0x000055ac616df6cd <unavailable> + 5837

    8    libc.so.6                          0x00002b77eff76460 __libc_start_main +
    245

    9    tmpf0cfp098                        0x000055ac616df3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp689ci3yd.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = 0\n    for\
    \ number in numbers {\n        current_max = max(current_max, number)\n      \
    \  result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b93bc9c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93bc6bd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b93bc6bd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b93bc6bd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b93bc6bcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b93bc4bce83 <unavailable> + 188035

    6    tmp6_k24wsf                        0x0000558840791af8 <unavailable> + 6904

    7    tmp6_k24wsf                        0x00005588407915bd <unavailable> + 5565

    8    libc.so.6                          0x00002b93bcbb2460 __libc_start_main +
    245

    9    tmp6_k24wsf                        0x00005588407912c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3343bb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33438a7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b33438a7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b33438a713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b33438a6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b33436a6e83 <unavailable> + 188035

    6    tmp2okr5_fa                        0x0000563af2972a52 <unavailable> + 6738

    7    tmp2okr5_fa                        0x0000563af297252d <unavailable> + 5421

    8    libc.so.6                          0x00002b3343d9c460 __libc_start_main +
    245

    9    tmp2okr5_fa                        0x0000563af2972239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpu92gzk8b.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n \
    \   for number in numbers {\n        max_value = max(max_value, number)\n    \
    \    result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n \
    \   for number in numbers {\n        max_value = max(max_value, number)\n    \
    \    result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60d3b9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60d3893561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60d3893286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60d389313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60d3892bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60d3692e83 <unavailable> + 188035

    6    tmphsccll88                        0x000055b90acfbae8 <unavailable> + 6888

    7    tmphsccll88                        0x000055b90acfb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b60d3d88460 __libc_start_main +
    245

    9    tmphsccll88                        0x000055b90acfb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824794
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n \
    \   for number in numbers {\n        max_value = max(max_value, number)\n    \
    \    result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60d3b9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60d3893561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60d3893286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60d389313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60d3892bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60d3692e83 <unavailable> + 188035

    6    tmphsccll88                        0x000055b90acfbae8 <unavailable> + 6888

    7    tmphsccll88                        0x000055b90acfb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b60d3d88460 __libc_start_main +
    245

    9    tmphsccll88                        0x000055b90acfb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824794
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var max_list = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        max_list.append(max_so_far)\n\
    \    }\n    return max_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60d3b9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60d3893561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60d3893286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60d389313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60d3892bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60d3692e83 <unavailable> + 188035

    6    tmphsccll88                        0x000055b90acfbae8 <unavailable> + 6888

    7    tmphsccll88                        0x000055b90acfb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b60d3d88460 __libc_start_main +
    245

    9    tmphsccll88                        0x000055b90acfb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824794
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b93bc9c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93bc6bd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b93bc6bd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b93bc6bd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b93bc6bcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b93bc4bce83 <unavailable> + 188035

    6    tmp6_k24wsf                        0x0000558840791af8 <unavailable> + 6904

    7    tmp6_k24wsf                        0x00005588407915bd <unavailable> + 5565

    8    libc.so.6                          0x00002b93bcbb2460 __libc_start_main +
    245

    9    tmp6_k24wsf                        0x00005588407912c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_numbers = [Int]()\n    var max_number = 0\n \
    \   for number in numbers {\n        max_number = max(max_number, number)\n  \
    \      max_numbers.append(max_number)\n    }\n    return max_numbers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b348cd47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b348ca3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b348ca3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b348ca3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b348ca3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b348c83de83 <unavailable> + 188035

    6    tmpp8k7st50                        0x000055b5d5e38ad8 <unavailable> + 6872

    7    tmpp8k7st50                        0x000055b5d5e385ad <unavailable> + 5549

    8    libc.so.6                          0x00002b348cf33460 __libc_start_main +
    245

    9    tmpp8k7st50                        0x000055b5d5e382b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d54ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d547a9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d547a9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d547a913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d547a8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d545a8e83 <unavailable> + 188035

    6    tmpwxlsc7x5                        0x000055584c113b68 <unavailable> + 7016

    7    tmpwxlsc7x5                        0x000055584c11362d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d54c9e460 __libc_start_main +
    245

    9    tmpwxlsc7x5                        0x000055584c113339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60d3b9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60d3893561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60d3893286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60d389313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60d3892bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60d3692e83 <unavailable> + 188035

    6    tmphsccll88                        0x000055b90acfbae8 <unavailable> + 6888

    7    tmphsccll88                        0x000055b90acfb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b60d3d88460 __libc_start_main +
    245

    9    tmphsccll88                        0x000055b90acfb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824794
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n\
    \    for number in numbers {\n        if number > max_value {\n            max_value\
    \ = number\n        }\n        result.append(max_value)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abf8c9ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf8c6c3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abf8c6c3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abf8c6c313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abf8c6c2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abf8c4c4e83 <unavailable> + 188035

    6    tmpu43yfam0                        0x000055d664871a5f <unavailable> + 6751

    7    tmpu43yfam0                        0x000055d66487152d <unavailable> + 5421

    8    libc.so.6                          0x00002abf8cbb8460 __libc_start_main +
    245

    9    tmpu43yfam0                        0x000055d664871239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppso325kz.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        max_so_far\
    \ = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f6a382c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f6a079561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f6a079286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f6a07913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f6a078bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f69e78e83 <unavailable> + 188035

    6    tmp8_3bv90z                        0x0000562d5590cb58 <unavailable> + 7000

    7    tmp8_3bv90z                        0x0000562d5590c62d <unavailable> + 5677

    8    libc.so.6                          0x00002b8f6a56e460 __libc_start_main +
    245

    9    tmp8_3bv90z                        0x0000562d5590c339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3380e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3380b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3380b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3380b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3380b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3380990e83 <unavailable> + 188035

    6    tmpxfo61d75                        0x000055d2b791eae8 <unavailable> + 6888

    7    tmpxfo61d75                        0x000055d2b791e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3381086460 __libc_start_main +
    245

    9    tmpxfo61d75                        0x000055d2b791e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824793
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60d3b9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60d3893561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60d3893286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60d389313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60d3892bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60d3692e83 <unavailable> + 188035

    6    tmphsccll88                        0x000055b90acfbae8 <unavailable> + 6888

    7    tmphsccll88                        0x000055b90acfb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b60d3d88460 __libc_start_main +
    245

    9    tmphsccll88                        0x000055b90acfb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824794
