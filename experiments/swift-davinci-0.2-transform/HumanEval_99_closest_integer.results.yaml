language: swift
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) == 0.5 {\n        if number > 0 {\n    \
    \        return ceil\n        } else {\n            return floor\n        }\n\
    \    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ decimal = number - Double(rounded)\n    if decimal > 0.5 {\n        return rounded\
    \ + 1\n    } else if decimal < -0.5 {\n        return rounded - 1\n    } else\
    \ {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    return Int(number.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    return Int(num.rounded(.awayFromZero))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RZDE4Q/tmp5x_qm8uq-1.o:tmp5x_qm8uq-1.o:function $s11tmp5x_qm8uq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1intpe.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rfjpuic.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfj"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6qmhcoc8.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floored = Int(number.rounded(.down))\n    let ceiled = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) < abs(number - Double(floored)) {\n    \
    \    return rounded\n    } else if abs(number - Double(rounded)) < abs(number\
    \ - Double(ceiled)) {\n        return rounded\n    } else if abs(number - Double(floored))\
    \ < abs(number - Double(ceiled)) {\n        return floored\n    } else {\n   \
    \     return ceiled\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2LzOfU/tmp8dgypdr5-1.o:tmp8dgypdr5-1.o:function $s11tmp8dgypdr515closest_i'
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpoovdz8zj/tmpoovdz8zj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25b182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25b1524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25b1524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25b15237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoovdz8zj                        0x000055e93337b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b25b1a19460 __libc_start_main +
    245

    6    tmpoovdz8zj                        0x000055e93337b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    let decimal = number - rounded\n    if decimal > 0.5 {\n\
    \        return roundedInt + 1\n    } else if decimal < -0.5 {\n        return\
    \ roundedInt - 1\n    } else {\n        return roundedInt\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpe6l1emno.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpop1ychme.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let dec = num - Double(int)\n\
    \    if dec < 0.5 {\n        return int\n    } else {\n        return int + 1\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpzwcaxdq_/tmpzwcaxdq_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd2b9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd2896b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd2896988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd28957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwcaxdq_                        0x00005641bab73512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd2d8b460 __libc_start_main +
    245

    6    tmpzwcaxdq_                        0x00005641bab73049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    if floorDiff == ceilDiff {\n\
    \        return number < 0 ? floor : ceil\n    }\n    return floorDiff < ceilDiff\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RpJt5Q/tmp9fcmwb5o-1.o:tmp9fcmwb5o-1.o:function $s11tmp9fcmwb5o15closest_i'
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let num_int = Int(num)\n    let num_dec = num\
    \ - Double(num_int)\n    if num_dec < 0.5 {\n        return num_int\n    } else\
    \ {\n        return num_int + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpcrymxa1d/tmpcrymxa1d.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77e4393c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77e408ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77e408a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77e40897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcrymxa1d                        0x0000556fd2153512 <unavailable> + 5394

    5    libc.so.6                          0x00002b77e457f460 __libc_start_main +
    245

    6    tmpcrymxa1d                        0x0000556fd2153049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimalNumber\
    \ = number - Double(intNumber)\n    if decimalNumber >= 0.5 {\n        return\
    \ intNumber + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp5u566b3d/tmp5u566b3d.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e7d14cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e7ce43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e7ce43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e7ce427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5u566b3d                        0x000055efb741d512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9e7d338460 __libc_start_main +
    245

    6    tmp5u566b3d                        0x000055efb741d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let rounded = round(doubleValue)\n  \
    \  return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpghv4r0el.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(doubleValue)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal < 0.5 {\n     \
    \   return intValue\n    } else {\n        return intValue + 1\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp_s0_0td_/tmp_s0_0td_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a22c64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a2295bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a2295b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a2295a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_s0_0td_                        0x000055a56c6cf512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4a22e50460 __libc_start_main +
    245

    6    tmp_s0_0td_                        0x000055a56c6cf049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor < ceil - number {\n        return Int(floor)\n    } else {\n        return\
    \ Int(ceil)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpksdwom9o.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpoovdz8zj/tmpoovdz8zj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25b182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25b1524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25b1524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25b15237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoovdz8zj                        0x000055e93337b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b25b1a19460 __libc_start_main +
    245

    6    tmpoovdz8zj                        0x000055e93337b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let intValue = Int(value)\n    let decimal\
    \ = value - Double(intValue)\n    if decimal < 0.5 {\n        return intValue\n\
    \    } else {\n        return intValue + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp4mqr1tqj/tmp4mqr1tqj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf3e2dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf3dfd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf3dfd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf3dfd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4mqr1tqj                        0x000055b6005f8512 <unavailable> + 5394

    5    libc.so.6                          0x00002abf3e4c6460 __libc_start_main +
    245

    6    tmp4mqr1tqj                        0x000055b6005f8049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    let decimal = number\
    \ - Double(int)\n    if decimal >= 0.5 {\n        return int + 1\n    } else {\n\
    \        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp_hy_7dou/tmp_hy_7dou.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8a700dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8a6d04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8a6d04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8a6d037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_hy_7dou                        0x0000560fbf5de512 <unavailable> + 5394

    5    libc.so.6                          0x00002af8a71f9460 __libc_start_main +
    245

    6    tmp_hy_7dou                        0x0000560fbf5de049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff_floor = abs(number - Double(floor))\n    let\
    \ diff_ceil = abs(number - Double(ceil))\n    if diff_floor == diff_ceil {\n \
    \       return number > 0 ? ceil : floor\n    }\n    return diff_floor < diff_ceil\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0bry3o4_.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmp0bry3o4_.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmp0bry3o4_.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmp0bry3o4_.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let floorValue = floor(doubleValue)\n\
    \    let ceilValue = ceil(doubleValue)\n    if doubleValue - floorValue < ceilValue\
    \ - doubleValue {\n        return Int(floorValue)\n    } else {\n        return\
    \ Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxwn0e7ju.swift:17:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue)\n                     ^~~~~\n/tmp/tmpxwn0e7ju.swift:18:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let rounded = value.rounded()\n    let floor\
    \ = value.rounded(.down)\n    let ceil = value.rounded(.up)\n    if value - floor\
    \ < ceil - value {\n        return Int(floor)\n    } else {\n        return Int(ceil)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp034ufppb.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = value.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link command\
    \ failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1.o:tmp034ufppb-1.o:function\
    \ $s11tmp034ufppb15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.E7oCbR/tmp034ufppb-1"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    if floorDiff < ceilDiff {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EVNEiQ/tmpz1_552wy-1.o:tmpz1_552wy-1.o:function $s11tmpz1_552wy15closest_i'
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let integerValue = Int(doubleValue)\n\
    \    let decimalValue = doubleValue - Double(integerValue)\n    if decimalValue\
    \ > 0.5 {\n        return integerValue + 1\n    } else if decimalValue < -0.5\
    \ {\n        return integerValue - 1\n    } else {\n        return integerValue\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpk63ono8j/tmpk63ono8j.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa72915c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa7260cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa7260c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa7260b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk63ono8j                        0x00005630cfc2e46b <unavailable> + 5227

    5    libc.so.6                          0x00002afa72b01460 __libc_start_main +
    245

    6    tmpk63ono8j                        0x00005630cfc2e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9xzctuen.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ decimal = number - Double(rounded)\n    if decimal > 0.5 {\n        return rounded\
    \ + 1\n    } else if decimal < -0.5 {\n        return rounded - 1\n    } else\
    \ {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Xb8D6y/tmpbfejneo4-1.o:tmpbfejneo4-1.o:function $s11tmpbfejneo415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    return\
    \ Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    if number - Double(int) == 0.5 {\n        return int + 1\n\
    \    }\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7io9dg2c.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let decimal\
    \ = number - rounded\n    if decimal < 0 {\n        return Int(rounded)\n    }\
    \ else if decimal > 0 {\n        return Int(rounded + 1)\n    } else {\n     \
    \   return Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.r9uS6T/tmp4133xsaz-1.o:tmp4133xsaz-1.o:function $s11tmp4133xsaz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    return floorDiff < ceilingDiff ? floor : ceiling\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0lcj_udd.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj_udd-1.o:tmp0lcj_udd-1.o:function\
    \ $s11tmp0lcj_udd15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.gnkLaR/tmp0lcj"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) >= 0.5 {\n        return intValue + 1\n  \
    \  } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpa34m89b6/tmpa34m89b6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd3bdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd38d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd38d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd38d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa34m89b6                        0x00005643036d3512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd3dcb460 __libc_start_main +
    245

    6    tmpa34m89b6                        0x00005643036d3049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.PhHLkQ/tmp9to7uen2-1.o:tmp9to7uen2-1.o:function $s11tmp9to7uen215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7yy15cxl.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp7yy15cxl.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp7yy15cxl.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp7yy15cxl.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    if\
    \ number - Double(rounded) >= 0.5 {\n        return rounded + 1\n    } else {\n\
    \        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Rcn9Uu/tmpipdq2yua-1.o:tmpipdq2yua-1.o:function $s11tmpipdq2yua15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diffFloor = abs(number - Double(floor))\n    let diffCeil = abs(number\
    \ - Double(ceil))\n    if diffFloor == diffCeil {\n        return number > 0 ?\
    \ ceil : floor\n    }\n    return diffFloor < diffCeil ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpczz0jbbp.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0jbbp-1.o:tmpczz0jbbp-1.o:function\
    \ $s11tmpczz0jbbp15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.GYfDaR/tmpczz0"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    return floorDiff < ceilDiff\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_i'
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ floor = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if number\
    \ - Double(floor) == 0.5 {\n        return rounded\n    } else if number - Double(floor)\
    \ > 0.5 {\n        return ceil\n    } else {\n        return floor\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjfwpjodo.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpjfwpjodo.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpjfwpjodo.swift:18:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpjfwpjodo.swift:19:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpjfwpjodo.swift:19:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number >= 0\
    \ ? ceil : floor\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpyvmmwn89.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmmwn89-1.o:tmpyvmmwn89-1.o:function\
    \ $s11tmpyvmmwn8915closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.ZpS2eU/tmpyvmm"
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpoovdz8zj/tmpoovdz8zj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25b182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25b1524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25b1524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25b15237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoovdz8zj                        0x000055e93337b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b25b1a19460 __libc_start_main +
    245

    6    tmpoovdz8zj                        0x000055e93337b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    if number\
    \ - Double(intNumber) < 0.5 {\n        return intNumber\n    } else {\n      \
    \  return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp_7q7_hfd/tmp_7q7_hfd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b03987c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b0367eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b0367e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b0367d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_7q7_hfd                        0x0000557773965512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6b03b73460 __libc_start_main +
    245

    6    tmp_7q7_hfd                        0x0000557773965049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9xzctuen.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal < 0.5 {\n        return intNumber\n\
    \    } else {\n        return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpe47ov1ny/tmpe47ov1ny.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0a68bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0a65b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0a65b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0a65b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe47ov1ny                        0x000056518f2db512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae0a6aa8460 __libc_start_main +
    245

    6    tmpe47ov1ny                        0x000056518f2db049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014043
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floor_diff = abs(number - Double(floor))\n    let ceil_diff = abs(number\
    \ - Double(ceil))\n    if floor_diff == ceil_diff {\n        return number > 0\
    \ ? ceil : floor\n    }\n    return floor_diff < ceil_diff ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0kuyu6vz.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuyu6vz-1.o:tmp0kuyu6vz-1.o:function\
    \ $s11tmp0kuyu6vz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.3cj74Q/tmp0kuy"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded == 0.5 {\n        return Int(rounded)\n    } else if number - rounded\
    \ > 0.5 {\n        return Int(rounded) + 1\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0gnckdhr.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let rounded_int\
    \ = Int(rounded)\n    if rounded - Double(rounded_int) < 0.5 {\n        return\
    \ rounded_int\n    } else {\n        return rounded_int + 1\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3mSXdb/tmpegwiitrr-1.o:tmpegwiitrr-1.o:function $s11tmpegwiitrr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ number - floor < ceil - number {\n        return floor\n    } else {\n     \
    \   return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8wfh0p7s.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmp8wfh0p7s.swift:20:30:\
    \ error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    if number - floor < ceil - number {\n                        ~~~~ ^ ~~~~~~\n\
    /tmp/tmp8wfh0p7s.swift:20:30: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n    if number - floor\
    \ < ceil - number {\n                             ^\n/tmp/tmp8wfh0p7s.swift:20:15:\
    \ error: binary operator '-' cannot be applied to operands of type 'Double' and\
    \ 'Int'\n    if number - floor < ceil - number {\n       ~~~~~~ ^ ~~~~~\n/tmp/tmp8wfh0p7s.swift:20:15:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    if number - floor < ceil - number {\n    \
    \          ^\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded) + 1\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7f549hfs.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff1 = abs(number - Double(rounded))\n    let diff2 = abs(number - Double(floor))\n\
    \    let diff3 = abs(number - Double(ceil))\n    if diff1 == 0 {\n        return\
    \ rounded\n    } else if diff2 < diff3 {\n        return floor\n    } else {\n\
    \        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.6r63fb/tmp5bim00__-1.o:tmp5bim00__-1.o:function $s11tmp5bim00__15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if rounded\
    \ - number > 0.5 {\n        return Int(rounded - 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.FSK7Da/tmpmm1z5ouh-1.o:tmpmm1z5ouh-1.o:function $s11tmpmm1z5ouh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(floor) > 0.5 {\n        return ceiling\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.lCigr9/tmp9bq84gsj-1.o:tmp9bq84gsj-1.o:function $s11tmp9bq84gsj15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    return Int(round(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp20z9juqk.swift:17:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(number))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1intpe.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rfjpuic.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfj"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7yy15cxl.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp7yy15cxl.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp7yy15cxl.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp7yy15cxl.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpruk5373f.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    if number > 0 {\n        return Int(number.rounded(.up))\n\
    \    } else {\n        return Int(number.rounded(.down))\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uAYy0k/tmpcvwxjpqz-1.o:tmpcvwxjpqz-1.o:function $s11tmpcvwxjpqz15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb5j98g80/tmpb5j98g80.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8c27dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8bf74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8bf74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8bf737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5j98g80                        0x000056172b4eb512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6d8c469460 __libc_start_main +
    245

    6    tmpb5j98g80                        0x000056172b4eb049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    if number.truncatingRemainder(dividingBy:\
    \ 1) > 0.5 {\n        return Int(number.rounded(.up))\n    } else {\n        return\
    \ Int(number.rounded(.down))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.mwBB5j/tmpm5o5_ec6-1.o:tmpm5o5_ec6-1.o:function $s11tmpm5o5_ec615closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diffRounded = abs(number - Double(rounded))\n    let diffCeiled = abs(number\
    \ - Double(ceiled))\n    let diffFloored = abs(number - Double(floored))\n   \
    \ if diffRounded < diffCeiled && diffRounded < diffFloored {\n        return rounded\n\
    \    } else if diffCeiled < diffRounded && diffCeiled < diffFloored {\n      \
    \  return ceiled\n    } else {\n        return floored\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.HlmNej/tmpr8cuwuj8-1.o:tmpr8cuwuj8-1.o:function $s11tmpr8cuwuj815closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb5j98g80/tmpb5j98g80.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8c27dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8bf74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8bf74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8bf737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5j98g80                        0x000056172b4eb512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6d8c469460 __libc_start_main +
    245

    6    tmpb5j98g80                        0x000056172b4eb049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let distanceToRounded = abs(number - Double(rounded))\n    let distanceToCeiled\
    \ = abs(number - Double(ceiled))\n    let distanceToFloored = abs(number - Double(floored))\n\
    \    if distanceToRounded < distanceToCeiled && distanceToRounded < distanceToFloored\
    \ {\n        return rounded\n    } else if distanceToCeiled < distanceToFloored\
    \ {\n        return ceiled\n    } else {\n        return floored\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wGLmwg/tmppa6qd9kr-1.o:tmppa6qd9kr-1.o:function $s11tmppa6qd9kr15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor < ceil - number {\n        return Int(floor)\n    } else {\n        return\
    \ Int(ceil)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpksdwom9o.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-1.o:tmpksdwom9o-1.o:function\
    \ $s11tmpksdwom9o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.VTfEUd/tmpksdwom9o-"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floor_diff = abs(number - Double(floor))\n    let ceil_diff = abs(number\
    \ - Double(ceil))\n    if floor_diff == ceil_diff {\n        return number < 0\
    \ ? floor : ceil\n    }\n    return floor_diff < ceil_diff ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpri80t3uw.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80t3uw-1.o:tmpri80t3uw-1.o:function\
    \ $s11tmpri80t3uw15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.jCYRPj/tmpri80"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floor_diff = abs(number - Double(floor))\n\
    \    let ceil_diff = abs(number - Double(ceil))\n    if floor_diff < ceil_diff\
    \ {\n        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    return floorDiff < ceilDiff\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_i'
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) < 0.5 {\n        return intValue\n    } else\
    \ {\n        return intValue + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp2hnekd3i/tmp2hnekd3i.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87c7101c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87c6df8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87c6df8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87c6df77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hnekd3i                        0x000055d3839ad512 <unavailable> + 5394

    5    libc.so.6                          0x00002b87c72ed460 __libc_start_main +
    245

    6    tmp2hnekd3i                        0x000055d3839ad049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.toNearestOrAwayFromZero))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff_floor = abs(number - Double(floor))\n    let diff_ceil = abs(number\
    \ - Double(ceil))\n    if diff_floor == diff_ceil {\n        return number > 0\
    \ ? ceil : floor\n    }\n    return diff_floor < diff_ceil ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx0gp3x1n.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp3x1n-1.o:tmpx0gp3x1n-1.o:function\
    \ $s11tmpx0gp3x1n15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Jj3Sqj/tmpx0gp"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\
    \ > 0 ? ceiling : floor\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let floorValue = floor(doubleValue)\n\
    \    let ceilValue = ceil(doubleValue)\n    let floorDiff = abs(doubleValue -\
    \ floorValue)\n    let ceilDiff = abs(doubleValue - ceilValue)\n    if floorDiff\
    \ == ceilDiff {\n        return Int(doubleValue < 0 ? floorValue : ceilValue)\n\
    \    }\n    return Int(floorDiff < ceilDiff ? floorValue : ceilValue)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpw9m3lk98.swift:17:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue)\n                     ^~~~~\n/tmp/tmpw9m3lk98.swift:18:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpoovdz8zj/tmpoovdz8zj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25b182dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25b1524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25b1524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25b15237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoovdz8zj                        0x000055e93337b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b25b1a19460 __libc_start_main +
    245

    6    tmpoovdz8zj                        0x000055e93337b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceiling) - number {\n        return floor\n\
    \    } else {\n        return ceiling\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppsz5a22o.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5a22o-1.o:tmppsz5a22o-1.o:function\
    \ $s11tmppsz5a22o15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.FUHU1m/tmppsz5"
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if number -\
    \ floor > ceil - number {\n        return Int(ceil)\n    } else {\n        return\
    \ Int(floor)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpi873j6le.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = number.rounded()\n    ~~~~^~~~~~~\n    _\nerror: link\
    \ command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-1.o:tmpi873j6le-1.o:function\
    \ $s11tmpi873j6le15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.0LdwTu/tmpi873j6le-"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s5FGTu/tmpr_kzzjx6-1.o:tmpr_kzzjx6-1.o:function $s11tmpr_kzzjx615closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) < 0.5 {\n        return intValue\n    } else\
    \ {\n        return intValue + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp2hnekd3i/tmp2hnekd3i.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87c7101c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87c6df8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87c6df8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87c6df77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hnekd3i                        0x000055d3839ad512 <unavailable> + 5394

    5    libc.so.6                          0x00002b87c72ed460 __libc_start_main +
    245

    6    tmp2hnekd3i                        0x000055d3839ad049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mnfnrq9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal < 0.5 {\n        return int\n    } else {\n        return int\
    \ + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp3wwshpld/tmp3wwshpld.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6a7b61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6a7858b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6a7858988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6a78577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3wwshpld                        0x000055f1c250d512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab6a7d4d460 __libc_start_main +
    245

    6    tmp3wwshpld                        0x000055f1c250d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return number\
    \ < 0 ? floor : ceiling\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdug5g_87.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5g_87-1.o:tmpdug5g_87-1.o:function\
    \ $s11tmpdug5g_8715closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.SYD0kl/tmpdug5"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let roundedNumber = Int(number.rounded())\n\
    \    let decimal = number - Double(roundedNumber)\n    if decimal > 0.5 {\n  \
    \      return roundedNumber + 1\n    } else if decimal < -0.5 {\n        return\
    \ roundedNumber - 1\n    } else {\n        return roundedNumber\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.bz06kj/tmpqekope_e-1.o:tmpqekope_e-1.o:function $s11tmpqekope_e15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimalNumber\
    \ = number - Double(intNumber)\n    if decimalNumber < 0.5 {\n        return intNumber\n\
    \    } else {\n        return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpqyefodoj/tmpqyefodoj.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6715cbbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67159b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67159b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67159b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqyefodoj                        0x0000557f26861512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6715ea7460 __libc_start_main +
    245

    6    tmpqyefodoj                        0x0000557f26861049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floor_diff = abs(number - Double(floor))\n\
    \    let ceil_diff = abs(number - Double(ceil))\n    if floor_diff < ceil_diff\
    \ {\n        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.WXYXVi/tmps5djzb57-1.o:tmps5djzb57-1.o:function $s11tmps5djzb5715closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ decimal = number - Double(rounded)\n    if decimal >= 0.5 {\n        return\
    \ rounded + 1\n    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.EaLaom/tmpt8xypwkg-1.o:tmpt8xypwkg-1.o:function $s11tmpt8xypwkg15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) < 0.5 {\n        return intValue\n    } else\
    \ {\n        return intValue + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp2hnekd3i/tmp2hnekd3i.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87c7101c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87c6df8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87c6df8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87c6df77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hnekd3i                        0x000055d3839ad512 <unavailable> + 5394

    5    libc.so.6                          0x00002b87c72ed460 __libc_start_main +
    245

    6    tmp2hnekd3i                        0x000055d3839ad049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let int\
    \ = Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QArcll/tmpu7k71jtt-1.o:tmpu7k71jtt-1.o:function $s11tmpu7k71jtt15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\
    \ > 0 ? ceiling : floor\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gjPbTN/tmp5gaf5wrq-1.o:tmp5gaf5wrq-1.o:function $s11tmp5gaf5wrq15closest_i'
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6qmhcoc8.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimalNumber\
    \ = number - Double(intNumber)\n    if decimalNumber >= 0.5 {\n        return\
    \ intNumber + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp5u566b3d/tmp5u566b3d.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e7d14cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e7ce43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e7ce43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e7ce427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5u566b3d                        0x000055efb741d512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9e7d338460 __libc_start_main +
    245

    6    tmp5u566b3d                        0x000055efb741d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpth5ptwc1.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let dec = num - Double(int)\n\
    \    if dec < 0.5 {\n        return int\n    } else {\n        return int + 1\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpzwcaxdq_/tmpzwcaxdq_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd2b9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd2896b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd2896988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd28957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwcaxdq_                        0x00005641bab73512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd2d8b460 __libc_start_main +
    245

    6    tmpzwcaxdq_                        0x00005641bab73049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ ceiled = Int(ceil(number))\n    let floored = Int(floor(number))\n    if abs(rounded\
    \ - number) < abs(ceiled - number) {\n        return rounded\n    } else if abs(rounded\
    \ - number) > abs(ceiled - number) {\n        return ceiled\n    } else {\n  \
    \      return floored\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpnvj_sn8l.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpnvj_sn8l.swift:18:22:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = Int(ceil(number))\n   \
    \                  ^~~~\n/tmp/tmpnvj_sn8l.swift:19:23: error: cannot find 'floor'\
    \ in scope\n    let floored = Int(floor(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diff_rounded = abs(number - Double(rounded))\n    let diff_ceiled = abs(number\
    \ - Double(ceiled))\n    let diff_floored = abs(number - Double(floored))\n  \
    \  if diff_rounded <= diff_ceiled && diff_rounded <= diff_floored {\n        return\
    \ rounded\n    } else if diff_ceiled <= diff_rounded && diff_ceiled <= diff_floored\
    \ {\n        return ceiled\n    } else {\n        return floored\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nirpDo/tmp0w8zjh67-1.o:tmp0w8zjh67-1.o:function $s11tmp0w8zjh6715closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let floor\
    \ = number.rounded(.down)\n    let ceil = number.rounded(.up)\n    if (rounded\
    \ - floor) < (ceil - rounded) {\n        return Int(floor)\n    } else {\n   \
    \     return Int(ceil)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.eTU6wo/tmphvzkqpwj-1.o:tmphvzkqpwj-1.o:function $s11tmphvzkqpwj15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff1 = abs(number - Double(rounded))\n    let diff2 = abs(number - Double(floor))\n\
    \    let diff3 = abs(number - Double(ceil))\n    if diff1 < diff2 && diff1 < diff3\
    \ {\n        return rounded\n    } else if diff2 < diff1 && diff2 < diff3 {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    if number\
    \ - Double(intNumber) < 0.5 {\n        return intNumber\n    } else {\n      \
    \  return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp_7q7_hfd/tmp_7q7_hfd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b03987c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b0367eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b0367e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b0367d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_7q7_hfd                        0x0000557773965512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6b03b73460 __libc_start_main +
    245

    6    tmp_7q7_hfd                        0x0000557773965049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let intValue = Int(value)\n    let decimal\
    \ = value - Double(intValue)\n    if decimal >= 0.5 {\n        return intValue\
    \ + 1\n    } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmptruj1qor/tmptruj1qor.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69a0815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69a050cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69a050c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69a050b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptruj1qor                        0x000056319e36b512 <unavailable> + 5394

    5    libc.so.6                          0x00002b69a0a01460 __libc_start_main +
    245

    6    tmptruj1qor                        0x000056319e36b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let rounded_away_from_zero\
    \ = rounded.rounded(.awayFromZero)\n    let rounded_towards_zero = rounded.rounded(.towardZero)\n\
    \    if rounded_away_from_zero == rounded_towards_zero {\n        return Int(rounded_away_from_zero)\n\
    \    }\n    if abs(rounded_away_from_zero - number) < abs(rounded_towards_zero\
    \ - number) {\n        return Int(rounded_away_from_zero)\n    }\n    return Int(rounded_towards_zero)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.F6UAnq/tmpl7qo30mb-1.o:tmpl7qo30mb-1.o:function $s11tmpl7qo30mb15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb5j98g80/tmpb5j98g80.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8c27dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d8bf74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d8bf74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d8bf737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5j98g80                        0x000056172b4eb512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6d8c469460 __libc_start_main +
    245

    6    tmpb5j98g80                        0x000056172b4eb049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded == 0.5 {\n        return Int(rounded) + 1\n    }\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Wjzknq/tmp9jpqn1sk-1.o:tmp9jpqn1sk-1.o:function $s11tmp9jpqn1sk15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) >= 0.5 {\n        return intValue + 1\n  \
    \  } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpa34m89b6/tmpa34m89b6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd3bdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd38d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd38d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd38d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa34m89b6                        0x00005643036d3512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd3dcb460 __libc_start_main +
    245

    6    tmpa34m89b6                        0x00005643036d3049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(rounded)\n    let ceil = Int(rounded) + 1\n    let diffFloor = abs(number\
    \ - Double(floor))\n    let diffCeil = abs(number - Double(ceil))\n    if diffFloor\
    \ < diffCeil {\n        return floor\n    } else {\n        return ceil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpocp8bsmh.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1intpe.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    if rounded - Double(roundedInt) < 0.5 {\n        return\
    \ roundedInt\n    } else {\n        return roundedInt + 1\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpgl_2fbgv.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpn5zuqzif/tmpn5zuqzif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42db182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42dae79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42dae79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42dae787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5zuqzif                        0x0000561b266a5512 <unavailable> + 5394

    5    libc.so.6                          0x00002b42db36e460 __libc_start_main +
    245

    6    tmpn5zuqzif                        0x0000561b266a5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let floorValue = floor(doubleValue)\n\
    \    let ceilValue = ceil(doubleValue)\n    if doubleValue - floorValue < ceilValue\
    \ - doubleValue {\n        return Int(floorValue)\n    } else {\n        return\
    \ Int(ceilValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxwn0e7ju.swift:17:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(doubleValue)\n                     ^~~~~\n/tmp/tmpxwn0e7ju.swift:18:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(doubleValue)\n\
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014130
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    if num - Double(int)\
    \ >= 0.5 {\n        return int + 1\n    } else {\n        return int\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpxl3dcv2u/tmpxl3dcv2u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ad75a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ad729db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ad729d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ad729c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxl3dcv2u                        0x0000556350ab0512 <unavailable> + 5394

    5    libc.so.6                          0x00002b2ad7792460 __libc_start_main +
    245

    6    tmpxl3dcv2u                        0x0000556350ab0049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    return\
    \ Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.0ma5OM/tmpun2am6bj-1.o:tmpun2am6bj-1.o:function $s11tmpun2am6bj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if rounded\
    \ > number {\n        return Int(rounded - 1)\n    }\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpu1z8wp4y.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if rounded\
    \ > number {\n        return Int(rounded)\n    } else {\n        return Int(rounded\
    \ + 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpyns42ef9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ decimal = number - Double(rounded)\n    return decimal >= 0.5 ? rounded + 1\
    \ : rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.SC9CcA/tmprrkolb0z-1.o:tmprrkolb0z-1.o:function $s11tmprrkolb0z15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = Int(doubleValue.rounded())\n\
    \    return roundedValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ToVC2E/tmpm_7mauut-1.o:tmpm_7mauut-1.o:function $s11tmpm_7mauut15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundedValue = round(doubleValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxtcwcati.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < 0.5 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz5m7rozs.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpz5m7rozs.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpz5m7rozs.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpz5m7rozs.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014041
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let floorDiff = abs(number - Double(floor))\n\
    \    let ceilDiff = abs(number - Double(ceil))\n    return floorDiff < ceilDiff\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.uNkk5T/tmphptydcrs-1.o:tmphptydcrs-1.o:function $s11tmphptydcrs15closest_i'
  stdout: ''
  timestamp: 1660014130
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ ceiled = Int(ceil(number))\n    let floored = Int(floor(number))\n    if number\
    \ - Double(floored) < 0.5 {\n        return floored\n    } else if Double(ceiled)\
    \ - number < 0.5 {\n        return ceiled\n    } else {\n        return rounded\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpsujxtuvf.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmpsujxtuvf.swift:18:22:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = Int(ceil(number))\n   \
    \                  ^~~~\n/tmp/tmpsujxtuvf.swift:19:23: error: cannot find 'floor'\
    \ in scope\n    let floored = Int(floor(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    if number - Double(floor) < Double(ceil)\
    \ - number {\n        return floor\n    } else {\n        return ceil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.GrBFBB/tmp73u0tj_t-1.o:tmp73u0tj_t-1.o:function $s11tmp73u0tj_t15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number > 0 ?\
    \ ceil : floor\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxfdly6de.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdly6de-1.o:tmpxfdly6de-1.o:function\
    \ $s11tmpxfdly6de15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.AGRkf4/tmpxfdl"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rfjpuic.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfjpuic-1.o:tmp_rfjpuic-1.o:function\
    \ $s11tmp_rfjpuic15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Nf1VSu/tmp_rfj"
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if rounded - number ==\
    \ 0.5 {\n        return Int(ceiled)\n    } else if number - rounded == 0.5 {\n\
    \        return Int(floored)\n    } else {\n        return Int(rounded)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq6v6dyax.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpq6v6dyax.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpq6v6dyax.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if doubleValue - Double(intValue) >= 0.5 {\n        return intValue + 1\n  \
    \  } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpa34m89b6/tmpa34m89b6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbd3bdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbd38d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbd38d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbd38d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa34m89b6                        0x00005643036d3512 <unavailable> + 5394

    5    libc.so.6                          0x00002afbd3dcb460 __libc_start_main +
    245

    6    tmpa34m89b6                        0x00005643036d3049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded) + 1\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Nc1eBB/tmpq3r_93t4-1.o:tmpq3r_93t4-1.o:function $s11tmpq3r_93t415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if rounded - number ==\
    \ 0.5 {\n        return Int(ceiled)\n    } else if number - rounded == 0.5 {\n\
    \        return Int(floored)\n    } else {\n        return Int(rounded)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq6v6dyax.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpq6v6dyax.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpq6v6dyax.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let decimal = number.truncatingRemainder(dividingBy:\
    \ 1)\n    if decimal >= 0.5 {\n        return Int(number) + 1\n    } else {\n\
    \        return Int(number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpx63d1d92/tmpx63d1d92.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b4b7ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b4b4c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b4b4c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b4b4c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx63d1d92                        0x00005592b86c45f2 <unavailable> + 5618

    5    libc.so.6                          0x00002b5b4b9b8460 __libc_start_main +
    245

    6    tmpx63d1d92                        0x00005592b86c4129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let roundedInt\
    \ = Int(rounded)\n    if rounded - Double(roundedInt) >= 0.5 {\n        return\
    \ roundedInt + 1\n    } else {\n        return roundedInt\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gIRUBB/tmp626xye8w-1.o:tmp626xye8w-1.o:function $s11tmp626xye8w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = doubleValue - Double(intValue)\n    if decimal >= 0.5 {\n    \
    \    return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphrztj8i1/tmphrztj8i1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf8553fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf85236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf85236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf852357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrztj8i1                        0x00005640fb238512 <unavailable> + 5394

    5    libc.so.6                          0x00002aaf8572b460 __libc_start_main +
    245

    6    tmphrztj8i1                        0x00005640fb238049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff1 = abs(number - Double(rounded))\n    let diff2 = abs(number - Double(floor))\n\
    \    let diff3 = abs(number - Double(ceil))\n    if diff1 < diff2 && diff1 < diff3\
    \ {\n        return rounded\n    } else if diff2 < diff1 && diff2 < diff3 {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.luu9Wo/tmpru3ffrj_-1.o:tmpru3ffrj_-1.o:function $s11tmpru3ffrj_15closest_i'
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimalValue = doubleValue - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp51_hz_j6/tmp51_hz_j6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a3878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a356fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2a356f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2a356e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51_hz_j6                        0x000056304faa4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae2a3a64460 __libc_start_main +
    245

    6    tmp51_hz_j6                        0x000056304faa4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let rounded = round(value)\n    let ceiled\
    \ = ceil(value)\n    let floored = floor(value)\n    if value - rounded == 0 {\n\
    \        return Int(rounded)\n    } else if value - rounded > 0 {\n        return\
    \ Int(ceiled)\n    } else {\n        return Int(floored)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpul6xsthm.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(value)\n                  ^~~~~\n/tmp/tmpul6xsthm.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(value)\n         \
    \        ^~~~\n/tmp/tmpul6xsthm.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(value)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpvmf5afa_/tmpvmf5afa_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74a8338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74a802fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74a802f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74a802e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmf5afa_                        0x000055556e231512 <unavailable> + 5394

    5    libc.so.6                          0x00002b74a8524460 __libc_start_main +
    245

    6    tmpvmf5afa_                        0x000055556e231049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if abs(number - Double(rounded)) == 0.5 {\n        if number > 0 {\n    \
    \        return ceil\n        } else {\n            return floor\n        }\n\
    \    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.OwhxoK/tmp5c_w1hoj-1.o:tmp5c_w1hoj-1.o:function $s11tmp5c_w1hoj15closest_i'
  stdout: ''
  timestamp: 1660014042
