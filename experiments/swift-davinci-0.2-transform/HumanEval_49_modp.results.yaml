language: swift
name: HumanEval_49_modp
results:
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    var p\
    \ = p\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6847e60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6847b57561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6847b57286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6847b5713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6847b56bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo0t_g801                        0x0000563dfef21730 <unavailable> + 5936

    6    tmpo0t_g801                        0x0000563dfef211e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b684804c460 __libc_start_main +
    245

    8    tmpo0t_g801                        0x0000563dfef20ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (n * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp7zethb4l/tmp7zethb4l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ec3a49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ec3740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ec3740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ec373f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7zethb4l                        0x000055da2f7752cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1ec3c35460 __libc_start_main +
    245

    6    tmp7zethb4l                        0x000055da2f774ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n & 1 == 1 {\n            result = (result\
    \ * p) % MOD\n        }\n        n >>= 1\n        p = (p * p) % MOD\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp695xgy2m.swift:19:37: error: cannot find 'MOD' in scope\n     \
    \       result = (result * p) % MOD\n                                    ^~~\n\
    /tmp/tmp695xgy2m.swift:22:23: error: cannot find 'MOD' in scope\n        p = (p\
    \ * p) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % mod\n        }\n        n /= 2\n        p = (p * p) % mod\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0iwi50iv.swift:19:37: error: cannot find 'mod' in scope\n     \
    \       result = (result * p) % mod\n                                    ^~~\n\
    /tmp/tmp0iwi50iv.swift:22:23: error: cannot find 'mod' in scope\n        p = (p\
    \ * p) % mod\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp5p2dpgjb/tmp5p2dpgjb.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad509e4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad509b42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad509b42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad509b417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5p2dpgjb                        0x00005633b13dd24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad50a037460 __libc_start_main +
    245

    6    tmp5p2dpgjb                        0x00005633b13dcef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp2s9igl4r/tmp2s9igl4r.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab82d305c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab82cffcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab82cffc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab82cffb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2s9igl4r                        0x000055f2f68a52cd <unavailable> + 4813

    5    libc.so.6                          0x00002ab82d4f1460 __libc_start_main +
    245

    6    tmp2s9igl4r                        0x000055f2f68a4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let m = modp(n: n / 2, p: p)\n        return (m\
    \ * m) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp01wssv84/tmp01wssv84.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c091c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c08eb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c08eb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c08eb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01wssv84                        0x00005580ed3d92cd <unavailable> + 4813

    5    libc.so.6                          0x00002b6c093ad460 __libc_start_main +
    245

    6    tmp01wssv84                        0x00005580ed3d8ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return (y\
    \ * y) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpoo3bxk74/tmpoo3bxk74.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b3dfb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b3dcaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b3dcae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b3dcad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoo3bxk74                        0x000055f44d17b2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b7b3e1a3460 __libc_start_main +
    245

    6    tmpoo3bxk74                        0x000055f44d17aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (n * modp(n: n - 1, p: p)) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp7zethb4l/tmp7zethb4l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ec3a49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ec3740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ec3740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ec373f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7zethb4l                        0x000055da2f7752cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1ec3c35460 __libc_start_main +
    245

    6    tmp7zethb4l                        0x000055da2f774ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var res\
    \ = 1\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e96f3cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e96c33561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5e96c33286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5e96c3313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5e96c32bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpvkiwzy9e                        0x00005641744c569d <unavailable> + 5789

    6    tmpvkiwzy9e                        0x00005641744c51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b5e97128460 __libc_start_main +
    245

    8    tmpvkiwzy9e                        0x00005641744c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % MOD\n        }\n        n /= 2\n        p = (p * p) % MOD\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpws5o7_l1.swift:19:37: error: cannot find 'MOD' in scope\n     \
    \       result = (result * p) % MOD\n                                    ^~~\n\
    /tmp/tmpws5o7_l1.swift:22:23: error: cannot find 'MOD' in scope\n        p = (p\
    \ * p) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var x = modp(n: n / 2, p: p)\n    x = (x * x) % p\n    if n % 2 == 1 {\n\
    \        x = (x * 2) % p\n    }\n    return x\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt6_fwv8b/tmpt6_fwv8b.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04867e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04864dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04864df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04864de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6_fwv8b                        0x0000562cf67b724d <unavailable> + 4685

    5    libc.so.6                          0x00002b04869d4460 __libc_start_main +
    245

    6    tmpt6_fwv8b                        0x0000562cf67b6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp3pln77q9/tmp3pln77q9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d947cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d944c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d944c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d944c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3pln77q9                        0x000055f3b2bb824d <unavailable> + 4685

    5    libc.so.6                          0x00002b5d949bb460 __libc_start_main +
    245

    6    tmp3pln77q9                        0x000055f3b2bb7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let r = modp(n: n / 2, p: p)\n        return (r\
    \ * r) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpef3lv27c/tmpef3lv27c.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9a7f77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9a7c6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9a7c6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9a7c6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpef3lv27c                        0x00005573b9f752cd <unavailable> + 4813

    5    libc.so.6                          0x00002ae9a8163460 __libc_start_main +
    245

    6    tmpef3lv27c                        0x00005573b9f74ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp3pln77q9/tmp3pln77q9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d947cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d944c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d944c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d944c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3pln77q9                        0x000055f3b2bb824d <unavailable> + 4685

    5    libc.so.6                          0x00002b5d949bb460 __libc_start_main +
    245

    6    tmp3pln77q9                        0x000055f3b2bb7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (n % p) * modp(n: n - 1, p: p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpqoejf4a2/tmpqoejf4a2.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ace665c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ace35cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ace35c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ace35b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqoejf4a2                        0x000056339f6dd2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b0ace851460 __libc_start_main +
    245

    6    tmpqoejf4a2                        0x000056339f6dcef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % MOD\n        }\n        n /= 2\n        p = (p * p) % MOD\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpws5o7_l1.swift:19:37: error: cannot find 'MOD' in scope\n     \
    \       result = (result * p) % MOD\n                                    ^~~\n\
    /tmp/tmpws5o7_l1.swift:22:23: error: cannot find 'MOD' in scope\n        p = (p\
    \ * p) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: 2, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014369
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let t = modp(n: n / 2, p: p)\n        return (t\
    \ * t) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp__wr2u6w/tmp__wr2u6w.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f31ff2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f31ce9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f31ce9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f31ce87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__wr2u6w                        0x00005603c774d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b8f321de460 __libc_start_main +
    245

    6    tmp__wr2u6w                        0x00005603c774cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % n\n        }\n        n = n / 2\n        p = (p * p) % n\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ae54b4d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae54b1c9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae54b1c9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae54b1c913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae54b1c8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpdllv0tai                        0x000055ee25fd28f9 <unavailable> + 6393

    6    tmpdllv0tai                        0x000055ee25fd21e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ae54b6be460 __libc_start_main +
    245

    8    tmpdllv0tai                        0x000055ee25fd1ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    if n < 0\
    \ {\n        n = n % p + p\n    }\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014363
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp3pln77q9/tmp3pln77q9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d947cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d944c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d944c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d944c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3pln77q9                        0x000055f3b2bb824d <unavailable> + 4685

    5    libc.so.6                          0x00002b5d949bb460 __libc_start_main +
    245

    6    tmp3pln77q9                        0x000055f3b2bb7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var r = 1\n    while n\
    \ > 0 {\n        if n & 1 == 1 {\n            r = (r * n) % p\n        }\n   \
    \     n = n >> 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8y1zccca/tmp8y1zccca.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61a2739c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61a2430b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61a2430988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61a242f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8y1zccca                        0x000055ed9f84f2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b61a2925460 __libc_start_main +
    245

    6    tmp8y1zccca                        0x000055ed9f84eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n & 1 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b1105fe0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1105cd7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1105cd7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1105cd713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1105cd6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpwetfkehq                        0x000055b51de9b69d <unavailable> + 5789

    6    tmpwetfkehq                        0x000055b51de9b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b11061cc460 __libc_start_main +
    245

    8    tmpwetfkehq                        0x000055b51de9aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = n % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8nx3ux0u/tmp8nx3ux0u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529e363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529e05ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529e05a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529e0597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nx3ux0u                        0x000055c9734162cd <unavailable> + 4813

    5    libc.so.6                          0x00002b529e54f460 __libc_start_main +
    245

    6    tmp8nx3ux0u                        0x000055c973415ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = n % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8nx3ux0u/tmp8nx3ux0u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529e363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529e05ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529e05a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529e0597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nx3ux0u                        0x000055c9734162cd <unavailable> + 4813

    5    libc.so.6                          0x00002b529e54f460 __libc_start_main +
    245

    6    tmp8nx3ux0u                        0x000055c973415ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * p) % 101\n\
    \        }\n        p = (p * p) % 101\n        n /= 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdyncz1pz.swift:20:9: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n        p = (p * p) % 101\n        ^\n"
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var res = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n\
    \        n = n / 2\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpmyridlds/tmpmyridlds.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e451a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e44e9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e44e9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e44e9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmyridlds                        0x000055a6bf06124d <unavailable> + 4685

    5    libc.so.6                          0x00002b4e45391460 __libc_start_main +
    245

    6    tmpmyridlds                        0x000055a6bf060ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: 2, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014369
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var result = 1\n    var n = n\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            result = (result * 2) % p\n        }\n        n /= 2\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpw2h_ewyc/tmpw2h_ewyc.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40fcde1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40fcad8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40fcad8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40fcad77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw2h_ewyc                        0x000055bbc828824d <unavailable> + 4685

    5    libc.so.6                          0x00002b40fcfcd460 __libc_start_main +
    245

    6    tmpw2h_ewyc                        0x000055bbc8287ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    var p\
    \ = p\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b6847e60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6847b57561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6847b57286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6847b5713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6847b56bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo0t_g801                        0x0000563dfef21730 <unavailable> + 5936

    6    tmpo0t_g801                        0x0000563dfef211e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b684804c460 __libc_start_main +
    245

    8    tmpo0t_g801                        0x0000563dfef20ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    var m = n\n    var result =\
    \ 1\n    while m > 0 {\n        if m % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = (n * n) % p\n        m = m / 2\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph80s_9s1.swift:26:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8wjrj6_f/tmp8wjrj6_f.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac64113fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac640e36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac640e36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac640e357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8wjrj6_f                        0x000056245f1ac24d <unavailable> + 4685

    5    libc.so.6                          0x00002ac64132b460 __libc_start_main +
    245

    6    tmp8wjrj6_f                        0x000056245f1abef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt6_fwv8b/tmpt6_fwv8b.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04867e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04864dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04864df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04864de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6_fwv8b                        0x0000562cf67b724d <unavailable> + 4685

    5    libc.so.6                          0x00002b04869d4460 __libc_start_main +
    245

    6    tmpt6_fwv8b                        0x0000562cf67b6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var base = n % p\n\
    \    var exponent = n\n    while exponent > 0 {\n        if exponent % 2 == 1\
    \ {\n            result = (result * base) % p\n        }\n        exponent /=\
    \ 2\n        base = (base * base) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj5jhy1cm/tmpj5jhy1cm.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e37965c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e3765cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e3765c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e3765b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj5jhy1cm                        0x000055e5eee0224d <unavailable> + 4685

    5    libc.so.6                          0x00002b2e37b51460 __libc_start_main +
    245

    6    tmpj5jhy1cm                        0x000055e5eee01ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8wjrj6_f/tmp8wjrj6_f.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac64113fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac640e36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac640e36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac640e357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8wjrj6_f                        0x000056245f1ac24d <unavailable> + 4685

    5    libc.so.6                          0x00002ac64132b460 __libc_start_main +
    245

    6    tmp8wjrj6_f                        0x000056245f1abef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var res = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p\n        }\n\
    \        n /= 2\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpyp8dh1do/tmpyp8dh1do.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af22c90cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af22c603b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af22c603988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af22c6027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyp8dh1do                        0x000056202675f24d <unavailable> + 4685

    5    libc.so.6                          0x00002af22caf8460 __libc_start_main +
    245

    6    tmpyp8dh1do                        0x000056202675eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let result = modp(n: n, p: p, x: 1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprk01w6ai.swift:14:38: error: extra argument 'x' in call\n    let\
    \ result = modp(n: n, p: p, x: 1)\n                     ~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % MOD\n        }\n        n = n / 2\n        p = (p * p) % MOD\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_jbn1m5j.swift:19:37: error: cannot find 'MOD' in scope\n     \
    \       result = (result * p) % MOD\n                                    ^~~\n\
    /tmp/tmp_jbn1m5j.swift:22:23: error: cannot find 'MOD' in scope\n        p = (p\
    \ * p) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var result = 1\n    var base = n\n    while p > 0 {\n        if p % 2 ==\
    \ 1 {\n            result = (result * base) % n\n        }\n        base = (base\
    \ * base) % n\n        p /= 2\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp04t95vps.swift:24:11: error: left side of mutating operator isn't\
    \ mutable: 'p' is a 'let' constant\n        p /= 2\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = n % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8nx3ux0u/tmp8nx3ux0u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529e363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529e05ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529e05a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529e0597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nx3ux0u                        0x000055c9734162cd <unavailable> + 4813

    5    libc.so.6                          0x00002b529e54f460 __libc_start_main +
    245

    6    tmp8nx3ux0u                        0x000055c973415ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = (n * n) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014291
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n /= 2\n        p = (p * p) % 101\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph8m_049u/tmph8m_049u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9b39d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9b36cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9b36cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9b36ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8m_049u                        0x000055d45488f24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad9b3bc4460 __libc_start_main +
    245

    6    tmph8m_049u                        0x000055d45488eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        n = n % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8nx3ux0u/tmp8nx3ux0u.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529e363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529e05ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529e05a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529e0597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8nx3ux0u                        0x000055c9734162cd <unavailable> + 4813

    5    libc.so.6                          0x00002b529e54f460 __libc_start_main +
    245

    6    tmp8nx3ux0u                        0x000055c973415ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n & 1 == 1 {\n            result = (result\
    \ * p) % MOD\n        }\n        n >>= 1\n        p = (p * p) % MOD\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp695xgy2m.swift:19:37: error: cannot find 'MOD' in scope\n     \
    \       result = (result * p) % MOD\n                                    ^~~\n\
    /tmp/tmp695xgy2m.swift:22:23: error: cannot find 'MOD' in scope\n        p = (p\
    \ * p) % MOD\n                      ^~~\n"
  stdout: ''
  timestamp: 1660014363
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp1ydqyovw/tmp1ydqyovw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b992a7bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b992a4b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b992a4b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b992a4b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ydqyovw                        0x000055a2f1bfa2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b992a9a8460 __libc_start_main +
    245

    6    tmp1ydqyovw                        0x000055a2f1bf9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var base = n % p\n\
    \    var exponent = n\n    while exponent > 0 {\n        if exponent % 2 == 1\
    \ {\n            result = (result * base) % p\n        }\n        exponent >>=\
    \ 1\n        base = (base * base) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp_2i8y7kj/tmp_2i8y7kj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5f0f0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5f0c05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5f0c05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5f0c047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_2i8y7kj                        0x000055c47ef1d24d <unavailable> + 4685

    5    libc.so.6                          0x00002af5f10fa460 __libc_start_main +
    245

    6    tmp_2i8y7kj                        0x000055c47ef1cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe06d295u/tmpe06d295u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0fbb88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0fb87fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0fb87f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0fb87e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe06d295u                        0x00005575f181524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab0fbd74460 __libc_start_main +
    245

    6    tmpe06d295u                        0x00005575f1814ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n  \
    \      }\n        n /= 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp43iroj9l/tmp43iroj9l.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0de27f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0de24eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0de24ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0de24ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp43iroj9l                        0x000056174b4c524d <unavailable> + 4685

    5    libc.so.6                          0x00002b0de29e3460 __libc_start_main +
    245

    6    tmp43iroj9l                        0x000056174b4c4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002baa90b90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa90887561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa90887286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa9088713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa90886bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzvd9j90q                        0x000055c8dc609730 <unavailable> + 5936

    6    tmpzvd9j90q                        0x000055c8dc6091e0 <unavailable> + 4576

    7    libc.so.6                          0x00002baa90d7c460 __libc_start_main +
    245

    8    tmpzvd9j90q                        0x000055c8dc608ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n: n / 2, p: p)\n        return (x\
    \ * x) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptd3w04e6/tmptd3w04e6.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affba90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affba606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affba606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affba6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd3w04e6                        0x0000560da8d942cd <unavailable> + 4813

    5    libc.so.6                          0x00002affbaafb460 __libc_start_main +
    245

    6    tmptd3w04e6                        0x0000560da8d93ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101\n        }\n        n = n / 2\n        p = (p * p) % 101\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4jdsv5k1/tmp4jdsv5k1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1785395c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b178508cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b178508c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b178508b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jdsv5k1                        0x000055e0e1d1e24d <unavailable> + 4685

    5    libc.so.6                          0x00002b1785581460 __libc_start_main +
    245

    6    tmp4jdsv5k1                        0x000055e0e1d1def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    var result\
    \ = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n        p = (p * p) % p\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3d1413c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3d110a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac3d110a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac3d110a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac3d1109bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgshix713                        0x00005631ae41b730 <unavailable> + 5936

    6    tmpgshix713                        0x00005631ae41b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ac3d15ff460 __libc_start_main +
    245

    8    tmpgshix713                        0x00005631ae41aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
