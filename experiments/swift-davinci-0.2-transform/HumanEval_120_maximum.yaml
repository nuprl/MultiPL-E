name: HumanEval_120_maximum
language: swift
prompt: "\n/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
  \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
  \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
  \ [Int], k: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4,\
  \ -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0,\
  \ 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3],\
  \ k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7)\
  \ == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
  \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
  \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
  assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
completions: ["    var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n\
    \        var max = Int.min\n        var maxIndex = 0\n        for i in 0..<arr.count\
    \ {\n            if arr[i] > max {\n                max = arr[i]\n           \
    \     maxIndex = i\n            }\n        }\n        result.append(max)\n   \
    \     arr.remove(at: maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ for _ in 0..<k {\n        var max = Int.min\n        var index = 0\n       \
    \ for i in 0..<arr.count {\n            if arr[i] > max {\n                max\
    \ = arr[i]\n                index = i\n            }\n        }\n        result.append(max)\n\
    \        arr.remove(at: index)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ for _ in 0..<k {\n        var max = Int.min\n        var index = 0\n       \
    \ for i in 0..<arr.count {\n            if arr[i] > max {\n                max\
    \ = arr[i]\n                index = i\n            }\n        }\n        result.append(max)\n\
    \        arr.remove(at: index)\n    }\n    return result", "    let n = arr.count\n\
    \    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in\
    \ 0..<k {\n        maxHeap.insert(arr[i])\n    }\n    for i in k..<n {\n     \
    \   if arr[i] < maxHeap.peek()! {\n            maxHeap.replace(arr[i])\n     \
    \   }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var index = 0\n   \
    \ while index < k {\n        var max = arr[index]\n        var maxIndex = index\n\
    \        for i in index..<arr.count {\n            if arr[i] > max {\n       \
    \         max = arr[i]\n                maxIndex = i\n            }\n        }\n\
    \        result.append(max)\n        arr.swapAt(index, maxIndex)\n        index\
    \ += 1\n    }\n    return result", "    var result = [Int]()\n    var maxHeap\
    \ = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for num in arr {\n\
    \        if result.count < k {\n            result.append(num)\n            result.sort()\n\
    \        } else {\n            if num > result[0] {\n                result.remove(at:\
    \ 0)\n                result.append(num)\n                result.sort()\n    \
    \        }\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        if\
    \ i < k {\n            maxHeap.insert(arr[i])\n        } else if arr[i] < maxHeap.peek()!\
    \ {\n            maxHeap.insert(arr[i])\n            maxHeap.remove()\n      \
    \  }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num in arr\
    \ {\n        heap.insert(num)\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        heap.insert(arr[i])\n        if heap.count\
    \ > k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty\
    \ {\n        result.append(heap.remove()!)\n    }\n    return result", "    var\
    \ result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var sortedArr = arr.sorted()\n    for i in 0..<k\
    \ {\n        result.append(sortedArr[sortedArr.count - i - 1])\n    }\n    return\
    \ result", "    var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for\
    \ num in arr {\n        heap.insert(num)\n        if heap.count > k {\n      \
    \      heap.remove()\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ for _ in 0..<k {\n        var max = Int.min\n        var maxIndex = -1\n   \
    \     for i in 0..<arr.count {\n            if arr[i] > max {\n              \
    \  max = arr[i]\n                maxIndex = i\n            }\n        }\n    \
    \    result.append(max)\n        arr.remove(at: maxIndex)\n    }\n    return result",
  "    var result = [Int]()\n    for i in 0..<k {\n        var max = Int.min\n   \
    \     var maxIndex = -1\n        for j in i..<arr.count {\n            if arr[j]\
    \ > max {\n                max = arr[j]\n                maxIndex = j\n      \
    \      }\n        }\n        result.append(max)\n        if maxIndex != i {\n\
    \            arr.swapAt(i, maxIndex)\n        }\n    }\n    return result", " \
    \   var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num in arr\
    \ {\n        heap.insert(num)\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var max = [Int]()\n\
    \    for i in 0..<arr.count {\n        if max.count < k {\n            max.append(arr[i])\n\
    \            max.sort()\n        } else {\n            if arr[i] > max[0] {\n\
    \                max[0] = arr[i]\n                max.sort()\n            }\n\
    \        }\n    }\n    return max", "    var result = [Int]()\n    var max = [Int]()\n\
    \    var i = 0\n    while i < k {\n        max.append(arr[i])\n        i += 1\n\
    \    }\n    while i < arr.count {\n        if arr[i] > max[0] {\n            max[0]\
    \ = arr[i]\n            max.sort()\n        }\n        i += 1\n    }\n    return\
    \ max", "    var result = [Int]()\n    var max = arr[0]\n    for i in 0..<k {\n\
    \        for j in i..<arr.count {\n            if arr[j] > max {\n           \
    \     max = arr[j]\n            }\n        }\n        result.append(max)\n   \
    \     max = arr[i + 1]\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.remove()\n            maxHeap.insert(arr[i])\n        }\n  \
    \  }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = MaxHeap(arr)\n    for _ in 0..<k {\n\
    \        result.append(maxHeap.pop()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var sortedArr = arr.sorted()\n    for i in 0..<k\
    \ {\n        result.append(sortedArr[sortedArr.count - 1 - i])\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var max = Int.min\n\
    \        var maxIndex = 0\n        for i in 0..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                maxIndex = i\n      \
    \      }\n        }\n        result.append(max)\n        arr.remove(at: maxIndex)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.remove()\n            maxHeap.insert(arr[i])\n        }\n  \
    \  }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.remove()\n            maxHeap.insert(arr[i])\n        }\n  \
    \  }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n\
    \        var max = Int.min\n        var index = 0\n        for i in 0..<arr.count\
    \ {\n            if arr[i] > max {\n                max = arr[i]\n           \
    \     index = i\n            }\n        }\n        result.append(max)\n      \
    \  arr.remove(at: index)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var max = Int.min\n\
    \        var maxIndex = 0\n        for i in 0..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                maxIndex = i\n      \
    \      }\n        }\n        result.append(max)\n        arr.remove(at: maxIndex)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        heap.insert(arr[i])\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ for _ in 0..<k {\n        var max = Int.min\n        var index = 0\n       \
    \ for i in 0..<arr.count {\n            if arr[i] > max {\n                max\
    \ = arr[i]\n                index = i\n            }\n        }\n        result.append(max)\n\
    \        arr.remove(at: index)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.remove()\n            maxHeap.insert(arr[i])\n        }\n  \
    \  }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(arr[i])\n    }\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result[0] = arr[i]\n       \
    \     result.sort()\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var nums = arr\n    for _ in 0..<k {\n        var max = Int.min\n       \
    \ var index = -1\n        for i in 0..<nums.count {\n            if nums[i] >\
    \ max {\n                max = nums[i]\n                index = i\n          \
    \  }\n        }\n        result.append(max)\n        nums.remove(at: index)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ for _ in 0..<k {\n        var max = Int.min\n        var maxIndex = 0\n    \
    \    for i in 0..<arr.count {\n            if arr[i] > max {\n               \
    \ max = arr[i]\n                maxIndex = i\n            }\n        }\n     \
    \   result.append(max)\n        arr.remove(at: maxIndex)\n    }\n    return result",
  "    var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var\
    \ max = Int.min\n        var maxIndex = -1\n        for (index, value) in arr.enumerated()\
    \ {\n            if value > max {\n                max = value\n             \
    \   maxIndex = index\n            }\n        }\n        result.append(max)\n \
    \       arr.remove(at: maxIndex)\n    }\n    return result", "    var result =\
    \ [Int]()\n    var queue = [Int]()\n    for i in 0..<arr.count {\n        if queue.count\
    \ == k {\n            if arr[i] > queue[0] {\n                queue.removeFirst()\n\
    \                queue.append(arr[i])\n            }\n        } else {\n     \
    \       queue.append(arr[i])\n        }\n    }\n    queue.sort()\n    return queue",
  "    var result = [Int]()\n    var max = [Int]()\n    var min = [Int]()\n    for\
    \ i in 0..<arr.count {\n        if max.count == 0 {\n            max.append(arr[i])\n\
    \        } else {\n            if arr[i] > max[0] {\n                max.insert(arr[i],\
    \ at: 0)\n            } else {\n                max.append(arr[i])\n         \
    \   }\n        }\n        if min.count == 0 {\n            min.append(arr[i])\n\
    \        } else {\n            if arr[i] < min[0] {\n                min.insert(arr[i],\
    \ at: 0)\n            } else {\n                min.append(arr[i])\n         \
    \   }\n        }\n    }\n    if k % 2 == 0 {\n        for i in 0..<k/2 {\n   \
    \         result.append(max[i])\n            result.append(min[i])\n        }\n\
    \    } else {\n        for i in 0..<k/2 {\n            result.append(max[i])\n\
    \            result.append(min[i])\n        }\n        result.append(max[k/2])\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        heap.insert(num)\n        if heap.count >\
    \ k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty {\n\
    \        result.append(heap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for num in arr {\n        if result.count < k {\n           \
    \ result.append(num)\n            result.sort()\n        } else {\n          \
    \  if num > result[0] {\n                result.remove(at: 0)\n              \
    \  result.append(num)\n                result.sort()\n            }\n        }\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for i in 0..<arr.count {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n\
    \        } else if arr[i] > maxHeap.peek()! {\n            maxHeap.pop()\n   \
    \         maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.pop()!)\n    }\n    return result", "    var\
    \ result = [Int]()\n    var max = [Int]()\n    var i = 0\n    while i < k {\n\
    \        max.append(arr[i])\n        i += 1\n    }\n    while i < arr.count {\n\
    \        if arr[i] > max[0] {\n            max[0] = arr[i]\n            max.sort()\n\
    \        }\n        i += 1\n    }\n    return max", "    var result = [Int]()\n\
    \    var max = Int.min\n    var maxIndex = 0\n    for i in 0..<k {\n        max\
    \ = Int.min\n        maxIndex = 0\n        for j in i..<arr.count {\n        \
    \    if arr[j] > max {\n                max = arr[j]\n                maxIndex\
    \ = j\n            }\n        }\n        result.append(max)\n        arr.swapAt(i,\
    \ maxIndex)\n    }\n    return result", '    return []', "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        heap.insert(arr[i])\n        if heap.count\
    \ > k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty\
    \ {\n        result.append(heap.remove()!)\n    }\n    return result", "    var\
    \ result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num in arr {\n\
    \        heap.insert(num)\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.pop()\n       \
    \     maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty {\n\
    \        result.append(maxHeap.pop()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var max = Int.min\n\
    \        var maxIndex = 0\n        for i in 0..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                maxIndex = i\n      \
    \      }\n        }\n        result.append(max)\n        arr.remove(at: maxIndex)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.remove()\n            maxHeap.insert(arr[i])\n        }\n  \
    \  }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var temp = [Int]()\n\
    \    for i in 0..<arr.count {\n        while !temp.isEmpty && arr[i] > temp.last!\
    \ && temp.count + arr.count - i > k {\n            temp.removeLast()\n       \
    \ }\n        if temp.count < k {\n            temp.append(arr[i])\n        }\n\
    \    }\n    return temp", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = MaxHeap<Int>()\n    for i in 0..<arr.count {\n\
    \        maxHeap.insert(arr[i])\n        if maxHeap.size() > k {\n           \
    \ maxHeap.remove()\n        }\n    }\n    for _ in 0..<k {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        var max = Int.min\n        var maxIndex = 0\n        for j in i..<arr.count\
    \ {\n            if arr[j] > max {\n                max = arr[j]\n           \
    \     maxIndex = j\n            }\n        }\n        result.append(max)\n   \
    \     arr.swapAt(i, maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var arr = arr\n   \
    \ for _ in 0..<k {\n        var max = Int.min\n        var maxIndex = 0\n    \
    \    for i in 0..<arr.count {\n            if arr[i] > max {\n               \
    \ max = arr[i]\n                maxIndex = i\n            }\n        }\n     \
    \   result.append(max)\n        arr.remove(at: maxIndex)\n    }\n    return result",
  "    var result = [Int]()\n    var max = [Int]()\n    var i = 0\n    while i < k\
    \ {\n        max.append(arr[i])\n        i += 1\n    }\n    i = k\n    while i\
    \ < arr.count {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n \
    \           max.sort()\n        }\n        i += 1\n    }\n    return max", " \
    \   var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    for i in 0..<k {\n        var max = arr[i]\n    \
    \    var maxIndex = i\n        for j in i+1..<arr.count {\n            if arr[j]\
    \ > max {\n                max = arr[j]\n                maxIndex = j\n      \
    \      }\n        }\n        result.append(max)\n        arr.swapAt(i, maxIndex)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(arr[i])\n    }\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result[0] = arr[i]\n       \
    \     result.sort()\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        heap.insert(num)\n        if heap.count >\
    \ k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty {\n\
    \        result.append(heap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var max = Int.min\n\
    \        var index = 0\n        for i in 0..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                index = i\n         \
    \   }\n        }\n        result.append(max)\n        arr.remove(at: index)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var temp = [Int]()\n    for i in 0..<arr.count\
    \ {\n        if temp.count < k {\n            temp.append(arr[i])\n        } else\
    \ {\n            if arr[i] > temp[0] {\n                temp.removeFirst()\n \
    \               temp.append(arr[i])\n            }\n        }\n    }\n    temp.sort()\n\
    \    for i in 0..<temp.count {\n        result.append(temp[temp.count - 1 - i])\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        var max = Int.min\n        var maxIndex = -1\n        for j in i..<arr.count\
    \ {\n            if arr[j] > max {\n                max = arr[j]\n           \
    \     maxIndex = j\n            }\n        }\n        result.append(max)\n   \
    \     if maxIndex != i {\n            arr.swapAt(i, maxIndex)\n        }\n   \
    \ }\n    return result", "    var result = [Int]()\n    var temp = [Int]()\n \
    \   for i in 0..<arr.count {\n        while !temp.isEmpty && temp.last! < arr[i]\
    \ {\n            temp.removeLast()\n        }\n        temp.append(arr[i])\n \
    \       if temp.count > k {\n            temp.removeFirst()\n        }\n    }\n\
    \    return temp", "    var result = [Int]()\n    var maxHeap = Heap<Int>(array:\
    \ arr, sort: >)\n    for _ in 0..<k {\n        result.append(maxHeap.pop()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.pop()\n            maxHeap.insert(arr[i])\n        }\n    }\n\
    \    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n\
    \    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var\
    \ max = Int.min\n        var maxIndex = 0\n        for i in 0..<arr.count {\n\
    \            if arr[i] > max {\n                max = arr[i]\n               \
    \ maxIndex = i\n            }\n        }\n        result.append(max)\n       \
    \ arr.remove(at: maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        if\
    \ maxHeap.count < k {\n            maxHeap.insert(arr[i])\n        } else if arr[i]\
    \ > maxHeap.peek()! {\n            maxHeap.remove()\n            maxHeap.insert(arr[i])\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.pop()\n       \
    \     maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty {\n\
    \        result.append(maxHeap.pop()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.pop()\n       \
    \     maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty {\n\
    \        result.append(maxHeap.pop()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var max = Int.min\n\
    \        var index = 0\n        for i in 0..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                index = i\n         \
    \   }\n        }\n        result.append(max)\n        arr.remove(at: index)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        heap.insert(num)\n        if heap.count >\
    \ k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty {\n\
    \        result.append(heap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var temp = [Int]()\n    for i in 0..<arr.count {\n\
    \        while !temp.isEmpty && temp.count + arr.count - i > k && temp.last! <\
    \ arr[i] {\n            temp.removeLast()\n        }\n        if temp.count <\
    \ k {\n            temp.append(arr[i])\n        }\n    }\n    return temp", " \
    \   var result = [Int]()\n    for i in 0..<k {\n        result.append(arr[i])\n\
    \    }\n    for i in k..<arr.count {\n        if arr[i] > result[0] {\n      \
    \      result[0] = arr[i]\n            result.sort()\n        }\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  guard arr.count > k else { return arr }\n    var result = [Int]()\n    for\
    \ i in 0..<k {\n        result.append(arr[i])\n    }\n    for i in k..<arr.count\
    \ {\n        var j = 0\n        while j < k && arr[i] > result[j] {\n        \
    \    j += 1\n        }\n        if j < k {\n            result.insert(arr[i],\
    \ at: j)\n            result.removeLast()\n        }\n    }\n    return result",
  "    var arr = arr\n    var result = [Int]()\n    for _ in 0..<k {\n        var\
    \ max = Int.min\n        var index = 0\n        for i in 0..<arr.count {\n   \
    \         if arr[i] > max {\n                max = arr[i]\n                index\
    \ = i\n            }\n        }\n        result.append(max)\n        arr.remove(at:\
    \ index)\n    }\n    return result", "    var result = [Int]()\n    var heap =\
    \ Heap<Int>(sort: >)\n    for num in arr {\n        heap.insert(num)\n       \
    \ if heap.count > k {\n            heap.remove()\n        }\n    }\n    while\
    \ !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return result",
  "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for i in 0..<arr.count {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n\
    \        } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n\
    \            maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for num in arr {\n       \
    \ heap.insert(num)\n        if heap.count > k {\n            heap.remove()\n \
    \       }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var temp = [Int]()\n    for i in 0..<arr.count {\n\
    \        while !temp.isEmpty && temp.last! < arr[i] {\n            temp.removeLast()\n\
    \        }\n        temp.append(arr[i])\n        if temp.count > k {\n       \
    \     temp.removeFirst()\n        }\n    }\n    return temp", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var max = Int.min\n\
    \        var index = 0\n        for i in 0..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                index = i\n         \
    \   }\n        }\n        result.append(max)\n        arr.remove(at: index)\n\
    \    }\n    return result", "    var res = [Int]()\n    var i = 0\n    while i\
    \ < k {\n        var max = Int.min\n        var maxIndex = 0\n        for j in\
    \ i..<arr.count {\n            if arr[j] > max {\n                max = arr[j]\n\
    \                maxIndex = j\n            }\n        }\n        res.append(max)\n\
    \        arr.swapAt(i, maxIndex)\n        i += 1\n    }\n    return res", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var temp = [Int]()\n    for i in 0..<arr.count {\n        if\
    \ temp.count < k {\n            temp.append(arr[i])\n        } else {\n      \
    \      if arr[i] > temp[0] {\n                temp.removeFirst()\n           \
    \     temp.append(arr[i])\n            }\n        }\n    }\n    temp.sort()\n\
    \    for i in 0..<temp.count {\n        result.append(temp[temp.count - 1 - i])\n\
    \    }\n    return result", "    var max = [Int]()\n    var maxIndex = [Int]()\n\
    \    for i in 0..<k {\n        max.append(arr[i])\n        maxIndex.append(i)\n\
    \    }\n    for i in k..<arr.count {\n        let min = max.min()!\n        if\
    \ arr[i] > min {\n            let index = max.firstIndex(of: min)!\n         \
    \   max[index] = arr[i]\n            maxIndex[index] = i\n        }\n    }\n \
    \   return maxIndex.map { arr[$0] }", "    if arr.count == 0 { return [] }\n \
    \   if arr.count == 1 { return arr }\n    var result = [Int]()\n    var max =\
    \ Int.min\n    var maxIndex = 0\n    for i in 0..<k {\n        max = Int.min\n\
    \        maxIndex = 0\n        for j in 0..<arr.count {\n            if arr[j]\
    \ > max {\n                max = arr[j]\n                maxIndex = j\n      \
    \      }\n        }\n        result.append(max)\n        arr[maxIndex] = Int.min\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.remove()\n            maxHeap.insert(arr[i])\n        }\n  \
    \  }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        if maxHeap.count < k {\n         \
    \   maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()! {\n   \
    \         maxHeap.pop()\n            maxHeap.insert(arr[i])\n        }\n    }\n\
    \    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n    }\n\
    \    return result", "    var result = [Int]()\n    var queue = [Int]()\n    for\
    \ i in 0..<arr.count {\n        while !queue.isEmpty && arr[i] > queue.last! {\n\
    \            queue.removeLast()\n        }\n        queue.append(arr[i])\n   \
    \     if queue.count > k {\n            queue.removeFirst()\n        }\n    }\n\
    \    return queue", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.pop()\n       \
    \     maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty {\n\
    \        result.append(maxHeap.pop()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var max = [Int]()\n    for i in 0..<arr.count {\n        if max.count\
    \ < k {\n            max.append(arr[i])\n            max.sort()\n        } else\
    \ {\n            if arr[i] > max[0] {\n                max[0] = arr[i]\n     \
    \           max.sort()\n            }\n        }\n    }\n    return max", "  \
    \  var result = [Int]()\n    var k = k\n    for num in arr {\n        while result.count\
    \ > 0 && result.last! < num && result.count + arr.count - arr.firstIndex(of: num)!\
    \ > k {\n            result.removeLast()\n        }\n        if result.count <\
    \ k {\n            result.append(num)\n        }\n    }\n    return result", " \
    \   var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var\
    \ max = Int.min\n        var maxIndex = -1\n        for i in 0..<arr.count {\n\
    \            if arr[i] > max {\n                max = arr[i]\n               \
    \ maxIndex = i\n            }\n        }\n        result.append(max)\n       \
    \ arr.remove(at: maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    for i in 0..<k {\n        result.append(arr[i])\n\
    \    }\n    for i in k..<arr.count {\n        var j = 0\n        while j < k &&\
    \ arr[i] > result[j] {\n            j += 1\n        }\n        if j < k {\n  \
    \          result.insert(arr[i], at: j)\n            result.removeLast()\n   \
    \     }\n    }\n    return result", "    var result = [Int]()\n    for i in 0..<k\
    \ {\n        var max = arr[i]\n        var maxIndex = i\n        for j in i+1..<arr.count\
    \ {\n            if arr[j] > max {\n                max = arr[j]\n           \
    \     maxIndex = j\n            }\n        }\n        result.append(max)\n   \
    \     arr.swapAt(i, maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        heap.insert(arr[i])\n        if heap.count\
    \ > k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty\
    \ {\n        result.append(heap.remove()!)\n    }\n    return result", "    var\
    \ result = [Int]()\n    var heap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        heap.insert(arr[i])\n        if heap.count > k {\n            heap.remove()\n\
    \        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var queue = [Int]()\n\
    \    for i in 0..<arr.count {\n        while !queue.isEmpty && arr[i] > queue.last!\
    \ {\n            queue.removeLast()\n        }\n        queue.append(arr[i])\n\
    \        if queue.count > k {\n            queue.removeFirst()\n        }\n  \
    \  }\n    return queue", "    var result = [Int]()\n    var minHeap = Heap<Int>(sort:\
    \ <)\n    for i in 0..<arr.count {\n        if i < k {\n            minHeap.insert(arr[i])\n\
    \        } else if arr[i] > minHeap.peek()! {\n            minHeap.remove()\n\
    \            minHeap.insert(arr[i])\n        }\n    }\n    while !minHeap.isEmpty()\
    \ {\n        result.append(minHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var max = Int.min\n    var maxIndex = 0\n    for\
    \ i in 0..<k {\n        max = Int.min\n        maxIndex = 0\n        for j in\
    \ 0..<arr.count {\n            if arr[j] > max {\n                max = arr[j]\n\
    \                maxIndex = j\n            }\n        }\n        result.append(max)\n\
    \        arr[maxIndex] = Int.min\n    }\n    return result", "    var result =\
    \ [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n      \
    \  maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(arr[i])\n    }\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result[0] = arr[i]\n       \
    \     result.sort()\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    for i in 0..<k {\n        result.append(arr[i])\n    }\n    result.sort()\n\
    \    for i in k..<arr.count {\n        if arr[i] > result[0] {\n            result[0]\
    \ = arr[i]\n            result.sort()\n        }\n    }\n    return result", " \
    \   var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var\
    \ max = Int.min\n        var index = 0\n        for i in 0..<arr.count {\n   \
    \         if arr[i] > max {\n                max = arr[i]\n                index\
    \ = i\n            }\n        }\n        result.append(max)\n        arr.remove(at:\
    \ index)\n    }\n    return result", "    var result = [Int]()\n    var maxHeap\
    \ = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        if maxHeap.count\
    \ < k {\n            maxHeap.insert(arr[i])\n        } else if arr[i] > maxHeap.peek()!\
    \ {\n            maxHeap.pop()\n            maxHeap.insert(arr[i])\n        }\n\
    \    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.pop()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(arr[i])\n    }\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result[0] = arr[i]\n       \
    \     result.sort()\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = MaxHeap<Int>()\n    for\
    \ i in 0..<k {\n        maxHeap.insert(arr[i])\n    }\n    for i in k..<arr.count\
    \ {\n        if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n   \
    \         maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty()\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        heap.insert(arr[i])\n        if heap.count\
    \ > k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty\
    \ {\n        result.append(heap.remove()!)\n    }\n    return result", "    var\
    \ result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n\
    \        maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var temp = [Int]()\n\
    \    for i in 0..<arr.count {\n        if temp.count < k {\n            temp.append(arr[i])\n\
    \        } else {\n            if arr[i] > temp[0] {\n                temp.removeFirst()\n\
    \                temp.append(arr[i])\n            }\n        }\n    }\n    temp.sort()\n\
    \    for i in 0..<temp.count {\n        result.append(temp[temp.count - 1 - i])\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        guard let max =\
    \ arr.max() else { break }\n        result.append(max)\n        arr.remove(at:\
    \ arr.firstIndex(of: max)!)\n    }\n    return result", "    var result = [Int]()\n\
    \    var max = Int.min\n    var maxIndex = 0\n    var count = 0\n    while count\
    \ < k {\n        for i in 0..<arr.count {\n            if arr[i] > max {\n   \
    \             max = arr[i]\n                maxIndex = i\n            }\n    \
    \    }\n        result.append(max)\n        arr[maxIndex] = Int.min\n        max\
    \ = Int.min\n        count += 1\n    }\n    return result", "    var result =\
    \ [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n\
    \        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var temp = arr\n    for _ in 0..<k {\n        let max = temp.max()!\n\
    \        result.append(max)\n        temp.remove(at: temp.firstIndex(of: max)!)\n\
    \    }\n    return result", "    var result = [Int]()\n    for i in 0..<k {\n\
    \        var max = Int.min\n        var maxIndex = -1\n        for j in i..<arr.count\
    \ {\n            if arr[j] > max {\n                max = arr[j]\n           \
    \     maxIndex = j\n            }\n        }\n        result.append(max)\n   \
    \     arr.swapAt(i, maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var heap = Heap<Int>(sort: >)\n    for num in arr {\n        heap.insert(num)\n\
    \        if heap.count > k {\n            heap.remove()\n        }\n    }\n  \
    \  while !heap.isEmpty {\n        result.append(heap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var index = 0\n    while index < k {\n        var\
    \ max = Int.min\n        var maxIndex = -1\n        for i in index..<arr.count\
    \ {\n            if arr[i] > max {\n                max = arr[i]\n           \
    \     maxIndex = i\n            }\n        }\n        result.append(max)\n   \
    \     index = maxIndex + 1\n    }\n    return result", "    var result = [Int]()\n\
    \    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n        maxHeap.insert(num)\n\
    \        if maxHeap.count > k {\n            maxHeap.remove()\n        }\n   \
    \ }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.pop()\n       \
    \     maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty {\n\
    \        result.append(maxHeap.pop()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    for i in 0..<k {\n        var max = arr[i]\n        var maxIndex\
    \ = i\n        for j in i+1..<arr.count {\n            if arr[j] > max {\n   \
    \             max = arr[j]\n                maxIndex = j\n            }\n    \
    \    }\n        result.append(max)\n        arr.swapAt(i, maxIndex)\n    }\n \
    \   return result", "    var result = [Int]()\n    var max = arr[0]\n    for i\
    \ in 1..<arr.count {\n        if arr[i] > max {\n            max = arr[i]\n  \
    \      }\n    }\n    result.append(max)\n    return result", "    var result =\
    \ [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count {\n\
    \        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in\
    \ arr {\n        maxHeap.insert(num)\n        if maxHeap.count > k {\n       \
    \     maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n     \
    \   result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var heap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        heap.insert(num)\n        if heap.count >\
    \ k {\n            heap.remove()\n        }\n    }\n    while !heap.isEmpty {\n\
    \        result.append(heap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var max = [Int]()\n    var i = 0\n    while i < k {\n       \
    \ max.append(arr[i])\n        i += 1\n    }\n    while i < arr.count {\n     \
    \   if arr[i] > max[0] {\n            max[0] = arr[i]\n            max.sort()\n\
    \        }\n        i += 1\n    }\n    return max", "    var result = [Int]()\n\
    \    var max = arr[0]\n    for i in 0..<k {\n        max = arr[i]\n        for\
    \ j in i+1..<arr.count {\n            if arr[j] > max {\n                max =\
    \ arr[j]\n            }\n        }\n        result.append(max)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        maxHeap.insert(arr[i])\n        if maxHeap.count > k {\n        \
    \    maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for num in arr {\n    \
    \    maxHeap.insert(num)\n        if maxHeap.count > k {\n            maxHeap.remove()\n\
    \        }\n    }\n    while !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n \
    \   for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count >\
    \ k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  guard arr.count > 0 else { return [] }\n    guard arr.count > k else { return\
    \ arr }\n    var result = [Int]()\n    var max = arr[0]\n    for i in 0..<k {\n\
    \        max = arr[i]\n        for j in i+1..<arr.count {\n            if arr[j]\
    \ > max {\n                max = arr[j]\n            }\n        }\n        result.append(max)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for num in arr {\n        maxHeap.insert(num)\n        if maxHeap.count\
    \ > k {\n            maxHeap.remove()\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for i in 0..<arr.count\
    \ {\n        if maxHeap.count < k {\n            maxHeap.insert(arr[i])\n    \
    \    } else if arr[i] > maxHeap.peek()! {\n            maxHeap.remove()\n    \
    \        maxHeap.insert(arr[i])\n        }\n    }\n    while !maxHeap.isEmpty\
    \ {\n        result.append(maxHeap.remove()!)\n    }\n    return result", "  \
    \  var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        var\
    \ max = Int.min\n        var maxIndex = 0\n        for i in 0..<arr.count {\n\
    \            if arr[i] > max {\n                max = arr[i]\n               \
    \ maxIndex = i\n            }\n        }\n        result.append(max)\n       \
    \ arr.remove(at: maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var index = 0\n    while index < k {\n        var max = Int.min\n       \
    \ var maxIndex = 0\n        for i in index..<arr.count {\n            if arr[i]\
    \ > max {\n                max = arr[i]\n                maxIndex = i\n      \
    \      }\n        }\n        result.append(max)\n        index = maxIndex + 1\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort:\
    \ >)\n    for i in 0..<arr.count {\n        maxHeap.insert(arr[i])\n        if\
    \ maxHeap.count > k {\n            maxHeap.remove()\n        }\n    }\n    while\
    \ !maxHeap.isEmpty {\n        result.append(maxHeap.remove()!)\n    }\n    return\
    \ result"]
stop_tokens:
- "\n}"
