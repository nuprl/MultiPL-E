language: swift
name: HumanEval_12_longest
results:
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) { (longest, string) in\n        if let longest\
    \ = longest {\n            return string.count > longest.count ? string : longest\n\
    \        } else {\n            return string\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    var longestLength = 0\n    for\
    \ string in strings {\n        if string.characters.count > longestLength {\n\
    \            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpdebj9zzw.swift:14:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdebj9zzw.swift:16:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > longest.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2i0398vu.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2i0398vu.swift:16:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7y1l_wc1.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7y1l_wc1.swift:16:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    return\
    \ strings.max { a, b in a.count < b.count }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (longest, string) in\n        return string.count > longest.count ? string\
    \ : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) {\n        $0 == nil || $0!.characters.count\
    \ < $1.characters.count ? $1 : $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpq7dslglt.swift:12:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        $0 == nil || $0!.characters.count < $1.characters.count\
    \ ? $1 : $0\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpq7dslglt.swift:12:48: error: 'characters' is unavailable:\
    \ Please use String directly\n        $0 == nil || $0!.characters.count < $1.characters.count\
    \ ? $1 : $0\n                                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { (longest, string) in\n        return string.count > longest.count ? string\
    \ : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > result.characters.count\
    \ {\n            result = string\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmptfdoi_d5.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > result.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptfdoi_d5.swift:16:45: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > result.characters.count\
    \ {\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (longest, string) in\n        return string.count > longest.count ? string\
    \ : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7y1l_wc1.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7y1l_wc1.swift:16:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ {\n        $0.count > $1.count ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpbhvuwayt/tmpbhvuwayt.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad017ecac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad017bc1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad017bc1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad017bc07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbhvuwayt                        0x000056105f48694a <unavailable> + 6474

    5    libc.so.6                          0x00002ad0180b6460 __libc_start_main +
    245

    6    tmpbhvuwayt                        0x000056105f486239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    var longestLength = 0\n    for\
    \ string in strings {\n        if string.characters.count > longestLength {\n\
    \            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpdebj9zzw.swift:14:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdebj9zzw.swift:16:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    for string in strings {\n     \
    \   if longestString == nil || string.count > longestString!.count {\n       \
    \     longestString = string\n        }\n    }\n    return longestString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (longest, string) in\n        return string.count > longest.count ? string\
    \ : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ {\n        $0.count > $1.count ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp3f9hb_od/tmp3f9hb_od.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3174327c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b317401eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b317401e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b317401d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3f9hb_od                        0x00005594b2d1294a <unavailable> + 6474

    5    libc.so.6                          0x00002b3174513460 __libc_start_main +
    245

    6    tmp3f9hb_od                        0x00005594b2d12239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n\
    \    for string in strings {\n        if string.count > longestString.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    for string in strings {\n     \
    \   if longestString == nil || string.count > longestString!.count {\n       \
    \     longestString = string\n        }\n    }\n    return longestString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var result: String? = nil\n    var maxLength = 0\n    for string in strings\
    \ {\n        if string.characters.count > maxLength {\n            maxLength =\
    \ string.characters.count\n            result = string\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpbo3gze2w.swift:14:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > maxLength {\n    \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbo3gze2w.swift:15:32: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxLength = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (longest, string) in\n        return string.count > longest.count ? string\
    \ : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    var longestStringLength = 0\n \
    \   for string in strings {\n        if string.characters.count > longestStringLength\
    \ {\n            longestString = string\n            longestStringLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7d42yzxd.swift:14:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestStringLength\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7d42yzxd.swift:16:42: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestStringLength = string.characters.count\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7y1l_wc1.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7y1l_wc1.swift:16:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n\
    \    for string in strings {\n        if string.count > longestString.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    for string in strings {\n     \
    \   if let longestString = longestString {\n            if string.count > longestString.count\
    \ {\n                longestString = string\n            }\n        } else {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpfva_bnf4.swift:15:17: error: cannot assign to value: 'longestString'\
    \ is a 'let' constant\n                longestString = string\n              \
    \  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    for string in strings {\n     \
    \   if longestString == nil || string.count > longestString!.count {\n       \
    \     longestString = string\n        }\n    }\n    return longestString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { (longest, string) in\n        return string.count > longest.count ? string\
    \ : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ {\n        $0.count > $1.count ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpbhvuwayt/tmpbhvuwayt.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad017ecac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad017bc1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad017bc1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad017bc07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbhvuwayt                        0x000056105f48694a <unavailable> + 6474

    5    libc.so.6                          0x00002ad0180b6460 __libc_start_main +
    245

    6    tmpbhvuwayt                        0x000056105f486239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > longest.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2i0398vu.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2i0398vu.swift:16:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    for string in strings {\n     \
    \   if longestString == nil || string.count > longestString!.count {\n       \
    \     longestString = string\n        }\n    }\n    return longestString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpdotluuib.swift:13:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdotluuib.swift:13:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.max {\
    \ $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > longest.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2i0398vu.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2i0398vu.swift:16:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) { (longest, string) in\n        if let longest\
    \ = longest {\n            return string.count > longest.count ? string : longest\n\
    \        } else {\n            return string\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    var longestLength = 0\n    for\
    \ string in strings {\n        if string.count > longestLength {\n           \
    \ longestString = string\n            longestLength = string.count\n        }\n\
    \    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ {\n        $0.count > $1.count ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpbfwyzzp8/tmpbfwyzzp8.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8565c5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8565952b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8565952988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85659517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbfwyzzp8                        0x0000561fef78c8fa <unavailable> + 6394

    5    libc.so.6                          0x00002b8565e47460 __libc_start_main +
    245

    6    tmpbfwyzzp8                        0x0000561fef78c1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    var longestLength = 0\n    for\
    \ string in strings {\n        if string.characters.count > longestLength {\n\
    \            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpdebj9zzw.swift:14:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdebj9zzw.swift:16:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7y1l_wc1.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7y1l_wc1.swift:16:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
