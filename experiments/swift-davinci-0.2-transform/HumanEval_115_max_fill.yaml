name: HumanEval_115_max_fill
language: swift
prompt: "\n/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n/// 5\n/// Example 3:\n///\
  \ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  func max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
  \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], capacity: 9) == 2)"
completions: ["    var result = 0\n    var max_height = 0\n    for row in grid {\n\
    \        var row_height = 0\n        for well in row {\n            if well ==\
    \ 1 {\n                row_height += 1\n            }\n        }\n        max_height\
    \ = max(max_height, row_height)\n    }\n    for row in grid {\n        var row_height\
    \ = 0\n        for well in row {\n            if well == 1 {\n               \
    \ row_height += 1\n            }\n        }\n        result += max_height - row_height\n\
    \    }\n    return result", "    var result = 0\n    var max_row = 0\n    for\
    \ row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n    }\n   \
    \ for _ in 0..<max_row {\n        for row in grid {\n            for i in 0..<row.count\
    \ {\n                if row[i] > 0 {\n                    row[i] -= 1\n      \
    \              result += 1\n                }\n            }\n        }\n    }\n\
    \    return result", "    var result = 0\n    var grid = grid\n    var max_water\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           max_water = max(max_water, grid[i][j])\n        }\n    }\n    for\
    \ _ in 0..<max_water {\n        for i in 0..<grid.count {\n            for j in\
    \ 0..<grid[i].count {\n                if grid[i][j] > 0 {\n                 \
    \   grid[i][j] -= 1\n                    result += 1\n                }\n    \
    \        }\n        }\n    }\n    return result", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  while true {\n        var filled = false\n        for i in 0..<grid.count {\n\
    \            for j in 0..<grid[i].count {\n                if grid[i][j] == 1\
    \ {\n                    filled = true\n                    grid[i][j] = 0\n \
    \                   for k in 0..<capacity {\n                        if i + k\
    \ < grid.count {\n                            grid[i + k][j] = 1\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n        if !filled {\n            break\n        }\n        count +=\
    \ 1\n    }\n    return count", "    var grid = grid\n    var count = 0\n    for\
    \ i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if\
    \ grid[i][j] == 1 {\n                count += 1\n                for k in 0..<capacity\
    \ {\n                    if i + k < grid.count {\n                        grid[i\
    \ + k][j] = 0\n                    }\n                }\n            }\n     \
    \   }\n    }\n    return count", "    var result = 0\n    var grid = grid\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n         \
    \   if grid[i][j] == 1 {\n                result += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return result", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                fill(grid: &grid, i: i, j: j, capacity:\
    \ capacity)\n            }\n        }\n    }\n    return count", "    var result\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                result += 1\n            }\n\
    \        }\n    }\n    return result * capacity", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      var row = i\n                while row < grid.count {\n               \
    \     grid[row][j] = 0\n                    row += 1\n                }\n    \
    \        }\n        }\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n    \
    \    }\n    }\n    return count", "    var grid = grid\n    var count = 0\n  \
    \  while true {\n        var filled = false\n        for i in 0..<grid.count {\n\
    \            for j in 0..<grid[i].count {\n                if grid[i][j] == 1\
    \ {\n                    filled = true\n                    grid[i][j] = 0\n \
    \                   if i > 0 {\n                        grid[i - 1][j] = min(grid[i\
    \ - 1][j] + 1, capacity)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j - 1] = min(grid[i][j - 1] + 1, capacity)\n                    }\n\
    \                    if j < grid[i].count - 1 {\n                        grid[i][j\
    \ + 1] = min(grid[i][j + 1] + 1, capacity)\n                    }\n          \
    \      }\n            }\n        }\n        if !filled {\n            break\n\
    \        }\n        count += 1\n    }\n    return count", "    var grid = grid\n\
    \    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \          count += 1\n                if i + 1 < grid.count && grid[i + 1][j]\
    \ == 1 {\n                    grid[i + 1][j] = 0\n                }\n        \
    \        if j + 1 < grid[i].count && grid[i][j + 1] == 1 {\n                 \
    \   grid[i][j + 1] = 0\n                }\n            }\n        }\n    }\n \
    \   return count", "    let rows = grid.count\n    let cols = grid[0].count\n\
    \    var grid = grid\n    var count = 0\n    for i in 0..<rows {\n        for\
    \ j in 0..<cols {\n            if grid[i][j] == 1 {\n                count +=\
    \ 1\n                fill(grid: &grid, i: i, j: j, capacity: capacity)\n     \
    \       }\n        }\n    }\n    return count", "    var grid = grid\n    var\
    \ count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                count += 1\n          \
    \      let bucket = capacity\n                var row = i\n                while\
    \ bucket > 0 && row < grid.count {\n                    if grid[row][j] == 1 {\n\
    \                        grid[row][j] = 0\n                        bucket -= 1\n\
    \                    }\n                    row += 1\n                }\n    \
    \        }\n        }\n    }\n    return count", "    var count = 0\n    var grid\
    \ = grid\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n\
    \            if grid[i][j] == 1 {\n                count += 1\n              \
    \  fill(grid: &grid, capacity: capacity, i: i, j: j)\n            }\n        }\n\
    \    }\n    return count", "    var grid = grid\n    var count = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                grid[i][j] = 0\n                count += 1\n       \
    \         if i > 0 {\n                    grid[i - 1][j] = min(grid[i - 1][j]\
    \ + 1, capacity)\n                }\n                if i < grid.count - 1 {\n\
    \                    grid[i + 1][j] = min(grid[i + 1][j] + 1, capacity)\n    \
    \            }\n                if j > 0 {\n                    grid[i][j - 1]\
    \ = min(grid[i][j - 1] + 1, capacity)\n                }\n                if j\
    \ < grid[i].count - 1 {\n                    grid[i][j + 1] = min(grid[i][j +\
    \ 1] + 1, capacity)\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var result = 0\n    var max_height = 0\n    for row in grid {\n\
    \        max_height = max(max_height, row.max() ?? 0)\n    }\n    for height in\
    \ 0..<max_height {\n        for row in grid {\n            for column in row {\n\
    \                if column > height {\n                    result += 1\n     \
    \           }\n            }\n        }\n    }\n    return result", "    var grid\
    \ = grid\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = 0\n      \
    \          count += 1\n                for k in 0..<grid.count {\n           \
    \         for l in 0..<grid[k].count {\n                        if grid[k][l]\
    \ == 1 {\n                            grid[k][l] = 0\n                       \
    \     count += 1\n                        }\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return count", "    var count\
    \ = 0\n    var grid = grid\n    for row in grid {\n        var bucket = capacity\n\
    \        for column in row {\n            if column == 1 {\n                if\
    \ bucket > 0 {\n                    bucket -= 1\n                } else {\n  \
    \                  count += 1\n                    bucket = capacity - 1\n   \
    \             }\n            }\n        }\n    }\n    return count"]
stop_tokens:
- "\n}"
