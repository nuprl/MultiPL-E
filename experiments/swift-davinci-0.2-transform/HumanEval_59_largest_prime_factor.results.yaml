language: swift
name: HumanEval_59_largest_prime_factor
results:
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    while n % 2 == 0 {\n        largest_prime = 2\n\
    \        n /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n\
    \        if n % i == 0 {\n            largest_prime = i\n            n /= i\n\
    \        } else {\n            i += 2\n        }\n    }\n    if n > 2 {\n    \
    \    largest_prime = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpku7s98b0.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_prime_factor = i\n            n /= i\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp4rydr5nl.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for i in\
    \ stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n        while n % i\
    \ == 0 {\n            n /= i\n            largest = i\n        }\n    }\n    if\
    \ n > 2 {\n        largest = n\n    }\n    return largest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpoj2irqvl.swift:13:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 2\n    while n > 1 {\n        if n % largest == 0 {\n       \
    \     n /= largest\n        } else {\n            largest += 1\n        }\n  \
    \  }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest =\
    \ 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest = i\n            n /= i\n        } else {\n            i += 1\n \
    \       }\n    }\n    if n > 1 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpl34do1yw.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp6puyoij_.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var factor = 3\n    while factor * factor <= n {\n        if n\
    \ % factor == 0 {\n            largest = factor\n            n /= factor\n   \
    \     } else {\n            factor += 2\n        }\n    }\n    if n > 2 {\n  \
    \      largest = n\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 0\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    while n % 2 == 0 {\n        largest_prime_factor\
    \ = 2\n        n /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n)))\
    \ {\n        if n % i == 0 {\n            largest_prime_factor = i\n         \
    \   n /= i\n        } else {\n            i += 2\n        }\n    }\n    if n >\
    \ 2 {\n        largest_prime_factor = n\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpgry1adzj.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    while n % 2 == 0 {\n        largest_prime_factor\
    \ = 2\n        n /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n)))\
    \ {\n        if n % i == 0 {\n            largest_prime_factor = i\n         \
    \   n /= i\n        } else {\n            i += 2\n        }\n    }\n    if n >\
    \ 2 {\n        largest_prime_factor = n\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpgry1adzj.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    if n > 1 {\n        largest = n\n    }\n \
    \   return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    var i = 2\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime =\
    \ n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 0\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphimoprsf.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > 1 {\n        if n % largest_prime == 0\
    \ {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > largest_prime {\n        if n % largest_prime\
    \ == 0 {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 2\n    while n > 1 {\n        if n % largest == 0 {\n       \
    \     n /= largest\n        } else {\n            largest += 1\n        }\n  \
    \  }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    var i = 2\n    while i <= n {\n        if n % i == 0\
    \ {\n            largest_prime = i\n            n /= i\n        } else {\n   \
    \         i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n        while\
    \ n % i == 0 {\n            n /= i\n            largest_prime = i\n        }\n\
    \    }\n    if n > largest_prime {\n        largest_prime = n\n    }\n    return\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp8yqoi31z.swift:13:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 0\n    var n = n\n    while n % 2 == 0 {\n        largest_prime = 2\n    \
    \    n /= 2\n    }\n    var i = 3\n    while i <= n {\n        while n % i ==\
    \ 0 {\n            largest_prime = i\n            n /= i\n        }\n        i\
    \ += 2\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > largest_prime {\n        if n % largest_prime\
    \ == 0 {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest =\
    \ 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    largest = i\n            n /= i\n        } else {\n            i += 1\n \
    \       }\n    }\n    if n > 1 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmptzqzkxg6.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphimoprsf.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        while\
    \ n % i == 0 {\n            largest = i\n            n /= i\n        }\n     \
    \   i += 2\n    }\n    if n > 2 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphpft07qp.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= n {\n        if n % i == 0 {\n     \
    \       largest = i\n            n /= i\n        } else {\n            i += 2\n\
    \        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    if n > 1 {\n        largest = n\n    }\n \
    \   return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor < n {\n        if n % factor == 0 {\n    \
    \        n /= factor\n        } else {\n            factor += 1\n        }\n \
    \   }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for\
    \ i in stride(from: 3, through: n, by: 2) {\n        while n % i == 0 {\n    \
    \        n /= i\n            largest_prime = i\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    var\
    \ i = 3\n    while i <= Int(sqrt(Double(n))) {\n        while n % i == 0 {\n \
    \           n /= i\n            largest_prime = i\n        }\n        i += 2\n\
    \    }\n    if n > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpst23rdn3.swift:14:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factors =\
    \ [Int]()\n    for i in 2...n {\n        if n % i == 0 {\n            factors.append(i)\n\
    \        }\n    }\n    var largest = 0\n    for factor in factors {\n        if\
    \ is_prime(n: factor) {\n            largest = factor\n        }\n    }\n    return\
    \ largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp_eo4kjxm.swift:16:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(n: factor) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        if n\
    \ % i == 0 {\n            largest = i\n            n /= i\n        } else {\n\
    \            i += 2\n        }\n    }\n    if n > 2 {\n        largest = n\n \
    \   }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpt12i2pk0.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime = i\n            n /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var n = n\n    for i in 2...n {\n        while n % i == 0 {\n     \
    \       largest_prime = i\n            n /= i\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var largest = 0\n    while i < n {\n        if n % i == 0 {\n            largest\
    \ = i\n            n /= i\n        } else {\n            i += 1\n        }\n \
    \   }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpu4pse6fe.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    return max(largest, n)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 2\n    while n > largest_prime_factor {\n      \
    \  if n % largest_prime_factor == 0 {\n            n /= largest_prime_factor\n\
    \        } else {\n            largest_prime_factor += 1\n        }\n    }\n \
    \   return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var prime = 2\n    while n > 1 {\n        if n % prime == 0 {\n           \
    \ n /= prime\n        } else {\n            prime += 1\n        }\n    }\n   \
    \ return prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor < n {\n        if n % factor == 0 {\n    \
    \        n /= factor\n        } else {\n            factor += 1\n        }\n \
    \   }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n > largest_prime {\n        if n % largest_prime\
    \ == 0 {\n            n /= largest_prime\n        } else {\n            largest_prime\
    \ += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var n = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i <= n {\n        if\
    \ n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n   \
    \     } else {\n            i += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    var i = 2\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            largest = i\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    if n > 1 {\n        largest = n\n    }\n \
    \   return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var n = n\n    var i = 2\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            largest_prime_factor = i\n            n /= i\n        }\
    \ else {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    while n % 2 == 0 {\n        largest_prime = 2\n\
    \        n /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n\
    \        if n % i == 0 {\n            largest_prime = i\n            n /= i\n\
    \        } else {\n            i += 2\n        }\n    }\n    if n > 2 {\n    \
    \    largest_prime = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpku7s98b0.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 2\n    while n % 2 == 0 {\n        n /= 2\n    }\n    for\
    \ i in stride(from: 3, through: n, by: 2) {\n        while n % i == 0 {\n    \
    \        largest_prime = i\n            n /= i\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 1\n    var i = 2\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            largest_prime = i\n            n /= i\n        } else\
    \ {\n            i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime\
    \ = n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var n = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor * factor <= n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor += 1\n  \
    \      }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    for i in 2...n {\n        while n % i == 0 {\n       \
    \     largest = i\n            n /= i\n        }\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime_factor = i\n            n /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphimoprsf.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n\
    \            largest = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime_factor = 1\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            largest_prime_factor = i\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n    \
    \    largest_prime_factor = n\n    }\n    return largest_prime_factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while factor <= n {\n        if n % factor == 0 {\n   \
    \         n /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(n))) {\n        while\
    \ n % i == 0 {\n            largest = i\n            n /= i\n        }\n     \
    \   i += 2\n    }\n    if n > 2 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmphpft07qp.swift:15:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
