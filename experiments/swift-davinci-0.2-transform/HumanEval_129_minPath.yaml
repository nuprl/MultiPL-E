name: HumanEval_129_minPath
language: swift
prompt: "\n/// Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n/// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You\
  \ have to find the minimum path of length k in the grid. You can start\n/// from\
  \ any cell, and in each step you can move to any of the neighbor cells,\n/// in\
  \ other words, you can go to cells which share an edge with you current\n/// cell.\n\
  /// Please note that a path of length k means visiting exactly k cells (not\n///\
  \ necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length\
  \ k) is considered less than a path B (of length k) if\n/// after making the ordered\
  \ lists of the values on the cells that A and B go\n/// through (let's call them\
  \ lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words,\
  \ there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i]\
  \ and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed\
  \ that the answer is unique.\n/// Return an ordered list of the values on the cells\
  \ that the minimum path go through.\n/// Examples:    \n/// >>> minPath(grid: [[1,\
  \ 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)\n/// [1, 2, 1]\n/// >>> minPath(grid: [[5,\
  \ 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)\n/// [1]\nfunc minPath(grid: [[Int]], k: Int)\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8,\
  \ 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10,\
  \ 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1,\
  \ 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1,\
  \ 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8,\
  \ 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6,\
  \ 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16,\
  \ 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid:\
  \ [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid:\
  \ [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid:\
  \ [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid:\
  \ [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"
completions: ["    let n = grid.count\n    var minPath = [Int]()\n    var minSum =\
    \ Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in\
    \ 0..<n {\n            var path = [Int]()\n            var sum = 0\n         \
    \   var paths = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n          \
    \      minSum = sum\n                minPaths = paths\n            }\n       \
    \ }\n    }\n    minPaths.sort { (a, b) -> Bool in\n        for i in 0..<a.count\
    \ {\n            if a[i] < b[i] {\n                return true\n            }\
    \ else if a[i] > b[i] {\n                return false\n            }\n       \
    \ }\n        return false\n    }\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    for i in 0..<n {\n \
    \       for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum)\n\
    \            if sum < minSum {\n                minSum = sum\n               \
    \ minPath = path\n            }\n        }\n    }\n    return minPath", "    let\
    \ n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            let path = minPath(grid:\
    \ grid, k: k, i: i, j: j, sum: 0)\n            if path.count == k {\n        \
    \        let sum = path.reduce(0, +)\n                if sum < minSum {\n    \
    \                minSum = sum\n                    minPath = path\n          \
    \      }\n            }\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            var paths = [[Int]]()\n            findPath(grid:\
    \ grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPaths =\
    \ paths\n            }\n        }\n    }\n    for path in minPaths {\n       \
    \ if path.count == k {\n            minPath = path\n            break\n      \
    \  }\n    }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j:\
    \ j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPaths = paths\n        \
    \    }\n        }\n    }\n    for path in minPaths {\n        if path.count ==\
    \ k {\n            minPath = path\n            break\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    for i in 0..<n {\n      \
    \  for j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n\
    \            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, visited:\
    \ &visited)\n            if sum < minSum {\n                minSum = sum\n   \
    \             minPaths = [[Int]]()\n                minPaths.append(path)\n  \
    \          } else if sum == minSum {\n                minPaths.append(path)\n\
    \            }\n        }\n    }\n    for i in 0..<minPaths.count {\n        if\
    \ minPaths[i] < minPath {\n            minPath = minPaths[i]\n        }\n    }\n\
    \    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n   \
    \ var minSum = Int.max\n    var minPathSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    var path = [Int]()\n    var sum = 0\n    var pathSum = 0\n    var paths\
    \ = [[Int]]()\n    var pathIndex = 0\n    var pathCount = 0\n    var minPathIndex\
    \ = 0\n    var minPathCount = 0\n    var minPathsCount = 0\n    var minPathsIndex\
    \ = 0\n    var minPathsSum = 0\n    var minPathsPathSum = 0\n    var minPathsPathIndex\
    \ = 0\n    var minPathsPathCount = 0\n    var minPathsPathsCount = 0\n    var\
    \ minPathsPathsIndex = 0\n    var minPathsPathsSum = 0\n    var minPathsPathsPathSum\
    \ = 0\n    var minPathsPathsPathIndex = 0\n    var minPathsPathsPathCount = 0\n\
    \    var minPathsPathsPathsCount = 0\n    var minPathsPathsPathsIndex = 0\n  \
    \  var minPathsPathsPathsSum = 0\n    var minPathsPathsPathsPathSum = 0\n    var\
    \ minPathsPathsPathsPathIndex = 0\n    var minPathsPathsPathsPathCount = 0\n \
    \   var minPathsPathsPathsPathsCount = 0\n    var minPathsPathsPathsPathsIndex\
    \ = 0\n    var minPathsPathsPathsPathsSum = 0\n    var minPathsPathsPathsPathsPathSum\
    \ = 0\n    var minPathsPathsPathsPathsPathIndex = 0\n    var minPathsPathsPathsPathsPathCount\
    \ = 0\n    var minPathsPathsPathsPathsPathsCount = 0\n    var minPathsPathsPathsPathsPathsIndex\
    \ = 0\n    var minPathsPathsPathsPathsPathsSum = 0\n    var minPathsPathsPathsPathsPathsPathSum\
    \ = 0\n    var min", "    let n = grid.count\n    var minPath = [Int]()\n    var\
    \ minSum = Int.max\n    var minPaths = [[Int]]()\n    var minPathsSum = [Int]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    var path = [Int]()\n    var sum = 0\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            dfs(grid: grid, i: i, j: j, k: k, visited: &visited,\
    \ path: &path, sum: &sum)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = [[Int]]()\n                minPathsSum = [Int]()\n\
    \            }\n            if sum == minSum {\n                minPaths.append(path)\n\
    \                minPathsSum.append(sum)\n            }\n            path = [Int]()\n\
    \            sum = 0\n            visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n        }\n    }\n    var minIndex = 0\n    for\
    \ i in 0..<minPaths.count {\n        if minPaths[i] < minPaths[minIndex] {\n \
    \           minIndex = i\n        }\n    }\n    return minPaths[minIndex]", '    return
    []', "    let n = grid.count\n    var dp = Array(repeating: Array(repeating: Int.max,\
    \ count: n), count: n)\n    var path = Array(repeating: Array(repeating: [Int](),\
    \ count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       dp[i][j] = grid[i][j]\n            path[i][j] = [grid[i][j]]\n       \
    \ }\n    }\n    for _ in 1..<k {\n        var next = Array(repeating: Array(repeating:\
    \ Int.max, count: n), count: n)\n        var nextPath = Array(repeating: Array(repeating:\
    \ [Int](), count: n), count: n)\n        for i in 0..<n {\n            for j in\
    \ 0..<n {\n                if i > 0 && dp[i - 1][j] < dp[i][j] {\n           \
    \         next[i][j] = dp[i - 1][j]\n                    nextPath[i][j] = path[i\
    \ - 1][j]\n                } else if i > 0 && dp[i - 1][j] == dp[i][j] {\n   \
    \                 if path[i - 1][j] < path[i][j] {\n                        next[i][j]\
    \ = dp[i - 1][j]\n                        nextPath[i][j] = path[i - 1][j]\n  \
    \                  } else {\n                        next[i][j] = dp[i][j]\n \
    \                       nextPath[i][j] = path[i][j]\n                    }\n \
    \               } else {\n                    next[i][j] = dp[i][j]\n        \
    \            nextPath[i][j] = path[i][j]\n                }\n                if\
    \ j > 0 && dp[i][j - 1] < next[i][j] {\n                    next[i][j] = dp[i][j\
    \ - 1]\n                    nextPath[i][j] = path[i][j - 1]\n                }\
    \ else if j > 0 && dp[i][j - 1] == next[i][", "    let n = grid.count\n    let\
    \ m = grid[0].count\n    var dp = Array(repeating: Array(repeating: Int.max, count:\
    \ m), count: n)\n    var prev = Array(repeating: Array(repeating: -1, count: m),\
    \ count: n)\n    for i in 0..<n {\n        for j in 0..<m {\n            if i\
    \ == 0 && j == 0 {\n                dp[i][j] = grid[i][j]\n            } else\
    \ if i == 0 {\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n        \
    \        prev[i][j] = 1\n            } else if j == 0 {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j]\n                prev[i][j] = 0\n            } else\
    \ {\n                if dp[i - 1][j] < dp[i][j - 1] {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j]\n                    prev[i][j] = 0\n          \
    \      } else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n  \
    \                  prev[i][j] = 1\n                }\n            }\n        }\n\
    \    }\n    var i = n - 1\n    var j = m - 1\n    var path = [Int]()\n    while\
    \ k > 0 {\n        path.append(grid[i][j])\n        if prev[i][j] == 0 {\n   \
    \         i -= 1\n        } else {\n            j -= 1\n        }\n        k -=\
    \ 1\n    }\n    return path", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j:\
    \ j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPaths = paths\n        \
    \    }\n        }\n    }\n    for path in minPaths {\n        if path.count ==\
    \ k {\n            minPath = path\n            break\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j\
    \ in 0..<n {\n            var path = [Int]()\n            var sum = 0\n      \
    \      var paths = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n          \
    \      minSum = sum\n                minPaths = paths\n            }\n       \
    \ }\n    }\n    minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            visited[i][j]\
    \ = true\n            dfs(grid: grid, i: i, j: j, k: k, sum: grid[i][j], path:\
    \ [grid[i][j]], visited: &visited, minSum: &minSum, minPaths: &minPaths)\n   \
    \         visited[i][j] = false\n        }\n    }\n    for path in minPaths {\n\
    \        if path.count == k {\n            minPath = path\n            break\n\
    \        }\n    }\n    return minPath", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited\
    \ = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            minPath = [Int]()\n    \
    \        minSum = Int.max\n            visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n            dfs(grid: grid, i: i, j: j, k: k, visited:\
    \ &visited, path: &minPath, sum: &minSum, paths: &minPaths)\n        }\n    }\n\
    \    return minPaths.sorted()[0]", "    let n = grid.count\n    var minPath =\
    \ [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited\
    \ = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n   \
    \         var sum = 0\n            dfs(grid: grid, i: i, j: j, k: k, path: &path,\
    \ sum: &sum, visited: &visited)\n            if sum < minSum {\n             \
    \   minSum = sum\n                minPaths = [[Int]]()\n                minPaths.append(path)\n\
    \            } else if sum == minSum {\n                minPaths.append(path)\n\
    \            }\n        }\n    }\n    minPaths.sort()\n    return minPaths[0]",
  "    // TODO: Implement this function\n    return []", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            var paths = [[Int]]()\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPaths =\
    \ paths\n            }\n        }\n    }\n    for path in minPaths {\n       \
    \ if path.count == k {\n            minPath = path\n            break\n      \
    \  }\n    }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    for i in 0..<n {\n      \
    \  for j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n\
    \            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, visited:\
    \ &visited)\n            if sum < minSum {\n                minSum = sum\n   \
    \             minPaths = [[Int]]()\n                minPaths.append(path)\n  \
    \          } else if sum == minSum {\n                minPaths.append(path)\n\
    \            }\n        }\n    }\n    minPaths.sort()\n    minPath = minPaths[0]\n\
    \    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n   \
    \ var minSum = Int.max\n    var minPaths = [[Int]]()\n    var grid = grid\n  \
    \  for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            var paths = [[Int]]()\n            dfs(grid:\
    \ &grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n          \
    \  if sum < minSum {\n                minSum = sum\n                minPath =\
    \ path\n                minPaths = paths\n            } else if sum == minSum\
    \ {\n                for path in paths {\n                    if path < minPath\
    \ {\n                        minPath = path\n                        minPaths\
    \ = [path]\n                    } else if path == minPath {\n                \
    \        minPaths.append(path)\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var minPath: [Int] = []\n    var minPathSum = Int.max\n    var visited: [[Bool]]\
    \ = Array(repeating: Array(repeating: false, count: n), count: n)\n    for i in\
    \ 0..<n {\n        for j in 0..<n {\n            var path: [Int] = []\n      \
    \      var pathSum = 0\n            dfs(grid: grid, i: i, j: j, k: k, path: &path,\
    \ pathSum: &pathSum, visited: &visited)\n            if pathSum < minPathSum {\n\
    \                minPathSum = pathSum\n                minPath = path\n      \
    \      }\n        }\n    }\n    return minPath", "    var grid = grid\n    var\
    \ k = k\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    while k >\
    \ 0 {\n        result.append(grid[i][j])\n        if i + 1 < grid.count && grid[i\
    \ + 1][j] < grid[i][j + 1] {\n            i += 1\n        } else {\n         \
    \   j += 1\n        }\n        k -= 1\n    }\n    return result", "    let n =\
    \ grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var sum = 0\n            var paths = [[Int]]()\n\
    \            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, paths:\
    \ &paths)\n            if sum < minSum {\n                minSum = sum\n     \
    \           minPaths = paths\n            }\n        }\n    }\n    minPaths.sort()\n\
    \    minPath = minPaths[0]\n    return minPath", "    var result = [Int]()\n \
    \   var minPath = [Int]()\n    var minSum = Int.max\n    var minPathSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    var minPathsSum = [Int]()\n    var minPathsLength\
    \ = [Int]()\n    var minPathsSumLength = [Int]()\n    var minPathsSumLengthIndex\
    \ = [Int]()\n    var minPathsSumIndex = [Int]()\n    var minPathsLengthIndex =\
    \ [Int]()\n    var minPathsIndex = [Int]()\n    var minPathsSumIndexIndex = [Int]()\n\
    \    var minPathsLengthIndexIndex = [Int]()\n    var minPathsIndexIndex = [Int]()\n\
    \    var minPathsSumIndexIndexIndex = [Int]()\n    var minPathsLengthIndexIndexIndex\
    \ = [Int]()\n    var minPathsIndexIndexIndex = [Int]()\n    var minPathsSumIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsLengthIndexIndexIndexIndex = [Int]()\n    var minPathsIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndex = [Int]()\n    var minPathsLengthIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsIndexIndexIndexIndexIndex = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsLengthIndexIndexIndexIndexIndexIndex = [Int]()\n\
    \    var minPathsIndexIndexIndexIndexIndexIndex = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsLengthIndexIndexIndexIndexIndexIndexIndex = [Int]()\n\
    \    var minPathsIndexIndexIndexIndexIndexIndexIndex = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsLengthIndexIndexIndexIndexIndexIndexIndexIndex =\
    \ [Int]()\n    var minPathsIndexIndexIndexIndexIndexIndexIndexIndex = [Int]()\n\
    \    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex = [Int]()\n\
    \    var", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    for i in 0..<n {\n        for j in 0..<n {\n            let path\
    \ = dfs(grid: grid, i: i, j: j, k: k, n: n)\n            if path.count == k {\n\
    \                let sum = path.reduce(0, +)\n                if sum < minSum\
    \ {\n                    minSum = sum\n                    minPath = path\n  \
    \              }\n            }\n        }\n    }\n    return minPath", "    let\
    \ n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var\
    \ minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       var path = [Int]()\n            var sum = 0\n            var paths = [[Int]]()\n\
    \            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, paths:\
    \ &paths)\n            if sum < minSum {\n                minSum = sum\n     \
    \           minPaths = paths\n            }\n        }\n    }\n    minPaths.sort()\n\
    \    minPath = minPaths[0]\n    return minPath", "    let n = grid.count\n   \
    \ var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, visited: &visited)\n            if sum < minSum {\n      \
    \          minSum = sum\n                minPaths = [[Int]]()\n              \
    \  minPaths.append(path)\n            } else if sum == minSum {\n            \
    \    minPaths.append(path)\n            }\n        }\n    }\n    minPaths.sort()\n\
    \    return minPaths[0]", "    // TODO: Implement this function\n    return []",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            var paths\
    \ = [[Int]]()\n            minPath(grid: grid, i: i, j: j, k: k, path: &path,\
    \ sum: &sum, paths: &paths)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = paths\n            }\n        }\n    }\n \
    \   for path in minPaths {\n        if path.count == k {\n            minPath\
    \ = path\n            break\n        }\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath = [Int]()\n    var minPathSum = Int.max\n    var\
    \ minPathSet = Set<Int>()\n    var visited = Set<Int>()\n    var queue = Queue<(Int,\
    \ Int, Int)>()\n    queue.enqueue((0, 0, 0))\n    while !queue.isEmpty {\n   \
    \     let (i, j, sum) = queue.dequeue()!\n        if i < 0 || i >= n || j < 0\
    \ || j >= n {\n            continue\n        }\n        let key = i * n + j\n\
    \        if visited.contains(key) {\n            continue\n        }\n       \
    \ visited.insert(key)\n        if sum > minPathSum {\n            continue\n \
    \       }\n        if sum == k {\n            if sum < minPathSum {\n        \
    \        minPathSum = sum\n                minPath = [grid[i][j]]\n          \
    \      minPathSet = [key]\n            } else if sum == minPathSum {\n       \
    \         let last = minPath.last!\n                if grid[i][j] < last {\n \
    \                   minPath = [grid[i][j]]\n                    minPathSet = [key]\n\
    \                } else if grid[i][j] == last {\n                    minPathSet.insert(key)\n\
    \                }\n            }\n            continue\n        }\n        queue.enqueue((i\
    \ - 1, j, sum + 1))\n        queue.enqueue((i + 1, j, sum + 1))\n        queue.enqueue((i,\
    \ j - 1, sum + 1))\n        queue.enqueue((i, j + 1, sum + 1))\n    }\n    if\
    \ minPath.isEmpty {\n        return minPath\n    }\n    var i = 0\n    var j =\
    \ 0\n    var key = 0\n    while minPath.count < k {\n        if i > 0 && !minPathSet.contains(key\
    \ - n) {\n            i -= 1\n        } else if i < n - 1 && !minPathSet.contains(key\
    \ + n) {\n            i += 1\n        } else if j > 0 && !minPathSet.contains(key\
    \ - 1) {\n            j -= 1", "    let n = grid.count\n    var dp = Array(repeating:\
    \ Array(repeating: Int.max, count: n), count: n)\n    var path = Array(repeating:\
    \ Array(repeating: [Int](), count: n), count: n)\n    for i in 0..<n {\n     \
    \   for j in 0..<n {\n            dp[i][j] = grid[i][j]\n            path[i][j]\
    \ = [grid[i][j]]\n        }\n    }\n    for _ in 1..<k {\n        var newDp =\
    \ Array(repeating: Array(repeating: Int.max, count: n), count: n)\n        var\
    \ newPath = Array(repeating: Array(repeating: [Int](), count: n), count: n)\n\
    \        for i in 0..<n {\n            for j in 0..<n {\n                if i\
    \ > 0 && dp[i - 1][j] < dp[i][j] {\n                    newDp[i][j] = dp[i - 1][j]\n\
    \                    newPath[i][j] = path[i - 1][j]\n                } else if\
    \ i > 0 && dp[i - 1][j] == dp[i][j] {\n                    if path[i - 1][j] <\
    \ path[i][j] {\n                        newDp[i][j] = dp[i - 1][j]\n         \
    \               newPath[i][j] = path[i - 1][j]\n                    } else {\n\
    \                        newDp[i][j] = dp[i][j]\n                        newPath[i][j]\
    \ = path[i][j]\n                    }\n                } else {\n            \
    \        newDp[i][j] = dp[i][j]\n                    newPath[i][j] = path[i][j]\n\
    \                }\n                if j > 0 && dp[i][j - 1] < newDp[i][j] {\n\
    \                    newDp[i][j] = dp[i][j - 1]\n                    newPath[i][j]\
    \ = path[i][j - 1]\n                } else if j > 0 &&", "    let n = grid.count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    var path = Array(repeating: Array(repeating: [Int](), count: n), count: n)\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n\
    \            path[i][j] = [grid[i][j]]\n        }\n    }\n    for _ in 1..<k {\n\
    \        var newDp = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        var newPath = Array(repeating: Array(repeating: [Int](), count:\
    \ n), count: n)\n        for i in 0..<n {\n            for j in 0..<n {\n    \
    \            if i > 0 {\n                    if dp[i - 1][j] < dp[i][j] {\n  \
    \                      newDp[i][j] = dp[i - 1][j]\n                        newPath[i][j]\
    \ = path[i - 1][j]\n                    } else if dp[i - 1][j] == dp[i][j] {\n\
    \                        if path[i - 1][j] < path[i][j] {\n                  \
    \          newDp[i][j] = dp[i - 1][j]\n                            newPath[i][j]\
    \ = path[i - 1][j]\n                        } else {\n                       \
    \     newDp[i][j] = dp[i][j]\n                            newPath[i][j] = path[i][j]\n\
    \                        }\n                    } else {\n                   \
    \     newDp[i][j] = dp[i][j]\n                        newPath[i][j] = path[i][j]\n\
    \                    }\n                }\n                if j > 0 {\n      \
    \              if dp[i][j - 1] < newDp[i][j] {\n                        newDp[i][j]\
    \ = dp[i][j - 1]\n                        newPath[i][j] = path[i][j - 1]", " \
    \   let n = grid.count\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, i: i, j: j, k: k, visited:\
    \ &visited, path: &path, sum: &sum)\n            if sum < minSum {\n         \
    \       minSum = sum\n                minPath = path\n            }\n        }\n\
    \    }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            let path = minPath(grid: grid, k: k, i:\
    \ i, j: j, sum: 0)\n            if path.sum < minSum {\n                minSum\
    \ = path.sum\n                minPaths = [path.path]\n            } else if path.sum\
    \ == minSum {\n                minPaths.append(path.path)\n            }\n   \
    \     }\n    }\n    minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    for i in 0..<n {\n \
    \       for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var visited = [[Bool]](repeating: [Bool](repeating: false,\
    \ count: n), count: n)\n            dfs(grid: grid, i: i, j: j, k: k, path: &path,\
    \ sum: &sum, visited: &visited)\n            if sum < minSum {\n             \
    \   minSum = sum\n                minPath = path\n            }\n        }\n \
    \   }\n    return minPath", "    let n = grid.count\n    var grid = grid\n   \
    \ var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    var minPath = [Int]()\n    var minPathValue = Int.max\n    var minPathValueIndex\
    \ = 0\n    var minPathValueIndexRow = 0\n    var minPathValueIndexCol = 0\n  \
    \  var path = [Int]()\n    var pathValue = 0\n    var pathValueIndex = 0\n   \
    \ var pathValueIndexRow = 0\n    var pathValueIndexCol = 0\n    var pathValueIndexRowStack\
    \ = [Int]()\n    var pathValueIndexColStack = [Int]()\n    var pathValueIndexStack\
    \ = [Int]()\n    var pathValueStack = [Int]()\n    var pathStack = [[Int]]()\n\
    \    var pathStackCount = 0\n    var pathStackIndex = 0\n    var pathStackIndexStack\
    \ = [Int]()\n    var pathStackCountStack = [Int]()\n    var pathStackIndexStackCount\
    \ = 0\n    var pathStackIndexStackIndex = 0\n    var pathStackIndexStackIndexStack\
    \ = [Int]()\n    var pathStackIndexStackIndexStackCount = 0\n    var pathStackIndexStackIndexStackIndex\
    \ = 0\n    var pathStackIndexStackIndexStackIndexStack = [Int]()\n    var pathStackIndexStackIndexStackIndexStackCount\
    \ = 0\n    var pathStackIndexStackIndexStackIndexStackIndex = 0\n    var pathStackIndexStackIndexStackIndexStackIndexStack\
    \ = [Int]()\n    var pathStackIndexStackIndexStackIndexStackIndexStackCount =\
    \ 0\n    var pathStackIndexStackIndexStackIndexStackIndexStackIndex = 0\n    var\
    \ pathStackIndexStackIndexStackIndexStackIndexStackIndexStack = [Int]()\n    var\
    \ pathStackIndexStackIndexStackIndexStackIndexStackIndexStackCount = 0\n    var\
    \ pathStackIndexStackIndexStackIndexStackIndexStackIndexStackIndex = 0\n    var\
    \ pathStackIndexStackIndexStackIndexStackIndexStackIndexStackIndexStack = [Int]()\n\
    \    var pathStackIndexStackIndexStackIndexStackIndexStackIndexStackIndexStackCount\
    \ = 0\n    var pathStackIndexStackIndexStackIndexStackIndexStackIndexStackIndexStackIndex\
    \ = 0\n    var pathStackIndexStackIndex", "    let n = grid.count\n    var dp\
    \ = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating: Int.max, count: n),\
    \ count: n), count: k + 1)\n    for i in 0..<n {\n        for j in 0..<n {\n \
    \           dp[0][i][j] = grid[i][j]\n        }\n    }\n    for l in 1...k {\n\
    \        for i in 0..<n {\n            for j in 0..<n {\n                if i\
    \ > 0 {\n                    dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i - 1][j])\n\
    \                }\n                if i < n - 1 {\n                    dp[l][i][j]\
    \ = min(dp[l][i][j], dp[l - 1][i + 1][j])\n                }\n               \
    \ if j > 0 {\n                    dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i][j\
    \ - 1])\n                }\n                if j < n - 1 {\n                 \
    \   dp[l][i][j] = min(dp[l][i][j], dp[l - 1][i][j + 1])\n                }\n \
    \           }\n        }\n    }\n    var ans = [Int]()\n    var i = 0, j = 0\n\
    \    for l in 0..<k {\n        ans.append(dp[l][i][j])\n        if i > 0 && dp[l\
    \ + 1][i - 1][j] == dp[l][i][j] {\n            i -= 1\n        } else if i < n\
    \ - 1 && dp[l + 1][i + 1][j] == dp[l][i][j] {\n            i += 1\n        } else\
    \ if j > 0 && dp[l + 1][i][j - 1] == dp[l][i][j] {\n            j -= 1\n     \
    \   } else {\n            j += 1\n        }\n    }\n    ans.append(dp[k][i][j])\n\
    \    return ans", "    var result = [Int]()\n    var minPath = [Int]()\n    var\
    \ minSum = Int.max\n    var minPathSum = Int.max\n    var path = [Int]()\n   \
    \ var sum = 0\n    var visited = [[Bool]](repeating: [Bool](repeating: false,\
    \ count: grid.count), count: grid.count)\n    var queue = [(Int, Int)]()\n   \
    \ queue.append((0, 0))\n    while !queue.isEmpty {\n        let (i, j) = queue.removeFirst()\n\
    \        if i < 0 || i >= grid.count || j < 0 || j >= grid.count || visited[i][j]\
    \ {\n            continue\n        }\n        path.append(grid[i][j])\n      \
    \  sum += grid[i][j]\n        visited[i][j] = true\n        if path.count == k\
    \ {\n            if sum < minSum {\n                minSum = sum\n           \
    \     minPath = path\n            } else if sum == minSum {\n                if\
    \ path < minPath {\n                    minPath = path\n                }\n  \
    \          }\n        } else {\n            queue.append((i + 1, j))\n       \
    \     queue.append((i - 1, j))\n            queue.append((i, j + 1))\n       \
    \     queue.append((i, j - 1))\n        }\n        visited[i][j] = false\n   \
    \     path.removeLast()\n        sum -= grid[i][j]\n    }\n    return minPath",
  "    var grid = grid\n    var result = [Int]()\n    var min = Int.max\n    var minPath\
    \ = [Int]()\n    var k = k\n    var i = 0\n    var j = 0\n    while k > 0 {\n\
    \        result.append(grid[i][j])\n        if i + 1 < grid.count && grid[i +\
    \ 1][j] < grid[i][j] {\n            i += 1\n        } else if j + 1 < grid[i].count\
    \ && grid[i][j + 1] < grid[i][j] {\n            j += 1\n        } else if i -\
    \ 1 >= 0 && grid[i - 1][j] < grid[i][j] {\n            i -= 1\n        } else\
    \ if j - 1 >= 0 && grid[i][j - 1] < grid[i][j] {\n            j -= 1\n       \
    \ }\n        k -= 1\n    }\n    return result", "    let n = grid.count\n    var\
    \ minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, visited: &visited)\n            if sum < minSum {\n      \
    \          minSum = sum\n                minPaths = [[Int]]()\n              \
    \  minPaths.append(path)\n            } else if sum == minSum {\n            \
    \    minPaths.append(path)\n            }\n        }\n    }\n    minPaths.sort()\n\
    \    return minPaths[0]", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    for i in 0..<n {\n        for j in 0..<n {\n  \
    \          var path = [Int]()\n            var sum = 0\n            var visited\
    \ = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n      \
    \      dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, visited: &visited)\n\
    \            if sum < minSum {\n                minSum = sum\n               \
    \ minPath = path\n            }\n        }\n    }\n    return minPath", "    let\
    \ n = grid.count\n    var minPath = Array(repeating: 0, count: k)\n    var minPathValue\
    \ = Int.max\n    var visited = Array(repeating: Array(repeating: false, count:\
    \ n), count: n)\n    func dfs(i: Int, j: Int, path: [Int], pathValue: Int) {\n\
    \        if path.count == k {\n            if pathValue < minPathValue {\n   \
    \             minPath = path\n                minPathValue = pathValue\n     \
    \       }\n            return\n        }\n        if i > 0 && !visited[i - 1][j]\
    \ {\n            visited[i - 1][j] = true\n            dfs(i: i - 1, j: j, path:\
    \ path + [grid[i - 1][j]], pathValue: pathValue * 10 + grid[i - 1][j])\n     \
    \       visited[i - 1][j] = false\n        }\n        if i < n - 1 && !visited[i\
    \ + 1][j] {\n            visited[i + 1][j] = true\n            dfs(i: i + 1, j:\
    \ j, path: path + [grid[i + 1][j]], pathValue: pathValue * 10 + grid[i + 1][j])\n\
    \            visited[i + 1][j] = false\n        }\n        if j > 0 && !visited[i][j\
    \ - 1] {\n            visited[i][j - 1] = true\n            dfs(i: i, j: j - 1,\
    \ path: path + [grid[i][j - 1]], pathValue: pathValue * 10 + grid[i][j - 1])\n\
    \            visited[i][j - 1] = false\n        }\n        if j < n - 1 && !visited[i][j\
    \ + 1] {\n            visited[i][j + 1] = true\n            dfs(i: i, j: j + 1,\
    \ path: path + [grid[i][j + 1]], pathValue: pathValue * 10 + grid[i][j + 1])\n\
    \            visited[i][j + 1] = false\n        }\n    }\n    for i in 0..<n {\n\
    \        for j in 0..<", "    let n = grid.count\n    var visited = Array(repeating:\
    \ Array(repeating: false, count: n), count: n)\n    var minPath = Array(repeating:\
    \ 0, count: k)\n    var minPathSum = Int.max\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            var path = [Int]()\n            var pathSum = 0\n\
    \            dfs(grid: grid, i: i, j: j, k: k, visited: &visited, path: &path,\
    \ pathSum: &pathSum)\n            if pathSum < minPathSum {\n                minPath\
    \ = path\n                minPathSum = pathSum\n            }\n        }\n   \
    \ }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j:\
    \ j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPaths = paths\n        \
    \    }\n        }\n    }\n    for i in 0..<minPaths.count {\n        if minPaths[i]\
    \ < minPath {\n            minPath = minPaths[i]\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    var minSums = [Int]()\n    var\
    \ visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n\
    \    var path = [Int]()\n    var sum = 0\n    var paths = [[Int]]()\n    var sums\
    \ = [Int]()\n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, visited: &visited, path: &path, sum: &sum, paths: &paths,\
    \ sums: &sums)\n            if minSum > sum {\n                minSum = sum\n\
    \                minPath = path\n                minPaths = paths\n          \
    \      minSums = sums\n            }\n        }\n    }\n    print(minPaths)\n\
    \    print(minSums)\n    return minPath", "    let n = grid.count\n    var dp\
    \ = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n    var dp2\
    \ = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n    for i\
    \ in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n  \
    \          dp2[i][j] = grid[i][j]\n        }\n    }\n    for _ in 0..<k-1 {\n\
    \        for i in 0..<n {\n            for j in 0..<n {\n                if i\
    \ > 0 {\n                    dp[i][j] = min(dp[i][j], dp[i-1][j])\n          \
    \      }\n                if j > 0 {\n                    dp[i][j] = min(dp[i][j],\
    \ dp[i][j-1])\n                }\n                if i < n-1 {\n             \
    \       dp[i][j] = min(dp[i][j], dp[i+1][j])\n                }\n            \
    \    if j < n-1 {\n                    dp[i][j] = min(dp[i][j], dp[i][j+1])\n\
    \                }\n            }\n        }\n        for i in 0..<n {\n     \
    \       for j in 0..<n {\n                if i > 0 {\n                    dp2[i][j]\
    \ = min(dp2[i][j], dp2[i-1][j])\n                }\n                if j > 0 {\n\
    \                    dp2[i][j] = min(dp2[i][j], dp2[i][j-1])\n               \
    \ }\n                if i < n-1 {\n                    dp2[i][j] = min(dp2[i][j],\
    \ dp2[i+1][j])\n                }\n                if j < n-1 {\n            \
    \        dp2[i][j] = min(dp2[i][j], dp2[i][j+1])\n                }\n        \
    \    }\n        }\n    }\n    var ans =", "    // TODO: Implement it\n    return\
    \ []", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum)\n            if sum < minSum {\n                minSum = sum\n\
    \                minPath = path\n            }\n        }\n    }\n    return minPath",
  "    let n = grid.count\n    var dp = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating:\
    \ Int.max, count: n), count: n), count: k + 1)\n    for i in 0..<n {\n       \
    \ for j in 0..<n {\n            dp[0][i][j] = grid[i][j]\n        }\n    }\n \
    \   for i in 1...k {\n        for j in 0..<n {\n            for l in 0..<n {\n\
    \                if j > 0 {\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i - 1][j - 1][l])\n                }\n                if j < n - 1 {\n  \
    \                  dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j + 1][l])\n     \
    \           }\n                if l > 0 {\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1])\n                }\n                if l < n - 1 {\n  \
    \                  dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j][l + 1])\n     \
    \           }\n            }\n        }\n    }\n    var ans = [Int](repeating:\
    \ 0, count: k)\n    var i = k - 1\n    var j = 0\n    var l = 0\n    while i >=\
    \ 0 {\n        ans[i] = dp[i + 1][j][l]\n        if j > 0 && dp[i][j - 1][l] ==\
    \ dp[i + 1][j][l] {\n            j -= 1\n        } else if j < n - 1 && dp[i][j\
    \ + 1][l] == dp[i + 1][j][l] {\n            j += 1\n        } else if l > 0 &&\
    \ dp[i][j][l - 1] == dp[i + 1][j][l] {\n            l -= 1\n        } else if\
    \ l < n - 1 && dp[i][j", "    // TODO: Implement\n    return []", "    let n =\
    \ grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var sum = 0\n            var paths = [[Int]]()\n\
    \            minPath(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, paths:\
    \ &paths)\n            if sum < minSum {\n                minSum = sum\n     \
    \           minPaths = paths\n            }\n        }\n    }\n    for path in\
    \ minPaths {\n        if path.count == k {\n            minPath = path\n     \
    \       break\n        }\n    }\n    return minPath", "    // TODO: Implement\n\
    \    return []", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j\
    \ in 0..<n {\n            var path = [Int]()\n            var sum = 0\n      \
    \      var paths = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n          \
    \      minSum = sum\n                minPaths = paths\n            }\n       \
    \ }\n    }\n    for path in minPaths {\n        if path.count == k {\n       \
    \     minPath = path\n            break\n        }\n    }\n    return minPath",
  "    // TODO: Implement this function\n    return []", "    let n = grid.count\n\
    \    var visited = Array(repeating: Array(repeating: false, count: n), count:\
    \ n)\n    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths =\
    \ [[Int]]()\n    var minSums = [Int]()\n    var path = [Int]()\n    var sum =\
    \ 0\n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(grid: grid,\
    \ visited: &visited, i: i, j: j, k: k, path: &path, sum: &sum, minPath: &minPath,\
    \ minSum: &minSum, minPaths: &minPaths, minSums: &minSums)\n        }\n    }\n\
    \    var minIndex = 0\n    for i in 0..<minPaths.count {\n        if minSums[i]\
    \ < minSums[minIndex] {\n            minIndex = i\n        }\n    }\n    return\
    \ minPaths[minIndex]", "    let n = grid.count\n    var minPath = [Int]()\n  \
    \  var minPathSum = Int.max\n    var minPathSet = Set<Int>()\n    var visited\
    \ = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n    func\
    \ dfs(_ i: Int, _ j: Int, _ path: [Int], _ pathSum: Int) {\n        if path.count\
    \ == k {\n            if pathSum < minPathSum {\n                minPathSum =\
    \ pathSum\n                minPath = path\n                minPathSet = Set(path)\n\
    \            } else if pathSum == minPathSum {\n                if path.lexicographicallyPrecedes(minPath)\
    \ {\n                    minPath = path\n                    minPathSet = Set(path)\n\
    \                }\n            }\n            return\n        }\n        if i\
    \ > 0 && !visited[i - 1][j] && !minPathSet.contains(grid[i - 1][j]) {\n      \
    \      visited[i - 1][j] = true\n            dfs(i - 1, j, path + [grid[i - 1][j]],\
    \ pathSum + grid[i - 1][j])\n            visited[i - 1][j] = false\n        }\n\
    \        if i < n - 1 && !visited[i + 1][j] && !minPathSet.contains(grid[i + 1][j])\
    \ {\n            visited[i + 1][j] = true\n            dfs(i + 1, j, path + [grid[i\
    \ + 1][j]], pathSum + grid[i + 1][j])\n            visited[i + 1][j] = false\n\
    \        }\n        if j > 0 && !visited[i][j - 1] && !minPathSet.contains(grid[i][j\
    \ - 1]) {\n            visited[i][j - 1] = true\n            dfs(i, j - 1, path\
    \ + [grid[i][j - 1]], pathSum + grid[i][j - 1])\n            visited[i][j - 1]\
    \ = false\n        }\n        if j < n - 1 && !visited[i][j + 1] && !minPathSet.cont",
  "    let n = grid.count\n    var dp = Array(repeating: Array(repeating: Int.max,\
    \ count: n), count: n)\n    var path = Array(repeating: Array(repeating: [Int](),\
    \ count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       dp[i][j] = grid[i][j]\n            path[i][j] = [grid[i][j]]\n       \
    \ }\n    }\n    for _ in 1..<k {\n        var newDp = Array(repeating: Array(repeating:\
    \ Int.max, count: n), count: n)\n        var newPath = Array(repeating: Array(repeating:\
    \ [Int](), count: n), count: n)\n        for i in 0..<n {\n            for j in\
    \ 0..<n {\n                if i > 0 && dp[i - 1][j] < dp[i][j] {\n           \
    \         newDp[i][j] = dp[i - 1][j]\n                    newPath[i][j] = path[i\
    \ - 1][j]\n                } else if i > 0 && dp[i - 1][j] == dp[i][j] {\n   \
    \                 if path[i - 1][j] < path[i][j] {\n                        newDp[i][j]\
    \ = dp[i - 1][j]\n                        newPath[i][j] = path[i - 1][j]\n   \
    \                 } else {\n                        newDp[i][j] = dp[i][j]\n \
    \                       newPath[i][j] = path[i][j]\n                    }\n  \
    \              } else {\n                    newDp[i][j] = dp[i][j]\n        \
    \            newPath[i][j] = path[i][j]\n                }\n                if\
    \ j > 0 && dp[i][j - 1] < newDp[i][j] {\n                    newDp[i][j] = dp[i][j\
    \ - 1]\n                    newPath[i][j] = path[i][j - 1]\n                }\
    \ else if j > 0 &&", "    let n = grid.count\n    var dp = Array(repeating: Array(repeating:\
    \ Int.max, count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n\
    \ {\n            dp[i][j] = grid[i][j]\n        }\n    }\n    for _ in 0..<k {\n\
    \        var temp = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        for i in 0..<n {\n            for j in 0..<n {\n               \
    \ if i > 0 {\n                    temp[i][j] = min(temp[i][j], dp[i - 1][j])\n\
    \                }\n                if i < n - 1 {\n                    temp[i][j]\
    \ = min(temp[i][j], dp[i + 1][j])\n                }\n                if j > 0\
    \ {\n                    temp[i][j] = min(temp[i][j], dp[i][j - 1])\n        \
    \        }\n                if j < n - 1 {\n                    temp[i][j] = min(temp[i][j],\
    \ dp[i][j + 1])\n                }\n            }\n        }\n        dp = temp\n\
    \    }\n    var ans = [Int]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            if dp[i][j] == grid[i][j] {\n                ans.append(dp[i][j])\n\
    \            }\n        }\n    }\n    return ans", "    let n = grid.count\n \
    \   let m = grid[0].count\n    var dp = Array(repeating: Array(repeating: Int.max,\
    \ count: m), count: n)\n    var q = [(Int, Int, Int)]()\n    q.append((0, 0, grid[0][0]))\n\
    \    dp[0][0] = grid[0][0]\n    while !q.isEmpty {\n        let (i, j, val) =\
    \ q.removeFirst()\n        if i > 0 {\n            let newVal = val + grid[i -\
    \ 1][j]\n            if newVal < dp[i - 1][j] {\n                dp[i - 1][j]\
    \ = newVal\n                q.append((i - 1, j, newVal))\n            }\n    \
    \    }\n        if i < n - 1 {\n            let newVal = val + grid[i + 1][j]\n\
    \            if newVal < dp[i + 1][j] {\n                dp[i + 1][j] = newVal\n\
    \                q.append((i + 1, j, newVal))\n            }\n        }\n    \
    \    if j > 0 {\n            let newVal = val + grid[i][j - 1]\n            if\
    \ newVal < dp[i][j - 1] {\n                dp[i][j - 1] = newVal\n           \
    \     q.append((i, j - 1, newVal))\n            }\n        }\n        if j < m\
    \ - 1 {\n            let newVal = val + grid[i][j + 1]\n            if newVal\
    \ < dp[i][j + 1] {\n                dp[i][j + 1] = newVal\n                q.append((i,\
    \ j + 1, newVal))\n            }\n        }\n    }\n    var ans = [Int]()\n  \
    \  var i = n - 1\n    var j = m - 1\n    while k > 0 {\n        ans.append(grid[i][j])\n\
    \        k -= 1\n        if i > 0 && dp[i - 1][j] < dp[i][j] {\n            i\
    \ -= 1\n        } else if i < n - 1 && dp", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    var minSum = Int.max\n    for i in 0..<n {\n        for j in\
    \ 0..<n {\n            var path = [Int]()\n            var sum = 0\n         \
    \   var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, visited:\
    \ &visited)\n            if sum < minSum {\n                minSum = sum\n   \
    \             minPath = path\n            }\n        }\n    }\n    return minPath",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            var paths\
    \ = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, sum: &sum, path:\
    \ &path, paths: &paths)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = paths\n            }\n        }\n    }\n \
    \   for path in minPaths {\n        if path.count == k {\n            minPath\
    \ = path\n            break\n        }\n    }\n    return minPath", "    var grid\
    \ = grid\n    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathSumIndex\
    \ = 0\n    var minPathSumIndexRow = 0\n    var minPathSumIndexCol = 0\n    var\
    \ minPathSumIndexRowCol = 0\n    var minPathSumIndexRowColIndex = 0\n    var minPathSumIndexRowColIndexRow\
    \ = 0\n    var minPathSumIndexRowColIndexCol = 0\n    var minPathSumIndexRowColIndexRowCol\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndex = 0\n    var minPathSumIndexRowColIndexRowColIndexRow\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexCol = 0\n    var minPathSumIndexRowColIndexRowColIndexRowCol\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndex = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRow\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexCol = 0\n    var\
    \ minPathSumIndexRowColIndexRowColIndexRowColIndexRowCol = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndex\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRow\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexCol\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowCol\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndex\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndexRow\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndexCol\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndexRowCol\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndex\
    \ = 0\n    var minPathSumIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndexRowColIndexRow\
    \ = 0\n    var minPathSumIndexRowColIndexRow", "    let n = grid.count\n    var\
    \ dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n    var\
    \ visited = Array(repeating: Array(repeating: false, count: n), count: n)\n  \
    \  var queue = [(Int, Int)]()\n    queue.append((0, 0))\n    dp[0][0] = grid[0][0]\n\
    \    visited[0][0] = true\n    while !queue.isEmpty {\n        let (x, y) = queue.removeFirst()\n\
    \        if x > 0 && !visited[x - 1][y] {\n            dp[x - 1][y] = min(dp[x\
    \ - 1][y], dp[x][y] + grid[x - 1][y])\n            visited[x - 1][y] = true\n\
    \            queue.append((x - 1, y))\n        }\n        if x < n - 1 && !visited[x\
    \ + 1][y] {\n            dp[x + 1][y] = min(dp[x + 1][y], dp[x][y] + grid[x +\
    \ 1][y])\n            visited[x + 1][y] = true\n            queue.append((x +\
    \ 1, y))\n        }\n        if y > 0 && !visited[x][y - 1] {\n            dp[x][y\
    \ - 1] = min(dp[x][y - 1], dp[x][y] + grid[x][y - 1])\n            visited[x][y\
    \ - 1] = true\n            queue.append((x, y - 1))\n        }\n        if y <\
    \ n - 1 && !visited[x][y + 1] {\n            dp[x][y + 1] = min(dp[x][y + 1],\
    \ dp[x][y] + grid[x][y + 1])\n            visited[x][y + 1] = true\n         \
    \   queue.append((x, y + 1))\n        }\n    }\n    var ans = [Int]()\n    var\
    \ x = 0\n    var y = 0\n    while k > 0 {\n        ans.append(grid[x][y])\n  \
    \     ", "    let n = grid.count\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            dfs(&grid,\
    \ &visited, &path, &sum, i, j, k)\n            if sum < minSum {\n           \
    \     minSum = sum\n                minPaths = [path]\n            } else if sum\
    \ == minSum {\n                minPaths.append(path)\n            }\n        }\n\
    \    }\n    minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n\
    \    let m = grid[0].count\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: m), count: n)\n    var minPath = [Int]()\n    var minPathSum =\
    \ Int.max\n    func dfs(_ i: Int, _ j: Int, _ path: [Int], _ pathSum: Int) {\n\
    \        if i < 0 || i >= n || j < 0 || j >= m || visited[i][j] {\n          \
    \  return\n        }\n        if path.count == k {\n            if pathSum < minPathSum\
    \ {\n                minPathSum = pathSum\n                minPath = path\n  \
    \          } else if pathSum == minPathSum {\n                if path < minPath\
    \ {\n                    minPath = path\n                }\n            }\n  \
    \          return\n        }\n        visited[i][j] = true\n        dfs(i - 1,\
    \ j, path + [grid[i][j]], pathSum + grid[i][j])\n        dfs(i + 1, j, path +\
    \ [grid[i][j]], pathSum + grid[i][j])\n        dfs(i, j - 1, path + [grid[i][j]],\
    \ pathSum + grid[i][j])\n        dfs(i, j + 1, path + [grid[i][j]], pathSum +\
    \ grid[i][j])\n        visited[i][j] = false\n    }\n    for i in 0..<n {\n  \
    \      for j in 0..<m {\n            dfs(i, j, [], 0)\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    for i in 0..<n {\n        for j in 0..<n {\n            var path\
    \ = [Int]()\n            var sum = 0\n            var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n            dfs(grid: grid, i:\
    \ i, j: j, k: k, path: &path, sum: &sum, visited: &visited)\n            if sum\
    \ < minSum {\n                minSum = sum\n                minPath = path\n \
    \           }\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    var pq = PriorityQueue<(Int, Int, Int)>(sort: { $0.2 < $1.2 })\n    pq.push((0,\
    \ 0, grid[0][0]))\n    dp[0][0] = grid[0][0]\n    while let (i, j, val) = pq.pop()\
    \ {\n        if i == n - 1 && j == n - 1 {\n            return getPath(grid: grid,\
    \ dp: dp, k: k)\n        }\n        if i > 0 && dp[i - 1][j] > val + grid[i -\
    \ 1][j] {\n            dp[i - 1][j] = val + grid[i - 1][j]\n            pq.push((i\
    \ - 1, j, dp[i - 1][j]))\n        }\n        if i < n - 1 && dp[i + 1][j] > val\
    \ + grid[i + 1][j] {\n            dp[i + 1][j] = val + grid[i + 1][j]\n      \
    \      pq.push((i + 1, j, dp[i + 1][j]))\n        }\n        if j > 0 && dp[i][j\
    \ - 1] > val + grid[i][j - 1] {\n            dp[i][j - 1] = val + grid[i][j -\
    \ 1]\n            pq.push((i, j - 1, dp[i][j - 1]))\n        }\n        if j <\
    \ n - 1 && dp[i][j + 1] > val + grid[i][j + 1] {\n            dp[i][j + 1] = val\
    \ + grid[i][j + 1]\n            pq.push((i, j + 1, dp[i][j + 1]))\n        }\n\
    \    }\n    return []", "    let n = grid.count\n    var minPath = [Int]()\n \
    \   for _ in 0..<k {\n        minPath.append(Int.max)\n    }\n    var visited\
    \ = [[Bool]]()\n    for _ in 0..<n {\n        visited.append([Bool](repeating:\
    \ false, count: n))\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n \
    \           visited[i][j] = true\n            dfs(grid: grid, i: i, j: j, k: k,\
    \ path: [grid[i][j]], minPath: &minPath, visited: &visited)\n            visited[i][j]\
    \ = false\n        }\n    }\n    return minPath", "    let n = grid.count\n  \
    \  var minPath = [Int]()\n    var minPathValue = Int.max\n    var minPaths = [[Int]]()\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var pathValue = 0\n            var paths = [[Int]]()\n          \
    \  dfs(grid: grid, i: i, j: j, k: k, path: &path, pathValue: &pathValue, paths:\
    \ &paths)\n            if pathValue < minPathValue {\n                minPath\
    \ = path\n                minPathValue = pathValue\n                minPaths =\
    \ paths\n            } else if pathValue == minPathValue {\n                if\
    \ path < minPath {\n                    minPath = path\n                    minPathValue\
    \ = pathValue\n                    minPaths = paths\n                }\n     \
    \       }\n        }\n    }\n    print(minPaths)\n    return minPath", "    let\
    \ n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var\
    \ minPaths = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var sum = 0\n            var path = [Int]()\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, sum: &sum, path: &path, visited: &visited)\n       \
    \     if sum < minSum {\n                minSum = sum\n                minPaths\
    \ = [[Int]]()\n                minPaths.append(path)\n            } else if sum\
    \ == minSum {\n                minPaths.append(path)\n            }\n        }\n\
    \    }\n    minPaths.sort()\n    return minPaths[0]", "    var result = [Int]()\n\
    \    var min = Int.max\n    var minPath = [Int]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: grid.count), count: grid.count)\n    var queue\
    \ = [(Int, Int)]()\n    queue.append((0, 0))\n    visited[0][0] = true\n    while\
    \ !queue.isEmpty {\n        let (row, col) = queue.removeFirst()\n        result.append(grid[row][col])\n\
    \        if result.count == k {\n            if result.lexicographicallyPrecedes(minPath)\
    \ {\n                minPath = result\n            }\n            result.removeLast()\n\
    \            continue\n        }\n        if row > 0 && !visited[row - 1][col]\
    \ {\n            queue.append((row - 1, col))\n            visited[row - 1][col]\
    \ = true\n        }\n        if row < grid.count - 1 && !visited[row + 1][col]\
    \ {\n            queue.append((row + 1, col))\n            visited[row + 1][col]\
    \ = true\n        }\n        if col > 0 && !visited[row][col - 1] {\n        \
    \    queue.append((row, col - 1))\n            visited[row][col - 1] = true\n\
    \        }\n        if col < grid.count - 1 && !visited[row][col + 1] {\n    \
    \        queue.append((row, col + 1))\n            visited[row][col + 1] = true\n\
    \        }\n    }\n    return minPath", "    let n = grid.count\n    var dp =\
    \ [[[Int]]](repeating: [[Int]](repeating: [Int](repeating: Int.max, count: n),\
    \ count: n), count: k + 1)\n    for i in 0..<n {\n        for j in 0..<n {\n \
    \           dp[0][i][j] = grid[i][j]\n        }\n    }\n    for i in 1...k {\n\
    \        for j in 0..<n {\n            for l in 0..<n {\n                if j\
    \ > 0 {\n                    dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j - 1][l])\n\
    \                }\n                if j < n - 1 {\n                    dp[i][j][l]\
    \ = min(dp[i][j][l], dp[i - 1][j + 1][l])\n                }\n               \
    \ if l > 0 {\n                    dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1])\n                }\n                if l < n - 1 {\n                 \
    \   dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j][l + 1])\n                }\n \
    \           }\n        }\n    }\n    var ans = [Int](repeating: Int.max, count:\
    \ k)\n    for i in 0..<n {\n        for j in 0..<n {\n            if ans[k - 1]\
    \ > dp[k][i][j] {\n                ans[k - 1] = dp[k][i][j]\n                ans[0]\
    \ = grid[i][j]\n            }\n        }\n    }\n    for i in 1..<k {\n      \
    \  ans[i] = dp[k - i][ans[i - 1] - 1][ans[i - 1] - 1]\n    }\n    return ans",
  "    let n = grid.count\n    var dp = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating:\
    \ Int.max, count: n), count: n), count: k + 1)\n    for i in 0..<n {\n       \
    \ for j in 0..<n {\n            dp[0][i][j] = grid[i][j]\n        }\n    }\n \
    \   for i in 1...k {\n        for j in 0..<n {\n            for l in 0..<n {\n\
    \                if j > 0 {\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i - 1][j - 1][l])\n                }\n                if j < n - 1 {\n  \
    \                  dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j + 1][l])\n     \
    \           }\n                if l > 0 {\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1])\n                }\n                if l < n - 1 {\n  \
    \                  dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j][l + 1])\n     \
    \           }\n            }\n        }\n    }\n    var ans = [Int](repeating:\
    \ Int.max, count: k)\n    for i in 0..<n {\n        for j in 0..<n {\n       \
    \     if dp[k][i][j] < ans[k - 1] {\n                ans = [Int](repeating: Int.max,\
    \ count: k)\n                ans[k - 1] = dp[k][i][j]\n            }\n       \
    \     if dp[k][i][j] == ans[k - 1] {\n                ans[k - 1] = dp[k][i][j]\n\
    \                var x = i\n                var y = j\n                for l in\
    \ (0..<k).reversed() {\n                    ans[l] = grid[x][y]\n            \
    \        if x > 0 && dp[l][x - 1][", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    var minPathValue = Int.max\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            let path = minPath(grid: grid, k: k, i: i, j: j, path:\
    \ [], pathValue: 0)\n            if pathValue(path: path) < minPathValue {\n \
    \               minPath = path\n                minPathValue = pathValue(path:\
    \ path)\n            }\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    var path = Array(repeating: Array(repeating: [Int](), count: n), count: n)\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n\
    \            path[i][j] = [grid[i][j]]\n        }\n    }\n    for _ in 1..<k {\n\
    \        var newDp = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        var newPath = Array(repeating: Array(repeating: [Int](), count:\
    \ n), count: n)\n        for i in 0..<n {\n            for j in 0..<n {\n    \
    \            for x in [i - 1, i, i + 1] {\n                    for y in [j - 1,\
    \ j, j + 1] {\n                        if x >= 0 && x < n && y >= 0 && y < n &&\
    \ !(x == i && y == j) {\n                            let newVal = dp[x][y] * 10\
    \ + grid[i][j]\n                            if newVal < newDp[i][j] {\n      \
    \                          newDp[i][j] = newVal\n                            \
    \    newPath[i][j] = path[x][y] + [grid[i][j]]\n                            }\
    \ else if newVal == newDp[i][j] {\n                                if path[x][y]\
    \ + [grid[i][j]] < newPath[i][j] {\n                                    newPath[i][j]\
    \ = path[x][y] + [grid[i][j]]\n                                }\n           \
    \                 }\n                        }\n                    }\n      \
    \          }\n            }\n        }\n        dp = newDp\n        path = newPath\n\
    \    }\n    var ans = path[0][0]\n    for i in 0..<n {\n        for j in 0..<n\
    \ {\n            if path[i][j] < ans {\n                ans = path[i][j", "  \
    \  let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            var paths\
    \ = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum:\
    \ &sum, paths: &paths)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = paths\n            }\n        }\n    }\n \
    \   for path in minPaths {\n        if path.count == k {\n            minPath\
    \ = path\n            break\n        }\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath = Array(repeating: 0, count: k)\n    var minPathValue\
    \ = Int.max\n    var minPathIndex = 0\n    for i in 0..<n {\n        for j in\
    \ 0..<n {\n            var path = [Int]()\n            var pathValue = 0\n   \
    \         var pathIndex = 0\n            var visited = Array(repeating: Array(repeating:\
    \ false, count: n), count: n)\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, pathValue: &pathValue, pathIndex: &pathIndex, visited: &visited)\n  \
    \          if pathValue < minPathValue {\n                minPath = path\n   \
    \             minPathValue = pathValue\n                minPathIndex = pathIndex\n\
    \            } else if pathValue == minPathValue {\n                for index\
    \ in 0..<k {\n                    if path[index] < minPath[index] {\n        \
    \                minPath = path\n                        minPathValue = pathValue\n\
    \                        minPathIndex = pathIndex\n                        break\n\
    \                    } else if path[index] > minPath[index] {\n              \
    \          break\n                    }\n                }\n            }\n  \
    \      }\n    }\n    return Array(minPath[0..<minPathIndex])", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, visited: &visited)\n            if sum < minSum {\n      \
    \          minSum = sum\n                minPaths = [[Int]]()\n              \
    \  minPaths.append(path)\n            } else if sum == minSum {\n            \
    \    minPaths.append(path)\n            }\n        }\n    }\n    minPaths.sort()\n\
    \    return minPaths[0]", "    var grid = grid\n    var result = [Int]()\n   \
    \ var min = Int.max\n    var minPath = [Int]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: grid.count), count: grid.count)\n    var queue\
    \ = [(Int, Int)]()\n    queue.append((0, 0))\n    visited[0][0] = true\n    while\
    \ !queue.isEmpty {\n        let (x, y) = queue.removeFirst()\n        result.append(grid[x][y])\n\
    \        if result.count == k {\n            if result.lexicographicallyPrecedes(minPath)\
    \ {\n                minPath = result\n            }\n            result.removeLast()\n\
    \            continue\n        }\n        if x > 0 && !visited[x - 1][y] {\n \
    \           queue.append((x - 1, y))\n            visited[x - 1][y] = true\n \
    \       }\n        if x < grid.count - 1 && !visited[x + 1][y] {\n           \
    \ queue.append((x + 1, y))\n            visited[x + 1][y] = true\n        }\n\
    \        if y > 0 && !visited[x][y - 1] {\n            queue.append((x, y - 1))\n\
    \            visited[x][y - 1] = true\n        }\n        if y < grid.count -\
    \ 1 && !visited[x][y + 1] {\n            queue.append((x, y + 1))\n          \
    \  visited[x][y + 1] = true\n        }\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath = [Int]()\n    var minPathSum = Int.max\n    var\
    \ minPathGrid = [[Int]]()\n    for i in 0..<n {\n        minPathGrid.append(Array(repeating:\
    \ Int.max, count: n))\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            if i == 0 && j == 0 {\n                minPathGrid[i][j] = grid[i][j]\n\
    \            } else if i == 0 {\n                minPathGrid[i][j] = minPathGrid[i][j\
    \ - 1] + grid[i][j]\n            } else if j == 0 {\n                minPathGrid[i][j]\
    \ = minPathGrid[i - 1][j] + grid[i][j]\n            } else {\n               \
    \ minPathGrid[i][j] = min(minPathGrid[i - 1][j], minPathGrid[i][j - 1]) + grid[i][j]\n\
    \            }\n        }\n    }\n    var i = n - 1\n    var j = n - 1\n    while\
    \ k > 0 {\n        if i == 0 && j == 0 {\n            minPath.append(grid[i][j])\n\
    \            break\n        } else if i == 0 {\n            minPath.append(grid[i][j])\n\
    \            j -= 1\n        } else if j == 0 {\n            minPath.append(grid[i][j])\n\
    \            i -= 1\n        } else {\n            if minPathGrid[i - 1][j] <\
    \ minPathGrid[i][j - 1] {\n                minPath.append(grid[i][j])\n      \
    \          i -= 1\n            } else {\n                minPath.append(grid[i][j])\n\
    \                j -= 1\n            }\n        }\n        k -= 1\n    }\n   \
    \ return minPath.reversed()", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    for i in 0..<n {\n      \
    \  for j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n\
    \            var paths = [[Int]]()\n            var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n            dfs(grid: grid, i:\
    \ i, j: j, k: k, path: &path, sum: &sum, paths: &paths, visited: &visited)\n \
    \           if sum < minSum {\n                minSum = sum\n                minPaths\
    \ = paths\n            }\n        }\n    }\n    minPaths.sort()\n    minPath =\
    \ minPaths[0]\n    return minPath", "    // TODO: Implement\n    return []", " \
    \   let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            minPath = [Int]()\n            minSum = Int.max\n            visited\
    \ = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n      \
    \      dfs(grid: grid, i: i, j: j, k: k, sum: 0, path: &minPath, minSum: &minSum,\
    \ visited: &visited)\n            minPaths.append(minPath)\n        }\n    }\n\
    \    minPaths.sort { (a, b) -> Bool in\n        for i in 0..<a.count {\n     \
    \       if a[i] < b[i] {\n                return true\n            } else if a[i]\
    \ > b[i] {\n                return false\n            }\n        }\n        return\
    \ false\n    }\n    return minPaths[0]", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i\
    \ in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n     \
    \       var sum = 0\n            var paths = [[Int]]()\n            minPathHelper(grid:\
    \ grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPaths =\
    \ paths\n            }\n        }\n    }\n    for path in minPaths {\n       \
    \ if path.count == k {\n            minPath = path\n            break\n      \
    \  }\n    }\n    return minPath", "    let n = grid.count\n    var visited = Array(repeating:\
    \ Array(repeating: false, count: n), count: n)\n    var minPath = Array(repeating:\
    \ 0, count: k)\n    var minPathValue = Int.max\n    func dfs(_ i: Int, _ j: Int,\
    \ _ path: inout [Int], _ pathValue: inout Int) {\n        if i < 0 || i >= n ||\
    \ j < 0 || j >= n || visited[i][j] {\n            return\n        }\n        path.append(grid[i][j])\n\
    \        pathValue += grid[i][j]\n        visited[i][j] = true\n        if path.count\
    \ == k {\n            if pathValue < minPathValue {\n                minPath =\
    \ path\n                minPathValue = pathValue\n            } else if pathValue\
    \ == minPathValue {\n                if path < minPath {\n                   \
    \ minPath = path\n                }\n            }\n        } else {\n       \
    \     dfs(i - 1, j, &path, &pathValue)\n            dfs(i + 1, j, &path, &pathValue)\n\
    \            dfs(i, j - 1, &path, &pathValue)\n            dfs(i, j + 1, &path,\
    \ &pathValue)\n        }\n        path.removeLast()\n        pathValue -= grid[i][j]\n\
    \        visited[i][j] = false\n    }\n    for i in 0..<n {\n        for j in\
    \ 0..<n {\n            var path = [Int]()\n            var pathValue = 0\n   \
    \         dfs(i, j, &path, &pathValue)\n        }\n    }\n    return minPath",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n            visited[i][j] = true\n            path.append(grid[i][j])\n\
    \            sum += grid[i][j]\n            if dfs(grid: grid, i: i, j: j, k:\
    \ k, path: &path, sum: &sum, visited: &visited, minPath: &minPath, minSum: &minSum)\
    \ {\n                return minPath\n            }\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j\
    \ in 0..<n {\n            var path = [Int]()\n            var sum = 0\n      \
    \      var paths = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n          \
    \      minSum = sum\n                minPaths = paths\n            }\n       \
    \ }\n    }\n    minPaths.sort { (a, b) -> Bool in\n        for i in 0..<a.count\
    \ {\n            if a[i] < b[i] {\n                return true\n            }\
    \ else if a[i] > b[i] {\n                return false\n            }\n       \
    \ }\n        return false\n    }\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    for i in 0..<n {\n \
    \       for j in 0..<n {\n            let path = findPath(grid: grid, i: i, j:\
    \ j, k: k)\n            if path.count == k {\n                let sum = path.reduce(0,\
    \ +)\n                if sum < minSum {\n                    minSum = sum\n  \
    \                  minPath = path\n                }\n            }\n        }\n\
    \    }\n    return minPath", "    let n = grid.count\n    var dp = Array(repeating:\
    \ Array(repeating: (Int.max, [Int]()), count: n), count: n)\n    for i in 0..<n\
    \ {\n        for j in 0..<n {\n            dp[i][j] = (grid[i][j], [grid[i][j]])\n\
    \        }\n    }\n    for _ in 1..<k {\n        var newDp = Array(repeating:\
    \ Array(repeating: (Int.max, [Int]()), count: n), count: n)\n        for i in\
    \ 0..<n {\n            for j in 0..<n {\n                if i > 0 {\n        \
    \            let (val, path) = dp[i - 1][j]\n                    if val < newDp[i][j].0\
    \ {\n                        newDp[i][j] = (val, path + [grid[i][j]])\n      \
    \              } else if val == newDp[i][j].0 {\n                        newDp[i][j]\
    \ = (val, min(path + [grid[i][j]], newDp[i][j].1))\n                    }\n  \
    \              }\n                if i < n - 1 {\n                    let (val,\
    \ path) = dp[i + 1][j]\n                    if val < newDp[i][j].0 {\n       \
    \                 newDp[i][j] = (val, path + [grid[i][j]])\n                 \
    \   } else if val == newDp[i][j].0 {\n                        newDp[i][j] = (val,\
    \ min(path + [grid[i][j]], newDp[i][j].1))\n                    }\n          \
    \      }\n                if j > 0 {\n                    let (val, path) = dp[i][j\
    \ - 1]\n                    if val < newDp[i][j].0 {\n                       \
    \ newDp[i][j] = (val, path + [grid[i][j]])\n                    } else if val\
    \ == newDp[i][j].0 {\n                        newDp[i][j] = (val, min(path + [grid[i][j]",
  "    var grid = grid\n    var result = [Int]()\n    var min = Int.max\n    var minPath\
    \ = [Int]()\n    var path = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: grid.count), count: grid.count)\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid.count {\n            path.append(grid[i][j])\n    \
    \        visited[i][j] = true\n            dfs(grid: &grid, i: i, j: j, k: k,\
    \ path: &path, visited: &visited, min: &min, minPath: &minPath)\n            path.removeLast()\n\
    \            visited[i][j] = false\n        }\n    }\n    return minPath", " \
    \   let n = grid.count\n    var grid = grid\n    var res = [Int]()\n    for _\
    \ in 0..<k {\n        var min = Int.max\n        var minRow = 0\n        var minCol\
    \ = 0\n        for i in 0..<n {\n            for j in 0..<n {\n              \
    \  if grid[i][j] < min {\n                    min = grid[i][j]\n             \
    \       minRow = i\n                    minCol = j\n                }\n      \
    \      }\n        }\n        res.append(min)\n        grid[minRow][minCol] = Int.max\n\
    \    }\n    return res", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    for i in 0..<n {\n      \
    \  for j in 0..<n {\n            visited[i][j] = true\n            var path =\
    \ [Int]()\n            path.append(grid[i][j])\n            var sum = grid[i][j]\n\
    \            findPath(grid: grid, i: i, j: j, k: k, visited: &visited, path: &path,\
    \ sum: &sum, minPaths: &minPaths, minSum: &minSum)\n            visited[i][j]\
    \ = false\n        }\n    }\n    minPaths.sort()\n    return minPaths[0]", " \
    \   let n = grid.count\n    var dp = Array(repeating: Array(repeating: Int.max,\
    \ count: n), count: n)\n    var minPath = [Int]()\n    for i in 0..<n {\n    \
    \    for j in 0..<n {\n            if i == 0 && j == 0 {\n                dp[i][j]\
    \ = grid[i][j]\n            } else if i == 0 {\n                dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j]\n            } else if j == 0 {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j]\n            } else {\n                dp[i][j]\
    \ = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n            }\n        }\n \
    \   }\n    var i = n - 1\n    var j = n - 1\n    while k > 0 {\n        minPath.append(grid[i][j])\n\
    \        if i == 0 {\n            j -= 1\n        } else if j == 0 {\n       \
    \     i -= 1\n        } else {\n            if dp[i - 1][j] < dp[i][j - 1] {\n\
    \                i -= 1\n            } else {\n                j -= 1\n      \
    \      }\n        }\n        k -= 1\n    }\n    return minPath", "    // Write\
    \ your code here\n    return []", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j:\
    \ j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPaths = paths\n        \
    \    }\n        }\n    }\n    for path in minPaths {\n        if path.count ==\
    \ k {\n            minPath = path\n            break\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j\
    \ in 0..<n {\n            var path = [Int]()\n            var sum = 0\n      \
    \      var paths = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path:\
    \ &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n          \
    \      minSum = sum\n                minPaths = paths\n            }\n       \
    \ }\n    }\n    minPaths.sort()\n    minPath = minPaths[0]\n    return minPath",
  "    let n = grid.count\n    var visited = Array(repeating: Array(repeating: false,\
    \ count: n), count: n)\n    var minPath = Array(repeating: 0, count: k)\n    var\
    \ minPathValue = Int.max\n    var minPathFound = false\n    func dfs(row: Int,\
    \ col: Int, path: [Int], pathValue: Int) {\n        if row < 0 || row >= n ||\
    \ col < 0 || col >= n || visited[row][col] {\n            return\n        }\n\
    \        if path.count == k {\n            if pathValue < minPathValue {\n   \
    \             minPath = path\n                minPathValue = pathValue\n     \
    \           minPathFound = true\n            } else if pathValue == minPathValue\
    \ && path < minPath {\n                minPath = path\n            }\n       \
    \     return\n        }\n        visited[row][col] = true\n        dfs(row: row\
    \ - 1, col: col, path: path + [grid[row][col]], pathValue: pathValue * n + grid[row][col])\n\
    \        dfs(row: row + 1, col: col, path: path + [grid[row][col]], pathValue:\
    \ pathValue * n + grid[row][col])\n        dfs(row: row, col: col - 1, path: path\
    \ + [grid[row][col]], pathValue: pathValue * n + grid[row][col])\n        dfs(row:\
    \ row, col: col + 1, path: path + [grid[row][col]], pathValue: pathValue * n +\
    \ grid[row][col])\n        visited[row][col] = false\n    }\n    for row in 0..<n\
    \ {\n        for col in 0..<n {\n            dfs(row: row, col: col, path: [],\
    \ pathValue: 0)\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    var path = Array(repeating: Array(repeating: [Int](), count: n), count: n)\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n\
    \            path[i][j] = [grid[i][j]]\n        }\n    }\n    for _ in 1..<k {\n\
    \        var newDp = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        var newPath = Array(repeating: Array(repeating: [Int](), count:\
    \ n), count: n)\n        for i in 0..<n {\n            for j in 0..<n {\n    \
    \            if i > 0 && dp[i - 1][j] < dp[i][j] {\n                    newDp[i][j]\
    \ = dp[i - 1][j]\n                    newPath[i][j] = path[i - 1][j]\n       \
    \         } else if i > 0 && dp[i - 1][j] == dp[i][j] {\n                    if\
    \ path[i - 1][j] < path[i][j] {\n                        newDp[i][j] = dp[i -\
    \ 1][j]\n                        newPath[i][j] = path[i - 1][j]\n            \
    \        } else {\n                        newDp[i][j] = dp[i][j]\n          \
    \              newPath[i][j] = path[i][j]\n                    }\n           \
    \     } else {\n                    newDp[i][j] = dp[i][j]\n                 \
    \   newPath[i][j] = path[i][j]\n                }\n                if j > 0 &&\
    \ dp[i][j - 1] < newDp[i][j] {\n                    newDp[i][j] = dp[i][j - 1]\n\
    \                    newPath[i][j] = path[i][j - 1]\n                } else if\
    \ j > 0 &&", '    return []', "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            minPathHelper(grid: grid,\
    \ i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum\
    \ < minSum {\n                minSum = sum\n                minPaths = paths\n\
    \            }\n        }\n    }\n    for path in minPaths {\n        if path.count\
    \ == k {\n            minPath = path\n            break\n        }\n    }\n  \
    \  return minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var\
    \ minSum = Int.max\n    for i in 0..<n {\n        for j in 0..<n {\n         \
    \   var sum = 0\n            var path = [Int]()\n            var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n            dfs(grid: grid, i:\
    \ i, j: j, k: k, sum: &sum, path: &path, visited: &visited)\n            if sum\
    \ < minSum {\n                minSum = sum\n                minPath = path\n \
    \           }\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var minPath = Array(repeating: 0, count: k)\n    var minPathSum = Int.max\n\
    \    var visited = Array(repeating: Array(repeating: false, count: n), count:\
    \ n)\n    var path = Array(repeating: 0, count: k)\n    var pathSum = 0\n    var\
    \ pathLength = 0\n    var row = 0\n    var col = 0\n    var i = 0\n    var j =\
    \ 0\n    var d = 0\n    var nextRow = 0\n    var nextCol = 0\n    var nextPathSum\
    \ = 0\n    var nextPathLength = 0\n    var nextPath = Array(repeating: 0, count:\
    \ k)\n    var nextVisited = Array(repeating: Array(repeating: false, count: n),\
    \ count: n)\n    var queue = Queue<(row: Int, col: Int, pathSum: Int, pathLength:\
    \ Int, path: [Int], visited: [[Bool]])>()\n    queue.enqueue((row: 0, col: 0,\
    \ pathSum: 0, pathLength: 0, path: [], visited: visited))\n    while !queue.isEmpty\
    \ {\n        (row, col, pathSum, pathLength, path, visited) = queue.dequeue()!\n\
    \        if pathLength == k {\n            if pathSum < minPathSum {\n       \
    \         minPathSum = pathSum\n                minPath = path\n            }\n\
    \            continue\n        }\n        for d in 0..<4 {\n            nextRow\
    \ = row + rowOffset[d]\n            nextCol = col + colOffset[d]\n           \
    \ if nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || visited[nextRow][nextCol]\
    \ {\n                continue\n            }\n            nextPathSum = pathSum\
    \ + grid[nextRow][nextCol]\n            nextPathLength = pathLength + 1\n    \
    \        nextPath = path\n            nextPath.append(grid[nextRow][nextCol])\n\
    \            nextVisited = visited\n            nextVisited[nextRow][nextCol]\
    \ = true\n            queue.enqueue((row: nextRow, col: nextCol, pathSum: nextPathSum,\
    \ pathLength: nextPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPathSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var minPathsSum = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var path = [Int]()\n    var pathSum = 0\n \
    \   var paths = [[Int]]()\n    var pathsSum = [Int]()\n    func dfs(_ i: Int,\
    \ _ j: Int, _ k: Int) {\n        if k == 0 {\n            if pathSum < minPathSum\
    \ {\n                minPath = path\n                minPathSum = pathSum\n  \
    \          } else if pathSum == minPathSum {\n                minPaths.append(path)\n\
    \                minPathsSum.append(pathSum)\n            }\n            return\n\
    \        }\n        if i < 0 || i >= n || j < 0 || j >= n || visited[i][j] {\n\
    \            return\n        }\n        visited[i][j] = true\n        path.append(grid[i][j])\n\
    \        pathSum += grid[i][j]\n        dfs(i - 1, j, k - 1)\n        dfs(i +\
    \ 1, j, k - 1)\n        dfs(i, j - 1, k - 1)\n        dfs(i, j + 1, k - 1)\n \
    \       visited[i][j] = false\n        path.removeLast()\n        pathSum -= grid[i][j]\n\
    \    }\n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(i, j,\
    \ k)\n        }\n    }\n    if minPaths.count == 0 {\n        return minPath\n\
    \    }\n    for i in 0..<minPaths.count {\n        if minPathsSum[i] < minSum\
    \ {\n            minPath = minPaths[i]\n            minSum = minPathsSum[i]\n\
    \        } else if minPathsSum[i] == minSum {\n            paths.append(minPaths[i])\n",
  "    let n = grid.count\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, visited: &visited, path:\
    \ &path, sum: &sum, i: i, j: j, k: k)\n            if sum < minSum {\n       \
    \         minSum = sum\n                minPath = path\n            }\n      \
    \  }\n    }\n    return minPath", "    let n = grid.count\n    var dp = Array(repeating:\
    \ Array(repeating: Int.max, count: n), count: n)\n    var prev = Array(repeating:\
    \ Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            dp[i][j] = grid[i][j]\n            prev[i][j] = -1\n\
    \        }\n    }\n    for _ in 1..<k {\n        var newDp = Array(repeating:\
    \ Array(repeating: Int.max, count: n), count: n)\n        var newPrev = Array(repeating:\
    \ Array(repeating: 0, count: n), count: n)\n        for i in 0..<n {\n       \
    \     for j in 0..<n {\n                if i > 0 && dp[i - 1][j] < dp[i][j] {\n\
    \                    newDp[i][j] = dp[i - 1][j]\n                    newPrev[i][j]\
    \ = 0\n                } else {\n                    newDp[i][j] = dp[i][j]\n\
    \                    newPrev[i][j] = prev[i][j]\n                }\n         \
    \       if j > 0 && dp[i][j - 1] < newDp[i][j] {\n                    newDp[i][j]\
    \ = dp[i][j - 1]\n                    newPrev[i][j] = 1\n                }\n \
    \               if i < n - 1 && dp[i + 1][j] < newDp[i][j] {\n               \
    \     newDp[i][j] = dp[i + 1][j]\n                    newPrev[i][j] = 2\n    \
    \            }\n                if j < n - 1 && dp[i][j + 1] < newDp[i][j] {\n\
    \                    newDp[i][j] = dp[i][j + 1]\n                    newPrev[i][j]\
    \ = 3\n                }\n            }\n        }\n        dp = newDp\n     \
    \   prev = newPrev\n    }\n    var ans = [Int]", "    let n = grid.count\n   \
    \ var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = Array(repeating: Array(repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            visited[i][j]\
    \ = true\n            var path = [Int]()\n            path.append(grid[i][j])\n\
    \            dfs(grid: grid, i: i, j: j, k: k, visited: &visited, path: &path,\
    \ minPaths: &minPaths, minSum: &minSum)\n            visited[i][j] = false\n \
    \       }\n    }\n    minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = Array(repeating: Array(repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            minPath = [Int]()\n\
    \            visited = Array(repeating: Array(repeating: false, count: n), count:\
    \ n)\n            dfs(grid: grid, i: i, j: j, k: k, visited: &visited, path: &minPath,\
    \ sum: &minSum, paths: &minPaths)\n        }\n    }\n    return minPaths.sorted()[0]",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minPathSum = Int.max\n\
    \    var minPathGrid = [[Int]]()\n    for i in 0..<n {\n        minPathGrid.append(Array(repeating:\
    \ 0, count: n))\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       if i == 0 && j == 0 {\n                minPathGrid[i][j] = grid[i][j]\n\
    \            } else if i == 0 {\n                minPathGrid[i][j] = minPathGrid[i][j\
    \ - 1] + grid[i][j]\n            } else if j == 0 {\n                minPathGrid[i][j]\
    \ = minPathGrid[i - 1][j] + grid[i][j]\n            } else {\n               \
    \ minPathGrid[i][j] = min(minPathGrid[i - 1][j], minPathGrid[i][j - 1]) + grid[i][j]\n\
    \            }\n        }\n    }\n    for i in 0..<n {\n        for j in 0..<n\
    \ {\n            if minPathGrid[i][j] <= minPathSum {\n                minPathSum\
    \ = minPathGrid[i][j]\n            }\n        }\n    }\n    var i = n - 1\n  \
    \  var j = n - 1\n    while k > 0 {\n        minPath.append(grid[i][j])\n    \
    \    if i == 0 && j == 0 {\n            break\n        } else if i == 0 {\n  \
    \          j -= 1\n        } else if j == 0 {\n            i -= 1\n        } else\
    \ {\n            if minPathGrid[i - 1][j] < minPathGrid[i][j - 1] {\n        \
    \        i -= 1\n            } else {\n                j -= 1\n            }\n\
    \        }\n        k -= 1\n    }\n    return minPath", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    for i in 0..<n {\n \
    \       for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum)\n\
    \            if sum < minSum {\n                minSum = sum\n               \
    \ minPath = path\n            }\n        }\n    }\n    return minPath", "    let\
    \ n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var\
    \ minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       var path = [Int]()\n            var sum = 0\n            var paths = [[Int]]()\n\
    \            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, paths:\
    \ &paths)\n            if sum < minSum {\n                minSum = sum\n     \
    \           minPaths = paths\n            }\n        }\n    }\n    for path in\
    \ minPaths {\n        if path.count == k {\n            minPath = path\n     \
    \       break\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    var prev = Array(repeating: Array(repeating: [Int](), count: n), count: n)\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n\
    \            prev[i][j] = [grid[i][j]]\n        }\n    }\n    for _ in 1..<k {\n\
    \        var newDp = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        var newPrev = Array(repeating: Array(repeating: [Int](), count:\
    \ n), count: n)\n        for i in 0..<n {\n            for j in 0..<n {\n    \
    \            if i > 0 && dp[i - 1][j] < dp[i][j] {\n                    newDp[i][j]\
    \ = dp[i - 1][j]\n                    newPrev[i][j] = prev[i - 1][j]\n       \
    \         } else if i > 0 && dp[i - 1][j] == dp[i][j] {\n                    newDp[i][j]\
    \ = dp[i - 1][j]\n                    newPrev[i][j] = min(prev[i - 1][j], prev[i][j])\n\
    \                } else {\n                    newDp[i][j] = dp[i][j]\n      \
    \              newPrev[i][j] = prev[i][j]\n                }\n               \
    \ if j > 0 && dp[i][j - 1] < newDp[i][j] {\n                    newDp[i][j] =\
    \ dp[i][j - 1]\n                    newPrev[i][j] = prev[i][j - 1]\n         \
    \       } else if j > 0 && dp[i][j - 1] == newDp[i][j] {\n                   \
    \ newDp[i][j] = dp[i][j - 1]\n                    newPrev[i][j] = min(prev[",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            var paths\
    \ = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum:\
    \ &sum, paths: &paths)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = paths\n            }\n        }\n    }\n \
    \   for path in minPaths {\n        if path.count == k {\n            minPath\
    \ = path\n            break\n        }\n    }\n    return minPath", "    var grid\
    \ = grid\n    var result = [Int]()\n    var minValue = Int.max\n    var minPath\
    \ = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count:\
    \ grid.count), count: grid.count)\n    var queue = [(Int, Int)]()\n    queue.append((0,\
    \ 0))\n    visited[0][0] = true\n    while !queue.isEmpty {\n        let (i, j)\
    \ = queue.removeFirst()\n        if i == grid.count - 1 && j == grid.count - 1\
    \ {\n            if result.count == k {\n                if result < minPath {\n\
    \                    minPath = result\n                }\n            }\n    \
    \        result.removeLast()\n            visited[i][j] = false\n            continue\n\
    \        }\n        result.append(grid[i][j])\n        if result.count == k {\n\
    \            if result < minPath {\n                minPath = result\n       \
    \     }\n            result.removeLast()\n            visited[i][j] = false\n\
    \            continue\n        }\n        if i > 0 && !visited[i - 1][j] {\n \
    \           queue.append((i - 1, j))\n            visited[i - 1][j] = true\n \
    \       }\n        if i < grid.count - 1 && !visited[i + 1][j] {\n           \
    \ queue.append((i + 1, j))\n            visited[i + 1][j] = true\n        }\n\
    \        if j > 0 && !visited[i][j - 1] {\n            queue.append((i, j - 1))\n\
    \            visited[i][j - 1] = true\n        }\n        if j < grid.count -\
    \ 1 && !visited[i][j + 1] {\n            queue.append((i, j + 1))\n          \
    \  visited[i][j + 1] = true\n        }\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var sum = 0\n            var paths = [[Int]]()\n\
    \            dfs(grid: grid, i: i, j: j, k: k, path: &path, sum: &sum, paths:\
    \ &paths)\n            if sum < minSum {\n                minSum = sum\n     \
    \           minPaths = paths\n            }\n        }\n    }\n    var minPathsSorted\
    \ = minPaths.sorted { (a, b) -> Bool in\n        for i in 0..<a.count {\n    \
    \        if a[i] < b[i] {\n                return true\n            } else if\
    \ a[i] > b[i] {\n                return false\n            }\n        }\n    \
    \    return false\n    }\n    return minPathsSorted[0]", "    let n = grid.count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n\
    \        }\n    }\n    for _ in 1..<k {\n        var newDp = Array(repeating:\
    \ Array(repeating: Int.max, count: n), count: n)\n        for i in 0..<n {\n \
    \           for j in 0..<n {\n                if i > 0 {\n                   \
    \ newDp[i][j] = min(newDp[i][j], dp[i - 1][j])\n                }\n          \
    \      if i < n - 1 {\n                    newDp[i][j] = min(newDp[i][j], dp[i\
    \ + 1][j])\n                }\n                if j > 0 {\n                  \
    \  newDp[i][j] = min(newDp[i][j], dp[i][j - 1])\n                }\n         \
    \       if j < n - 1 {\n                    newDp[i][j] = min(newDp[i][j], dp[i][j\
    \ + 1])\n                }\n            }\n        }\n        dp = newDp\n   \
    \ }\n    var ans = [Int]()\n    for i in 0..<n {\n        for j in 0..<n {\n \
    \           ans.append(dp[i][j])\n        }\n    }\n    return ans.sorted()",
  "    let n = grid.count\n    var dp = Array(repeating: Array(repeating: Int.max,\
    \ count: n), count: n)\n    var path = Array(repeating: Array(repeating: [Int](),\
    \ count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       dp[i][j] = grid[i][j]\n            path[i][j] = [grid[i][j]]\n       \
    \ }\n    }\n    for _ in 1..<k {\n        var newDp = Array(repeating: Array(repeating:\
    \ Int.max, count: n), count: n)\n        var newPath = Array(repeating: Array(repeating:\
    \ [Int](), count: n), count: n)\n        for i in 0..<n {\n            for j in\
    \ 0..<n {\n                if i > 0 {\n                    if dp[i - 1][j] < dp[i][j]\
    \ {\n                        newDp[i][j] = dp[i - 1][j]\n                    \
    \    newPath[i][j] = path[i - 1][j]\n                    } else if dp[i - 1][j]\
    \ == dp[i][j] {\n                        if path[i - 1][j] < path[i][j] {\n  \
    \                          newDp[i][j] = dp[i - 1][j]\n                      \
    \      newPath[i][j] = path[i - 1][j]\n                        } else {\n    \
    \                        newDp[i][j] = dp[i][j]\n                            newPath[i][j]\
    \ = path[i][j]\n                        }\n                    } else {\n    \
    \                    newDp[i][j] = dp[i][j]\n                        newPath[i][j]\
    \ = path[i][j]\n                    }\n                }\n                if j\
    \ > 0 {\n                    if dp[i][j - 1] < newDp[i][j] {\n               \
    \         newDp[i][j] = dp[i][j - 1]\n                        newPath[i][j] =\
    \ path[i][j - 1]", "    let n = grid.count\n    var minPath = [Int]()\n    var\
    \ minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n     \
    \   for j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n\
    \            var paths = [[Int]]()\n            var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n            visited[i][j] = true\n\
    \            path.append(grid[i][j])\n            sum += grid[i][j]\n        \
    \    paths.append([i, j])\n            dfs(grid: grid, i: i, j: j, k: k, visited:\
    \ &visited, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPath = path\n          \
    \      minPaths = paths\n            } else if sum == minSum {\n             \
    \   if path < minPath {\n                    minPath = path\n                \
    \    minPaths = paths\n                }\n            }\n        }\n    }\n  \
    \  print(minPaths)\n    return minPath", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i\
    \ in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n     \
    \       var sum = 0\n            var paths = [[Int]]()\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPaths =\
    \ paths\n            }\n        }\n    }\n    for path in minPaths {\n       \
    \ if path.count == k {\n            return path\n        }\n    }\n    return\
    \ minPath", "    // TODO: Implement\n    return []", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    for i in 0..<n {\n \
    \       for j in 0..<n {\n            let path = minPath(grid: grid, k: k, i:\
    \ i, j: j, sum: 0)\n            if path.count == k {\n                let sum\
    \ = path.reduce(0, +)\n                if sum < minSum {\n                   \
    \ minSum = sum\n                    minPath = path\n                }\n      \
    \      }\n        }\n    }\n    return minPath", "    let n = grid.count\n   \
    \ var minPath: [Int] = []\n    var minSum = Int.max\n    for i in 0..<n {\n  \
    \      for j in 0..<n {\n            let path = findMinPath(grid: grid, i: i,\
    \ j: j, k: k)\n            let sum = path.reduce(0, +)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPath = path\n          \
    \  }\n        }\n    }\n    return minPath", "    let n = grid.count\n    let\
    \ m = grid[0].count\n    var dp = Array(repeating: Array(repeating: Int.max, count:\
    \ k + 1), count: n * m)\n    var path = Array(repeating: Array(repeating: [Int](),\
    \ count: k + 1), count: n * m)\n    for i in 0..<n {\n        for j in 0..<m {\n\
    \            dp[i * m + j][1] = grid[i][j]\n            path[i * m + j][1] = [grid[i][j]]\n\
    \        }\n    }\n    for i in 2...k {\n        for j in 0..<n {\n          \
    \  for l in 0..<m {\n                for p in 0..<n {\n                    for\
    \ q in 0..<m {\n                        if abs(j - p) + abs(l - q) == 1 {\n  \
    \                          let tmp = dp[p * m + q][i - 1] * 10 + grid[j][l]\n\
    \                            if tmp < dp[j * m + l][i] {\n                   \
    \             dp[j * m + l][i] = tmp\n                                path[j *\
    \ m + l][i] = path[p * m + q][i - 1] + [grid[j][l]]\n                        \
    \    }\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    var ans = [Int]()\n    var min = Int.max\n\
    \    for i in 0..<n {\n        for j in 0..<m {\n            if dp[i * m + j][k]\
    \ < min {\n                min = dp[i * m + j][k]\n                ans = path[i\
    \ * m + j][k]\n            }\n        }\n    }\n    return ans", "    let n =\
    \ grid.count\n    var minPath = [Int]()\n    var minPathSum = Int.max\n    var\
    \ minPaths = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var path = [Int]()\n    var pathSum = 0\n \
    \   var pathSums = [Int]()\n    var i = 0\n    var j = 0\n    var dfs = { (i:\
    \ Int, j: Int) in\n        if path.count == k {\n            if pathSum < minPathSum\
    \ {\n                minPathSum = pathSum\n                minPaths = [[Int]]()\n\
    \                minPaths.append(path)\n            } else if pathSum == minPathSum\
    \ {\n                minPaths.append(path)\n            }\n            return\n\
    \        }\n        if i > 0 && !visited[i - 1][j] {\n            path.append(grid[i\
    \ - 1][j])\n            pathSum += grid[i - 1][j]\n            pathSums.append(pathSum)\n\
    \            visited[i - 1][j] = true\n            dfs(i - 1, j)\n           \
    \ visited[i - 1][j] = false\n            path.removeLast()\n            pathSum\
    \ = pathSums.removeLast()\n        }\n        if i < n - 1 && !visited[i + 1][j]\
    \ {\n            path.append(grid[i + 1][j])\n            pathSum += grid[i +\
    \ 1][j]\n            pathSums.append(pathSum)\n            visited[i + 1][j] =\
    \ true\n            dfs(i + 1, j)\n            visited[i + 1][j] = false\n   \
    \         path.removeLast()\n            pathSum = pathSums.removeLast()\n   \
    \     }\n        if j > 0 && !visited[i][j - 1] {\n            path.append(grid[i][j\
    \ - 1])\n            pathSum += grid[i][j - 1]\n            pathSums.append(pathSum)\n\
    \            visited[i][j - 1] = true\n            dfs(i, j - 1)\n           ",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            var paths\
    \ = [[Int]]()\n            findPath(grid: grid, i: i, j: j, k: k, path: &path,\
    \ sum: &sum, paths: &paths)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = paths\n            }\n        }\n    }\n \
    \   minPaths.sort()\n    minPath = minPaths[0]\n    return minPath", "    let\
    \ n = grid.count\n    var visited = [[Bool]](repeating: [Bool](repeating: false,\
    \ count: n), count: n)\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, visited: &visited, path: &path, sum: &sum)\n       \
    \     if sum < minSum {\n                minSum = sum\n                minPaths\
    \ = [[Int]]()\n                minPaths.append(path)\n            } else if sum\
    \ == minSum {\n                minPaths.append(path)\n            }\n        }\n\
    \    }\n    minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathGrid\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var pathSum = 0\n            var pathGrid = [[Int]]()\n\
    \            for _ in 0..<k {\n                path.append(grid[i][j])\n     \
    \           pathSum += grid[i][j]\n                pathGrid.append([i, j])\n \
    \               if i > 0 {\n                    path.append(grid[i - 1][j])\n\
    \                    pathSum += grid[i - 1][j]\n                    pathGrid.append([i\
    \ - 1, j])\n                }\n                if i < n - 1 {\n              \
    \      path.append(grid[i + 1][j])\n                    pathSum += grid[i + 1][j]\n\
    \                    pathGrid.append([i + 1, j])\n                }\n        \
    \        if j > 0 {\n                    path.append(grid[i][j - 1])\n       \
    \             pathSum += grid[i][j - 1]\n                    pathGrid.append([i,\
    \ j - 1])\n                }\n                if j < n - 1 {\n               \
    \     path.append(grid[i][j + 1])\n                    pathSum += grid[i][j +\
    \ 1]\n                    pathGrid.append([i, j + 1])\n                }\n   \
    \         }\n            if pathSum < minPathSum {\n                minPath =\
    \ path\n                minPathSum = pathSum\n                minPathGrid = pathGrid\n\
    \            }\n        }\n    }\n    return minPath", "    var grid = grid\n\
    \    var result = [Int]()\n    var min = Int.max\n    var minPath = [Int]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: grid.count),\
    \ count: grid.count)\n    var queue = Queue<(Int, Int)>()\n    var path = [Int]()\n\
    \    var pathLength = 0\n    var i = 0\n    var j = 0\n    while i < grid.count\
    \ {\n        while j < grid.count {\n            queue.enqueue((i, j))\n     \
    \       while !queue.isEmpty {\n                let current = queue.dequeue()!\n\
    \                if !visited[current.0][current.1] {\n                    visited[current.0][current.1]\
    \ = true\n                    path.append(grid[current.0][current.1])\n      \
    \              pathLength += 1\n                    if pathLength == k {\n   \
    \                     if path < minPath {\n                            minPath\
    \ = path\n                        }\n                        path.removeLast()\n\
    \                        pathLength -= 1\n                        visited[current.0][current.1]\
    \ = false\n                        continue\n                    }\n         \
    \           if current.0 > 0 && !visited[current.0 - 1][current.1] {\n       \
    \                 queue.enqueue((current.0 - 1, current.1))\n                \
    \    }\n                    if current.0 < grid.count - 1 && !visited[current.0\
    \ + 1][current.1] {\n                        queue.enqueue((current.0 + 1, current.1))\n\
    \                    }\n                    if current.1 > 0 && !visited[current.0][current.1\
    \ - 1] {\n                        queue.enqueue((current.0, current.1 - 1))\n\
    \                    }\n                    if current.1 < grid.count - 1 && !visited[current.0][current.1\
    \ + 1] {\n                        queue.enqueue((current.0, current.1 + 1))\n\
    \                    }\n                    path.removeLast()\n              \
    \      pathLength -= 1\n                    visited[current.0][current.1] = false\n\
    \                }\n            }\n            j += 1\n        }\n        i +=\
    \ 1\n    }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    for i in 0..<n {\n      \
    \  for j in 0..<n {\n            minPath.append(grid[i][j])\n            visited[i][j]\
    \ = true\n            dfs(grid: grid, i: i, j: j, k: k, visited: &visited, sum:\
    \ grid[i][j], path: &minPath, paths: &minPaths, minSum: &minSum)\n           \
    \ visited[i][j] = false\n            minPath.removeLast()\n        }\n    }\n\
    \    return minPaths.sorted()[0]", "    let n = grid.count\n    var minPath =\
    \ [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited\
    \ = Array(repeating: Array(repeating: false, count: n), count: n)\n    for i in\
    \ 0..<n {\n        for j in 0..<n {\n            minPath.append(grid[i][j])\n\
    \            visited[i][j] = true\n            dfs(grid: grid, i: i, j: j, k:\
    \ k, visited: &visited, minPath: &minPath, minSum: &minSum, minPaths: &minPaths)\n\
    \            visited[i][j] = false\n            minPath.removeLast()\n       \
    \ }\n    }\n    return minPaths.sorted()[0]", "    let n = grid.count\n    var\
    \ minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            var paths = [[Int]]()\n            findMinPath(grid:\
    \ grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPath = path\n\
    \                minPaths = paths\n            } else if sum == minSum {\n   \
    \             if path < minPath {\n                    minPath = path\n      \
    \              minPaths = paths\n                } else if path == minPath {\n\
    \                    minPaths.append(contentsOf: paths)\n                }\n \
    \           }\n        }\n    }\n    print(minPaths)\n    return minPath", " \
    \   var grid = grid\n    var result = [Int]()\n    var min = Int.max\n    var\
    \ minPath = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false,\
    \ count: grid.count), count: grid.count)\n    for i in 0..<grid.count {\n    \
    \    for j in 0..<grid.count {\n            visited[i][j] = true\n           \
    \ dfs(&grid, &visited, &result, i, j, k, &min, &minPath)\n            visited[i][j]\
    \ = false\n        }\n    }\n    return minPath", "    // TODO: Implement\n  \
    \  return []", "    let n = grid.count\n    var visited = Array(repeating: Array(repeating:\
    \ false, count: n), count: n)\n    var minPath = Array(repeating: Array(repeating:\
    \ Int.max, count: n), count: n)\n    var minPathValues = [[Int]]()\n    var minPathSum\
    \ = Int.max\n    var minPathLength = Int.max\n    var minPaths = [[Int]]()\n \
    \   var minPathsValues = [[Int]]()\n    var minPathsLength = Int.max\n    var\
    \ minPathsSum = Int.max\n    var minPathsCount = 0\n    var minPathsCountSum =\
    \ Int.max\n    var minPathsCountLength = Int.max\n    var minPathsCountValues\
    \ = [[Int]]()\n    var minPathsCountSumValues = [[Int]]()\n    var minPathsCountLengthValues\
    \ = [[Int]]()\n    var minPathsCountSumLengthValues = [[Int]]()\n    var minPathsCountSumLength\
    \ = Int.max\n    var minPathsCountSumLengthCount = Int.max\n    var minPathsCountSumLengthCountValues\
    \ = [[Int]]()\n    var minPathsCountSumLengthCountSum = Int.max\n    var minPathsCountSumLengthCountSumValues\
    \ = [[Int]]()\n    var minPathsCountSumLengthCountSumLength = Int.max\n    var\
    \ minPathsCountSumLengthCountSumLengthValues = [[Int]]()\n    var minPathsCountSumLengthCountSumLengthCount\
    \ = Int.max\n    var minPathsCountSumLengthCountSumLengthCountValues = [[Int]]()\n\
    \    var minPathsCountSumLengthCountSumLengthCountSum = Int.max\n    var minPathsCountSumLengthCountSumLengthCountSumValues\
    \ = [[Int]]()\n    var minPathsCountSumLengthCountSumLengthCountSumLength = Int.max\n\
    \    var minPathsCountSumLengthCountSumLengthCountSumLengthValues = [[Int]]()\n\
    \    var minPathsCountSumLengthCountSumLengthCountSumLengthCount = Int.max\n \
    \   var minPathsCountSumLengthCountSumLengthCountSumLengthCountValues = [[Int]]()\n\
    \    var minPathsCountSumLengthCountSumLengthCountSumLengthCountSum = Int.max",
  "    let n = grid.count\n    var visited = Array(repeating: Array(repeating: false,\
    \ count: n), count: n)\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    var path = [Int]()\n    var sum = 0\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            dfs(grid: grid, n: n, i:\
    \ i, j: j, k: k, visited: &visited, path: &path, sum: &sum, minPaths: &minPaths,\
    \ minSum: &minSum)\n        }\n    }\n    minPaths.sort()\n    return minPaths[0]",
  "    var grid = grid\n    var result = [Int]()\n    var min = Int.max\n    var minPath\
    \ = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false, count:\
    \ grid.count), count: grid.count)\n    var queue = [(Int, Int)]()\n    queue.append((0,\
    \ 0))\n    visited[0][0] = true\n    while !queue.isEmpty {\n        let (row,\
    \ col) = queue.removeFirst()\n        result.append(grid[row][col])\n        if\
    \ result.count == k {\n            if result.lexicographicallyPrecedes(minPath)\
    \ {\n                minPath = result\n            }\n            result.removeLast()\n\
    \            continue\n        }\n        if row > 0 && !visited[row - 1][col]\
    \ {\n            queue.append((row - 1, col))\n            visited[row - 1][col]\
    \ = true\n        }\n        if row < grid.count - 1 && !visited[row + 1][col]\
    \ {\n            queue.append((row + 1, col))\n            visited[row + 1][col]\
    \ = true\n        }\n        if col > 0 && !visited[row][col - 1] {\n        \
    \    queue.append((row, col - 1))\n            visited[row][col - 1] = true\n\
    \        }\n        if col < grid.count - 1 && !visited[row][col + 1] {\n    \
    \        queue.append((row, col + 1))\n            visited[row][col + 1] = true\n\
    \        }\n    }\n    return minPath", "    let n = grid.count\n    let m = grid[0].count\n\
    \    var dp = Array(repeating: Array(repeating: Int.max, count: m), count: n)\n\
    \    var minPath = [Int]()\n    for i in 0..<n {\n        for j in 0..<m {\n \
    \           if i == 0 && j == 0 {\n                dp[i][j] = grid[i][j]\n   \
    \         } else if i == 0 {\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n\
    \            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n\
    \            } else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j -\
    \ 1]) + grid[i][j]\n            }\n        }\n    }\n    var i = n - 1\n    var\
    \ j = m - 1\n    while k > 0 {\n        minPath.append(grid[i][j])\n        if\
    \ i == 0 {\n            j -= 1\n        } else if j == 0 {\n            i -= 1\n\
    \        } else {\n            if dp[i - 1][j] < dp[i][j - 1] {\n            \
    \    i -= 1\n            } else {\n                j -= 1\n            }\n   \
    \     }\n        k -= 1\n    }\n    return minPath", "    // TODO: Write some\
    \ code to solve this coding problem\n    return []", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            var paths = [[Int]]()\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, path: &path, sum: &sum, paths: &paths)\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPaths =\
    \ paths\n            }\n        }\n    }\n    for path in minPaths {\n       \
    \ if path.count == k {\n            minPath = path\n            break\n      \
    \  }\n    }\n    return minPath", "    let n = grid.count\n    var grid = grid\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    var path = [Int]()\n    var sum = 0\n    var row = 0\n    var col =\
    \ 0\n    var dfs = { (row: Int, col: Int, sum: Int, path: [Int]) in\n        if\
    \ sum >= minSum {\n            return\n        }\n        if path.count == k {\n\
    \            if sum < minSum {\n                minSum = sum\n               \
    \ minPaths = [[Int]]()\n            }\n            minPaths.append(path)\n   \
    \         return\n        }\n        if row < 0 || row >= n || col < 0 || col\
    \ >= n || visited[row][col] {\n            return\n        }\n        visited[row][col]\
    \ = true\n        dfs(row: row - 1, col: col, sum: sum + grid[row][col], path:\
    \ path + [grid[row][col]])\n        dfs(row: row + 1, col: col, sum: sum + grid[row][col],\
    \ path: path + [grid[row][col]])\n        dfs(row: row, col: col - 1, sum: sum\
    \ + grid[row][col], path: path + [grid[row][col]])\n        dfs(row: row, col:\
    \ col + 1, sum: sum + grid[row][col], path: path + [grid[row][col]])\n       \
    \ visited[row][col] = false\n    }\n    for i in 0..<n {\n        for j in 0..<n\
    \ {\n            dfs(row: i, col: j, sum: 0, path: [])\n        }\n    }\n   \
    \ minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n    var visited\
    \ = Array(repeating: Array(repeating: false, count: n), count: n)\n    var minPath\
    \ = Array(repeating: 0, count: k)\n    var minPathValue = Int.max\n    var minPathIndex\
    \ = 0\n    var path = [Int]()\n    var pathValue = 0\n    var pathIndex = 0\n\
    \    var pathLength = 0\n    var i = 0\n    var j = 0\n    var x = 0\n    var\
    \ y = 0\n    var d = 0\n    var dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n  \
    \  var queue = [[Int]]()\n    queue.append([0, 0, 0])\n    visited[0][0] = true\n\
    \    while queue.count > 0 {\n        path = queue.removeFirst()\n        i =\
    \ path[0]\n        j = path[1]\n        pathLength = path[2]\n        pathValue\
    \ = grid[i][j]\n        pathIndex = pathLength\n        if pathLength == k - 1\
    \ {\n            if pathValue < minPathValue {\n                minPathValue =\
    \ pathValue\n                minPathIndex = pathIndex\n                minPath\
    \ = path\n            } else if pathValue == minPathValue {\n                if\
    \ pathIndex < minPathIndex {\n                    minPathIndex = pathIndex\n \
    \                   minPath = path\n                }\n            }\n       \
    \     continue\n        }\n        for d in 0..<4 {\n            x = i + dirs[d][0]\n\
    \            y = j + dirs[d][1]\n            if x >= 0 && x < n && y >= 0 && y\
    \ < n && !visited[x][y] {\n                visited[x][y] = true\n            \
    \    queue.append([x, y, pathLength + 1])\n            }\n        }\n    }\n \
    \   return minPath", "    let n = grid.count\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    var minPath = [Int]()\n \
    \   var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j:\
    \ j, k: k, path: &path, sum: &sum, paths: &paths, visited: &visited)\n       \
    \     if sum < minSum {\n                minSum = sum\n                minPath\
    \ = path\n                minPaths = paths\n            } else if sum == minSum\
    \ {\n                if path < minPath {\n                    minPath = path\n\
    \                    minPaths = paths\n                } else if path == minPath\
    \ {\n                    minPaths.append(contentsOf: paths)\n                }\n\
    \            }\n        }\n    }\n    print(minPaths)\n    return minPath", " \
    \   let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var sum = 0\n            var paths\
    \ = [[Int]]()\n            findPath(grid: grid, i: i, j: j, k: k, path: &path,\
    \ sum: &sum, paths: &paths)\n            if sum < minSum {\n                minSum\
    \ = sum\n                minPaths = paths\n            }\n        }\n    }\n \
    \   for path in minPaths {\n        if path.count == k {\n            minPath\
    \ = path\n            break\n        }\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    for i\
    \ in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n     \
    \       var sum = 0\n            var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n            visited[i][j] = true\n            path.append(grid[i][j])\n\
    \            sum += grid[i][j]\n            dfs(grid: grid, i: i, j: j, k: k,\
    \ path: &path, sum: &sum, visited: &visited, minPath: &minPath, minSum: &minSum)\n\
    \        }\n    }\n    return minPath", "    let n = grid.count\n    var dp =\
    \ Array(repeating: Array(repeating: Int.max, count: n), count: n)\n    var path\
    \ = Array(repeating: Array(repeating: [Int](), count: n), count: n)\n    for i\
    \ in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n  \
    \          path[i][j] = [grid[i][j]]\n        }\n    }\n    for _ in 1..<k {\n\
    \        var newDp = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        var newPath = Array(repeating: Array(repeating: [Int](), count:\
    \ n), count: n)\n        for i in 0..<n {\n            for j in 0..<n {\n    \
    \            if i > 0 {\n                    if dp[i - 1][j] < dp[i][j] {\n  \
    \                      newDp[i][j] = dp[i - 1][j]\n                        newPath[i][j]\
    \ = path[i - 1][j]\n                    } else if dp[i - 1][j] == dp[i][j] {\n\
    \                        if path[i - 1][j] < path[i][j] {\n                  \
    \          newDp[i][j] = dp[i - 1][j]\n                            newPath[i][j]\
    \ = path[i - 1][j]\n                        } else {\n                       \
    \     newDp[i][j] = dp[i][j]\n                            newPath[i][j] = path[i][j]\n\
    \                        }\n                    } else {\n                   \
    \     newDp[i][j] = dp[i][j]\n                        newPath[i][j] = path[i][j]\n\
    \                    }\n                }\n                if j > 0 {\n      \
    \              if dp[i][j - 1] < newDp[i][j] {\n                        newDp[i][j]\
    \ = dp[i][j - 1]\n                        newPath[i][j] = path[i][j - 1]", " \
    \   let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var path = [Int]()\n    var sum = 0\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            minPath.removeAll()\n  \
    \          minSum = Int.max\n            minPaths.removeAll()\n            visited\
    \ = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\n      \
    \      path.removeAll()\n            sum = 0\n            dfs(grid: grid, i: i,\
    \ j: j, k: k, minSum: &minSum, minPath: &minPath, minPaths: &minPaths, visited:\
    \ &visited, path: &path, sum: &sum)\n        }\n    }\n    return minPath", " \
    \   var minPath = [Int]()\n    var minPathSum = Int.max\n    var grid = grid\n\
    \    var k = k\n    var row = 0\n    var col = 0\n    while k > 0 {\n        minPath.append(grid[row][col])\n\
    \        grid[row][col] = Int.max\n        var min = Int.max\n        var minRow\
    \ = 0\n        var minCol = 0\n        if row > 0 && grid[row - 1][col] < min\
    \ {\n            min = grid[row - 1][col]\n            minRow = row - 1\n    \
    \        minCol = col\n        }\n        if row < grid.count - 1 && grid[row\
    \ + 1][col] < min {\n            min = grid[row + 1][col]\n            minRow\
    \ = row + 1\n            minCol = col\n        }\n        if col > 0 && grid[row][col\
    \ - 1] < min {\n            min = grid[row][col - 1]\n            minRow = row\n\
    \            minCol = col - 1\n        }\n        if col < grid[0].count - 1 &&\
    \ grid[row][col + 1] < min {\n            min = grid[row][col + 1]\n         \
    \   minRow = row\n            minCol = col + 1\n        }\n        row = minRow\n\
    \        col = minCol\n        k -= 1\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths\
    \ = [[Int]]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false,\
    \ count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       visited[i][j] = true\n            minPath.append(grid[i][j])\n       \
    \     dfs(grid: grid, i: i, j: j, k: k, minPath: &minPath, minSum: &minSum, minPaths:\
    \ &minPaths, visited: &visited)\n            visited[i][j] = false\n         \
    \   minPath.removeLast()\n        }\n    }\n    return minPaths.sorted()[0]",
  "    // TODO: Implement\n    return []", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited\
    \ = Array(repeating: Array(repeating: false, count: n), count: n)\n    for i in\
    \ 0..<n {\n        for j in 0..<n {\n            minPath.append(grid[i][j])\n\
    \            visited[i][j] = true\n            dfs(grid: grid, i: i, j: j, k:\
    \ k, n: n, visited: &visited, minPath: &minPath, minSum: &minSum, minPaths: &minPaths)\n\
    \            visited[i][j] = false\n            minPath.removeLast()\n       \
    \ }\n    }\n    return minPaths.sorted()[0]", "    let n = grid.count\n    var\
    \ minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathSet = Set<Int>()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    var dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    func dfs(_ i: Int,\
    \ _ j: Int, _ sum: Int, _ path: [Int]) {\n        if sum > minPathSum {\n    \
    \        return\n        }\n        if path.count == k {\n            if sum <\
    \ minPathSum {\n                minPathSum = sum\n                minPath = path\n\
    \                minPathSet = Set(path)\n            } else if sum == minPathSum\
    \ {\n                if path < minPath {\n                    minPath = path\n\
    \                    minPathSet = Set(path)\n                }\n            }\n\
    \            return\n        }\n        for dir in dirs {\n            let x =\
    \ i + dir[0]\n            let y = j + dir[1]\n            if x >= 0 && x < n &&\
    \ y >= 0 && y < n && !visited[x][y] {\n                visited[x][y] = true\n\
    \                dfs(x, y, sum + grid[x][y], path + [grid[x][y]])\n          \
    \      visited[x][y] = false\n            }\n        }\n    }\n    for i in 0..<n\
    \ {\n        for j in 0..<n {\n            visited[i][j] = true\n            dfs(i,\
    \ j, grid[i][j], [grid[i][j]])\n            visited[i][j] = false\n        }\n\
    \    }\n    return minPath", "    let n = grid.count\n    let m = grid[0].count\n\
    \    var visited = Array(repeating: Array(repeating: false, count: m), count:\
    \ n)\n    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths =\
    \ [[Int]]()\n    var paths = [[Int]]()\n    var sums = [Int]()\n    var path =\
    \ [Int]()\n    var sum = 0\n    for i in 0..<n {\n        for j in 0..<m {\n \
    \           path.append(grid[i][j])\n            sum += grid[i][j]\n         \
    \   visited[i][j] = true\n            dfs(grid: grid, i: i, j: j, k: k, visited:\
    \ &visited, path: &path, sum: &sum, paths: &paths, sums: &sums)\n            visited[i][j]\
    \ = false\n            path.removeLast()\n            sum -= grid[i][j]\n    \
    \    }\n    }\n    for i in 0..<sums.count {\n        if sums[i] < minSum {\n\
    \            minSum = sums[i]\n            minPaths = [paths[i]]\n        } else\
    \ if sums[i] == minSum {\n            minPaths.append(paths[i])\n        }\n \
    \   }\n    minPaths.sort()\n    return minPaths[0]", "    var grid = grid\n  \
    \  var result = [Int]()\n    var min = Int.max\n    var minPath = [Int]()\n  \
    \  var visited = [[Bool]](repeating: [Bool](repeating: false, count: grid.count),\
    \ count: grid.count)\n    var queue = [(Int, Int)]()\n    queue.append((0, 0))\n\
    \    visited[0][0] = true\n    while !queue.isEmpty {\n        let (row, col)\
    \ = queue.removeFirst()\n        result.append(grid[row][col])\n        if result.count\
    \ == k {\n            let value = result.reduce(0, { $0 * 10 + $1 })\n       \
    \     if value < min {\n                min = value\n                minPath =\
    \ result\n            }\n            result.removeLast()\n            continue\n\
    \        }\n        if row > 0 && !visited[row - 1][col] {\n            queue.append((row\
    \ - 1, col))\n            visited[row - 1][col] = true\n        }\n        if\
    \ row < grid.count - 1 && !visited[row + 1][col] {\n            queue.append((row\
    \ + 1, col))\n            visited[row + 1][col] = true\n        }\n        if\
    \ col > 0 && !visited[row][col - 1] {\n            queue.append((row, col - 1))\n\
    \            visited[row][col - 1] = true\n        }\n        if col < grid.count\
    \ - 1 && !visited[row][col + 1] {\n            queue.append((row, col + 1))\n\
    \            visited[row][col + 1] = true\n        }\n        result.removeLast()\n\
    \    }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    for i in 0..<n {\n      \
    \  for j in 0..<n {\n            visited[i][j] = true\n            minPath.append(grid[i][j])\n\
    \            dfs(grid: grid, i: i, j: j, k: k, visited: &visited, minPath: &minPath,\
    \ minSum: &minSum, minPaths: &minPaths)\n            visited[i][j] = false\n \
    \           minPath.removeLast()\n        }\n    }\n    return minPaths.sorted()[0]",
  "    let n = grid.count\n    let m = grid[0].count\n    var dp = [[[Int]]](repeating:\
    \ [[Int]](repeating: [Int](repeating: Int.max, count: k + 1), count: n), count:\
    \ m)\n    var path = [[[Int]]](repeating: [[Int]](repeating: [Int](repeating:\
    \ 0, count: k + 1), count: n), count: m)\n    for i in 0..<n {\n        for j\
    \ in 0..<m {\n            dp[i][j][1] = grid[i][j]\n            path[i][j][1]\
    \ = grid[i][j]\n        }\n    }\n    for l in 2...k {\n        for i in 0..<n\
    \ {\n            for j in 0..<m {\n                for d in 0..<4 {\n        \
    \            let ni = i + dx[d]\n                    let nj = j + dy[d]\n    \
    \                if ni >= 0 && ni < n && nj >= 0 && nj < m {\n               \
    \         if dp[ni][nj][l - 1] < dp[i][j][l] {\n                            dp[i][j][l]\
    \ = dp[ni][nj][l - 1]\n                            path[i][j][l] = path[ni][nj][l\
    \ - 1]\n                        } else if dp[ni][nj][l - 1] == dp[i][j][l] {\n\
    \                            path[i][j][l] = min(path[i][j][l], path[ni][nj][l\
    \ - 1])\n                        }\n                    }\n                }\n\
    \                dp[i][j][l] += grid[i][j]\n                path[i][j][l] = min(path[i][j][l],\
    \ grid[i][j])\n            }\n        }\n    }\n    var ans = [Int](repeating:\
    \ Int.max, count: k)\n    for i in 0..<n {\n        for j in 0..<m {\n       \
    \     if dp[i][j][k] < ans[k - 1] {\n                ans = path[", "    let n\
    \ = grid.count\n    var dp = Array(repeating: Array(repeating: Array(repeating:\
    \ Int.max, count: n), count: n), count: k + 1)\n    for i in 0..<n {\n       \
    \ for j in 0..<n {\n            dp[1][i][j] = grid[i][j]\n        }\n    }\n \
    \   for l in 2...k {\n        for i in 0..<n {\n            for j in 0..<n {\n\
    \                for x in 0..<n {\n                    for y in 0..<n {\n    \
    \                    if abs(x - i) + abs(y - j) == 1 {\n                     \
    \       dp[l][i][j] = min(dp[l][i][j], dp[l - 1][x][y])\n                    \
    \    }\n                    }\n                }\n            }\n        }\n \
    \   }\n    var ans = Int.max\n    var x = 0\n    var y = 0\n    for i in 0..<n\
    \ {\n        for j in 0..<n {\n            if dp[k][i][j] < ans {\n          \
    \      ans = dp[k][i][j]\n                x = i\n                y = j\n     \
    \       }\n        }\n    }\n    var res = [Int]()\n    res.append(ans)\n    for\
    \ l in (1..<k).reversed() {\n        for i in 0..<n {\n            for j in 0..<n\
    \ {\n                if abs(i - x) + abs(j - y) == 1 && dp[l][i][j] + grid[x][y]\
    \ == dp[l + 1][x][y] {\n                    res.append(grid[x][y])\n         \
    \           x = i\n                    y = j\n                    break\n    \
    \            }\n            }\n        }\n    }\n    res.append(grid[x][y])\n\
    \    return res.reversed()", "    guard k >= 1 else { return [] }\n    guard k\
    \ <= grid.count * grid.count else { return [] }\n    guard grid.count >= 2 else\
    \ { return [] }\n    guard grid.count == grid[0].count else { return [] }\n  \
    \  var result = [Int]()\n    var visited = Set<Int>()\n    var queue = [(Int,\
    \ Int, [Int])]()\n    let n = grid.count\n    let start = (0, 0)\n    queue.append((start.0,\
    \ start.1, [grid[start.0][start.1]]))\n    visited.insert(start.0 * n + start.1)\n\
    \    while !queue.isEmpty {\n        let (i, j, path) = queue.removeFirst()\n\
    \        if path.count == k {\n            if result.isEmpty || path < result\
    \ {\n                result = path\n            }\n            continue\n    \
    \    }\n        for (di, dj) in [(0, 1), (0, -1), (1, 0), (-1, 0)] {\n       \
    \     let ni = i + di\n            let nj = j + dj\n            if ni < 0 || ni\
    \ >= n || nj < 0 || nj >= n {\n                continue\n            }\n     \
    \       let nidx = ni * n + nj\n            if visited.contains(nidx) {\n    \
    \            continue\n            }\n            visited.insert(nidx)\n     \
    \       queue.append((ni, nj, path + [grid[ni][nj]]))\n        }\n    }\n    return\
    \ result", "    let n = grid.count\n    var minPath = [Int]()\n    var minPathSum\
    \ = Int.max\n    var minPathGrid = [[Int]]()\n    for i in 0..<n {\n        minPathGrid.append(Array(repeating:\
    \ 0, count: n))\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       if i == 0 && j == 0 {\n                minPathGrid[i][j] = grid[i][j]\n\
    \            } else if i == 0 {\n                minPathGrid[i][j] = minPathGrid[i][j\
    \ - 1] + grid[i][j]\n            } else if j == 0 {\n                minPathGrid[i][j]\
    \ = minPathGrid[i - 1][j] + grid[i][j]\n            } else {\n               \
    \ minPathGrid[i][j] = min(minPathGrid[i - 1][j], minPathGrid[i][j - 1]) + grid[i][j]\n\
    \            }\n        }\n    }\n    for i in 0..<n {\n        for j in 0..<n\
    \ {\n            if minPathGrid[i][j] < minPathSum {\n                minPathSum\
    \ = minPathGrid[i][j]\n            }\n        }\n    }\n    var i = n - 1\n  \
    \  var j = n - 1\n    while k > 0 {\n        if i == 0 && j == 0 {\n         \
    \   minPath.append(grid[i][j])\n            break\n        } else if i == 0 {\n\
    \            minPath.append(grid[i][j])\n            j -= 1\n        } else if\
    \ j == 0 {\n            minPath.append(grid[i][j])\n            i -= 1\n     \
    \   } else {\n            if minPathGrid[i - 1][j] < minPathGrid[i][j - 1] {\n\
    \                minPath.append(grid[i][j])\n                i -= 1\n        \
    \    } else {\n                minPath.append(grid[i][j])\n                j -=\
    \ 1\n            }\n        }\n        k -= 1\n    }\n    return minPath.reversed()",
  "    let n = grid.count\n    var result = [Int]()\n    var min = Int.max\n    var\
    \ minPath = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating: false,\
    \ count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n     \
    \       visited[i][j] = true\n            let path = [grid[i][j]]\n          \
    \  dfs(grid: grid, i: i, j: j, k: k, visited: &visited, path: path, min: &min,\
    \ minPath: &minPath)\n            visited[i][j] = false\n        }\n    }\n  \
    \  return minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var\
    \ minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n     \
    \   for j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n\
    \            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j: j, k:\
    \ k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n \
    \               minSum = sum\n                minPaths = paths\n            }\n\
    \        }\n    }\n    minPaths.sort()\n    minPath = minPaths[0]\n    return\
    \ minPath", "    let n = grid.count\n    var dp = [[Int]](repeating: [Int](repeating:\
    \ Int.max, count: n), count: n)\n    var prev = [[Int]](repeating: [Int](repeating:\
    \ -1, count: n), count: n)\n    var q = [(Int, Int)]()\n    var ans = [Int]()\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n\
    \            prev[i][j] = -1\n            q.append((i, j))\n        }\n    }\n\
    \    while !q.isEmpty {\n        let (i, j) = q.removeFirst()\n        if i >\
    \ 0 && dp[i - 1][j] > dp[i][j] {\n            dp[i - 1][j] = dp[i][j]\n      \
    \      prev[i - 1][j] = i * n + j\n            q.append((i - 1, j))\n        }\n\
    \        if i < n - 1 && dp[i + 1][j] > dp[i][j] {\n            dp[i + 1][j] =\
    \ dp[i][j]\n            prev[i + 1][j] = i * n + j\n            q.append((i +\
    \ 1, j))\n        }\n        if j > 0 && dp[i][j - 1] > dp[i][j] {\n         \
    \   dp[i][j - 1] = dp[i][j]\n            prev[i][j - 1] = i * n + j\n        \
    \    q.append((i, j - 1))\n        }\n        if j < n - 1 && dp[i][j + 1] > dp[i][j]\
    \ {\n            dp[i][j + 1] = dp[i][j]\n            prev[i][j + 1] = i * n +\
    \ j\n            q.append((i, j + 1))\n        }\n    }\n    var min = Int.max\n\
    \    var minI = -1\n    var minJ = -1\n    for i in 0..", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathGrid\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ gridCopy = grid\n            var path = [Int]()\n            var pathSum = 0\n\
    \            path.append(gridCopy[i][j])\n            pathSum += gridCopy[i][j]\n\
    \            gridCopy[i][j] = 0\n            var pathGrid = [[Int]]()\n      \
    \      for _ in 0..<n {\n                pathGrid.append(Array(repeating: 0, count:\
    \ n))\n            }\n            pathGrid[i][j] = 1\n            dfs(grid: &gridCopy,\
    \ i: i, j: j, path: &path, pathSum: &pathSum, pathGrid: &pathGrid, k: k)\n   \
    \         if pathSum < minPathSum {\n                minPathSum = pathSum\n  \
    \              minPath = path\n                minPathGrid = pathGrid\n      \
    \      }\n        }\n    }\n    printGrid(grid: minPathGrid)\n    return minPath",
  "    let n = grid.count\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    var minPath = [Int]()\n    var minSum = Int.max\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n\
    \            var sum = 0\n            dfs(grid: grid, visited: &visited, i: i,\
    \ j: j, k: k, path: &path, sum: &sum)\n            if sum < minSum {\n       \
    \         minSum = sum\n                minPath = path\n            }\n      \
    \  }\n    }\n    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minPathSum = Int.max\n    var minPathGrid = [[Int]]()\n    for i in 0..<n\
    \ {\n        minPathGrid.append(Array(repeating: 0, count: n))\n    }\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            var path = [Int]()\n   \
    \         var pathSum = 0\n            var pathGrid = [[Int]]()\n            for\
    \ i in 0..<n {\n                pathGrid.append(Array(repeating: 0, count: n))\n\
    \            }\n            path.append(grid[i][j])\n            pathSum += grid[i][j]\n\
    \            pathGrid[i][j] = 1\n            minPathHelper(grid: grid, i: i, j:\
    \ j, k: k, path: &path, pathSum: &pathSum, pathGrid: &pathGrid, minPath: &minPath,\
    \ minPathSum: &minPathSum, minPathGrid: &minPathGrid)\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minPathSum\
    \ = Int.max\n    for i in 0..<n {\n        for j in 0..<n {\n            var path\
    \ = [Int]()\n            var pathSum = 0\n            var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n            dfs(grid: grid, i:\
    \ i, j: j, k: k, path: &path, pathSum: &pathSum, visited: &visited)\n        \
    \    if pathSum < minPathSum {\n                minPathSum = pathSum\n       \
    \         minPath = path\n            }\n        }\n    }\n    return minPath",
  "    let n = grid.count\n    let m = grid[0].count\n    var dp = Array(repeating:\
    \ Array(repeating: Int.max, count: m), count: n)\n    var path = Array(repeating:\
    \ Array(repeating: [Int](), count: m), count: n)\n    for i in 0..<n {\n     \
    \   for j in 0..<m {\n            if i == 0 && j == 0 {\n                dp[i][j]\
    \ = grid[i][j]\n                path[i][j] = [grid[i][j]]\n            } else\
    \ if i == 0 {\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n        \
    \        path[i][j] = path[i][j - 1] + [grid[i][j]]\n            } else if j ==\
    \ 0 {\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n                path[i][j]\
    \ = path[i - 1][j] + [grid[i][j]]\n            } else {\n                if dp[i\
    \ - 1][j] < dp[i][j - 1] {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n\
    \                    path[i][j] = path[i - 1][j] + [grid[i][j]]\n            \
    \    } else if dp[i - 1][j] > dp[i][j - 1] {\n                    dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j]\n                    path[i][j] = path[i][j - 1] + [grid[i][j]]\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n\
    \                    path[i][j] = min(path[i - 1][j] + [grid[i][j]], path[i][j\
    \ - 1] + [grid[i][j]])\n                }\n            }\n        }\n    }\n \
    \   return path[n - 1][m - 1]", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    for i in 0..<n {\n        for j in 0..<n {\n  \
    \          let path = findMinPath(grid: grid, k: k, i: i, j: j, sum: 0, path:\
    \ [])\n            if path.count == k {\n                let sum = path.reduce(0,\
    \ +)\n                if sum < minSum {\n                    minSum = sum\n  \
    \                  minPath = path\n                }\n            }\n        }\n\
    \    }\n    return minPath", "    let n = grid.count\n    var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n    var minPath = [Int]()\n \
    \   var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            dfs(grid: grid, i: i, j: j, k: k, visited: &visited, path:\
    \ &path, sum: &sum)\n            if sum < minSum {\n                minSum = sum\n\
    \                minPaths = [[Int]]()\n                minPaths.append(path)\n\
    \            } else if sum == minSum {\n                minPaths.append(path)\n\
    \            }\n        }\n    }\n    minPaths.sort()\n    return minPaths[0]",
  "    let n = grid.count\n    let m = grid[0].count\n    var dp = Array(repeating:\
    \ Array(repeating: Int.max, count: m), count: n)\n    var pq = PriorityQueue<(Int,\
    \ Int, Int)>(ascending: true)\n    pq.enqueue((0, 0, 0))\n    while !pq.isEmpty\
    \ {\n        let (i, j, cost) = pq.dequeue()!\n        if i < 0 || i >= n || j\
    \ < 0 || j >= m {\n            continue\n        }\n        if dp[i][j] <= cost\
    \ {\n            continue\n        }\n        dp[i][j] = cost\n        if cost\
    \ == k {\n            break\n        }\n        pq.enqueue((i - 1, j, cost + 1))\n\
    \        pq.enqueue((i + 1, j, cost + 1))\n        pq.enqueue((i, j - 1, cost\
    \ + 1))\n        pq.enqueue((i, j + 1, cost + 1))\n    }\n    var res = [Int]()\n\
    \    var i = 0\n    var j = 0\n    for _ in 0..<k {\n        res.append(grid[i][j])\n\
    \        if i > 0 && dp[i - 1][j] == dp[i][j] - 1 {\n            i -= 1\n    \
    \    } else if i < n - 1 && dp[i + 1][j] == dp[i][j] - 1 {\n            i += 1\n\
    \        } else if j > 0 && dp[i][j - 1] == dp[i][j] - 1 {\n            j -= 1\n\
    \        } else if j < m - 1 && dp[i][j + 1] == dp[i][j] - 1 {\n            j\
    \ += 1\n        }\n    }\n    return res", "    let n = grid.count\n    var dp\
    \ = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n    var prev\
    \ = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n    for i\
    \ in 0..<n {\n        for j in 0..<n {\n            dp[i][j] = grid[i][j]\n  \
    \          prev[i][j] = -1\n        }\n    }\n    for _ in 1..<k {\n        var\
    \ newDp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n  \
    \      var newPrev = Array(repeating: Array(repeating: Int.max, count: n), count:\
    \ n)\n        for i in 0..<n {\n            for j in 0..<n {\n               \
    \ if i > 0 && dp[i - 1][j] < dp[i][j] {\n                    newDp[i][j] = dp[i\
    \ - 1][j]\n                    newPrev[i][j] = i - 1\n                } else {\n\
    \                    newDp[i][j] = dp[i][j]\n                    newPrev[i][j]\
    \ = i\n                }\n                if j > 0 && dp[i][j - 1] < newDp[i][j]\
    \ {\n                    newDp[i][j] = dp[i][j - 1]\n                    newPrev[i][j]\
    \ = j - 1\n                }\n                if i < n - 1 && dp[i + 1][j] < newDp[i][j]\
    \ {\n                    newDp[i][j] = dp[i + 1][j]\n                    newPrev[i][j]\
    \ = i + 1\n                }\n                if j < n - 1 && dp[i][j + 1] < newDp[i][j]\
    \ {\n                    newDp[i][j] = dp[i][j + 1]\n                    newPrev[i][j]\
    \ = j + 1\n                }\n            }\n        }\n        dp = newDp\n \
    \       prev = newPrev\n    }\n", "    // TODO: Implement\n    return []", " \
    \   // TODO: Write some code to solve this coding problem\n    return []", " \
    \   var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathSet =\
    \ Set<Int>()\n    var grid = grid\n    var k = k\n    var n = grid.count\n   \
    \ var m = grid[0].count\n    var visited = Array(repeating: Array(repeating: false,\
    \ count: m), count: n)\n    var path = [Int]()\n    var pathSum = 0\n    var pathSet\
    \ = Set<Int>()\n    var dfs = { (i: Int, j: Int) in\n        if k == 0 {\n   \
    \         if pathSum < minPathSum {\n                minPathSum = pathSum\n  \
    \              minPath = path\n                minPathSet = pathSet\n        \
    \    } else if pathSum == minPathSum {\n                if pathSet < minPathSet\
    \ {\n                    minPath = path\n                    minPathSet = pathSet\n\
    \                }\n            }\n            return\n        }\n        if i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j] {\n            return\n  \
    \      }\n        visited[i][j] = true\n        path.append(grid[i][j])\n    \
    \    pathSum += grid[i][j]\n        pathSet.insert(grid[i][j])\n        k -= 1\n\
    \        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n       \
    \ dfs(i, j + 1)\n        k += 1\n        path.removeLast()\n        pathSum -=\
    \ grid[i][j]\n        pathSet.remove(grid[i][j])\n        visited[i][j] = false\n\
    \    }\n    for i in 0..<n {\n        for j in 0..<m {\n            dfs(i, j)\n\
    \        }\n    }\n    return minPath", "    let n = grid.count\n    var minPath\
    \ = [Int]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var path\
    \ = [Int]()\n            path.append(grid[i][j])\n            var visited = [[Bool]](repeating:\
    \ [Bool](repeating: false, count: n), count: n)\n            visited[i][j] = true\n\
    \            dfs(grid: grid, visited: &visited, path: &path, i: i, j: j, k: k,\
    \ minPath: &minPath)\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            minPath.append(grid[i][j])\n\
    \            visited[i][j] = true\n            dfs(grid: grid, i: i, j: j, k:\
    \ k, visited: &visited, path: &minPath, sum: grid[i][j], minSum: &minSum, minPaths:\
    \ &minPaths)\n            visited[i][j] = false\n            minPath.removeLast()\n\
    \        }\n    }\n    return minPaths.sorted()[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathGrid\
    \ = [[Int]]()\n    for i in 0..<n {\n        minPathGrid.append(Array(repeating:\
    \ Int.max, count: n))\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            if i == 0 && j == 0 {\n                minPathGrid[i][j] = grid[i][j]\n\
    \            } else if i == 0 {\n                minPathGrid[i][j] = minPathGrid[i][j\
    \ - 1] + grid[i][j]\n            } else if j == 0 {\n                minPathGrid[i][j]\
    \ = minPathGrid[i - 1][j] + grid[i][j]\n            } else {\n               \
    \ minPathGrid[i][j] = min(minPathGrid[i - 1][j], minPathGrid[i][j - 1]) + grid[i][j]\n\
    \            }\n        }\n    }\n    for i in 0..<n {\n        for j in 0..<n\
    \ {\n            if minPathGrid[i][j] <= minPathSum {\n                minPathSum\
    \ = minPathGrid[i][j]\n            }\n        }\n    }\n    var i = n - 1\n  \
    \  var j = n - 1\n    while i >= 0 && j >= 0 {\n        minPath.append(grid[i][j])\n\
    \        if i == 0 && j == 0 {\n            break\n        } else if i == 0 {\n\
    \            j -= 1\n        } else if j == 0 {\n            i -= 1\n        }\
    \ else {\n            if minPathGrid[i - 1][j] < minPathGrid[i][j - 1] {\n   \
    \             i -= 1\n            } else {\n                j -= 1\n         \
    \   }\n        }\n    }\n    return Array(minPath.reversed())", "    var grid\
    \ = grid\n    var result = [Int]()\n    var min = Int.max\n    var minPath = [Int]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: grid.count),\
    \ count: grid.count)\n    for i in 0..<grid.count {\n        for j in 0..<grid.count\
    \ {\n            if grid[i][j] < min {\n                min = grid[i][j]\n   \
    \             minPath = [i, j]\n            }\n        }\n    }\n    result.append(grid[minPath[0]][minPath[1]])\n\
    \    visited[minPath[0]][minPath[1]] = true\n    var path = [minPath]\n    var\
    \ count = 1\n    while count < k {\n        var min = Int.max\n        var minPath\
    \ = [Int]()\n        for i in 0..<path.count {\n            let x = path[i][0]\n\
    \            let y = path[i][1]\n            if x > 0 && !visited[x - 1][y] &&\
    \ grid[x - 1][y] < min {\n                min = grid[x - 1][y]\n             \
    \   minPath = [x - 1, y]\n            }\n            if x < grid.count - 1 &&\
    \ !visited[x + 1][y] && grid[x + 1][y] < min {\n                min = grid[x +\
    \ 1][y]\n                minPath = [x + 1, y]\n            }\n            if y\
    \ > 0 && !visited[x][y - 1] && grid[x][y - 1] < min {\n                min = grid[x][y\
    \ - 1]\n                minPath = [x, y - 1]\n            }\n            if y\
    \ < grid.count - 1 && !visited[x][y + 1] && grid[x][y + 1] < min {\n         \
    \       min = grid[x][y + 1]\n                minPath = [x, y + 1]\n         \
    \   }\n        }\n        result.append(grid[minPath[0]][minPath[1]])\n      \
    \  visited[minPath[0]][minPath[1", "    let n = grid.count\n    var minPath =\
    \ [Int]()\n    var minPathSum = Int.max\n    var minPathSet = Set<Int>()\n   \
    \ var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    var path = [Int]()\n    var pathSum = 0\n    var pathSet = Set<Int>()\n\
    \    var dfs = DFS(grid: grid, n: n, k: k, minPath: &minPath, minPathSum: &minPathSum,\
    \ minPathSet: &minPathSet, visited: &visited, path: &path, pathSum: &pathSum,\
    \ pathSet: &pathSet)\n    dfs.run()\n    return minPath", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathGrid\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var pathSum = 0\n            var pathGrid = [[Int]]()\n\
    \            for _ in 0..<k {\n                path.append(grid[i][j])\n     \
    \           pathSum += grid[i][j]\n                pathGrid.append([i, j])\n \
    \               if i > 0 && j > 0 {\n                    if pathSum + grid[i -\
    \ 1][j - 1] < minPathSum {\n                        minPath = path\n         \
    \               minPathSum = pathSum + grid[i - 1][j - 1]\n                  \
    \      minPathGrid = pathGrid\n                    }\n                }\n    \
    \            if i > 0 && j < n - 1 {\n                    if pathSum + grid[i\
    \ - 1][j + 1] < minPathSum {\n                        minPath = path\n       \
    \                 minPathSum = pathSum + grid[i - 1][j + 1]\n                \
    \        minPathGrid = pathGrid\n                    }\n                }\n  \
    \              if i < n - 1 && j > 0 {\n                    if pathSum + grid[i\
    \ + 1][j - 1] < minPathSum {\n                        minPath = path\n       \
    \                 minPathSum = pathSum + grid[i + 1][j - 1]\n                \
    \        minPathGrid = pathGrid\n                    }\n                }\n  \
    \              if i < n - 1 && j < n - 1 {\n                    if pathSum + grid[i\
    \ + 1][j + 1] < minPathSum {\n                        minPath = path\n       \
    \                 minPathSum = pathSum + grid[i + 1][j + 1]\n                \
    \        minPathGrid = pathGrid\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return minPath", "    let n = grid.count\n\
    \    let m = grid[0].count\n    var visited = Array(repeating: Array(repeating:\
    \ false, count: m), count: n)\n    var minPath = Array(repeating: 0, count: k)\n\
    \    var minPathSum = Int.max\n    var minPathValues = [Int]()\n    func dfs(_\
    \ i: Int, _ j: Int, _ path: inout [Int], _ pathSum: inout Int, _ pathValues: inout\
    \ [Int], _ pathLength: Int) {\n        if pathLength == k {\n            if pathSum\
    \ < minPathSum {\n                minPathSum = pathSum\n                minPath\
    \ = path\n                minPathValues = pathValues\n            }\n        \
    \    return\n        }\n        if i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ {\n            return\n        }\n        visited[i][j] = true\n        path[pathLength]\
    \ = grid[i][j]\n        pathSum += grid[i][j]\n        pathValues.append(grid[i][j])\n\
    \        dfs(i - 1, j, &path, &pathSum, &pathValues, pathLength + 1)\n       \
    \ dfs(i + 1, j, &path, &pathSum, &pathValues, pathLength + 1)\n        dfs(i,\
    \ j - 1, &path, &pathSum, &pathValues, pathLength + 1)\n        dfs(i, j + 1,\
    \ &path, &pathSum, &pathValues, pathLength + 1)\n        visited[i][j] = false\n\
    \        pathSum -= grid[i][j]\n        pathValues.removeLast()\n    }\n    for\
    \ i in 0..<n {\n        for j in 0..<m {\n            var path = Array(repeating:\
    \ 0, count: k)\n            var pathSum = 0\n            var pathValues = [Int]()\n\
    \            dfs(i, j, &path, &pathSum, &pathValues, 0)\n        }\n    }\n  \
    \  return minPathValues", "    var grid = grid\n    var minPath = [Int]()\n  \
    \  var minSum = Int.max\n    var minPathSum = Int.max\n    var minPaths = [[Int]]()\n\
    \    var minPathsSum = [Int]()\n    var minPathsSumIndex = [Int]()\n    var minPathsSumIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndex = [Int]()\n    var minPathsSumIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndex = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndex = [Int]()\n\
    \    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex = [Int]()\n    var\
    \ minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex = [Int]()\n    var\
    \ minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = [Int]()\n  \
    \  var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = [Int]()\n\
    \    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [Int]()\n    var min", "    let n = grid.count\n    var minPath = [Int]()\n\
    \    var minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            var path = [Int]()\n            var sum\
    \ = 0\n            var paths = [[Int]]()\n            dfs(grid: grid, i: i, j:\
    \ j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPaths = paths\n        \
    \    }\n        }\n    }\n    minPaths.sort { (a, b) -> Bool in\n        for i\
    \ in 0..<a.count {\n            if a[i] < b[i] {\n                return true\n\
    \            } else if a[i] > b[i] {\n                return false\n         \
    \   }\n        }\n        return false\n    }\n    return minPaths[0]", "    let\
    \ n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n    var\
    \ minPaths = [[Int]]()\n    var grid = grid\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n    \
    \        var paths = [[Int]]()\n            findPath(grid: &grid, i: i, j: j,\
    \ k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum {\n\
    \                minSum = sum\n                minPath = path\n              \
    \  minPaths = paths\n            } else if sum == minSum {\n                if\
    \ path < minPath {\n                    minPath = path\n                    minPaths\
    \ = paths\n                } else if path == minPath {\n                    minPaths.append(contentsOf:\
    \ paths)\n                }\n            }\n        }\n    }\n    print(minPaths)\n\
    \    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n   \
    \ var minPathValue = Int.max\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            var path = [Int]()\n            var pathValue = 0\n            dfs(grid:\
    \ grid, i: i, j: j, k: k, path: &path, pathValue: &pathValue, visited: &visited)\n\
    \            if pathValue < minPathValue {\n                minPathValue = pathValue\n\
    \                minPath = path\n            }\n        }\n    }\n    return minPath",
  "    let n = grid.count\n    var minPath = Array(repeating: 0, count: k)\n    var\
    \ minPathSum = Int.max\n    var minPathIndex = 0\n    var minPaths = [[Int]]()\n\
    \    var visited = Array(repeating: Array(repeating: false, count: n), count:\
    \ n)\n    var path = Array(repeating: 0, count: k)\n    var pathIndex = 0\n  \
    \  var pathSum = 0\n    func dfs(row: Int, col: Int) {\n        if pathIndex ==\
    \ k {\n            if pathSum < minPathSum {\n                minPathSum = pathSum\n\
    \                minPath = path\n                minPathIndex = 0\n          \
    \      minPaths = [[Int]]()\n            }\n            if pathSum == minPathSum\
    \ {\n                minPaths.append(path)\n            }\n            return\n\
    \        }\n        for i in 0..<4 {\n            let nextRow = row + d[i][0]\n\
    \            let nextCol = col + d[i][1]\n            if nextRow >= 0 && nextRow\
    \ < n && nextCol >= 0 && nextCol < n && !visited[nextRow][nextCol] {\n       \
    \         visited[nextRow][nextCol] = true\n                path[pathIndex] =\
    \ grid[nextRow][nextCol]\n                pathIndex += 1\n                pathSum\
    \ += grid[nextRow][nextCol]\n                dfs(row: nextRow, col: nextCol)\n\
    \                pathIndex -= 1\n                pathSum -= grid[nextRow][nextCol]\n\
    \                visited[nextRow][nextCol] = false\n            }\n        }\n\
    \    }\n    for i in 0..<n {\n        for j in 0..<n {\n            visited[i][j]\
    \ = true\n            path[pathIndex] = grid[i][j]\n            pathIndex += 1\n\
    \            pathSum += grid[i][j]\n            dfs(row: i, col: j)\n        \
    \    pathIndex -= 1\n            pathSum -= grid[i][j]\n            visited[i][j]\
    \ = false\n        }\n    }\n    if minPaths.count > 1 {\n        for i in 1..<minPaths.count\
    \ {\n", "    var grid = grid\n    var result = [Int]()\n    var min = Int.max\n\
    \    var minPath = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: grid.count), count: grid.count)\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid.count {\n            dfs(&grid, &visited, &result,\
    \ i, j, k)\n            if result.count == k {\n                if result < minPath\
    \ {\n                    minPath = result\n                }\n            }\n\
    \            result.removeAll()\n        }\n    }\n    return minPath", "    let\
    \ n = grid.count\n    var dp = Array(repeating: Array(repeating: Int.max, count:\
    \ n), count: n)\n    var prev = Array(repeating: Array(repeating: -1, count: n),\
    \ count: n)\n    var q = [(Int, Int)]()\n    for i in 0..<n {\n        for j in\
    \ 0..<n {\n            dp[i][j] = grid[i][j]\n            prev[i][j] = -1\n  \
    \          q.append((i, j))\n        }\n    }\n    while !q.isEmpty {\n      \
    \  let (i, j) = q.removeFirst()\n        if i > 0 && dp[i - 1][j] > dp[i][j] {\n\
    \            dp[i - 1][j] = dp[i][j]\n            prev[i - 1][j] = i * n + j\n\
    \            q.append((i - 1, j))\n        }\n        if i < n - 1 && dp[i + 1][j]\
    \ > dp[i][j] {\n            dp[i + 1][j] = dp[i][j]\n            prev[i + 1][j]\
    \ = i * n + j\n            q.append((i + 1, j))\n        }\n        if j > 0 &&\
    \ dp[i][j - 1] > dp[i][j] {\n            dp[i][j - 1] = dp[i][j]\n           \
    \ prev[i][j - 1] = i * n + j\n            q.append((i, j - 1))\n        }\n  \
    \      if j < n - 1 && dp[i][j + 1] > dp[i][j] {\n            dp[i][j + 1] = dp[i][j]\n\
    \            prev[i][j + 1] = i * n + j\n            q.append((i, j + 1))\n  \
    \      }\n    }\n    var ans = [Int]()\n    var cur = 0\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            if dp[i][j] <", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathGrid\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var pathSum = 0\n            var pathGrid = [[Int]]()\n\
    \            var visited = [[Bool]]()\n            for _ in 0..<n {\n        \
    \        visited.append([Bool](repeating: false, count: n))\n            }\n \
    \           dfs(grid: grid, i: i, j: j, k: k, path: &path, pathSum: &pathSum,\
    \ pathGrid: &pathGrid, visited: &visited)\n            if pathSum < minPathSum\
    \ {\n                minPath = path\n                minPathSum = pathSum\n  \
    \              minPathGrid = pathGrid\n            }\n        }\n    }\n    print(minPathGrid)\n\
    \    return minPath", "    let n = grid.count\n    var minPath = [Int]()\n   \
    \ var minPathSum = Int.max\n    var minPathGrid = [[Int]]()\n    for i in 0..<n\
    \ {\n        for j in 0..<n {\n            var path = [Int]()\n            var\
    \ pathSum = 0\n            var pathGrid = [[Int]]()\n            for _ in 0..<k\
    \ {\n                path.append(grid[i][j])\n                pathSum += grid[i][j]\n\
    \                pathGrid.append([i, j])\n                if pathSum > minPathSum\
    \ {\n                    break\n                }\n                if path.count\
    \ == k {\n                    if pathSum < minPathSum {\n                    \
    \    minPath = path\n                        minPathSum = pathSum\n          \
    \              minPathGrid = pathGrid\n                    } else if pathSum ==\
    \ minPathSum {\n                        if path < minPath {\n                \
    \            minPath = path\n                            minPathSum = pathSum\n\
    \                            minPathGrid = pathGrid\n                        }\n\
    \                    }\n                }\n                var min = Int.max\n\
    \                var minI = -1\n                var minJ = -1\n              \
    \  if i > 0 {\n                    if grid[i - 1][j] < min {\n               \
    \         min = grid[i - 1][j]\n                        minI = i - 1\n       \
    \                 minJ = j\n                    }\n                }\n       \
    \         if i < n - 1 {\n                    if grid[i + 1][j] < min {\n    \
    \                    min = grid[i + 1][j]\n                        minI = i +\
    \ 1\n                        minJ = j\n                    }\n               \
    \ }\n                if j > 0 {\n                    if grid[i][j - 1] < min {\n\
    \                        min = grid[i][j - 1]\n                        minI =\
    \ i\n                        minJ = j - 1\n                    }\n           \
    \     }\n                if j < n - 1 {\n                    if grid[i][j + 1]\
    \ < min {\n                        min = grid[i][j + 1]\n                    \
    \    minI = i\n                        minJ = j + 1\n                    }\n \
    \               }\n                if minI == -1 {\n                    break\n\
    \                }\n                i = minI\n                j = minJ\n     \
    \       }\n       ", "    let n = grid.count\n    var minPath = [Int]()\n    var\
    \ minSum = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n     \
    \   for j in 0..<n {\n            var path = [Int]()\n            var sum = 0\n\
    \            var paths = [[Int]]()\n            minPathHelper(grid: grid, i: i,\
    \ j: j, k: k, path: &path, sum: &sum, paths: &paths)\n            if sum < minSum\
    \ {\n                minSum = sum\n                minPaths = paths\n        \
    \    }\n        }\n    }\n    for path in minPaths {\n        if path.count ==\
    \ k {\n            minPath = path\n            break\n        }\n    }\n    return\
    \ minPath", "    let n = grid.count\n    var minPath = [Int]()\n    var minSum\
    \ = Int.max\n    var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j\
    \ in 0..<n {\n            var path = [Int]()\n            var sum = 0\n      \
    \      var paths = [[Int]]()\n            findPath(grid: grid, i: i, j: j, k:\
    \ k, sum: &sum, path: &path, paths: &paths)\n            if sum < minSum {\n \
    \               minSum = sum\n                minPaths = paths\n            }\n\
    \        }\n    }\n    for path in minPaths {\n        if path.count == k {\n\
    \            minPath = path\n            break\n        }\n    }\n    return minPath",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            let path = findMinPath(grid: grid, i: i, j: j, k: k)\n          \
    \  let sum = path.reduce(0, +)\n            if sum < minSum {\n              \
    \  minSum = sum\n                minPaths = [path]\n            } else if sum\
    \ == minSum {\n                minPaths.append(path)\n            }\n        }\n\
    \    }\n    minPaths.sort()\n    return minPaths[0]", "    let n = grid.count\n\
    \    var minPath = [Int]()\n    var minPathSum = Int.max\n    var minPathGrid\
    \ = [[Int]]()\n    for i in 0..<n {\n        for j in 0..<n {\n            var\
    \ path = [Int]()\n            var pathSum = 0\n            var pathGrid = [[Int]]()\n\
    \            var pathGridRow = [Int]()\n            for _ in 0..<n {\n       \
    \         pathGridRow.append(0)\n            }\n            for _ in 0..<n {\n\
    \                pathGrid.append(pathGridRow)\n            }\n            pathGrid[i][j]\
    \ = 1\n            path.append(grid[i][j])\n            pathSum += grid[i][j]\n\
    \            if pathSum < minPathSum {\n                minPathSum = pathSum\n\
    \                minPath = path\n                minPathGrid = pathGrid\n    \
    \        }\n            for _ in 1..<k {\n                var minPathSumNext =\
    \ Int.max\n                var minPathNext = [Int]()\n                var minPathGridNext\
    \ = [[Int]]()\n                for x in 0..<n {\n                    for y in\
    \ 0..<n {\n                        if pathGrid[x][y] == 1 {\n                \
    \            if x > 0 && pathGrid[x - 1][y] == 0 {\n                         \
    \       var pathNext = path\n                                var pathSumNext =\
    \ pathSum\n                                var pathGridNext = pathGrid\n     \
    \                           pathNext.append(grid[x - 1][y])\n                \
    \                pathSumNext += grid[x - 1][y]\n                             \
    \   pathGridNext[x - 1][y] = 1\n                                if pathSumNext\
    \ < minPathSumNext {\n                                    minPathSumNext = pathSumNext\n\
    \                                    minPathNext = pathNext\n                \
    \                    minPathGridNext = pathGridNext\n                        \
    \        }\n                            }\n                            if x <\
    \ n - 1 && pathGrid[x + 1][y] == 0 {\n                                var pathNext\
    \ = path\n                                var pathSumNext = pathSum\n        \
    \                        var pathGridNext = pathGrid\n                       \
    \         pathNext.append(grid[x + 1][y])\n                                pathSumNext\
    \ += grid[x +", "    var grid = grid\n    var result = [Int]()\n    var min =\
    \ Int.max\n    var minPath = [Int]()\n    var visited = [[Bool]](repeating: [Bool](repeating:\
    \ false, count: grid.count), count: grid.count)\n    var queue = [(Int, Int)]()\n\
    \    queue.append((0, 0))\n    visited[0][0] = true\n    while !queue.isEmpty\
    \ {\n        let (i, j) = queue.removeFirst()\n        result.append(grid[i][j])\n\
    \        if result.count == k {\n            if result.lexicographicallyPrecedes(minPath)\
    \ {\n                minPath = result\n            }\n            result.removeLast()\n\
    \            continue\n        }\n        if i > 0 && !visited[i - 1][j] {\n \
    \           queue.append((i - 1, j))\n            visited[i - 1][j] = true\n \
    \       }\n        if i < grid.count - 1 && !visited[i + 1][j] {\n           \
    \ queue.append((i + 1, j))\n            visited[i + 1][j] = true\n        }\n\
    \        if j > 0 && !visited[i][j - 1] {\n            queue.append((i, j - 1))\n\
    \            visited[i][j - 1] = true\n        }\n        if j < grid.count -\
    \ 1 && !visited[i][j + 1] {\n            queue.append((i, j + 1))\n          \
    \  visited[i][j + 1] = true\n        }\n    }\n    return minPath", "    let n\
    \ = grid.count\n    var minPath: [Int] = []\n    var minSum = Int.max\n    var\
    \ minPaths: [[Int]] = []\n    var visited: [[Bool]] = Array(repeating: Array(repeating:\
    \ false, count: n), count: n)\n    func dfs(row: Int, col: Int, path: [Int], sum:\
    \ Int) {\n        if row < 0 || row >= n || col < 0 || col >= n || visited[row][col]\
    \ {\n            return\n        }\n        if path.count == k {\n           \
    \ if sum < minSum {\n                minSum = sum\n                minPaths =\
    \ [path]\n            } else if sum == minSum {\n                minPaths.append(path)\n\
    \            }\n            return\n        }\n        visited[row][col] = true\n\
    \        dfs(row: row - 1, col: col, path: path + [grid[row][col]], sum: sum +\
    \ grid[row][col])\n        dfs(row: row + 1, col: col, path: path + [grid[row][col]],\
    \ sum: sum + grid[row][col])\n        dfs(row: row, col: col - 1, path: path +\
    \ [grid[row][col]], sum: sum + grid[row][col])\n        dfs(row: row, col: col\
    \ + 1, path: path + [grid[row][col]], sum: sum + grid[row][col])\n        visited[row][col]\
    \ = false\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n           \
    \ dfs(row: i, col: j, path: [], sum: 0)\n        }\n    }\n    for path in minPaths\
    \ {\n        if minPath.isEmpty || path < minPath {\n            minPath = path\n\
    \        }\n    }\n    return minPath", "    let n = grid.count\n    var grid\
    \ = grid\n    var result = [Int]()\n    var min = Int.max\n    var minPath = [Int]()\n\
    \    var visited = [[Bool]](repeating: [Bool](repeating: false, count: n), count:\
    \ n)\n    for i in 0..<n {\n        for j in 0..<n {\n            visited[i][j]\
    \ = true\n            dfs(grid: &grid, i: i, j: j, k: k, visited: &visited, path:\
    \ [grid[i][j]], sum: grid[i][j])\n            visited[i][j] = false\n        }\n\
    \    }\n    return minPath", "    let n = grid.count\n    var dp = [[[Int]]](repeating:\
    \ [[Int]](repeating: [Int](repeating: Int.max, count: n), count: n), count: k\
    \ + 1)\n    for i in 0..<n {\n        for j in 0..<n {\n            dp[0][i][j]\
    \ = grid[i][j]\n        }\n    }\n    for i in 1...k {\n        for j in 0..<n\
    \ {\n            for l in 0..<n {\n                if j > 0 {\n              \
    \      dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j - 1][l])\n                }\n\
    \                if j < n - 1 {\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i - 1][j + 1][l])\n                }\n                if l > 0 {\n      \
    \              dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j][l - 1])\n         \
    \       }\n                if l < n - 1 {\n                    dp[i][j][l] = min(dp[i][j][l],\
    \ dp[i - 1][j][l + 1])\n                }\n            }\n        }\n    }\n \
    \   var ans = [Int]()\n    var i = k\n    var j = 0\n    var l = 0\n    while\
    \ i > 0 {\n        ans.append(dp[i][j][l])\n        if j > 0 && dp[i - 1][j -\
    \ 1][l] < dp[i - 1][j + 1][l] && dp[i - 1][j - 1][l] < dp[i - 1][j][l - 1] &&\
    \ dp[i - 1][j - 1][l] < dp[i - 1][j][l + 1] {\n            j -= 1\n        } else\
    \ if j < n - 1 && dp[i - 1][j + 1][l] < dp[i - 1][j - 1][l] && dp[i - 1][j + 1",
  "    let n = grid.count\n    var minPath = [Int]()\n    var minSum = Int.max\n \
    \   var minPaths = [[Int]]()\n    var visited = Array(repeating: Array(repeating:\
    \ false, count: n), count: n)\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            minPath.append(grid[i][j])\n            visited[i][j] = true\n  \
    \          dfs(grid: grid, i: i, j: j, k: k, visited: &visited, path: &minPath,\
    \ paths: &minPaths, sum: grid[i][j])\n            visited[i][j] = false\n    \
    \        minPath.removeLast()\n        }\n    }\n    return minPaths.min()!",
  "    var result = [Int]()\n    var grid = grid\n    var k = k\n    var i = 0\n \
    \   var j = 0\n    while k > 0 {\n        result.append(grid[i][j])\n        grid[i][j]\
    \ = 0\n        if i > 0 && grid[i - 1][j] > 0 {\n            i -= 1\n        }\
    \ else if j > 0 && grid[i][j - 1] > 0 {\n            j -= 1\n        } else if\
    \ i < grid.count - 1 && grid[i + 1][j] > 0 {\n            i += 1\n        } else\
    \ if j < grid[0].count - 1 && grid[i][j + 1] > 0 {\n            j += 1\n     \
    \   }\n        k -= 1\n    }\n    return result", "    let n = grid.count\n  \
    \  var dp = Array(repeating: Array(repeating: Int.max, count: n), count: n)\n\
    \    for i in 0..<n {\n        for j in 0..<n {\n            if i == 0 && j ==\
    \ 0 {\n                dp[i][j] = grid[i][j]\n            } else if i == 0 {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            } else if j\
    \ == 0 {\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n            }\
    \ else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\
    \            }\n        }\n    }\n    var res = [Int]()\n    var i = n - 1\n \
    \   var j = n - 1\n    while k > 0 {\n        if i == 0 && j == 0 {\n        \
    \    res.append(grid[i][j])\n            break\n        } else if i == 0 {\n \
    \           res.append(grid[i][j])\n            j -= 1\n        } else if j ==\
    \ 0 {\n            res.append(grid[i][j])\n            i -= 1\n        } else\
    \ {\n            if dp[i - 1][j] < dp[i][j - 1] {\n                res.append(grid[i][j])\n\
    \                i -= 1\n            } else {\n                res.append(grid[i][j])\n\
    \                j -= 1\n            }\n        }\n        k -= 1\n    }\n   \
    \ return res.reversed()", "    let n = grid.count\n    var dp = Array(repeating:\
    \ Array(repeating: Int.max, count: n), count: n)\n    var prev = Array(repeating:\
    \ Array(repeating: 0, count: n), count: n)\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            if i == 0 && j == 0 {\n                dp[i][j] =\
    \ grid[i][j]\n            } else if i == 0 {\n                dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j]\n                prev[i][j] = 1\n            } else if j ==\
    \ 0 {\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n                prev[i][j]\
    \ = 2\n            } else {\n                if dp[i - 1][j] < dp[i][j - 1] {\n\
    \                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                  \
    \  prev[i][j] = 2\n                } else {\n                    dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j]\n                    prev[i][j] = 1\n                }\n \
    \           }\n        }\n    }\n    var res = [Int]()\n    var i = n - 1\n  \
    \  var j = n - 1\n    while k > 0 {\n        res.append(grid[i][j])\n        if\
    \ prev[i][j] == 1 {\n            j -= 1\n        } else {\n            i -= 1\n\
    \        }\n        k -= 1\n    }\n    return res"]
stop_tokens:
- "\n}"
