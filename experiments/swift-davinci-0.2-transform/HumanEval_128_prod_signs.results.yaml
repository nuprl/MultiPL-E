language: swift
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var prod =\
    \ 1\n    var sum = 0\n    for i in arr {\n        prod *= i < 0 ? -1 : i == 0\
    \ ? 0 : 1\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var prod =\
    \ 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let mags = arr.map { abs($0) }\n    let sum = mags.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes\
    \ = arr.map { abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prodSigns = signs.reduce(1, *)\n    let sumMagnitudes = magnitudes.reduce(0,\
    \ +)\n    return prodSigns * sumMagnitudes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpx0x4q6an/tmpx0x4q6an.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c3810ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c37e01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c37e01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c37e007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx0x4q6an                        0x000055a84cb2b815 <unavailable> + 6165

    5    libc.so.6                          0x00002b0c382f6460 __libc_start_main +
    245

    6    tmpx0x4q6an                        0x000055a84cb2b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp48lx91wm/tmp48lx91wm.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb8179bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb81492b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb81492988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb814917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp48lx91wm                        0x0000564f4a7768a5 <unavailable> + 6309

    5    libc.so.6                          0x00002acb81987460 __libc_start_main +
    245

    6    tmp48lx91wm                        0x0000564f4a7762a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5ubqf4ts/tmp5ubqf4ts.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bcbb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bcb843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bcb843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bcb8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ubqf4ts                        0x0000559ddf016639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2bcbd38460 __libc_start_main +
    245

    6    tmp5ubqf4ts                        0x0000559ddf0161c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1\n        } else if i > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 >= 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n \
    \   let signProduct = signs.reduce(1, *)\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp90xt2y5q/tmp90xt2y5q.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf6d54fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf6d246b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf6d246988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf6d2457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp90xt2y5q                        0x00005590dadc77c5 <unavailable> + 6085

    5    libc.so.6                          0x00002aaf6d73b460 __libc_start_main +
    245

    6    tmp90xt2y5q                        0x00005590dadc71c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i / abs(i)\n        }\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpujis1t0l/tmpujis1t0l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0691cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06919c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06919c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06919c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujis1t0l                        0x00005632489f38a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b0691ebe460 __libc_start_main +
    245

    6    tmpujis1t0l                        0x00005632489f32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp4rmwvbzl/tmp4rmwvbzl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4b9bf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4b98eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4b98ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4b98e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rmwvbzl                        0x000055b6ac9298a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab4b9ddf460 __libc_start_main +
    245

    6    tmp4rmwvbzl                        0x000055b6ac9292a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign\
    \ = arr.map { $0 >= 0 ? 1 : -1 }.reduce(1, *)\n    let mag = arr.map { abs($0)\
    \ }.reduce(0, +)\n    return sign * mag\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpr4qq82k9/tmpr4qq82k9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8969ff1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8969ce8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8969ce8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8969ce77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr4qq82k9                        0x000055ad03f427c5 <unavailable> + 6085

    5    libc.so.6                          0x00002b896a1dd460 __libc_start_main +
    245

    6    tmpr4qq82k9                        0x000055ad03f421c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let product = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1g2m_538/tmp1g2m_538.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1g2m_538                        0x00005609d25cb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ba88f46a460 __libc_start_main +
    245

    6    tmp1g2m_538                        0x00005609d25cb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : (i > 0 ? 1 : 0)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i / abs(i)\n        }\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpujis1t0l/tmpujis1t0l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0691cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06919c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06919c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06919c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujis1t0l                        0x00005632489f38a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b0691ebe460 __libc_start_main +
    245

    6    tmpujis1t0l                        0x00005632489f32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0\
    \ + abs($1) }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp9tnkiwpi/tmp9tnkiwpi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d3f4d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d3f1d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d3f1d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d3f1cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9tnkiwpi                        0x000055a5493c9815 <unavailable> + 6165

    5    libc.so.6                          0x00002b7d3f6c5460 __libc_start_main +
    245

    6    tmp9tnkiwpi                        0x000055a5493c9219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let signProduct = signs.reduce(1, *)\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes\
    \ = arr.map { abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5ubqf4ts/tmp5ubqf4ts.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bcbb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bcb843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bcb843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bcb8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ubqf4ts                        0x0000559ddf016639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2bcbd38460 __libc_start_main +
    245

    6    tmp5ubqf4ts                        0x0000559ddf0161c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var prod = 1\n    for i in arr {\n  \
    \      if i > 0 {\n            sum += i\n            prod *= 1\n        } else\
    \ if i < 0 {\n            sum += abs(i)\n            prod *= -1\n        } else\
    \ {\n            prod *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpeb8t9gll/tmpeb8t9gll.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b806dbe4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b806d8dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b806d8db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b806d8da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeb8t9gll                        0x000055e47720ea5c <unavailable> + 6748

    5    libc.so.6                          0x00002b806ddd0460 __libc_start_main +
    245

    6    tmpeb8t9gll                        0x000055e47720e1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n        } else if num < 0 {\n            prod *= -1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiaonx8jz/tmpiaonx8jz.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3c13c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3c10bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3c10ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3c10b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaonx8jz                        0x000055aeae3ab8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ac3c15af460 __libc_start_main +
    245

    6    tmpiaonx8jz                        0x000055aeae3ab2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplkf12j_q/tmplkf12j_q.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57b6657c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57b634eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57b634e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57b634d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplkf12j_q                        0x000055b4f38be649 <unavailable> + 5705

    5    libc.so.6                          0x00002b57b6843460 __libc_start_main +
    245

    6    tmplkf12j_q                        0x000055b4f38be1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num == 0 {\n       \
    \     continue\n        }\n        sum += abs(num)\n        prod *= num > 0 ?\
    \ 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3rqf9bm_/tmp3rqf9bm_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7d07fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7d04f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7d04f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7d04f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rqf9bm_                        0x000055d7a1379815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab7d09e8460 __libc_start_main +
    245

    6    tmp3rqf9bm_                        0x000055d7a1379219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1g2m_538/tmp1g2m_538.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1g2m_538                        0x00005609d25cb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ba88f46a460 __libc_start_main +
    245

    6    tmp1g2m_538                        0x00005609d25cb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num < 0 ? -1 : num > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpuegarw32/tmpuegarw32.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7556478c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b755616fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b755616f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b755616e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuegarw32                        0x000056319cf8b639 <unavailable> + 5689

    5    libc.so.6                          0x00002b7556664460 __libc_start_main +
    245

    6    tmpuegarw32                        0x000056319cf8b1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var product = 1\n    for i in arr {\n        if i > 0 {\n         \
    \   product *= 1\n        } else if i < 0 {\n            product *= -1\n     \
    \   } else {\n            product *= 0\n        }\n        sum += abs(i)\n   \
    \ }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let mags = arr.map { abs($0) }\n    let sum = mags.reduce(0, +)\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0ccjz1x8/tmp0ccjz1x8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b18127b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b18124afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b18124af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b18124ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0ccjz1x8                        0x000055b9c3989815 <unavailable> + 6165

    5    libc.so.6                          0x00002b18129a4460 __libc_start_main +
    245

    6    tmp0ccjz1x8                        0x000055b9c3989219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prodSigns = signs.reduce(1, *)\n    let sumMagnitudes = magnitudes.reduce(0,\
    \ +)\n    return prodSigns * sumMagnitudes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for n in arr {\n        sum += abs(n)\n        prod\
    \ *= n > 0 ? 1 : n < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i / abs(i)\n        }\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpujis1t0l/tmpujis1t0l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0691cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06919c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06919c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06919c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujis1t0l                        0x00005632489f38a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b0691ebe460 __libc_start_main +
    245

    6    tmpujis1t0l                        0x00005632489f32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var prod = 1\n    for num in arr {\n\
    \        if num > 0 {\n            sum += num\n            prod *= 1\n       \
    \ } else if num < 0 {\n            sum += abs(num)\n            prod *= -1\n \
    \       } else {\n            prod *= 0\n        }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpf_ul6ek3/tmpf_ul6ek3.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e039e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e036dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e036db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e036da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf_ul6ek3                        0x0000556507742a5c <unavailable> + 6748

    5    libc.so.6                          0x00002b9e03bd0460 __libc_start_main +
    245

    6    tmpf_ul6ek3                        0x00005565077421c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    return arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpx0x4q6an/tmpx0x4q6an.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c3810ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c37e01b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c37e01988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c37e007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx0x4q6an                        0x000055a84cb2b815 <unavailable> + 6165

    5    libc.so.6                          0x00002b0c382f6460 __libc_start_main +
    245

    6    tmpx0x4q6an                        0x000055a84cb2b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitude = arr.map { abs($0)\
    \ }\n    let prod = sign.reduce(1, *)\n    let sum = magnitude.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= (num == 0 ? 1 : num > 0 ? 1 : -1)\n    }\n    return sum * prod\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6vno_14k/tmp6vno_14k.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6e3329c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6e3020b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6e3020988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6e301f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6vno_14k                        0x000055e673438815 <unavailable> + 6165

    5    libc.so.6                          0x00002ac6e3515460 __libc_start_main +
    245

    6    tmp6vno_14k                        0x000055e673438219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5ubqf4ts/tmp5ubqf4ts.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bcbb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bcb843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bcb843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bcb8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ubqf4ts                        0x0000559ddf016639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2bcbd38460 __libc_start_main +
    245

    6    tmp5ubqf4ts                        0x0000559ddf0161c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 < 0 ? -1 : 1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i == 0 {\n           \
    \ continue\n        }\n        sum += abs(i)\n        prod *= i > 0 ? 1 : -1\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp8pt5ldl8/tmp8pt5ldl8.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5b9c39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5b9930b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5b9930988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5b992f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8pt5ldl8                        0x000055cdd0948815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab5b9e25460 __libc_start_main +
    245

    6    tmp8pt5ldl8                        0x000055cdd0948219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let mags = arr.map { abs($0) }\n    let sum = mags.reduce(0, +)\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1g2m_538/tmp1g2m_538.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1g2m_538                        0x00005609d25cb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ba88f46a460 __libc_start_main +
    245

    6    tmp1g2m_538                        0x00005609d25cb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpdaiupz12/tmpdaiupz12.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add7f465c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add7f15cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add7f15c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add7f15b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdaiupz12                        0x00005652c0ac2815 <unavailable> + 6165

    5    libc.so.6                          0x00002add7f651460 __libc_start_main +
    245

    6    tmpdaiupz12                        0x00005652c0ac2219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let product = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1g2m_538/tmp1g2m_538.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1g2m_538                        0x00005609d25cb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ba88f46a460 __libc_start_main +
    245

    6    tmp1g2m_538                        0x00005609d25cb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    return arr.reduce(1)\
    \ { $0 * $1.signum() } * arr.reduce(0) { $0 + abs($1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n \
    \           prod *= 1\n        } else if i < 0 {\n            prod *= -1\n   \
    \     } else {\n            prod *= 0\n        }\n        sum += abs(i)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1g2m_538/tmp1g2m_538.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1g2m_538                        0x00005609d25cb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ba88f46a460 __libc_start_main +
    245

    6    tmp1g2m_538                        0x00005609d25cb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let signsProduct = signs.reduce(1, *)\n    let magnitudesSum\
    \ = magnitudes.reduce(0, +)\n    return signsProduct * magnitudesSum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 < 0 ? -1 : 1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppln6rj1m/tmppln6rj1m.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9746f00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9746bf7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9746bf7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9746bf67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppln6rj1m                        0x000055dffc421649 <unavailable> + 5705

    5    libc.so.6                          0x00002b97470ec460 __libc_start_main +
    245

    6    tmppln6rj1m                        0x000055dffc4211d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkdsma13r/tmpkdsma13r.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b8f27bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b8ef72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b8ef72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b8ef717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdsma13r                        0x0000556bbdbf03d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b4b8f467460 __libc_start_main +
    245

    6    tmpkdsma13r                        0x0000556bbdbeff69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let sign =\
    \ arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = sign.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiaonx8jz/tmpiaonx8jz.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3c13c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3c10bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3c10ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3c10b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaonx8jz                        0x000055aeae3ab8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ac3c15af460 __libc_start_main +
    245

    6    tmpiaonx8jz                        0x000055aeae3ab2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num < 0 ? -1 : 1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpl1ew37sm/tmpl1ew37sm.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0253b03c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02537fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02537fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02537f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1ew37sm                        0x000056170ff57815 <unavailable> + 6165

    5    libc.so.6                          0x00002b0253cef460 __libc_start_main +
    245

    6    tmpl1ew37sm                        0x000056170ff57219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0\
    \ + abs($1) }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5ubqf4ts/tmp5ubqf4ts.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bcbb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bcb843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bcb843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bcb8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ubqf4ts                        0x0000559ddf016639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2bcbd38460 __libc_start_main +
    245

    6    tmp5ubqf4ts                        0x0000559ddf0161c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpu4jnbw5b/tmpu4jnbw5b.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f7f57dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f7f274b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f7f274988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f7f2737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu4jnbw5b                        0x0000558269a52815 <unavailable> + 6165

    5    libc.so.6                          0x00002b0f7f769460 __libc_start_main +
    245

    6    tmpu4jnbw5b                        0x0000558269a52219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1g2m_538/tmp1g2m_538.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba88f27ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba88ef75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba88ef75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba88ef747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1g2m_538                        0x00005609d25cb8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ba88f46a460 __libc_start_main +
    245

    6    tmp1g2m_538                        0x00005609d25cb2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    return arr.reduce(1)\
    \ { $0 * $1.signum() } * arr.reduce(0) { $0 + abs($1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.map { abs($0)\
    \ }.reduce(0, +)\n    let product = signs.reduce(1, *)\n    return sum * product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplkf12j_q/tmplkf12j_q.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57b6657c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57b634eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57b634e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57b634d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplkf12j_q                        0x000055b4f38be649 <unavailable> + 5705

    5    libc.so.6                          0x00002b57b6843460 __libc_start_main +
    245

    6    tmplkf12j_q                        0x000055b4f38be1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = sign.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1\n        } else if i > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpuegarw32/tmpuegarw32.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7556478c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b755616fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b755616f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b755616e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuegarw32                        0x000056319cf8b639 <unavailable> + 5689

    5    libc.so.6                          0x00002b7556664460 __libc_start_main +
    245

    6    tmpuegarw32                        0x000056319cf8b1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5ubqf4ts/tmp5ubqf4ts.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bcbb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bcb843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bcb843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bcb8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ubqf4ts                        0x0000559ddf016639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2bcbd38460 __libc_start_main +
    245

    6    tmp5ubqf4ts                        0x0000559ddf0161c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    return arr.map\
    \ { $0.signum() }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        if\
    \ i != 0 {\n            prod *= i / abs(i)\n        }\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpujis1t0l/tmpujis1t0l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0691cd2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06919c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06919c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06919c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujis1t0l                        0x00005632489f38a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b0691ebe460 __libc_start_main +
    245

    6    tmpujis1t0l                        0x00005632489f32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signProduct\
    \ = arr.reduce(1) { $0 * sign($1) }\n    let magnitudeSum = arr.reduce(0) { $0\
    \ + abs($1) }\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8svaxhw0.swift:17:44: error: cannot find 'sign' in scope\n    let\
    \ signProduct = arr.reduce(1) { $0 * sign($1) }\n                            \
    \               ^~~~\n"
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n        } else if num < 0 {\n            prod *= -1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpmwgtfexv/tmpmwgtfexv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd9819dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd97e94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd97e94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd97e937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmwgtfexv                        0x000055f35fbf0649 <unavailable> + 5705

    5    libc.so.6                          0x00002acd98389460 __libc_start_main +
    245

    6    tmpmwgtfexv                        0x000055f35fbf01d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = sign.reduce(1, *)\n\
    \    let mag = arr.map { abs($0) }\n    let sum = mag.reduce(0, +)\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= num < 0 ? -1 : num\
    \ == 0 ? 0 : 1\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp4rmwvbzl/tmp4rmwvbzl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4b9bf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4b98eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4b98ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4b98e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rmwvbzl                        0x000055b6ac9298a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab4b9ddf460 __libc_start_main +
    245

    6    tmp4rmwvbzl                        0x000055b6ac9292a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    return arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp5ubqf4ts/tmp5ubqf4ts.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bcbb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bcb843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bcb843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bcb8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ubqf4ts                        0x0000559ddf016639 <unavailable> + 5689

    5    libc.so.6                          0x00002b2bcbd38460 __libc_start_main +
    245

    6    tmp5ubqf4ts                        0x0000559ddf0161c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiaonx8jz/tmpiaonx8jz.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3c13c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3c10bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3c10ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3c10b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaonx8jz                        0x000055aeae3ab8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ac3c15af460 __libc_start_main +
    245

    6    tmpiaonx8jz                        0x000055aeae3ab2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let sum = magnitudes.reduce(0, +)\n    let product = signs.reduce(1,\
    \ *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp9muyei62/tmp9muyei62.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46e3779c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46e3470b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46e3470988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46e346f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9muyei62                        0x00005653e909c639 <unavailable> + 5689

    5    libc.so.6                          0x00002b46e3965460 __libc_start_main +
    245

    6    tmp9muyei62                        0x00005653e909c1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = sign.reduce(1, *)\n\
    \    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let mags = arr.map { abs($0) }\n    let sum = mags.reduce(0, +)\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkdsma13r/tmpkdsma13r.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b8f27bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b8ef72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b8ef72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b8ef717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdsma13r                        0x0000556bbdbf03d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b4b8f467460 __libc_start_main +
    245

    6    tmpkdsma13r                        0x0000556bbdbeff69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n \
    \           prod *= -1\n        } else if i > 0 {\n            prod *= 1\n   \
    \     } else {\n            prod *= 0\n        }\n        sum += abs(i)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n \
    \           prod *= 1\n        } else if i < 0 {\n            prod *= -1\n   \
    \     } else {\n            prod *= 0\n        }\n        sum += abs(i)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var product = 1\n    for i in arr {\n        sum += abs(i)\n      \
    \  if i != 0 {\n            product *= i / abs(i)\n        }\n    }\n    return\
    \ sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp8tns6mcy/tmp8tns6mcy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6aa002c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6a9cf9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6a9cf9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6a9cf87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tns6mcy                        0x000055fd9c56d8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002af6aa1ee460 __libc_start_main +
    245

    6    tmp8tns6mcy                        0x000055fd9c56d2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    return arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var sign = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n        } else if num < 0 {\n            sum += -num\n      \
    \      sign *= -1\n        }\n    }\n    return sum * sign\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpj5cjqqeu/tmpj5cjqqeu.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cf1cf4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cf19ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cf19eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cf19ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj5cjqqeu                        0x0000561bd7d31725 <unavailable> + 5925

    5    libc.so.6                          0x00002b8cf1ee0460 __libc_start_main +
    245

    6    tmpj5cjqqeu                        0x0000561bd7d31129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824738
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp4rmwvbzl/tmp4rmwvbzl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4b9bf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4b98eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4b98ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4b98e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rmwvbzl                        0x000055b6ac9298a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab4b9ddf460 __libc_start_main +
    245

    6    tmp4rmwvbzl                        0x000055b6ac9292a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n          \
    \  sum += num\n            prod *= 1\n        } else if num < 0 {\n          \
    \  sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var product = 1\n    for i in arr {\n        sum += abs(i)\n        product\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7gk_8oyo/tmp7gk_8oyo.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0434868c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b043455fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b043455f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b043455e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7gk_8oyo                        0x000055ddc6de68a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b0434a54460 __libc_start_main +
    245

    6    tmp7gk_8oyo                        0x000055ddc6de62a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824738
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num > 0 ? 1 : -1\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpdaiupz12/tmpdaiupz12.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add7f465c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add7f15cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add7f15c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add7f15b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdaiupz12                        0x00005652c0ac2815 <unavailable> + 6165

    5    libc.so.6                          0x00002add7f651460 __libc_start_main +
    245

    6    tmpdaiupz12                        0x00005652c0ac2219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n\
    \    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n         \
    \   prod *= 1\n        } else if num < 0 {\n            prod *= -1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n \
    \   return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return magnitudes.reduce(1, *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpuegarw32/tmpuegarw32.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7556478c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b755616fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b755616f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b755616e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuegarw32                        0x000056319cf8b639 <unavailable> + 5689

    5    libc.so.6                          0x00002b7556664460 __libc_start_main +
    245

    6    tmpuegarw32                        0x000056319cf8b1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        if num > 0 {\n        \
    \    sum += num\n            prod *= 1\n        } else if num < 0 {\n        \
    \    sum += abs(num)\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiaonx8jz/tmpiaonx8jz.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3c13c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3c10bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3c10ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3c10b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaonx8jz                        0x000055aeae3ab8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ac3c15af460 __libc_start_main +
    245

    6    tmpiaonx8jz                        0x000055aeae3ab2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i == 0 ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp4rmwvbzl/tmp4rmwvbzl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4b9bf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4b98eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4b98ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4b98e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rmwvbzl                        0x000055b6ac9298a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab4b9ddf460 __libc_start_main +
    245

    6    tmp4rmwvbzl                        0x000055b6ac9292a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n \
    \           sum += i\n            prod *= 1\n        } else if i < 0 {\n     \
    \       sum += -i\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for num in arr {\n        sum += abs(num)\n       \
    \ prod *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7crelc9y/tmp7crelc9y.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adfe4d5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adfe4a53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adfe4a53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adfe4a527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7crelc9y                        0x000055eb78bdd8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002adfe4f48460 __libc_start_main +
    245

    6    tmp7crelc9y                        0x000055eb78bdd2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0\
    \ + abs($1) }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard !arr.isEmpty else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824737
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n            sum\
    \ += i\n            prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824736
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0)\
    \ }\n    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824738
