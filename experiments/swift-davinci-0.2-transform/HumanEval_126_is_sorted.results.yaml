language: swift
name: HumanEval_126_is_sorted
results:
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f35e71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f35b68561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9f35b68286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9f35b6813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9f35b67bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppzgpv1i9                        0x0000560b85d420ee <unavailable> + 8430

    6    tmppzgpv1i9                        0x0000560b85d419d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b9f3605d460 __libc_start_main +
    245

    8    tmppzgpv1i9                        0x0000560b85d411a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b926109dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9260d94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9260d94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9260d9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9260d93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9260b93e83 <unavailable> + 188035

    6    tmp03ohnjgr                        0x000055e0e98cbfd6 <unavailable> + 8150

    7    tmp03ohnjgr                        0x000055e0e98cb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b9261289460 __libc_start_main +
    245

    9    tmp03ohnjgr                        0x000055e0e98cb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f35e71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f35b68561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9f35b68286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9f35b6813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9f35b67bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppzgpv1i9                        0x0000560b85d420ee <unavailable> + 8430

    6    tmppzgpv1i9                        0x0000560b85d419d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b9f3605d460 __libc_start_main +
    245

    8    tmppzgpv1i9                        0x0000560b85d411a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = 0\n    for i in lst {\n        if i < last {\n            sorted = false\n\
    \        }\n        last = i\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpwx_7gfsl/tmpwx_7gfsl.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af750b04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7507fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7507fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7507fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwx_7gfsl                        0x000055b76d0f1c2b <unavailable> + 7211

    5    libc.so.6                          0x00002af750cf0460 __libc_start_main +
    245

    6    tmpwx_7gfsl                        0x000055b76d0f10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae78c7fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae78c4f4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae78c4f4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae78c4f413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae78c4f3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpeu55teic                        0x000055b3a478b0f3 <unavailable> + 8435

    6    tmpeu55teic                        0x000055b3a478a9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ae78c9e9460 __libc_start_main +
    245

    8    tmpeu55teic                        0x000055b3a478a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted_lst = lst.sorted()\n\
    \    var count = 0\n    for i in 0..<lst.count {\n        if lst[i] == sorted_lst[i]\
    \ {\n            count += 1\n        }\n    }\n    if count == lst.count {\n \
    \       return true\n    }\n    else {\n        return false\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp9pmqgno9/tmp9pmqgno9.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ff7084c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ff6d7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ff6d7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ff6d7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9pmqgno9                        0x00005562a70b9d9b <unavailable> + 7579

    5    libc.so.6                          0x00002b1ff7270460 __libc_start_main +
    245

    6    tmp9pmqgno9                        0x00005562a70b9249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3058d97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3058a8e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3058a8e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3058a8e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3058a8dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpuqp4uafo                        0x000055867dadf0ee <unavailable> + 8430

    6    tmpuqp4uafo                        0x000055867dade9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b3058f83460 __libc_start_main +
    245

    8    tmpuqp4uafo                        0x000055867dade1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in lst {\n        if i < prev {\n            return false\n        }\n   \
    \     prev = i\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c177ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c1471561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8c1471286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8c147113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8c1470bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8c1270e83 <unavailable> + 188035

    6    tmp04rqz9m5                        0x00005626cd7eefc2 <unavailable> + 8130

    7    tmp04rqz9m5                        0x00005626cd7ee954 <unavailable> + 6484

    8    libc.so.6                          0x00002ae8c1966460 __libc_start_main +
    245

    9    tmp04rqz9m5                        0x00005626cd7ee129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in lst {\n        if i < last {\n            sorted\
    \ = false\n        }\n        last = i\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4501ee9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4501be0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4501be0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4501be013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4501bdfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b45019dfe83 <unavailable> + 188035

    6    tmpmoais1kc                        0x0000563ce3aebfd6 <unavailable> + 8150

    7    tmpmoais1kc                        0x0000563ce3aeb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b45020d5460 __libc_start_main +
    245

    9    tmpmoais1kc                        0x0000563ce3aeb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if prev > lst[i] {\n  \
    \          sorted = false\n            break\n        }\n        prev = lst[i]\n\
    \    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7eec14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7ee90b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad7ee90b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad7ee90b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad7ee90abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad7ee70ae83 <unavailable> + 188035

    6    tmpcqfo6gu9                        0x0000561794607056 <unavailable> + 8278

    7    tmpcqfo6gu9                        0x00005617946069d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad7eee00460 __libc_start_main +
    245

    9    tmpcqfo6gu9                        0x00005617946061a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c1b71bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c1b412561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c1b412286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c1b41213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c1b411bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_ej5dz3d                        0x000055f7dc0630f3 <unavailable> + 8435

    6    tmp_ej5dz3d                        0x000055f7dc0629d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b8c1b907460 __libc_start_main +
    245

    8    tmp_ej5dz3d                        0x000055f7dc0621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in lst {\n        if i < prev {\n            sorted\
    \ = false\n        }\n        prev = i\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bdb1abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bdaea2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1bdaea2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1bdaea213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1bdaea1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1bdaca1e83 <unavailable> + 188035

    6    tmpdyd3trr7                        0x000055639e72efd6 <unavailable> + 8150

    7    tmpdyd3trr7                        0x000055639e72e954 <unavailable> + 6484

    8    libc.so.6                          0x00002b1bdb397460 __libc_start_main +
    245

    9    tmpdyd3trr7                        0x000055639e72e129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for num in lst {\n        if num < last {\n            sorted\
    \ = false\n        }\n        last = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b795a3bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b795a0b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b795a0b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b795a0b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b795a0b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7959eb1e83 <unavailable> + 188035

    6    tmp8jgp4zkz                        0x00005555fa12cfd6 <unavailable> + 8150

    7    tmp8jgp4zkz                        0x00005555fa12c954 <unavailable> + 6484

    8    libc.so.6                          0x00002b795a5a7460 __libc_start_main +
    245

    9    tmp8jgp4zkz                        0x00005555fa12c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] >= lst[i+1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b412e92ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b412e625561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b412e625286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b412e62513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b412e624bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzg_6ld74                        0x0000558f93e2d0ee <unavailable> + 8430

    6    tmpzg_6ld74                        0x0000558f93e2c9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b412eb1a460 __libc_start_main +
    245

    8    tmpzg_6ld74                        0x0000558f93e2c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f35e71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f35b68561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9f35b68286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9f35b6813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9f35b67bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppzgpv1i9                        0x0000560b85d420ee <unavailable> + 8430

    6    tmppzgpv1i9                        0x0000560b85d419d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b9f3605d460 __libc_start_main +
    245

    8    tmppzgpv1i9                        0x0000560b85d411a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ num in lst {\n        if num < prev {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb402aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb3ffa1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb3ffa1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb3ffa113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb3ffa0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb3fda0e83 <unavailable> + 188035

    6    tmp6h27yyei                        0x000055f59ed00fc2 <unavailable> + 8130

    7    tmp6h27yyei                        0x000055f59ed00954 <unavailable> + 6484

    8    libc.so.6                          0x00002afb40496460 __libc_start_main +
    245

    9    tmp6h27yyei                        0x000055f59ed00129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] <= prev {\n \
    \           sorted = false\n            break\n        }\n        prev = lst[i]\n\
    \    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab04fa03c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab04f6fa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab04f6fa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab04f6fa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab04f6f9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab04f4f9e83 <unavailable> + 188035

    6    tmp8p4sxy03                        0x000055bd5d4ec056 <unavailable> + 8278

    7    tmp8p4sxy03                        0x000055bd5d4eb9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ab04fbef460 __libc_start_main +
    245

    9    tmp8p4sxy03                        0x000055bd5d4eb1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if prev > lst[i] {\n  \
    \          sorted = false\n            break\n        }\n        prev = lst[i]\n\
    \    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7eec14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7ee90b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad7ee90b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad7ee90b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad7ee90abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad7ee70ae83 <unavailable> + 188035

    6    tmpcqfo6gu9                        0x0000561794607056 <unavailable> + 8278

    7    tmpcqfo6gu9                        0x00005617946069d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad7eee00460 __libc_start_main +
    245

    9    tmpcqfo6gu9                        0x00005617946061a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ num in lst {\n        if num < prev {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb402aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb3ffa1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb3ffa1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb3ffa113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb3ffa0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb3fda0e83 <unavailable> + 188035

    6    tmp6h27yyei                        0x000055f59ed00fc2 <unavailable> + 8130

    7    tmp6h27yyei                        0x000055f59ed00954 <unavailable> + 6484

    8    libc.so.6                          0x00002afb40496460 __libc_start_main +
    245

    9    tmp6h27yyei                        0x000055f59ed00129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] <= prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b608beb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b608bbad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b608bbad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b608bbad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b608bbacbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b608b9ace83 <unavailable> + 188035

    6    tmpald0psc7                        0x000055e3cdc2a042 <unavailable> + 8258

    7    tmpald0psc7                        0x000055e3cdc299d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b608c0a2460 __libc_start_main +
    245

    9    tmpald0psc7                        0x000055e3cdc291a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var sorted = true\n    for i in 0..<lst.count -\
    \ 1 {\n        if lst[i] > lst[i + 1] {\n            sorted = false\n        }\n\
    \    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b43d8c5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43d8952561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b43d8952286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b43d895213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b43d8951bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqsp00p8h                        0x0000556f5bfa7107 <unavailable> + 8455

    6    tmpqsp00p8h                        0x0000556f5bfa69d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b43d8e47460 __libc_start_main +
    245

    8    tmpqsp00p8h                        0x0000556f5bfa61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c1b71bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c1b412561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c1b412286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c1b41213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c1b411bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_ej5dz3d                        0x000055f7dc0630f3 <unavailable> + 8435

    6    tmp_ej5dz3d                        0x000055f7dc0629d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b8c1b907460 __libc_start_main +
    245

    8    tmp_ej5dz3d                        0x000055f7dc0621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    for i in 0..<lst.count-1\
    \ {\n        if lst[i] >= lst[i+1] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac93a5eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac93a2e5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac93a2e5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac93a2e513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac93a2e4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpnjzkdghk                        0x000055ad8a3210da <unavailable> + 8410

    6    tmpnjzkdghk                        0x000055ad8a3209d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ac93a7da460 __libc_start_main +
    245

    8    tmpnjzkdghk                        0x000055ad8a3201a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ previous = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < previous\
    \ {\n            sorted = false\n        }\n        previous = lst[i]\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b732931ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7329015561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7329015286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b732901513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7329014bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7328e14e83 <unavailable> + 188035

    6    tmpx_e74b4x                        0x0000564c63ae3056 <unavailable> + 8278

    7    tmpx_e74b4x                        0x0000564c63ae29d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b732950a460 __libc_start_main +
    245

    9    tmpx_e74b4x                        0x0000564c63ae21a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ num in lst {\n        if num < prev {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb402aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb3ffa1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb3ffa1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb3ffa113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb3ffa0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb3fda0e83 <unavailable> + 188035

    6    tmp6h27yyei                        0x000055f59ed00fc2 <unavailable> + 8130

    7    tmp6h27yyei                        0x000055f59ed00954 <unavailable> + 6484

    8    libc.so.6                          0x00002afb40496460 __libc_start_main +
    245

    9    tmp6h27yyei                        0x000055f59ed00129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if prev == lst[i] {\n \
    \           sorted = false\n        }\n        if prev > lst[i] {\n          \
    \  sorted = false\n        }\n        prev = lst[i]\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aec65f6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec65c65561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aec65c65286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aec65c6513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aec65c64bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aec65a64e83 <unavailable> + 188035

    6    tmp9d87oosx                        0x000055c7d072605c <unavailable> + 8284

    7    tmp9d87oosx                        0x000055c7d07259d4 <unavailable> + 6612

    8    libc.so.6                          0x00002aec6615a460 __libc_start_main +
    245

    9    tmp9d87oosx                        0x000055c7d07251a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c1b71bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c1b412561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c1b412286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c1b41213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c1b411bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_ej5dz3d                        0x000055f7dc0630f3 <unavailable> + 8435

    6    tmp_ej5dz3d                        0x000055f7dc0629d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b8c1b907460 __libc_start_main +
    245

    8    tmp_ej5dz3d                        0x000055f7dc0621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c1b71bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c1b412561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c1b412286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c1b41213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c1b411bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_ej5dz3d                        0x000055f7dc0630f3 <unavailable> + 8435

    6    tmp_ej5dz3d                        0x000055f7dc0629d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b8c1b907460 __libc_start_main +
    245

    8    tmp_ej5dz3d                        0x000055f7dc0621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ num in lst {\n        if num < prev {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb402aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb3ffa1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb3ffa1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb3ffa113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb3ffa0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb3fda0e83 <unavailable> + 188035

    6    tmp6h27yyei                        0x000055f59ed00fc2 <unavailable> + 8130

    7    tmp6h27yyei                        0x000055f59ed00954 <unavailable> + 6484

    8    libc.so.6                          0x00002afb40496460 __libc_start_main +
    245

    9    tmp6h27yyei                        0x000055f59ed00129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp082vqvx_/tmp082vqvx_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad274c98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad27498fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad27498f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad27498e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp082vqvx_                        0x0000559b481512ea <unavailable> + 4842

    5    libc.so.6                          0x00002ad274e84460 __libc_start_main +
    245

    6    tmp082vqvx_                        0x0000559b48150f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae78c7fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae78c4f4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae78c4f4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae78c4f413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae78c4f3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpeu55teic                        0x000055b3a478b0f3 <unavailable> + 8435

    6    tmpeu55teic                        0x000055b3a478a9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ae78c9e9460 __libc_start_main +
    245

    8    tmpeu55teic                        0x000055b3a478a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var i = 0\n    var j = 1\n\
    \    while j < lst.count {\n        if lst[i] == lst[j] {\n            return\
    \ false\n        }\n        if lst[i] > lst[j] {\n            return false\n \
    \       }\n        i += 1\n        j += 1\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp582qipwj/tmp582qipwj.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3562cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba355fc5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba355fc5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba355fc47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp582qipwj                        0x0000555ccfe52d53 <unavailable> + 7507

    5    libc.so.6                          0x00002ba3564ba460 __libc_start_main +
    245

    6    tmp582qipwj                        0x0000555ccfe52019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af665aa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af66579a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af66579a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af66579a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af665799bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af665599e83 <unavailable> + 188035

    6    tmp3r9nas7d                        0x000055d39a16f05b <unavailable> + 8283

    7    tmp3r9nas7d                        0x000055d39a16e9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002af665c8f460 __libc_start_main +
    245

    9    tmp3r9nas7d                        0x000055d39a16e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae78c7fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae78c4f4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae78c4f4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae78c4f413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae78c4f3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpeu55teic                        0x000055b3a478b0f3 <unavailable> + 8435

    6    tmpeu55teic                        0x000055b3a478a9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ae78c9e9460 __libc_start_main +
    245

    8    tmpeu55teic                        0x000055b3a478a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for num in lst {\n        if num < last {\n            sorted\
    \ = false\n        }\n        last = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b795a3bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b795a0b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b795a0b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b795a0b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b795a0b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7959eb1e83 <unavailable> + 188035

    6    tmp8jgp4zkz                        0x00005555fa12cfd6 <unavailable> + 8150

    7    tmp8jgp4zkz                        0x00005555fa12c954 <unavailable> + 6484

    8    libc.so.6                          0x00002b795a5a7460 __libc_start_main +
    245

    9    tmp8jgp4zkz                        0x00005555fa12c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < last {\n            return false\n\
    \        }\n        last = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb89793c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb8948a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb8948a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb8948a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb89489bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb89289e83 <unavailable> + 188035

    6    tmpd6aqdy3p                        0x00005639e547f042 <unavailable> + 8258

    7    tmpd6aqdy3p                        0x00005639e547e9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002afb8997f460 __libc_start_main +
    245

    9    tmpd6aqdy3p                        0x00005639e547e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in lst {\n        if i < prev {\n            return false\n        }\n   \
    \     prev = i\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c177ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c1471561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8c1471286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8c147113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8c1470bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8c1270e83 <unavailable> + 188035

    6    tmp04rqz9m5                        0x00005626cd7eefc2 <unavailable> + 8130

    7    tmp04rqz9m5                        0x00005626cd7ee954 <unavailable> + 6484

    8    libc.so.6                          0x00002ae8c1966460 __libc_start_main +
    245

    9    tmp04rqz9m5                        0x00005626cd7ee129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3058d97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3058a8e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3058a8e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3058a8e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3058a8dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpuqp4uafo                        0x000055867dadf0ee <unavailable> + 8430

    6    tmpuqp4uafo                        0x000055867dade9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b3058f83460 __libc_start_main +
    245

    8    tmpuqp4uafo                        0x000055867dade1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ num in lst {\n        if num < prev {\n            return false\n        }\n\
    \        prev = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb402aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb3ffa1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb3ffa1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb3ffa113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb3ffa0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb3fda0e83 <unavailable> + 188035

    6    tmp6h27yyei                        0x000055f59ed00fc2 <unavailable> + 8130

    7    tmp6h27yyei                        0x000055f59ed00954 <unavailable> + 6484

    8    libc.so.6                          0x00002afb40496460 __libc_start_main +
    245

    9    tmp6h27yyei                        0x000055f59ed00129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev: Int? = nil\n  \
    \  for num in lst {\n        if let prev = prev {\n            if num < prev {\n\
    \                return false\n            }\n        }\n        prev = num\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp8mr2vz6a/tmp8mr2vz6a.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea1684fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea16546b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea16546988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea165457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8mr2vz6a                        0x000055d90bb68c2b <unavailable> + 7211

    5    libc.so.6                          0x00002aea16a3b460 __libc_start_main +
    245

    6    tmp8mr2vz6a                        0x000055d90bb680d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b926109dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9260d94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9260d94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9260d9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9260d93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9260b93e83 <unavailable> + 188035

    6    tmp03ohnjgr                        0x000055e0e98cbfd6 <unavailable> + 8150

    7    tmp03ohnjgr                        0x000055e0e98cb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b9261289460 __libc_start_main +
    245

    9    tmp03ohnjgr                        0x000055e0e98cb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if last > lst[i] {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b8660dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b86304561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8b86304286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8b8630413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8b86303bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8b86103e83 <unavailable> + 188035

    6    tmp5kxdm0pp                        0x000055b3ae2d0056 <unavailable> + 8278

    7    tmp5kxdm0pp                        0x000055b3ae2cf9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b8b867f9460 __libc_start_main +
    245

    9    tmp5kxdm0pp                        0x000055b3ae2cf1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in lst {\n        if i < prev {\n            return false\n        }\n   \
    \     prev = i\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c177ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c1471561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8c1471286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8c147113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8c1470bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8c1270e83 <unavailable> + 188035

    6    tmp04rqz9m5                        0x00005626cd7eefc2 <unavailable> + 8130

    7    tmp04rqz9m5                        0x00005626cd7ee954 <unavailable> + 6484

    8    libc.so.6                          0x00002ae8c1966460 __libc_start_main +
    245

    9    tmp04rqz9m5                        0x00005626cd7ee129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in lst {\n        if i < prev {\n            return false\n        }\n   \
    \     prev = i\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c177ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c1471561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8c1471286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8c147113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8c1470bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8c1270e83 <unavailable> + 188035

    6    tmp04rqz9m5                        0x00005626cd7eefc2 <unavailable> + 8130

    7    tmp04rqz9m5                        0x00005626cd7ee954 <unavailable> + 6484

    8    libc.so.6                          0x00002ae8c1966460 __libc_start_main +
    245

    9    tmp04rqz9m5                        0x00005626cd7ee129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // TODO: Implement me!\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqjbn9ptb/tmpqjbn9ptb.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22ceccfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22ce9c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22ce9c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22ce9c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqjbn9ptb                        0x00005619bae282ea <unavailable> + 4842

    5    libc.so.6                          0x00002b22ceebb460 __libc_start_main +
    245

    6    tmpqjbn9ptb                        0x00005619bae27f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af665aa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af66579a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af66579a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af66579a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af665799bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af665599e83 <unavailable> + 188035

    6    tmp3r9nas7d                        0x000055d39a16f05b <unavailable> + 8283

    7    tmp3r9nas7d                        0x000055d39a16e9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002af665c8f460 __libc_start_main +
    245

    9    tmp3r9nas7d                        0x000055d39a16e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af665aa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af66579a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af66579a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af66579a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af665799bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af665599e83 <unavailable> + 188035

    6    tmp3r9nas7d                        0x000055d39a16f05b <unavailable> + 8283

    7    tmp3r9nas7d                        0x000055d39a16e9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002af665c8f460 __libc_start_main +
    245

    9    tmp3r9nas7d                        0x000055d39a16e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in lst {\n        if i < last {\n            sorted\
    \ = false\n        }\n        last = i\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4501ee9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4501be0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4501be0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4501be013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4501bdfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b45019dfe83 <unavailable> + 188035

    6    tmpmoais1kc                        0x0000563ce3aebfd6 <unavailable> + 8150

    7    tmpmoais1kc                        0x0000563ce3aeb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b45020d5460 __libc_start_main +
    245

    9    tmpmoais1kc                        0x0000563ce3aeb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for num in lst {\n        if num < last {\n            sorted\
    \ = false\n        }\n        last = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b795a3bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b795a0b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b795a0b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b795a0b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b795a0b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7959eb1e83 <unavailable> + 188035

    6    tmp8jgp4zkz                        0x00005555fa12cfd6 <unavailable> + 8150

    7    tmp8jgp4zkz                        0x00005555fa12c954 <unavailable> + 6484

    8    libc.so.6                          0x00002b795a5a7460 __libc_start_main +
    245

    9    tmp8jgp4zkz                        0x00005555fa12c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ previous = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < previous\
    \ {\n            sorted = false\n        }\n        previous = lst[i]\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b732931ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7329015561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7329015286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b732901513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7329014bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7328e14e83 <unavailable> + 188035

    6    tmpx_e74b4x                        0x0000564c63ae3056 <unavailable> + 8278

    7    tmpx_e74b4x                        0x0000564c63ae29d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b732950a460 __libc_start_main +
    245

    9    tmpx_e74b4x                        0x0000564c63ae21a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpsbk4_m4o/tmpsbk4_m4o.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab20016cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1ffe63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1ffe63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1ffe627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsbk4_m4o                        0x0000558258614486 <unavailable> + 5254

    5    libc.so.6                          0x00002ab200358460 __libc_start_main +
    245

    6    tmpsbk4_m4o                        0x0000558258613f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b926109dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9260d94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9260d94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9260d9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9260d93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9260b93e83 <unavailable> + 188035

    6    tmp03ohnjgr                        0x000055e0e98cbfd6 <unavailable> + 8150

    7    tmp03ohnjgr                        0x000055e0e98cb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b9261289460 __libc_start_main +
    245

    9    tmp03ohnjgr                        0x000055e0e98cb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n\
    \        if lst[i] < prev {\n            return false\n        }\n        prev\
    \ = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af665aa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af66579a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af66579a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af66579a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af665799bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af665599e83 <unavailable> + 188035

    6    tmp3r9nas7d                        0x000055d39a16f05b <unavailable> + 8283

    7    tmp3r9nas7d                        0x000055d39a16e9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002af665c8f460 __libc_start_main +
    245

    9    tmp3r9nas7d                        0x000055d39a16e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b926109dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9260d94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9260d94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9260d9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9260d93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9260b93e83 <unavailable> + 188035

    6    tmp03ohnjgr                        0x000055e0e98cbfd6 <unavailable> + 8150

    7    tmp03ohnjgr                        0x000055e0e98cb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b9261289460 __libc_start_main +
    245

    9    tmp03ohnjgr                        0x000055e0e98cb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3058d97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3058a8e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3058a8e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3058a8e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3058a8dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpuqp4uafo                        0x000055867dadf0ee <unavailable> + 8430

    6    tmpuqp4uafo                        0x000055867dade9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b3058f83460 __libc_start_main +
    245

    8    tmpuqp4uafo                        0x000055867dade1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in lst {\n        if i < prev {\n            return false\n        }\n   \
    \     prev = i\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c177ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c1471561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae8c1471286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae8c147113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae8c1470bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae8c1270e83 <unavailable> + 188035

    6    tmp04rqz9m5                        0x00005626cd7eefc2 <unavailable> + 8130

    7    tmp04rqz9m5                        0x00005626cd7ee954 <unavailable> + 6484

    8    libc.so.6                          0x00002ae8c1966460 __libc_start_main +
    245

    9    tmp04rqz9m5                        0x00005626cd7ee129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count-1 {\n        if lst[i] > lst[i+1] {\n            sorted =\
    \ false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f35e71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f35b68561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9f35b68286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9f35b6813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9f35b67bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppzgpv1i9                        0x0000560b85d420ee <unavailable> + 8430

    6    tmppzgpv1i9                        0x0000560b85d419d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b9f3605d460 __libc_start_main +
    245

    8    tmppzgpv1i9                        0x0000560b85d411a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae78c7fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae78c4f4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae78c4f4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae78c4f413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae78c4f3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpeu55teic                        0x000055b3a478b0f3 <unavailable> + 8435

    6    tmpeu55teic                        0x000055b3a478a9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ae78c9e9460 __libc_start_main +
    245

    8    tmpeu55teic                        0x000055b3a478a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var i = 0\n    var j = 1\n\
    \    while j < lst.count {\n        if lst[i] > lst[j] {\n            return false\n\
    \        }\n        i += 1\n        j += 1\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgecvj2c_/tmpgecvj2c_.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ee43e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ee40dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ee40df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ee40de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgecvj2c_                        0x00005645cde50b6b <unavailable> + 7019

    5    libc.so.6                          0x00002b9ee45d4460 __libc_start_main +
    245

    6    tmpgecvj2c_                        0x00005645cde50019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    var count = 0\n    for i in lst {\n        if i == prev {\n\
    \            count += 1\n        }\n        if i < prev {\n            sorted\
    \ = false\n        }\n        prev = i\n    }\n    if count > 1 {\n        sorted\
    \ = false\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a7ba9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a7b793561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3a7b793286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3a7b79313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3a7b792bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3a7b592e83 <unavailable> + 188035

    6    tmp1krlv07v                        0x0000561d7ff3ffe6 <unavailable> + 8166

    7    tmp1krlv07v                        0x0000561d7ff3f954 <unavailable> + 6484

    8    libc.so.6                          0x00002b3a7bc88460 __libc_start_main +
    245

    9    tmp1krlv07v                        0x0000561d7ff3f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c1b71bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c1b412561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c1b412286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c1b41213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c1b411bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_ej5dz3d                        0x000055f7dc0630f3 <unavailable> + 8435

    6    tmp_ej5dz3d                        0x000055f7dc0629d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b8c1b907460 __libc_start_main +
    245

    8    tmp_ej5dz3d                        0x000055f7dc0621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = -1\n    for num\
    \ in lst {\n        if num <= last {\n            return false\n        }\n  \
    \      last = num\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp29gw5b13/tmp29gw5b13.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea9871bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea98412b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea98412988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea984117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29gw5b13                        0x000055b83f989e13 <unavailable> + 7699

    5    libc.so.6                          0x00002aea98907460 __libc_start_main +
    245

    6    tmp29gw5b13                        0x000055b83f9890d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return true }\n    var prev = lst[0]\n    for i in 1..<lst.count {\n     \
    \   if lst[i] < prev {\n            return false\n        }\n        prev = lst[i]\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmphjbwnmsz/tmphjbwnmsz.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4d9e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4d9b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4d9b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4d9b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphjbwnmsz                        0x000055ea4b5fdcfb <unavailable> + 7419

    5    libc.so.6                          0x00002ac4da014460 __libc_start_main +
    245

    6    tmphjbwnmsz                        0x000055ea4b5fd1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if prev > lst[i] {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1305cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13059ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13059ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13059ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13059ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13057ece83 <unavailable> + 188035

    6    tmp1clzep55                        0x00005587ed6f2056 <unavailable> + 8278

    7    tmp1clzep55                        0x00005587ed6f19d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b1305ee2460 __libc_start_main +
    245

    9    tmp1clzep55                        0x00005587ed6f11a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3058d97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3058a8e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3058a8e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3058a8e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3058a8dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpuqp4uafo                        0x000055867dadf0ee <unavailable> + 8430

    6    tmpuqp4uafo                        0x000055867dade9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b3058f83460 __libc_start_main +
    245

    8    tmpuqp4uafo                        0x000055867dade1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = 0\n    for i in lst {\n        if i < prev {\n            sorted = false\n\
    \        }\n        prev = i\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp5ft2on6r/tmp5ft2on6r.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba32fb0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba32f805b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba32f805988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba32f8047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ft2on6r                        0x000055b030c83c2b <unavailable> + 7211

    5    libc.so.6                          0x00002ba32fcfa460 __libc_start_main +
    245

    6    tmp5ft2on6r                        0x000055b030c830d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3058d97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3058a8e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3058a8e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3058a8e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3058a8dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpuqp4uafo                        0x000055867dadf0ee <unavailable> + 8430

    6    tmpuqp4uafo                        0x000055867dade9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b3058f83460 __libc_start_main +
    245

    8    tmpuqp4uafo                        0x000055867dade1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = 0\n    for i in lst {\n        if i < prev {\n            sorted = false\n\
    \        }\n        prev = i\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp5ft2on6r/tmp5ft2on6r.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba32fb0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba32f805b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba32f805988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba32f8047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ft2on6r                        0x000055b030c83c2b <unavailable> + 7211

    5    libc.so.6                          0x00002ba32fcfa460 __libc_start_main +
    245

    6    tmp5ft2on6r                        0x000055b030c830d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev = lst[0]\n    for\
    \ i in 1..<lst.count {\n        if lst[i] < prev {\n            return false\n\
    \        }\n        prev = lst[i]\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad57d5ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad57d2e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad57d2e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad57d2e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad57d2e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad57d0e2e83 <unavailable> + 188035

    6    tmpmnianqb1                        0x000055d5fb4eb042 <unavailable> + 8258

    7    tmpmnianqb1                        0x000055d5fb4ea9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002ad57d7d8460 __libc_start_main +
    245

    9    tmpmnianqb1                        0x000055d5fb4ea1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b52877e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52874db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b52874db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b52874db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b52874dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3vro904v                        0x0000560df5c800f3 <unavailable> + 8435

    6    tmp3vro904v                        0x0000560df5c7f9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b52879d0460 __libc_start_main +
    245

    8    tmp3vro904v                        0x0000560df5c7f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b926109dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9260d94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9260d94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9260d9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9260d93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9260b93e83 <unavailable> + 188035

    6    tmp03ohnjgr                        0x000055e0e98cbfd6 <unavailable> + 8150

    7    tmp03ohnjgr                        0x000055e0e98cb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b9261289460 __libc_start_main +
    245

    9    tmp03ohnjgr                        0x000055e0e98cb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    for\
    \ i in 0..<lst.count - 1 {\n        if lst[i] > lst[i + 1] {\n            sorted\
    \ = false\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3058d97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3058a8e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3058a8e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3058a8e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3058a8dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpuqp4uafo                        0x000055867dadf0ee <unavailable> + 8430

    6    tmpuqp4uafo                        0x000055867dade9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b3058f83460 __libc_start_main +
    245

    8    tmpuqp4uafo                        0x000055867dade1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < prev {\n  \
    \          sorted = false\n        }\n        prev = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b48c15dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48c12d3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b48c12d3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b48c12d313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b48c12d2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b48c10d2e83 <unavailable> + 188035

    6    tmp9tnh3wh3                        0x00005617685dd056 <unavailable> + 8278

    7    tmp9tnh3wh3                        0x00005617685dc9d4 <unavailable> + 6612

    8    libc.so.6                          0x00002b48c17c8460 __libc_start_main +
    245

    9    tmp9tnh3wh3                        0x00005617685dc1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ prev = lst[0]\n    for num in lst {\n        if num < prev {\n            sorted\
    \ = false\n        }\n        prev = num\n    }\n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b926109dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9260d94561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9260d94286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9260d9413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9260d93bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9260b93e83 <unavailable> + 188035

    6    tmp03ohnjgr                        0x000055e0e98cbfd6 <unavailable> + 8150

    7    tmp03ohnjgr                        0x000055e0e98cb954 <unavailable> + 6484

    8    libc.so.6                          0x00002b9261289460 __libc_start_main +
    245

    9    tmp03ohnjgr                        0x000055e0e98cb129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var sorted = true\n    var\
    \ last = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < last {\n  \
    \          sorted = false\n        }\n        last = lst[i]\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acbedbf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbed8e9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acbed8e9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acbed8e913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acbed8e8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acbed6e8e83 <unavailable> + 188035

    6    tmpocu9zlna                        0x0000555f4eae6056 <unavailable> + 8278

    7    tmpocu9zlna                        0x0000555f4eae59d4 <unavailable> + 6612

    8    libc.so.6                          0x00002acbeddde460 __libc_start_main +
    245

    9    tmpocu9zlna                        0x0000555f4eae51a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count-1 {\n        if lst[i] >\
    \ lst[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c1b71bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c1b412561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8c1b412286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8c1b41213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8c1b411bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_ej5dz3d                        0x000055f7dc0630f3 <unavailable> + 8435

    6    tmp_ej5dz3d                        0x000055f7dc0629d4 <unavailable> + 6612

    7    libc.so.6                          0x00002b8c1b907460 __libc_start_main +
    245

    8    tmp_ej5dz3d                        0x000055f7dc0621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var i = 0\n    while i < lst.count - 1 {\n     \
    \   if lst[i] >= lst[i + 1] {\n            return false\n        }\n        i\
    \ += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp4_ub6ei5/tmp4_ub6ei5.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea593e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea590dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea590df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea590de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4_ub6ei5                        0x0000561ab67d7d53 <unavailable> + 7507

    5    libc.so.6                          0x00002aea595d4460 __libc_start_main +
    245

    6    tmp4_ub6ei5                        0x0000561ab67d7019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013757
- exit_code: -4
  program: "\n/// Given a list of numbers, return whether or not they are sorted\n\
    /// in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    for i in 0..<lst.count - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae78c7fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae78c4f4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae78c4f4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae78c4f413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae78c4f3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpeu55teic                        0x000055b3a478b0f3 <unavailable> + 8435

    6    tmpeu55teic                        0x000055b3a478a9d4 <unavailable> + 6612

    7    libc.so.6                          0x00002ae78c9e9460 __libc_start_main +
    245

    8    tmpeu55teic                        0x000055b3a478a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013757
