language: swift
name: HumanEval_119_match_parens
results:
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if str.count > 0 && str.last! == \")\" {\n            str.removeLast()\n\
    \            if str.count > 0 && str.last! == \"(\" {\n                str.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    return str.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpg_ov0_uw/tmpg_ov0_uw.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acfe699ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfe6695b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acfe6695988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acfe66947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg_ov0_uw                        0x0000556ecf8c2906 <unavailable> + 6406

    5    libc.so.6                          0x00002acfe6b8a460 __libc_start_main +
    245

    6    tmpg_ov0_uw                        0x0000556ecf8c24e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmptxpo34om/tmptxpo34om.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaca61cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaca5ec6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaca5ec6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaca5ec57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptxpo34om                        0x000055c9c92ecb76 <unavailable> + 7030

    5    libc.so.6                          0x00002aaca63bb460 __libc_start_main +
    245

    6    tmptxpo34om                        0x000055c9c92ec2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var c = 0\n    for i in s {\n \
    \       if i == \"(\" {\n            c += 1\n        } else {\n            c -=\
    \ 1\n        }\n        if c < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    return c == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmprznebety/tmprznebety.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b198fa88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b198f77fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b198f77f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b198f77e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprznebety                        0x0000562683facc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b198fc74460 __libc_start_main +
    245

    6    tmprznebety                        0x0000562683fac3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for i in s {\n        if i == \"(\" {\n            stack.append(i)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    } else {\n \
    \       return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7oqa5pm8/tmp7oqa5pm8.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef8a5d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef8a2cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef8a2ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef8a2c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7oqa5pm8                        0x000055ffdf516e76 <unavailable> + 7798

    5    libc.so.6                          0x00002aef8a7bf460 __libc_start_main +
    245

    6    tmp7oqa5pm8                        0x000055ffdf5165d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        let\
    \ s = lst.removeFirst()\n        str += s\n        for c in s {\n            if\
    \ c == \"(\" {\n                count += 1\n            } else {\n           \
    \     count -= 1\n            }\n            if count < 0 {\n                return\
    \ \"No\"\n            }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpc0a9i_dl/tmpc0a9i_dl.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7bf932c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7bf629b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7bf629988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7bf6287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc0a9i_dl                        0x000055b71bc2ac26 <unavailable> + 7206

    5    libc.so.6                          0x00002ad7bfb1e460 __libc_start_main +
    245

    6    tmpc0a9i_dl                        0x000055b71bc2a389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        for char in lst[i]\
    \ {\n            if char == \"(\" {\n                stack.push(char)\n      \
    \      } else {\n                if stack.isEmpty() {\n                    return\
    \ \"No\"\n                } else {\n                    stack.pop()\n        \
    \        }\n            }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmphgoxy_4f.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8uv9iuqx/tmp8uv9iuqx.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1fe9ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1fe6d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1fe6d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1fe6d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uv9iuqx                        0x000055fa051fee76 <unavailable> + 7798

    5    libc.so.6                          0x00002ae1febc9460 __libc_start_main +
    245

    6    tmp8uv9iuqx                        0x000055fa051fe5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    let stack = Stack<Character>()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.push(c)\n    \
    \    } else {\n            if stack.isEmpty() {\n                return \"No\"\
    \n            }\n            stack.pop()\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpfxui2q5m.swift:20:17: error: cannot find 'Stack' in scope\n   \
    \ let stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str3 = str1 + str2\n    let str4 = str2 + str1\n\
    \    if is_good(str: str3) || is_good(str: str4) {\n        return \"Yes\"\n \
    \   }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2tz4va39.swift:20:8: error: cannot find 'is_good' in scope\n  \
    \  if is_good(str: str3) || is_good(str: str4) {\n       ^~~~~~~\n/tmp/tmp2tz4va39.swift:20:30:\
    \ error: cannot find 'is_good' in scope\n    if is_good(str: str3) || is_good(str:\
    \ str4) {\n                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmptxpo34om/tmptxpo34om.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaca61cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaca5ec6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaca5ec6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaca5ec57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptxpo34om                        0x000055c9c92ecb76 <unavailable> + 7030

    5    libc.so.6                          0x00002aaca63bb460 __libc_start_main +
    245

    6    tmptxpo34om                        0x000055c9c92ec2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str = str1 + str2\n    var stack = [Character]()\n\
    \    for char in str {\n        if char == \"(\" {\n            stack.append(char)\n\
    \        } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpkxd5p_11/tmpkxd5p_11.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68fb0e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68faddeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68fadde988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68faddd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkxd5p_11                        0x000055688ca19da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b68fb2d3460 __libc_start_main +
    245

    6    tmpkxd5p_11                        0x000055688ca19509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        for c in lst[i] {\n\
    \            if c == \"(\" {\n                stack.push(c)\n            } else\
    \ {\n                if stack.isEmpty() {\n                    return \"No\"\n\
    \                } else {\n                    stack.pop()\n                }\n\
    \            }\n        }\n    }\n    while !stack.isEmpty() {\n        str.append(stack.pop()!)\n\
    \    }\n    if str.count % 2 == 0 {\n        return \"Yes\"\n    } else {\n  \
    \      return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpu0ceu2dx.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            count += 1\n\
    \        } else {\n            count -= 1\n        }\n    }\n    for char in lst[1]\
    \ {\n        if char == \"(\" {\n            count += 1\n        } else {\n  \
    \          count -= 1\n        }\n    }\n    if count == 0 {\n        return \"\
    Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpmx29dnyx/tmpmx29dnyx.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb4afd8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb4accfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb4accf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb4acce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmx29dnyx                        0x000055bde9cb0468 <unavailable> + 9320

    5    libc.so.6                          0x00002aeb4b1c4460 __libc_start_main +
    245

    6    tmpmx29dnyx                        0x000055bde9caf289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var count = 0\n    for char in str1 {\n        if\
    \ char == \"(\" {\n            count += 1\n        } else {\n            count\
    \ -= 1\n        }\n    }\n    for char in str2 {\n        if char == \"(\" {\n\
    \            count += 1\n        } else {\n            count -= 1\n        }\n\
    \    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_f5q82nc/tmp_f5q82nc.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae19f241c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae19ef38b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae19ef38988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae19ef377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_f5q82nc                        0x000055ba8283b468 <unavailable> + 9320

    5    libc.so.6                          0x00002ae19f42d460 __libc_start_main +
    245

    6    tmp_f5q82nc                        0x000055ba8283a289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp45lg3o4_/tmp45lg3o4_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab71855dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab718254b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab718254988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7182537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp45lg3o4_                        0x000055b0fd9d6b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab718749460 __libc_start_main +
    245

    6    tmp45lg3o4_                        0x000055b0fd9d62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var stack = Stack<Character>()\n    for str in lst {\n        for char\
    \ in str {\n            if char == \"(\" {\n                stack.push(char)\n\
    \            } else {\n                if stack.isEmpty() {\n                \
    \    result = \"No\"\n                    break\n                } else {\n  \
    \                  stack.pop()\n                }\n            }\n        }\n\
    \    }\n    if !stack.isEmpty() {\n        result = \"No\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpnnjnmzeh.swift:17:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           stack.append(c)\n            } else {\n                if stack.count\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack.removeLast()\n            }\n        }\n    }\n    return stack.count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyj2rarl6/tmpyj2rarl6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bf878bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bf8482b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bf8482988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bf84817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyj2rarl6                        0x0000562a48e40e26 <unavailable> + 7718

    5    libc.so.6                          0x00002b5bf8977460 __libc_start_main +
    245

    6    tmpyj2rarl6                        0x0000562a48e40589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpiuase0pe/tmpiuase0pe.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb33fe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb33ce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb33ce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb33cdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiuase0pe                        0x0000562b8725ac96 <unavailable> + 7318

    5    libc.so.6                          0x00002aeb341d5460 __libc_start_main +
    245

    6    tmpiuase0pe                        0x0000562b8725a3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var s = s1 + s2\n    var count = 0\n    for c in s {\n\
    \        if c == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    s =\
    \ s2 + s1\n    count = 0\n    for c in s {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4t__w6kr/tmp4t__w6kr.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31b93bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31b90b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31b90b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31b90b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4t__w6kr                        0x0000562cd0c2bb76 <unavailable> + 7030

    5    libc.so.6                          0x00002b31b95a9460 __libc_start_main +
    245

    6    tmp4t__w6kr                        0x0000562cd0c2b2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = \"\"\n    for s in lst {\n        str += s\n    }\n    for c in\
    \ str {\n        if c == \"(\" {\n            stack.append(c)\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   } else {\n                stack.removeLast()\n            }\n        }\n \
    \   }\n    if stack.isEmpty {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzjwmovt3/tmpzjwmovt3.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2be3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2be0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2be0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2be0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzjwmovt3                        0x000055f86b02fe76 <unavailable> + 7798

    5    libc.so.6                          0x00002ba2be5c9460 __libc_start_main +
    245

    6    tmpzjwmovt3                        0x000055f86b02f5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp45lg3o4_/tmp45lg3o4_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab71855dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab718254b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab718254988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7182537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp45lg3o4_                        0x000055b0fd9d6b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab718749460 __libc_start_main +
    245

    6    tmp45lg3o4_                        0x000055b0fd9d62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var lst4 = lst2 + lst1\n    if lst3.is_balanced() {\n        return \"Yes\"\
    \n    } else if lst4.is_balanced() {\n        return \"Yes\"\n    } else {\n \
    \       return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpos075b21.swift:21:13: error: value of type 'String' has no member\
    \ 'is_balanced'\n    if lst3.is_balanced() {\n       ~~~~ ^~~~~~~~~~~\n/tmp/tmpos075b21.swift:23:20:\
    \ error: value of type 'String' has no member 'is_balanced'\n    } else if lst4.is_balanced()\
    \ {\n              ~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgtxoj_p.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbgtxoj_p.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpiuase0pe/tmpiuase0pe.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb33fe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb33ce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb33ce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb33cdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiuase0pe                        0x0000562b8725ac96 <unavailable> + 7318

    5    libc.so.6                          0x00002aeb341d5460 __libc_start_main +
    245

    6    tmpiuase0pe                        0x0000562b8725a3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let str1 = lst.removeFirst()\n    let str2 = lst.removeFirst()\n    let str\
    \ = str1 + str2\n    var stack = [Character]()\n    for char in str {\n      \
    \  if char == \"(\" {\n            stack.append(char)\n        } else {\n    \
    \        if stack.isEmpty {\n                return \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0jwgg6xf/tmp0jwgg6xf.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b94b0ef8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b94b0befb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b94b0bef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94b0bee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jwgg6xf                        0x000055809e57dda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b94b10e4460 __libc_start_main +
    245

    6    tmp0jwgg6xf                        0x000055809e57d509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n \
    \           count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyk5df_he/tmpyk5df_he.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8745a9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8745796b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8745796988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87457957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyk5df_he                        0x0000559b74e13b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b8745c8b460 __libc_start_main +
    245

    6    tmpyk5df_he                        0x0000559b74e132d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s3 = s1 + s2\n    let s4 = s2 + s1\n    let s5 =\
    \ s3.replacingOccurrences(of: \"()\", with: \"\")\n    let s6 = s4.replacingOccurrences(of:\
    \ \"()\", with: \"\")\n    if s5 == \"\" {\n        return \"Yes\"\n    } else\
    \ if s6 == \"\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\
    \n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpiy56hwuz.swift:20:17: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let s5 = s3.replacingOccurrences(of: \"()\", with:\
    \ \"\")\n             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpiy56hwuz.swift:21:17: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    let s6 = s4.replacingOccurrences(of:\
    \ \"()\", with: \"\")\n             ~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.count\n    let str2_count =\
    \ str2.count\n    var str1_open = 0\n    var str1_close = 0\n    var str2_open\
    \ = 0\n    var str2_close = 0\n    for char in str1 {\n        if char == \"(\"\
    \ {\n            str1_open += 1\n        } else {\n            str1_close += 1\n\
    \        }\n    }\n    for char in str2 {\n        if char == \"(\" {\n      \
    \      str2_open += 1\n        } else {\n            str2_close += 1\n       \
    \ }\n    }\n    if str1_open == str1_close && str2_open == str2_close {\n    \
    \    return \"Yes\"\n    } else if str1_open == str1_close && str2_open != str2_close\
    \ {\n        if str2_open < str2_close {\n            if str1_open >= str2_close\
    \ - str2_open {\n                return \"Yes\"\n            } else {\n      \
    \          return \"No\"\n            }\n        } else {\n            if str1_open\
    \ >= str2_open - str2_close {\n                return \"Yes\"\n            } else\
    \ {\n                return \"No\"\n            }\n        }\n    } else if str1_open\
    \ != str1_close && str2_open == str2_close {\n        if str1_open < str1_close\
    \ {\n            if str2_open >= str1_close - str1_open {\n                return\
    \ \"Yes\"\n            } else {\n                return \"No\"\n            }\n\
    \        } else {\n            if str2_open >= str1_open - str1_close {\n    \
    \            return \"Yes\"\n            } else {\n                return \"No\"\
    \n            }\n        }\n    } else {\n        if str1_open < str1_close {\n\
    \            if str2_open < str2_close {\n                if str1_open + str2_open\
    \ >= str1_close + str2_close {\n                    return \"Yes\"\n         \
    \       } else {\n                    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp5834xvp7.swift:101:47: error: expected '}' at end of brace statement\n\
    assert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")\n                       \
    \                       ^\n/tmp/tmp5834xvp7.swift:70:39: note: to match this opening\
    \ '{'\n            if str2_open < str2_close {\n                             \
    \         ^\n/tmp/tmp5834xvp7.swift:101:47: error: expected '}' at end of brace\
    \ statement\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")\n          \
    \                                    ^\n/tmp/tmp5834xvp7.swift:69:35: note: to\
    \ match this opening '{'\n        if str1_open < str1_close {\n              \
    \                    ^\n/tmp/tmp5834xvp7.swift:101:47: error: expected '}' at\
    \ end of brace statement\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\"\
    )\n                                              ^\n/tmp/tmp5834xvp7.swift:68:12:\
    \ note: to match this opening '{'\n    } else {\n           ^\n/tmp/tmp5834xvp7.swift:101:47:\
    \ error: expected '}' at end of brace statement\nassert(match_parens(lst: [\"\
    )\", \"(\"]) == \"Yes\")\n                                              ^\n/tmp/tmp5834xvp7.swift:15:44:\
    \ note: to match this opening '{'\nfunc match_parens(lst: [String]) -> String\
    \ {\n                                           ^\n/tmp/tmp5834xvp7.swift:78:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp5834xvp7.swift:18:9:\
    \ warning: initialization of immutable value 'str1_count' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    let str1_count = str1.count\n\
    \    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp5834xvp7.swift:19:9: warning: initialization\
    \ of immutable value 'str2_count' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let str2_count = str2.count\n    ~~~~^~~~~~~~~~\n\
    \    _\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8uv9iuqx/tmp8uv9iuqx.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1fe9ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1fe6d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1fe6d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1fe6d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uv9iuqx                        0x000055fa051fee76 <unavailable> + 7798

    5    libc.so.6                          0x00002ae1febc9460 __libc_start_main +
    245

    6    tmp8uv9iuqx                        0x000055fa051fe5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    return is_good(str: str) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptdhvpa5_.swift:27:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgtxoj_p.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbgtxoj_p.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    return open == close ?\
    \ \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpt0xjjojs/tmpt0xjjojs.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45ec636c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45ec32db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45ec32d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45ec32c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt0xjjojs                        0x00005557f7b59468 <unavailable> + 9320

    5    libc.so.6                          0x00002b45ec822460 __libc_start_main +
    245

    6    tmpt0xjjojs                        0x00005557f7b58289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst2 = lst\n    lst2.reverse()\n    var str = \"\"\n    var str2 = \"\
    \"\n    for i in lst {\n        str += i\n    }\n    for i in lst2 {\n       \
    \ str2 += i\n    }\n    if str.is_balanced() && str2.is_balanced() {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeraaxxc.swift:27:12: error: value of type 'String' has no member\
    \ 'is_balanced'\n    if str.is_balanced() && str2.is_balanced() {\n       ~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpoeraaxxc.swift:27:34: error: value of type 'String' has\
    \ no member 'is_balanced'\n    if str.is_balanced() && str2.is_balanced() {\n\
    \                            ~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for i in s {\n        if i == \"(\" {\n            stack.append(i)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\n    } else {\n \
    \       return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7oqa5pm8/tmp7oqa5pm8.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef8a5d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef8a2cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef8a2ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef8a2c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7oqa5pm8                        0x000055ffdf516e76 <unavailable> + 7798

    5    libc.so.6                          0x00002aef8a7bf460 __libc_start_main +
    245

    6    tmp7oqa5pm8                        0x000055ffdf5165d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for char in str {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmptxpo34om/tmptxpo34om.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaca61cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaca5ec6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaca5ec6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaca5ec57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptxpo34om                        0x000055c9c92ecb76 <unavailable> + 7030

    5    libc.so.6                          0x00002aaca63bb460 __libc_start_main +
    245

    6    tmptxpo34om                        0x000055c9c92ec2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp26tvo7e4/tmp26tvo7e4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ad38a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ad359fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ad359f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ad359e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp26tvo7e4                        0x000056239080cda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b4ad3a94460 __libc_start_main +
    245

    6    tmp26tvo7e4                        0x000056239080c509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.count\n    let str2_count =\
    \ str2.count\n    var str1_open = 0\n    var str1_close = 0\n    var str2_open\
    \ = 0\n    var str2_close = 0\n    for char in str1 {\n        if char == \"(\"\
    \ {\n            str1_open += 1\n        } else {\n            str1_close += 1\n\
    \        }\n    }\n    for char in str2 {\n        if char == \"(\" {\n      \
    \      str2_open += 1\n        } else {\n            str2_close += 1\n       \
    \ }\n    }\n    if str1_open == str1_close && str2_open == str2_close {\n    \
    \    return \"Yes\"\n    } else if str1_open == str1_close && str2_open != str2_close\
    \ {\n        return \"No\"\n    } else if str1_open != str1_close && str2_open\
    \ == str2_close {\n        return \"No\"\n    } else if str1_open != str1_close\
    \ && str2_open != str2_close {\n        if str1_open > str1_close {\n        \
    \    if str2_open > str2_close {\n                return \"No\"\n            }\
    \ else {\n                if str1_open - str1_close == str2_close - str2_open\
    \ {\n                    return \"Yes\"\n                } else {\n          \
    \          return \"No\"\n                }\n            }\n        } else {\n\
    \            if str2_open > str2_close {\n                if str1_close - str1_open\
    \ == str2_open - str2_close {\n                    return \"Yes\"\n          \
    \      } else {\n                    return \"No\"\n                }\n      \
    \      } else {\n                return \"No\"\n            }\n        }\n   \
    \ }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd10jul8t/tmpd10jul8t.swift:92: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b874fd04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b874f9fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b874f9fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b874f9fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd10jul8t                        0x0000559ec53ca4b8 <unavailable> + 9400

    5    libc.so.6                          0x00002b874fef0460 __libc_start_main +
    245

    6    tmpd10jul8t                        0x0000559ec53c92d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i].contains(\"(\") {\n            count += 1\n        } else {\n    \
    \        count -= 1\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6y_m73ax/tmp6y_m73ax.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab60837dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab608074b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab608074988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6080737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6y_m73ax                        0x0000556528ecacd6 <unavailable> + 7382

    5    libc.so.6                          0x00002ab608569460 __libc_start_main +
    245

    6    tmp6y_m73ax                        0x0000556528eca439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var s = \"\"\n    for str in lst {\n        s += str\n    }\n    for char\
    \ in s {\n        if char == \"(\" {\n            stack.push(char)\n        }\
    \ else {\n            if stack.isEmpty() {\n                return \"No\"\n  \
    \          } else {\n                stack.pop()\n            }\n        }\n \
    \   }\n    if stack.isEmpty() {\n        return \"Yes\"\n    } else {\n      \
    \  return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpsd6w52wk.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_count = str1.count\n    let str2_count =\
    \ str2.count\n    var str1_open = 0\n    var str1_close = 0\n    var str2_open\
    \ = 0\n    var str2_close = 0\n    for i in 0..<str1_count {\n        if str1[i]\
    \ == \"(\" {\n            str1_open += 1\n        } else {\n            str1_close\
    \ += 1\n        }\n    }\n    for i in 0..<str2_count {\n        if str2[i] ==\
    \ \"(\" {\n            str2_open += 1\n        } else {\n            str2_close\
    \ += 1\n        }\n    }\n    if str1_open == str1_close && str2_open == str2_close\
    \ {\n        return \"Yes\"\n    } else if str1_open == str1_close && str2_open\
    \ != str2_close {\n        return \"No\"\n    } else if str1_open != str1_close\
    \ && str2_open == str2_close {\n        return \"No\"\n    } else {\n        if\
    \ str1_open > str1_close {\n            if str2_open > str2_close {\n        \
    \        return \"No\"\n            } else {\n                if str1_open - str1_close\
    \ == str2_close - str2_open {\n                    return \"Yes\"\n          \
    \      } else {\n                    return \"No\"\n                }\n      \
    \      }\n        } else {\n            if str2_open > str2_close {\n        \
    \        if str1_close - str1_open == str2_open - str2_close {\n             \
    \       return \"Yes\"\n                } else {\n                    return \"\
    No\"\n                }\n            } else {\n                return \"No\"\n\
    \            }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9nm4otdm.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str1[i]\
    \ == \"(\" {\n           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp9nm4otdm.swift:32:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if str2[i] == \"(\" {\n           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n \
    \           count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyk5df_he/tmpyk5df_he.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8745a9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8745796b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8745796988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87457957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyk5df_he                        0x0000559b74e13b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b8745c8b460 __libc_start_main +
    245

    6    tmpyk5df_he                        0x0000559b74e132d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpmikwc4sg/tmpmikwc4sg.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2518cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace24e83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace24e83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace24e827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmikwc4sg                        0x000055ced408f468 <unavailable> + 9320

    5    libc.so.6                          0x00002ace25378460 __libc_start_main +
    245

    6    tmpmikwc4sg                        0x000055ced408e289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp45lg3o4_/tmp45lg3o4_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab71855dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab718254b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab718254988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7182537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp45lg3o4_                        0x000055b0fd9d6b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab718749460 __libc_start_main +
    245

    6    tmp45lg3o4_                        0x000055b0fd9d62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_len = str1.count\n    let str2_len = str2.count\n\
    \    var str1_open = 0\n    var str2_open = 0\n    var str1_close = 0\n    var\
    \ str2_close = 0\n    for i in 0..<str1_len {\n        if str1[i] == \"(\" {\n\
    \            str1_open += 1\n        } else {\n            str1_close += 1\n \
    \       }\n    }\n    for i in 0..<str2_len {\n        if str2[i] == \"(\" {\n\
    \            str2_open += 1\n        } else {\n            str2_close += 1\n \
    \       }\n    }\n    if str1_open == str1_close && str2_open == str2_close {\n\
    \        return \"Yes\"\n    } else if str1_open == str1_close && str2_open !=\
    \ str2_close {\n        if str2_open > str2_close {\n            return \"Yes\"\
    \n        } else {\n            return \"No\"\n        }\n    } else if str1_open\
    \ != str1_close && str2_open == str2_close {\n        if str1_open > str1_close\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    } else {\n        if str1_open > str1_close && str2_open > str2_close\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp435p06gj.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str1[i]\
    \ == \"(\" {\n           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp435p06gj.swift:32:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if str2[i] == \"(\" {\n           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_len = str1.count\n    let str2_len = str2.count\n\
    \    var str1_open = 0\n    var str2_open = 0\n    var str1_close = 0\n    var\
    \ str2_close = 0\n    for i in 0..<str1_len {\n        if str1[i] == \"(\" {\n\
    \            str1_open += 1\n        } else {\n            str1_close += 1\n \
    \       }\n    }\n    for i in 0..<str2_len {\n        if str2[i] == \"(\" {\n\
    \            str2_open += 1\n        } else {\n            str2_close += 1\n \
    \       }\n    }\n    if str1_open == str1_close && str2_open == str2_close {\n\
    \        return \"Yes\"\n    } else if str1_open == str1_close && str2_open <\
    \ str2_close {\n        return \"No\"\n    } else if str1_open < str1_close &&\
    \ str2_open == str2_close {\n        return \"No\"\n    } else if str1_open <\
    \ str1_close && str2_open < str2_close {\n        return \"No\"\n    } else {\n\
    \        return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxt6kuxv1.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str1[i]\
    \ == \"(\" {\n           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpxt6kuxv1.swift:32:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if str2[i] == \"(\" {\n           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_str = \"\"\n    for str in lst {\n        lst_str += str\n    }\n\
    \    var count = 0\n    for char in lst_str {\n        if char == \"(\" {\n  \
    \          count += 1\n        } else {\n            count -= 1\n        }\n \
    \       if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpb15yu4sd/tmpb15yu4sd.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f1cd35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f1ca2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f1ca2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f1ca2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb15yu4sd                        0x000055ba278c7c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b4f1cf21460 __libc_start_main +
    245

    6    tmpb15yu4sd                        0x000055ba278c73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp26tvo7e4/tmp26tvo7e4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ad38a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ad359fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ad359f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ad359e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp26tvo7e4                        0x000056239080cda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b4ad3a94460 __libc_start_main +
    245

    6    tmp26tvo7e4                        0x000056239080c509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for i in lst[0] {\n        if i == \"(\" {\n            count += 1\n    \
    \    } else {\n            count -= 1\n        }\n    }\n    for i in lst[1] {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n\
    \    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmphrvsrv79/tmphrvsrv79.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b573c4dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b573c1d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b573c1d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b573c1d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrvsrv79                        0x0000559b39111468 <unavailable> + 9320

    5    libc.so.6                          0x00002b573c6cb460 __libc_start_main +
    245

    6    tmphrvsrv79                        0x0000559b39110289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcd2p1n8z.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpiz6v_lah/tmpiz6v_lah.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49e3193c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49e2e8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49e2e8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49e2e897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiz6v_lah                        0x00005654c559ae76 <unavailable> + 7798

    5    libc.so.6                          0x00002b49e337f460 __libc_start_main +
    245

    6    tmpiz6v_lah                        0x00005654c559a5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for str in lst {\n        for char in str {\n         \
    \   if char == \"(\" {\n                open += 1\n            } else {\n    \
    \            close += 1\n            }\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpsljl23ct/tmpsljl23ct.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b840d3b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b840d0a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b840d0a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b840d0a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsljl23ct                        0x0000557bd1542578 <unavailable> + 9592

    5    libc.so.6                          0x00002b840d59c460 __libc_start_main +
    245

    6    tmpsljl23ct                        0x0000557bd1541399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgtxoj_p.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbgtxoj_p.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ for j in 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n         \
    \       count += 1\n            } else {\n                count -= 1\n       \
    \     }\n            if count < 0 {\n                return \"No\"\n         \
    \   }\n        }\n        str += lst[i]\n    }\n    if count == 0 {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq4tb7ipy.swift:21:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpq4tb7ipy.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8uv9iuqx/tmp8uv9iuqx.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1fe9ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1fe6d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1fe6d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1fe6d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uv9iuqx                        0x000055fa051fee76 <unavailable> + 7798

    5    libc.so.6                          0x00002ae1febc9460 __libc_start_main +
    245

    6    tmp8uv9iuqx                        0x000055fa051fe5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var count = 0\n    for c in\
    \ s {\n        if c == \"(\" {\n            count += 1\n        } else {\n   \
    \         count -= 1\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi6d8k_sy/tmpi6d8k_sy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5060947c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b506063eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b506063e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b506063d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi6d8k_sy                        0x0000560f1e0d1c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b5060b33460 __libc_start_main +
    245

    6    tmpi6d8k_sy                        0x0000560f1e0d13f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    return is_good(str: str) ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmprehcb9hp.swift:20:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str = str1 + str2\n    var count = 0\n    for\
    \ c in str {\n        if c == \"(\" {\n            count += 1\n        } else\
    \ {\n            count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprmc0ul0x/tmprmc0ul0x.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0773bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0770b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0770b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0770b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmc0ul0x                        0x0000556674c17b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ac0775aa460 __libc_start_main +
    245

    6    tmprmc0ul0x                        0x0000556674c172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7z4bs815/tmp7z4bs815.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae515dc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae515abcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae515abc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae515abb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7z4bs815                        0x000055f762d4c6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002ae515fb1460 __libc_start_main +
    245

    6    tmp7z4bs815                        0x000055f762d4c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           count += 1\n            } else {\n                count -= 1\n   \
    \         }\n            if count < 0 {\n                return \"No\"\n     \
    \       }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpkhhigtw1/tmpkhhigtw1.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aabf18dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aabf15d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aabf15d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aabf15d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkhhigtw1                        0x00005593d2efdc36 <unavailable> + 7222

    5    libc.so.6                          0x00002aabf1acb460 __libc_start_main +
    245

    6    tmpkhhigtw1                        0x00005593d2efd399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str1 = lst[0]\n\
    \    var str2 = lst[1]\n    var count = 0\n    for c in str1 {\n        if c ==\
    \ \"(\" {\n            count += 1\n        } else {\n            count -= 1\n\
    \        }\n    }\n    for c in str2 {\n        if c == \"(\" {\n            count\
    \ += 1\n        } else {\n            count -= 1\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpc5ua4hoe/tmpc5ua4hoe.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef16b1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef16815b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef16815988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef168147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc5ua4hoe                        0x000055979cf9d468 <unavailable> + 9320

    5    libc.so.6                          0x00002aef16d0a460 __libc_start_main +
    245

    6    tmpc5ua4hoe                        0x000055979cf9c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for c in str {\n        if c ==\
    \ \"(\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp06rkk8p4/tmp06rkk8p4.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafc503dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafc4d34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafc4d34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafc4d337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06rkk8p4                        0x000055ab5535bda6 <unavailable> + 7590

    5    libc.so.6                          0x00002aafc5229460 __libc_start_main +
    245

    6    tmp06rkk8p4                        0x000055ab5535b509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpnz0l46ft/tmpnz0l46ft.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81ae24cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81adf43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81adf43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81adf427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz0l46ft                        0x0000560b14f37e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b81ae438460 __libc_start_main +
    245

    6    tmpnz0l46ft                        0x0000560b14f375d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.count == 0 {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp11jzy69h/tmp11jzy69h.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0514517c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b051420eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b051420e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b051420d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp11jzy69h                        0x000056059dc39d66 <unavailable> + 7526

    5    libc.so.6                          0x00002b0514703460 __libc_start_main +
    245

    6    tmp11jzy69h                        0x000056059dc394c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afa34622c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa34319561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa34319286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa3431913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa34318bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afa34118fc3 <unavailable> + 188355

    6    tmpmk76owem                        0x0000558630c8ba17 <unavailable> + 10775

    7    tmpmk76owem                        0x0000558630c8a735 <unavailable> + 5941

    8    libc.so.6                          0x00002afa3480e460 __libc_start_main +
    245

    9    tmpmk76owem                        0x0000558630c8a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var s3 = \"\"\n    var s4 = \"\"\n    var s5 = \"\"\n\
    \    var s6 = \"\"\n    var s7 = \"\"\n    var s8 = \"\"\n    var s9 = \"\"\n\
    \    var s10 = \"\"\n    var s11 = \"\"\n    var s12 = \"\"\n    var s13 = \"\"\
    \n    var s14 = \"\"\n    var s15 = \"\"\n    var s16 = \"\"\n    var s17 = \"\
    \"\n    var s18 = \"\"\n    var s19 = \"\"\n    var s20 = \"\"\n    var s21 =\
    \ \"\"\n    var s22 = \"\"\n    var s23 = \"\"\n    var s24 = \"\"\n    var s25\
    \ = \"\"\n    var s26 = \"\"\n    var s27 = \"\"\n    var s28 = \"\"\n    var\
    \ s29 = \"\"\n    var s30 = \"\"\n    var s31 = \"\"\n    var s32 = \"\"\n   \
    \ var s33 = \"\"\n    var s34 = \"\"\n    var s35 = \"\"\n    var s36 = \"\"\n\
    \    var s37 = \"\"\n    var s38 = \"\"\n    var s39 = \"\"\n    var s40 = \"\"\
    \n    var s41 = \"\"\n    var s42 = \"\"\n    var s43 = \"\"\n    var s44 = \"\
    \"\n    var s45 = \"\"\n    var s46 = \"\"\n    var s47 = \"\"\n    var s48 =\
    \ \"\"\n    var s49 = \"\"\n    var s50 = \"\"\n    var s51 = \"\"\n    var s52\
    \ = \"\"\n    var s53 = \"\"\n    var s54 = \"\"\n    var s55 = \"\"\n    var\
    \ s56 = \"\"\n    var s57 = \"\"\n    var s58 = \"\"\n    var s59 = \"\"\n   \
    \ var s60 = \"\"\n    var s61 = \"\"\n    var s62 = \"\"\n    var s63 = \"\"\n\
    \    var s64 = \"\"\n    var s65 = \"\"\n    var s66 = \"\"\n    var s67 = \"\"\
    \n    var s68 = \"\"\n    var s69 = \"\"\n    var s70 = \"\"\n    var s71 = \"\
    \"\n    var s72 = \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpsb8d0js7.swift:16:9: warning: initialization of variable 's1' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ s1 = lst[0]\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:17:9: warning: initialization\
    \ of variable 's2' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s2 = lst[1]\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:18:9:\
    \ warning: initialization of variable 's3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s3 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmpsb8d0js7.swift:19:9: warning: initialization of variable 's4' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s4 =\
    \ \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:20:9: warning: initialization\
    \ of variable 's5' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s5 = \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:21:9:\
    \ warning: initialization of variable 's6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s6 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmpsb8d0js7.swift:22:9: warning: initialization of variable 's7' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s7 =\
    \ \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:23:9: warning: initialization\
    \ of variable 's8' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s8 = \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:24:9:\
    \ warning: initialization of variable 's9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s9 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmpsb8d0js7.swift:25:9: warning: initialization of variable 's10' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s10\
    \ = \"\"\n    ~~~~^~~\n    _\n/tmp/tmpsb8d0js7.swift:26:9: warning: initialization\
    \ of variable 's11' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var s11 = \"\"\n    ~~~~^~~\n    _\n/tmp/tmpsb8d0js7.swift:27:9:\
    \ warning: initialization of variable 's12' was never used; consider re"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let first = lst.removeFirst()\n    let second = lst.removeFirst()\n    let\
    \ first_count = first.count\n    let second_count = second.count\n    let total_count\
    \ = first_count + second_count\n    let first_open = first.filter { $0 == \"(\"\
    \ }.count\n    let first_close = first.filter { $0 == \")\" }.count\n    let second_open\
    \ = second.filter { $0 == \"(\" }.count\n    let second_close = second.filter\
    \ { $0 == \")\" }.count\n    let total_open = first_open + second_open\n    let\
    \ total_close = first_close + second_close\n    if total_count % 2 != 0 {\n  \
    \      return \"No\"\n    } else if total_open != total_close {\n        return\
    \ \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp7ql1ecjj/tmp7ql1ecjj.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba988e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba985dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba985df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba985de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ql1ecjj                        0x0000556f3182b578 <unavailable> + 9592

    5    libc.so.6                          0x00002aba98ad4460 __libc_start_main +
    245

    6    tmp7ql1ecjj                        0x0000556f3182a399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        let\
    \ s = lst.removeFirst()\n        for c in s {\n            if c == \"(\" {\n \
    \               count += 1\n            } else {\n                count -= 1\n\
    \            }\n            if count < 0 {\n                return \"No\"\n  \
    \          }\n        }\n        str += s\n    }\n    return count == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmph7cg8emx/tmph7cg8emx.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc334e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc331d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc331d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc331d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph7cg8emx                        0x0000563ab3cbdc26 <unavailable> + 7206

    5    libc.so.6                          0x00002adc336cd460 __libc_start_main +
    245

    6    tmph7cg8emx                        0x0000563ab3cbd389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp26tvo7e4/tmp26tvo7e4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ad38a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ad359fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ad359f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ad359e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp26tvo7e4                        0x000056239080cda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b4ad3a94460 __libc_start_main +
    245

    6    tmp26tvo7e4                        0x000056239080c509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var count = 0\n    var result = \"Yes\"\n    for i in 0..<lst.count {\n \
    \       for j in 0..<lst[i].count {\n            if lst[i][j] == \"(\" {\n   \
    \             count += 1\n            } else {\n                count -= 1\n \
    \           }\n            if count < 0 {\n                result = \"No\"\n \
    \               break\n            }\n        }\n    }\n    if count != 0 {\n\
    \        result = \"No\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9lb1z8yt.swift:21:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp9lb1z8yt.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var cnt = 0\n    while lst.count > 0 {\n        if lst[0].count\
    \ > 0 {\n            str += lst[0].removeFirst()\n            cnt += str.last\
    \ == \"(\" ? 1 : -1\n        } else {\n            lst.removeFirst()\n       \
    \ }\n        if cnt < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn1wv0sgu.swift:21:27: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            str += lst[0].removeFirst()\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    for str in lst {\n        for char in str {\n            if char == \"(\"\
    \ {\n                stack.append(char)\n            } else {\n              \
    \  if stack.count == 0 {\n                    return \"No\"\n                }\n\
    \                stack.removeLast()\n            }\n        }\n    }\n    return\
    \ stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpwh5xpijr/tmpwh5xpijr.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ff75bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ff72b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ff72b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ff72b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwh5xpijr                        0x000055cd8205ce26 <unavailable> + 7718

    5    libc.so.6                          0x00002b5ff77a9460 __libc_start_main +
    245

    6    tmpwh5xpijr                        0x000055cd8205c589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var c = 0\n    for i in s {\n        if i == \"(\" {\n         \
    \   c += 1\n        } else {\n            c -= 1\n        }\n        if c < 0\
    \ {\n            return \"No\"\n        }\n    }\n    return c == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptl3b9cn5/tmptl3b9cn5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71c1e7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71c1b74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71c1b74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71c1b737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptl3b9cn5                        0x0000561749b17b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b71c2069460 __libc_start_main +
    245

    6    tmptl3b9cn5                        0x0000561749b172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for c in str {\n        if c == \"(\" {\n\
    \            stack.append(c)\n        } else {\n            if stack.isEmpty {\n\
    \                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzm3gg9km/tmpzm3gg9km.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b045c70dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b045c404b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b045c404988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b045c4037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzm3gg9km                        0x000055cc6e492da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b045c8f9460 __libc_start_main +
    245

    6    tmpzm3gg9km                        0x000055cc6e492509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    return is_good(str: str) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptdhvpa5_.swift:27:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.pop()\n        }\n    }\n    for char in lst[1]\
    \ {\n        if char == \"(\" {\n            if stack.isEmpty {\n            \
    \    return \"No\"\n            }\n            stack.pop()\n        } else {\n\
    \            stack.push(char)\n        }\n    }\n    return stack.isEmpty ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpx2l9qb3m.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    while !lst.isEmpty {\n        let s1 = lst.removeFirst()\n\
    \        let s2 = lst.removeFirst()\n        if is_good(s: s1 + s2) {\n      \
    \      s = s1 + s2\n            break\n        } else if is_good(s: s2 + s1) {\n\
    \            s = s2 + s1\n            break\n        }\n    }\n    return is_good(s:\
    \ s) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpj2om_cr7.swift:21:12: error: cannot find 'is_good' in scope\n \
    \       if is_good(s: s1 + s2) {\n           ^~~~~~~\n/tmp/tmpj2om_cr7.swift:24:19:\
    \ error: cannot find 'is_good' in scope\n        } else if is_good(s: s2 + s1)\
    \ {\n                  ^~~~~~~\n/tmp/tmpj2om_cr7.swift:29:12: error: cannot find\
    \ 'is_good' in scope\n    return is_good(s: s) ? \"Yes\" : \"No\"\n          \
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var s = s1 + s2\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp06xzubye/tmp06xzubye.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae865a3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae865736b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae865736988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8657357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06xzubye                        0x0000561f8023bda6 <unavailable> + 7590

    5    libc.so.6                          0x00002ae865c2b460 __libc_start_main +
    245

    6    tmp06xzubye                        0x0000561f8023b509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           stack.append(c)\n            } else {\n                if stack.isEmpty\
    \ {\n                    return \"No\"\n                } else {\n           \
    \         stack.removeLast()\n                }\n            }\n        }\n  \
    \  }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxk7mu1xx/tmpxk7mu1xx.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b483a3e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b483a0d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b483a0d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b483a0d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxk7mu1xx                        0x00005556d4930e26 <unavailable> + 7718

    5    libc.so.6                          0x00002b483a5cd460 __libc_start_main +
    245

    6    tmpxk7mu1xx                        0x00005556d4930589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s1_open = s1.filter { $0 == \"(\" }.count\n    let\
    \ s1_close = s1.filter { $0 == \")\" }.count\n    let s2_open = s2.filter { $0\
    \ == \"(\" }.count\n    let s2_close = s2.filter { $0 == \")\" }.count\n    if\
    \ s1_open == s1_close && s2_open == s2_close {\n        return \"Yes\"\n    }\n\
    \    if s1_open == s1_close && s2_open < s2_close {\n        return \"Yes\"\n\
    \    }\n    if s1_open < s1_close && s2_open == s2_close {\n        return \"\
    Yes\"\n    }\n    if s1_open < s1_close && s2_open < s2_close {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp70y3yu4s/tmp70y3yu4s.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10bd798c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10bd48fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10bd48f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10bd48e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp70y3yu4s                        0x0000564f75d416d6 <unavailable> + 5846

    5    libc.so.6                          0x00002b10bd984460 __libc_start_main +
    245

    6    tmp70y3yu4s                        0x0000564f75d412b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = [Character]()\n    for c in str {\n        if c == \"(\"\
    \ {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpmdx5etke/tmpmdx5etke.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84a0d3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84a0a36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84a0a36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84a0a357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmdx5etke                        0x000055fbafe56f86 <unavailable> + 8070

    5    libc.so.6                          0x00002b84a0f2b460 __libc_start_main +
    245

    6    tmpmdx5etke                        0x000055fbafe566e9 <unavailable> + 5865

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           count += 1\n            } else {\n                count -= 1\n   \
    \         }\n            if count < 0 {\n                return \"No\"\n     \
    \       }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpkhhigtw1/tmpkhhigtw1.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aabf18dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aabf15d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aabf15d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aabf15d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkhhigtw1                        0x00005593d2efdc36 <unavailable> + 7222

    5    libc.so.6                          0x00002aabf1acb460 __libc_start_main +
    245

    6    tmpkhhigtw1                        0x00005593d2efd399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        str\
    \ = lst.removeFirst()\n        for char in str {\n            if char == \"(\"\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if count < 0 {\n                return \"No\"\n\
    \            }\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmph105uzra/tmph105uzra.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0ee82dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0ee524b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0ee524988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0ee5237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph105uzra                        0x000055bdacbaabc6 <unavailable> + 7110

    5    libc.so.6                          0x00002ae0eea19460 __libc_start_main +
    245

    6    tmph105uzra                        0x000055bdacbaa329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8ws5mxq_/tmp8ws5mxq_.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2cf4de2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2cf4ad9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2cf4ad9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2cf4ad87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ws5mxq_                        0x000055d46ca18468 <unavailable> + 9320

    5    libc.so.6                          0x00002b2cf4fce460 __libc_start_main +
    245

    6    tmp8ws5mxq_                        0x000055d46ca17289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s1_count = s1.count\n    let s2_count = s2.count\n\
    \    var s1_open = 0\n    var s2_open = 0\n    var s1_close = 0\n    var s2_close\
    \ = 0\n    for c in s1 {\n        if c == \"(\" {\n            s1_open += 1\n\
    \        } else {\n            s1_close += 1\n        }\n    }\n    for c in s2\
    \ {\n        if c == \"(\" {\n            s2_open += 1\n        } else {\n   \
    \         s2_close += 1\n        }\n    }\n    if s1_open + s2_open == s1_close\
    \ + s2_close {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmplwpd6pzh/tmplwpd6pzh.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fe5c47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fe593eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fe593e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fe593d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplwpd6pzh                        0x0000560d21da24b8 <unavailable> + 9400

    5    libc.so.6                          0x00002b6fe5e33460 __libc_start_main +
    245

    6    tmplwpd6pzh                        0x0000560d21da12d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for i in lst[0] {\n        if i == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for i in lst[1] {\n        if i == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpgt45tra0/tmpgt45tra0.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2a3f4dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2a3c44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2a3c44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2a3c437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgt45tra0                        0x000055edc201f468 <unavailable> + 9320

    5    libc.so.6                          0x00002af2a4139460 __libc_start_main +
    245

    6    tmpgt45tra0                        0x000055edc201e289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for char in str {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else {\n            if\
    \ stack.isEmpty {\n                return \"No\"\n            } else {\n     \
    \           stack.removeLast()\n            }\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpnscc8nut/tmpnscc8nut.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b85f618dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b85f5e84b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b85f5e84988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85f5e837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnscc8nut                        0x0000562b71244da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b85f6379460 __libc_start_main +
    245

    6    tmpnscc8nut                        0x0000562b71244509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = \"\"\n    for s in lst {\n        str += s\n    }\n    for c in\
    \ str {\n        if c == \"(\" {\n            stack.append(c)\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   } else {\n                stack.removeLast()\n            }\n        }\n \
    \   }\n    if stack.isEmpty {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzjwmovt3/tmpzjwmovt3.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2be3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2be0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2be0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2be0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzjwmovt3                        0x000055f86b02fe76 <unavailable> + 7798

    5    libc.so.6                          0x00002ba2be5c9460 __libc_start_main +
    245

    6    tmpzjwmovt3                        0x000055f86b02f5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var count = 0\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == \"(\" {\n                count += 1\n       \
    \     } else {\n                count -= 1\n            }\n            if count\
    \ < 0 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5qg8yqe.swift:20:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy5qg8yqe.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    var c = 0\n    var d = 0\n    for i in 0..<lst.count {\n\
    \        s += lst[i]\n        for j in 0..<lst[i].count {\n            if lst[i][j]\
    \ == \"(\" {\n                c += 1\n            } else {\n                d\
    \ += 1\n            }\n        }\n    }\n    if c == d {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmppietdqo3.swift:23:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmppietdqo3.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        let s = lst.removeFirst()\n\
    \        str += s\n        if !is_good(str: str) {\n            str = \"\"\n \
    \           if lst.count > 0 {\n                str += lst.removeFirst()\n   \
    \         }\n        }\n    }\n    return is_good(str: str) ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpupsf5znz.swift:21:13: error: cannot find 'is_good' in scope\n \
    \       if !is_good(str: str) {\n            ^~~~~~~\n/tmp/tmpupsf5znz.swift:28:12:\
    \ error: cannot find 'is_good' in scope\n    return is_good(str: str) ? \"Yes\"\
    \ : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    while !lst.isEmpty {\n        let s1 = lst.removeFirst()\n\
    \        let s2 = lst.removeFirst()\n        if is_good(s: s1 + s2) {\n      \
    \      s = s1 + s2\n            break\n        } else if is_good(s: s2 + s1) {\n\
    \            s = s2 + s1\n            break\n        }\n    }\n    return is_good(s:\
    \ s) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpj2om_cr7.swift:21:12: error: cannot find 'is_good' in scope\n \
    \       if is_good(s: s1 + s2) {\n           ^~~~~~~\n/tmp/tmpj2om_cr7.swift:24:19:\
    \ error: cannot find 'is_good' in scope\n        } else if is_good(s: s2 + s1)\
    \ {\n                  ^~~~~~~\n/tmp/tmpj2om_cr7.swift:29:12: error: cannot find\
    \ 'is_good' in scope\n    return is_good(s: s) ? \"Yes\" : \"No\"\n          \
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcd2p1n8z.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_str = \"\"\n    for i in 0..<lst.count {\n        lst_str += lst[i]\n\
    \    }\n    var stack = Stack<Character>()\n    for char in lst_str {\n      \
    \  if char == \"(\" {\n            stack.push(char)\n        } else if char ==\
    \ \")\" {\n            if stack.isEmpty() {\n                return \"No\"\n \
    \           } else {\n                stack.pop()\n            }\n        }\n\
    \    }\n    if stack.isEmpty() {\n        return \"Yes\"\n    } else {\n     \
    \   return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ocj3azt.swift:21:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var stack = [Character]()\n    for c in s {\n        if c == \"\
    (\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpyqwqjz8f/tmpyqwqjz8f.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2a6b62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2a6859b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2a6859988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2a68587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyqwqjz8f                        0x000055abe5f57da6 <unavailable> + 7590

    5    libc.so.6                          0x00002ad2a6d4e460 __libc_start_main +
    245

    6    tmpyqwqjz8f                        0x000055abe5f57509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpnz0l46ft/tmpnz0l46ft.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81ae24cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81adf43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81adf43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81adf427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz0l46ft                        0x0000560b14f37e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b81ae438460 __libc_start_main +
    245

    6    tmpnz0l46ft                        0x0000560b14f375d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var count = 0\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == \"(\" {\n                count += 1\n       \
    \     } else {\n                count -= 1\n            }\n            if count\
    \ < 0 {\n                result = \"No\"\n                break\n            }\n\
    \        }\n    }\n    if count != 0 {\n        result = \"No\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyhmw_byb.swift:20:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    while lst.count > 0 {\n        str\
    \ += lst.removeFirst()\n        for char in str {\n            if char == \"(\"\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if count < 0 {\n                return \"No\"\n\
    \            }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpavwsm_8o/tmpavwsm_8o.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5dc7578c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5dc726fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5dc726f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5dc726e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpavwsm_8o                        0x00005565cb2a87a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b5dc7764460 __libc_start_main +
    245

    6    tmpavwsm_8o                        0x00005565cb2a8389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpiuase0pe/tmpiuase0pe.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb33fe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb33ce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb33ce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb33cdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiuase0pe                        0x0000562b8725ac96 <unavailable> + 7318

    5    libc.so.6                          0x00002aeb341d5460 __libc_start_main +
    245

    6    tmpiuase0pe                        0x0000562b8725a3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        str += lst.removeFirst()\n\
    \        if str.count > 0 {\n            if str.last == \")\" {\n            \
    \    if str.contains(\"(\") {\n                    str.removeLast()\n        \
    \            str.removeLast()\n                } else {\n                    return\
    \ \"No\"\n                }\n            }\n        }\n    }\n    if str.count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpa5mrvy96/tmpa5mrvy96.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0caa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b0c79ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b0c79a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b0c7997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa5mrvy96                        0x000055d1748d1956 <unavailable> + 6486

    5    libc.so.6                          0x00002b6b0cc8f460 __libc_start_main +
    245

    6    tmpa5mrvy96                        0x000055d1748d1539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    var i = 0\n    while i < lst.count {\n        if lst[i].count\
    \ == 0 {\n            lst.remove(at: i)\n        } else {\n            i += 1\n\
    \        }\n    }\n    if lst.count == 0 {\n        return \"Yes\"\n    }\n  \
    \  if lst.count == 1 {\n        return \"No\"\n    }\n    if lst[0].count == 0\
    \ {\n        return match_parens(lst: [lst[1]])\n    }\n    if lst[1].count ==\
    \ 0 {\n        return match_parens(lst: [lst[0]])\n    }\n    if lst[0].first!\
    \ == \"(\" {\n        s = lst[0] + lst[1]\n    } else {\n        s = lst[1] +\
    \ lst[0]\n    }\n    if is_good(s: s) {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptxzxmevr.swift:43:8: error: cannot find 'is_good' in scope\n  \
    \  if is_good(s: s) {\n       ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcd2p1n8z.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpnz0l46ft/tmpnz0l46ft.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81ae24cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81adf43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81adf43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81adf427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz0l46ft                        0x0000560b14f37e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b81ae438460 __libc_start_main +
    245

    6    tmpnz0l46ft                        0x0000560b14f375d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var stack = Stack<Character>()\n    for str in lst {\n        for char\
    \ in str {\n            if char == \"(\" {\n                stack.push(char)\n\
    \            } else {\n                if stack.isEmpty {\n                  \
    \  result = \"No\"\n                    break\n                } else {\n    \
    \                stack.pop()\n                }\n            }\n        }\n  \
    \  }\n    if !stack.isEmpty {\n        result = \"No\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_2bzjfsq.swift:17:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var c = 0\n    for ch in s\
    \ {\n        if ch == \"(\" {\n            c += 1\n        } else {\n        \
    \    c -= 1\n        }\n        if c < 0 {\n            return \"No\"\n      \
    \  }\n    }\n    return c == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9of40x94/tmp9of40x94.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad842cb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8429b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8429b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8429af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9of40x94                        0x000055df582cdc96 <unavailable> + 7318

    5    libc.so.6                          0x00002ad842ea5460 __libc_start_main +
    245

    6    tmp9of40x94                        0x000055df582cd3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var count = 0\n    for c in\
    \ s {\n        if c == \"(\" {\n            count += 1\n        } else {\n   \
    \         count -= 1\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi6d8k_sy/tmpi6d8k_sy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5060947c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b506063eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b506063e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b506063d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi6d8k_sy                        0x0000560f1e0d1c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b5060b33460 __libc_start_main +
    245

    6    tmpi6d8k_sy                        0x0000560f1e0d13f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var s3 = \"\"\n    var s4 = \"\"\n    var s5 = \"\"\n\
    \    var s6 = \"\"\n    var s7 = \"\"\n    var s8 = \"\"\n    var s9 = \"\"\n\
    \    var s10 = \"\"\n    var s11 = \"\"\n    var s12 = \"\"\n    var s13 = \"\"\
    \n    var s14 = \"\"\n    var s15 = \"\"\n    var s16 = \"\"\n    var s17 = \"\
    \"\n    var s18 = \"\"\n    var s19 = \"\"\n    var s20 = \"\"\n    var s21 =\
    \ \"\"\n    var s22 = \"\"\n    var s23 = \"\"\n    var s24 = \"\"\n    var s25\
    \ = \"\"\n    var s26 = \"\"\n    var s27 = \"\"\n    var s28 = \"\"\n    var\
    \ s29 = \"\"\n    var s30 = \"\"\n    var s31 = \"\"\n    var s32 = \"\"\n   \
    \ var s33 = \"\"\n    var s34 = \"\"\n    var s35 = \"\"\n    var s36 = \"\"\n\
    \    var s37 = \"\"\n    var s38 = \"\"\n    var s39 = \"\"\n    var s40 = \"\"\
    \n    var s41 = \"\"\n    var s42 = \"\"\n    var s43 = \"\"\n    var s44 = \"\
    \"\n    var s45 = \"\"\n    var s46 = \"\"\n    var s47 = \"\"\n    var s48 =\
    \ \"\"\n    var s49 = \"\"\n    var s50 = \"\"\n    var s51 = \"\"\n    var s52\
    \ = \"\"\n    var s53 = \"\"\n    var s54 = \"\"\n    var s55 = \"\"\n    var\
    \ s56 = \"\"\n    var s57 = \"\"\n    var s58 = \"\"\n    var s59 = \"\"\n   \
    \ var s60 = \"\"\n    var s61 = \"\"\n    var s62 = \"\"\n    var s63 = \"\"\n\
    \    var s64 = \"\"\n    var s65 = \"\"\n    var s66 = \"\"\n    var s67 = \"\"\
    \n    var s68 = \"\"\n    var s69 = \"\"\n    var s70 = \"\"\n    var s71 = \"\
    \"\n    var s72 = \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpsb8d0js7.swift:16:9: warning: initialization of variable 's1' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ s1 = lst[0]\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:17:9: warning: initialization\
    \ of variable 's2' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s2 = lst[1]\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:18:9:\
    \ warning: initialization of variable 's3' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s3 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmpsb8d0js7.swift:19:9: warning: initialization of variable 's4' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s4 =\
    \ \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:20:9: warning: initialization\
    \ of variable 's5' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s5 = \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:21:9:\
    \ warning: initialization of variable 's6' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s6 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmpsb8d0js7.swift:22:9: warning: initialization of variable 's7' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s7 =\
    \ \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:23:9: warning: initialization\
    \ of variable 's8' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var s8 = \"\"\n    ~~~~^~\n    _\n/tmp/tmpsb8d0js7.swift:24:9:\
    \ warning: initialization of variable 's9' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var s9 = \"\"\n    ~~~~^~\n    _\n\
    /tmp/tmpsb8d0js7.swift:25:9: warning: initialization of variable 's10' was never\
    \ used; consider replacing with assignment to '_' or removing it\n    var s10\
    \ = \"\"\n    ~~~~^~~\n    _\n/tmp/tmpsb8d0js7.swift:26:9: warning: initialization\
    \ of variable 's11' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var s11 = \"\"\n    ~~~~^~~\n    _\n/tmp/tmpsb8d0js7.swift:27:9:\
    \ warning: initialization of variable 's12' was never used; consider re"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afa34622c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa34319561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa34319286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa3431913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa34318bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afa34118fc3 <unavailable> + 188355

    6    tmpmk76owem                        0x0000558630c8ba17 <unavailable> + 10775

    7    tmpmk76owem                        0x0000558630c8a735 <unavailable> + 5941

    8    libc.so.6                          0x00002afa3480e460 __libc_start_main +
    245

    9    tmpmk76owem                        0x0000558630c8a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = \"\"\n    for s in lst {\n        for c in s {\n            if\
    \ c == \"(\" {\n                stack.append(c)\n            } else {\n      \
    \          if stack.count > 0 {\n                    stack.removeLast()\n    \
    \            } else {\n                    str += \")\"\n                }\n \
    \           }\n        }\n    }\n    if stack.count > 0 {\n        str = String(stack)\
    \ + str\n    }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n\
    \            count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqx43bv5v/tmpqx43bv5v.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57d4be9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57d48e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57d48e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57d48df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqx43bv5v                        0x000055b604e53562 <unavailable> + 9570

    5    libc.so.6                          0x00002b57d4dd5460 __libc_start_main +
    245

    6    tmpqx43bv5v                        0x000055b604e52699 <unavailable> + 5785

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           stack.append(c)\n            } else {\n                if stack.isEmpty\
    \ {\n                    return \"No\"\n                }\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpeu85bexj/tmpeu85bexj.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b408e287c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b408df7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b408df7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b408df7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeu85bexj                        0x0000558178a9de26 <unavailable> + 7718

    5    libc.so.6                          0x00002b408e473460 __libc_start_main +
    245

    6    tmpeu85bexj                        0x0000558178a9d589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7z4bs815/tmp7z4bs815.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae515dc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae515abcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae515abc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae515abb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7z4bs815                        0x000055f762d4c6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002ae515fb1460 __libc_start_main +
    245

    6    tmp7z4bs815                        0x000055f762d4c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for s in lst {\n        for c in s {\n            if c\
    \ == \"(\" {\n                open += 1\n            } else {\n              \
    \  close += 1\n            }\n        }\n    }\n    return open == close ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzdvvjibz/tmpzdvvjibz.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58703cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58700c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58700c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58700c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzdvvjibz                        0x0000557c2d802578 <unavailable> + 9592

    5    libc.so.6                          0x00002b58705b6460 __libc_start_main +
    245

    6    tmpzdvvjibz                        0x0000557c2d801399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp26tvo7e4/tmp26tvo7e4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ad38a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ad359fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ad359f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ad359e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp26tvo7e4                        0x000056239080cda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b4ad3a94460 __libc_start_main +
    245

    6    tmp26tvo7e4                        0x000056239080c509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            s += lst[0]\n            lst.remove(at: 0)\n        } else {\n\
    \            s += lst[1]\n            lst.remove(at: 1)\n        }\n    }\n  \
    \  return is_good(s: s) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptb87e3xl.swift:27:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(s: s) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var count = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            count += 1\n        } else {\n \
    \           count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpiuase0pe/tmpiuase0pe.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb33fe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb33ce0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb33ce0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb33cdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiuase0pe                        0x0000562b8725ac96 <unavailable> + 7318

    5    libc.so.6                          0x00002aeb341d5460 __libc_start_main +
    245

    6    tmpiuase0pe                        0x0000562b8725a3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for ch in s {\n        if ch == \"(\" {\n            stack.append(ch)\n \
    \       } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpov0owos8/tmpov0owos8.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad500ae5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5007dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5007dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5007db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpov0owos8                        0x00005580e26b3e76 <unavailable> + 7798

    5    libc.so.6                          0x00002ad500cd1460 __libc_start_main +
    245

    6    tmpov0owos8                        0x00005580e26b35d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n       \
    \     cnt += 1\n        } else {\n            cnt -= 1\n        }\n        if\
    \ cnt < 0 {\n            return \"No\"\n        }\n    }\n    return cnt == 0\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp64e5m5ws/tmp64e5m5ws.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0653123c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0652e1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0652e1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0652e197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64e5m5ws                        0x000055dd8b8f5b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b065330f460 __libc_start_main +
    245

    6    tmp64e5m5ws                        0x000055dd8b8f52d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var s = \"\"\n    var count = 0\n    for c in s1 {\n\
    \        s.append(c)\n        if c == \"(\" {\n            count += 1\n      \
    \  } else {\n            count -= 1\n        }\n        if count < 0 {\n     \
    \       return \"No\"\n        }\n    }\n    for c in s2 {\n        s.append(c)\n\
    \        if c == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmph9ltx7em/tmph9ltx7em.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d09cf1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d099e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d099e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d099e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph9ltx7em                        0x00005585f4b01b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b8d09edd460 __libc_start_main +
    245

    6    tmph9ltx7em                        0x00005585f4b012d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var count = 0\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == \"(\" {\n                count += 1\n       \
    \     } else {\n                count -= 1\n            }\n            if count\
    \ < 0 {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5qg8yqe.swift:20:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy5qg8yqe.swift:16:9: warning: variable\
    \ 'lst' was never mutated; consider changing to 'let' constant\n    var lst =\
    \ lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8ws5mxq_/tmp8ws5mxq_.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2cf4de2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2cf4ad9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2cf4ad9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2cf4ad87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ws5mxq_                        0x000055d46ca18468 <unavailable> + 9320

    5    libc.so.6                          0x00002b2cf4fce460 __libc_start_main +
    245

    6    tmp8ws5mxq_                        0x000055d46ca17289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for i in lst[0] {\n        if i == \"(\" {\n            count += 1\n    \
    \    } else {\n            count -= 1\n        }\n    }\n    for i in lst[1] {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n\
    \    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmphrvsrv79/tmphrvsrv79.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b573c4dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b573c1d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b573c1d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b573c1d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphrvsrv79                        0x0000559b39111468 <unavailable> + 9320

    5    libc.so.6                          0x00002b573c6cb460 __libc_start_main +
    245

    6    tmphrvsrv79                        0x0000559b39110289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    while !lst.isEmpty {\n        let str = lst.removeFirst()\n\
    \        if str.isEmpty {\n            continue\n        }\n        if str.first!\
    \ == \")\" {\n            s = str + s\n        } else {\n            s += str\n\
    \        }\n    }\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n\
    \            cnt += 1\n        } else {\n            cnt -= 1\n        }\n   \
    \     if cnt < 0 {\n            return \"No\"\n        }\n    }\n    return cnt\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpwtv298s3/tmpwtv298s3.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a66060c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a65d57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a65d57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a65d567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwtv298s3                        0x0000562e724a29a6 <unavailable> + 6566

    5    libc.so.6                          0x00002b6a6624c460 __libc_start_main +
    245

    6    tmpwtv298s3                        0x0000562e724a2589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lhs = lst[0]\n\
    \    var rhs = lst[1]\n    var lhs_open = 0\n    var rhs_open = 0\n    for char\
    \ in lhs {\n        if char == \"(\" {\n            lhs_open += 1\n        } else\
    \ {\n            lhs_open -= 1\n        }\n    }\n    for char in rhs {\n    \
    \    if char == \"(\" {\n            rhs_open += 1\n        } else {\n       \
    \     rhs_open -= 1\n        }\n    }\n    if lhs_open == 0 && rhs_open == 0 {\n\
    \        return \"Yes\"\n    } else if lhs_open > 0 && rhs_open < 0 && lhs_open\
    \ + rhs_open == 0 {\n        return \"Yes\"\n    } else if lhs_open < 0 && rhs_open\
    \ > 0 && lhs_open + rhs_open == 0 {\n        return \"Yes\"\n    } else {\n  \
    \      return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpch41hnho/tmpch41hnho.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b879f33ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b879f031b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b879f031988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b879f0307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpch41hnho                        0x00005599a42bd468 <unavailable> + 9320

    5    libc.so.6                          0x00002b879f526460 __libc_start_main +
    245

    6    tmpch41hnho                        0x00005599a42bc289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var c = 0\n    for i in s {\n        if i == \"(\" {\n         \
    \   c += 1\n        } else {\n            c -= 1\n        }\n        if c < 0\
    \ {\n            return \"No\"\n        }\n    }\n    return c == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmptl3b9cn5/tmptl3b9cn5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71c1e7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71c1b74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71c1b74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71c1b737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptl3b9cn5                        0x0000561749b17b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b71c2069460 __libc_start_main +
    245

    6    tmptl3b9cn5                        0x0000561749b172d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgtxoj_p.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbgtxoj_p.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var str1_open = 0\n    var str2_open = 0\n    for\
    \ char in str1 {\n        if char == \"(\" {\n            str1_open += 1\n   \
    \     } else {\n            str1_open -= 1\n        }\n    }\n    for char in\
    \ str2 {\n        if char == \"(\" {\n            str2_open += 1\n        } else\
    \ {\n            str2_open -= 1\n        }\n    }\n    if str1_open == 0 && str2_open\
    \ == 0 {\n        return \"Yes\"\n    } else if str1_open == 0 && str2_open <\
    \ 0 {\n        return \"Yes\"\n    } else if str1_open < 0 && str2_open == 0 {\n\
    \        return \"Yes\"\n    } else if str1_open < 0 && str2_open < 0 {\n    \
    \    if str1_open + str2_open == 0 {\n            return \"Yes\"\n        } else\
    \ {\n            return \"No\"\n        }\n    } else {\n        return \"No\"\
    \n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpr629imib/tmpr629imib.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e5a886c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e5a57db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e5a57d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e5a57c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr629imib                        0x0000561b7e05b6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b8e5aa72460 __libc_start_main +
    245

    6    tmpr629imib                        0x0000561b7e05b289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst1 = lst[0]\n    var lst2 = lst[1]\n    var lst3 = lst1 + lst2\n  \
    \  var count = 0\n    for i in lst3 {\n        if i == \"(\" {\n            count\
    \ += 1\n        } else {\n            count -= 1\n        }\n        if count\
    \ < 0 {\n            return \"No\"\n        }\n    }\n    if count == 0 {\n  \
    \      return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbs5u7tsk/tmpbs5u7tsk.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b669433ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6694031b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6694031988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66940307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbs5u7tsk                        0x000055e5d5939b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b6694526460 __libc_start_main +
    245

    6    tmpbs5u7tsk                        0x000055e5d59392d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var str = \"\"\n    for s in lst {\n        str += s\n    }\n    for c in\
    \ str {\n        if c == \"(\" {\n            stack.push(c)\n        } else {\n\
    \            if stack.isEmpty() {\n                return \"No\"\n           \
    \ } else {\n                stack.pop()\n            }\n        }\n    }\n   \
    \ if stack.isEmpty() {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2r8v7bcw.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var stack = Stack<Character>()\n    for str in lst {\n        for char\
    \ in str {\n            if char == \"(\" {\n                stack.push(char)\n\
    \            } else {\n                if stack.isEmpty {\n                  \
    \  result = \"No\"\n                    break\n                } else {\n    \
    \                stack.pop()\n                }\n            }\n        }\n  \
    \  }\n    if !stack.isEmpty {\n        result = \"No\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_2bzjfsq.swift:17:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = lst.removeFirst()\n    while !lst.isEmpty {\n        let next =\
    \ lst.removeFirst()\n        if str.last == \"(\" && next.first == \")\" {\n \
    \           str.removeLast()\n            str.append(next)\n        } else {\n\
    \            str.append(next)\n        }\n    }\n    return str.isEmpty ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6n778aat/tmp6n778aat.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac5f55d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac5f52cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac5f52cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5f52cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6n778aat                        0x000055a8b1905946 <unavailable> + 6470

    5    libc.so.6                          0x00002ac5f57c2460 __libc_start_main +
    245

    6    tmp6n778aat                        0x000055a8b1905529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.append(char)\n\
    \        } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    for char\
    \ in lst[1] {\n        if char == \"(\" {\n            stack.append(char)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmptyxy_xil/tmptyxy_xil.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7dc339c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7dc030b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7dc030988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7dc02f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptyxy_xil                        0x0000556edd268d46 <unavailable> + 7494

    5    libc.so.6                          0x00002ac7dc525460 __libc_start_main +
    245

    6    tmptyxy_xil                        0x0000556edd2684a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_str = lst.joined()\n    while lst_str.contains(\"()\") {\n      \
    \  lst_str = lst_str.replacingOccurrences(of: \"()\", with: \"\")\n    }\n   \
    \ return lst_str.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9xunsu1e.swift:19:27: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        lst_str = lst_str.replacingOccurrences(of: \"\
    ()\", with: \"\")\n                  ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for str in lst {\n        for char in str {\n            if char == \"(\"\
    \ {\n                stack.push(char)\n            } else {\n                if\
    \ stack.isEmpty() {\n                    return \"No\"\n                } else\
    \ {\n                    stack.pop()\n                }\n            }\n     \
    \   }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m3hm3ng.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    for i in 0..<lst.count {\n        str += lst[i]\n   \
    \ }\n    var stack = Stack<Character>()\n    for c in str {\n        if c == \"\
    (\" {\n            stack.push(c)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpeo530c72.swift:21:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var count = 0\n    for c in\
    \ s {\n        if c == \"(\" {\n            count += 1\n        } else {\n   \
    \         count -= 1\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi6d8k_sy/tmpi6d8k_sy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5060947c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b506063eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b506063e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b506063d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi6d8k_sy                        0x0000560f1e0d1c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b5060b33460 __libc_start_main +
    245

    6    tmpi6d8k_sy                        0x0000560f1e0d13f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var stack = Stack<Character>()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.push(c)\n      \
    \  } else {\n            if stack.isEmpty {\n                return \"No\"\n \
    \           }\n            stack.pop()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcw4lg_8z.swift:19:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    return stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9agzisd8/tmp9agzisd8.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b932fe13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b932fb0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b932fb0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b932fb097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9agzisd8                        0x000056187c4ece76 <unavailable> + 7798

    5    libc.so.6                          0x00002b932ffff460 __libc_start_main +
    245

    6    tmp9agzisd8                        0x000056187c4ec5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var s = \"\"\n    for i in 0..<lst.count {\n        s += lst[i]\n    }\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.push(c)\n      \
    \  } else {\n            if stack.isEmpty() {\n                return \"No\"\n\
    \            } else {\n                stack.pop()\n            }\n        }\n\
    \    }\n    if stack.isEmpty() {\n        return \"Yes\"\n    } else {\n     \
    \   return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp16n_3h5t.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpnz0l46ft/tmpnz0l46ft.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81ae24cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81adf43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81adf43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81adf427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz0l46ft                        0x0000560b14f37e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b81ae438460 __libc_start_main +
    245

    6    tmpnz0l46ft                        0x0000560b14f375d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var s = s1 + s2\n    var count = 0\n    for c in s {\n\
    \        if c == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    s =\
    \ s2 + s1\n    count = 0\n    for c in s {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4t__w6kr/tmp4t__w6kr.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31b93bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31b90b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31b90b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31b90b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4t__w6kr                        0x0000562cd0c2bb76 <unavailable> + 7030

    5    libc.so.6                          0x00002b31b95a9460 __libc_start_main +
    245

    6    tmp4t__w6kr                        0x0000562cd0c2b2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    return is_good(str: str) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptdhvpa5_.swift:27:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(str: str) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.isEmpty {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphseb3w8q/tmphseb3w8q.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c675b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c672adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c672ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c672ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphseb3w8q                        0x0000563fce3e0e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b2c677a2460 __libc_start_main +
    245

    6    tmphseb3w8q                        0x0000563fce3e05d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          } else {\n                stack.removeLast()\n            }\n     \
    \   }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8uv9iuqx/tmp8uv9iuqx.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1fe9ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1fe6d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1fe6d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1fe6d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uv9iuqx                        0x000055fa051fee76 <unavailable> + 7798

    5    libc.so.6                          0x00002ae1febc9460 __libc_start_main +
    245

    6    tmp8uv9iuqx                        0x000055fa051fe5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.isEmpty() {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.isEmpty() {\n   \
    \             return \"No\"\n            }\n            stack.pop()\n        }\
    \ else {\n            stack.push(char)\n        }\n    }\n    return stack.isEmpty()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcd2p1n8z.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        open += 1\n        } else {\n            close += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            open += 1\n\
    \        } else {\n            close += 1\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpmikwc4sg/tmpmikwc4sg.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2518cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace24e83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace24e83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace24e827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmikwc4sg                        0x000055ced408f468 <unavailable> + 9320

    5    libc.so.6                          0x00002ace25378460 __libc_start_main +
    245

    6    tmpmikwc4sg                        0x000055ced408e289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var str = \"\"\n    var count = 0\n    for char in\
    \ str1 {\n        if char == \"(\" {\n            count += 1\n        } else {\n\
    \            count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    for char in str2 {\n        if char == \"(\" {\n\
    \            count += 1\n        } else {\n            count -= 1\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfkv333bv/tmpfkv333bv.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33290e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3328de0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3328de0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3328ddf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfkv333bv                        0x000055f82189cb26 <unavailable> + 6950

    5    libc.so.6                          0x00002b33292d5460 __libc_start_main +
    245

    6    tmpfkv333bv                        0x000055f82189c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = \"\"\n    for s in lst {\n        str += s\n    }\n    for c in\
    \ str {\n        if c == \"(\" {\n            stack.append(c)\n        } else\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   } else {\n                stack.removeLast()\n            }\n        }\n \
    \   }\n    if stack.isEmpty {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzjwmovt3/tmpzjwmovt3.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2be3ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2be0d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2be0d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2be0d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzjwmovt3                        0x000055f86b02fe76 <unavailable> + 7798

    5    libc.so.6                          0x00002ba2be5c9460 __libc_start_main +
    245

    6    tmpzjwmovt3                        0x000055f86b02f5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    return stack.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9agzisd8/tmp9agzisd8.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b932fe13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b932fb0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b932fb0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b932fb097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9agzisd8                        0x000056187c4ece76 <unavailable> + 7798

    5    libc.so.6                          0x00002b932ffff460 __libc_start_main +
    245

    6    tmp9agzisd8                        0x000056187c4ec5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var first = lst.removeFirst()\n    var second = lst.removeFirst()\n    var\
    \ first_count = 0\n    var second_count = 0\n    for char in first {\n       \
    \ if char == \"(\" {\n            first_count += 1\n        } else {\n       \
    \     first_count -= 1\n        }\n    }\n    for char in second {\n        if\
    \ char == \"(\" {\n            second_count += 1\n        } else {\n         \
    \   second_count -= 1\n        }\n    }\n    if first_count + second_count ==\
    \ 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpb6lzbqrv/tmpb6lzbqrv.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee9ce89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee9cb80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee9cb80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee9cb7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb6lzbqrv                        0x0000559a484b94a8 <unavailable> + 9384

    5    libc.so.6                          0x00002aee9d075460 __libc_start_main +
    245

    6    tmpb6lzbqrv                        0x0000559a484b82c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while !lst.isEmpty {\n        let s = lst.removeFirst()\n\
    \        if s.count == 1 {\n            str += s\n        } else {\n         \
    \   str += s.prefix(1)\n            lst.append(String(s.suffix(s.count - 1)))\n\
    \        }\n    }\n    var count = 0\n    for c in str {\n        if c == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpk3kz2h1q/tmpk3kz2h1q.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b078b77cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b078b473b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b078b473988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b078b4727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk3kz2h1q                        0x0000555fe947fb36 <unavailable> + 6966

    5    libc.so.6                          0x00002b078b968460 __libc_start_main +
    245

    6    tmpk3kz2h1q                        0x0000555fe947f719 <unavailable> + 5913

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgtxoj_p.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbgtxoj_p.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var stack = Stack<Character>()\n    for c in str1\
    \ {\n        if c == \"(\" {\n            stack.push(c)\n        } else {\n  \
    \          if stack.isEmpty() {\n                return \"No\"\n            }\n\
    \            stack.pop()\n        }\n    }\n    for c in str2 {\n        if c\
    \ == \"(\" {\n            stack.push(c)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            }\n            stack.pop()\n \
    \       }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpdxo3_tqa.swift:18:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp45lg3o4_/tmp45lg3o4_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab71855dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab718254b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab718254988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7182537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp45lg3o4_                        0x000055b0fd9d6b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab718749460 __libc_start_main +
    245

    6    tmp45lg3o4_                        0x000055b0fd9d62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var count = 0\n    for str in lst {\n        for char in str {\n  \
    \          if char == \"(\" {\n                count += 1\n            } else\
    \ {\n                count -= 1\n            }\n            if count < 0 {\n \
    \               result = \"No\"\n                break\n            }\n      \
    \  }\n    }\n    if count != 0 {\n        result = \"No\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpx_vcy6vf/tmpx_vcy6vf.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a8ce13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a8cb0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a8cb0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a8cb097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx_vcy6vf                        0x00005612e6964c36 <unavailable> + 7222

    5    libc.so.6                          0x00002b9a8cfff460 __libc_start_main +
    245

    6    tmpx_vcy6vf                        0x00005612e6964399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n       \
    \     cnt += 1\n        } else {\n            cnt -= 1\n        }\n        if\
    \ cnt < 0 {\n            return \"No\"\n        }\n    }\n    return cnt == 0\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp64e5m5ws/tmp64e5m5ws.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0653123c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0652e1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0652e1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0652e197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64e5m5ws                        0x000055dd8b8f5b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b065330f460 __libc_start_main +
    245

    6    tmp64e5m5ws                        0x000055dd8b8f52d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp45lg3o4_/tmp45lg3o4_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab71855dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab718254b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab718254988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7182537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp45lg3o4_                        0x000055b0fd9d6b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab718749460 __libc_start_main +
    245

    6    tmp45lg3o4_                        0x000055b0fd9d62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for char in lst[0] {\n        if char == \"(\" {\n    \
    \        left += 1\n        } else {\n            right += 1\n        }\n    }\n\
    \    for char in lst[1] {\n        if char == \"(\" {\n            left -= 1\n\
    \        } else {\n            right -= 1\n        }\n    }\n    if left == 0\
    \ && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7z4bs815/tmp7z4bs815.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae515dc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae515abcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae515abc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae515abb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7z4bs815                        0x000055f762d4c6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002ae515fb1460 __libc_start_main +
    245

    6    tmp7z4bs815                        0x000055f762d4c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.count == 0 {\n                return \"No\"\n\
    \            }\n            stack.removeLast()\n        }\n    }\n    return stack.count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5wz37fgh/tmp5wz37fgh.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72c2886c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72c257db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72c257d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72c257c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5wz37fgh                        0x0000555676af7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b72c2a72460 __libc_start_main +
    245

    6    tmp5wz37fgh                        0x0000555676af75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ if lst[i].contains(\"(\") {\n            str += lst[i]\n            count +=\
    \ 1\n        } else {\n            str += lst[i]\n            count -= 1\n   \
    \     }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpb07v74jx/tmpb07v74jx.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0297fe5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0297cdcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0297cdc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0297cdb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb07v74jx                        0x000055a049121d26 <unavailable> + 7462

    5    libc.so.6                          0x00002b02981d1460 __libc_start_main +
    245

    6    tmpb07v74jx                        0x000055a049121489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var stack = [Character]()\n   \
    \ for c in s {\n        if c == \"(\" {\n            stack.append(c)\n       \
    \ } else {\n            if stack.isEmpty {\n                return \"No\"\n  \
    \          }\n            stack.removeLast()\n        }\n    }\n    return stack.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprr4us3lj/tmprr4us3lj.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b596bdb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b596baafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b596baaf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b596baae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprr4us3lj                        0x0000557c83be1da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b596bfa4460 __libc_start_main +
    245

    6    tmprr4us3lj                        0x0000557c83be1509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str = str1 + str2\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpefjjrzz_/tmpefjjrzz_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d400d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d3fdcab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d3fdca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d3fdc97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpefjjrzz_                        0x00005627c4db2da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b6d402bf460 __libc_start_main +
    245

    6    tmpefjjrzz_                        0x00005627c4db2509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var count = 0\n    for c in s1 {\n        if c == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n    }\n    for c in s2 {\n        if c == \"(\" {\n            count +=\
    \ 1\n        } else {\n            count -= 1\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpvchuqd66/tmpvchuqd66.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d0ca0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d0c705b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d0c705988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d0c7047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvchuqd66                        0x0000555615ac1468 <unavailable> + 9320

    5    libc.so.6                          0x00002b4d0cbfa460 __libc_start_main +
    245

    6    tmpvchuqd66                        0x0000555615ac0289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    var count = 0\n    for c in\
    \ s {\n        if c == \"(\" {\n            count += 1\n        } else {\n   \
    \         count -= 1\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi6d8k_sy/tmpi6d8k_sy.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5060947c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b506063eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b506063e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b506063d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi6d8k_sy                        0x0000560f1e0d1c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b5060b33460 __libc_start_main +
    245

    6    tmpi6d8k_sy                        0x0000560f1e0d13f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    var count = 0\n    for i in 0..<lst.count {\n       \
    \ str += lst[i]\n    }\n    for i in 0..<str.count {\n        if str[i] == \"\
    (\" {\n            count += 1\n        } else {\n            count -= 1\n    \
    \    }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if count == 0 {\n        return \"Yes\"\n    } else {\n        return \"\
    No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgtxoj_p.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpbgtxoj_p.swift:16:9: warning: variable 'lst'\
    \ was never mutated; consider changing to 'let' constant\n    var lst = lst\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824692
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for str in lst {\n        for char in str {\n            if char == \"(\"\
    \ {\n                stack.push(char)\n            } else {\n                if\
    \ stack.isEmpty() {\n                    return \"No\"\n                } else\
    \ {\n                    stack.pop()\n                }\n            }\n     \
    \   }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp3m3hm3ng.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp45lg3o4_/tmp45lg3o4_.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab71855dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab718254b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab718254988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7182537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp45lg3o4_                        0x000055b0fd9d6b76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab718749460 __libc_start_main +
    245

    6    tmp45lg3o4_                        0x000055b0fd9d62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var count = 0\n    for i in s {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0kpev4n2/tmp0kpev4n2.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8704c60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8704957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8704957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87049567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kpev4n2                        0x000055ef944cfc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b8704e4c460 __libc_start_main +
    245

    6    tmp0kpev4n2                        0x000055ef944cf3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var stack = [Character]()\n    var str = \"\"\n    for i in 0..<lst.count\
    \ {\n        str += lst[i]\n    }\n    for char in str {\n        if char == \"\
    (\" {\n            stack.append(char)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    if stack.isEmpty {\n        return \"Yes\"\
    \n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpfm990sa0/tmpfm990sa0.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d13377c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d1306eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d1306e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d1306d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfm990sa0                        0x00005555867c6f86 <unavailable> + 8070

    5    libc.so.6                          0x00002b9d13563460 __libc_start_main +
    245

    6    tmpfm990sa0                        0x00005555867c66e9 <unavailable> + 5865

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var c = 0\n    for i in s {\n \
    \       if i == \"(\" {\n            c += 1\n        } else {\n            c -=\
    \ 1\n        }\n        if c < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    return c == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmprznebety/tmprznebety.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b198fa88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b198f77fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b198f77f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b198f77e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprznebety                        0x0000562683facc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b198fc74460 __libc_start_main +
    245

    6    tmprznebety                        0x0000562683fac3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    let s1 = lst.removeFirst()\n    let s2 = lst.removeFirst()\n    let s = s1\
    \ + s2\n    var stack = [Character]()\n    for c in s {\n        if c == \"(\"\
    \ {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpt6jqrt9e/tmpt6jqrt9e.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fd744bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fd7142b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fd7142988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fd71417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt6jqrt9e                        0x0000555e9ebe2da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b9fd7637460 __libc_start_main +
    245

    6    tmpt6jqrt9e                        0x0000555e9ebe2509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var str = \"\"\n    while lst.count > 0 {\n        if lst[0].count > lst[1].count\
    \ {\n            str += lst[0]\n            lst.remove(at: 0)\n        } else\
    \ {\n            str += lst[1]\n            lst.remove(at: 1)\n        }\n   \
    \ }\n    var count = 0\n    for c in str {\n        if c == \"(\" {\n        \
    \    count += 1\n        } else {\n            count -= 1\n        }\n       \
    \ if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afa34622c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa34319561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa34319286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa3431913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa34318bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afa34118fc3 <unavailable> + 188355

    6    tmpmk76owem                        0x0000558630c8ba17 <unavailable> + 10775

    7    tmpmk76owem                        0x0000558630c8a735 <unavailable> + 5941

    8    libc.so.6                          0x00002afa3480e460 __libc_start_main +
    245

    9    tmpmk76owem                        0x0000558630c8a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s1_count = s1.count\n    let s2_count = s2.count\n\
    \    var s1_open = 0\n    var s2_open = 0\n    var s1_close = 0\n    var s2_close\
    \ = 0\n    for c in s1 {\n        if c == \"(\" {\n            s1_open += 1\n\
    \        } else {\n            s1_close += 1\n        }\n    }\n    for c in s2\
    \ {\n        if c == \"(\" {\n            s2_open += 1\n        } else {\n   \
    \         s2_close += 1\n        }\n    }\n    if s1_open == s1_count && s2_close\
    \ == s2_count {\n        return \"Yes\"\n    }\n    if s2_open == s2_count &&\
    \ s1_close == s1_count {\n        return \"Yes\"\n    }\n    if s1_open == s1_count\
    \ && s2_open == s2_count {\n        return \"Yes\"\n    }\n    if s1_close ==\
    \ s1_count && s2_close == s2_count {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpdc2tagj6/tmpdc2tagj6.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7858a9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7858793b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7858793988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78587927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdc2tagj6                        0x000055f99baad6f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b7858c88460 __libc_start_main +
    245

    6    tmpdc2tagj6                        0x000055f99baad2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659824694
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            } else {\n                stack.removeLast()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpnz0l46ft/tmpnz0l46ft.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81ae24cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81adf43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81adf43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81adf427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz0l46ft                        0x0000560b14f37e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b81ae438460 __libc_start_main +
    245

    6    tmpnz0l46ft                        0x0000560b14f375d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824693
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var stack = [Character]()\n\
    \    for c in str {\n        if c == \"(\" {\n            stack.append(c)\n  \
    \      } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4acwfxac/tmp4acwfxac.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32ea39fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32ea096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32ea096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32ea0957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4acwfxac                        0x00005630f33d7e76 <unavailable> + 7798

    5    libc.so.6                          0x00002b32ea58b460 __libc_start_main +
    245

    6    tmp4acwfxac                        0x00005630f33d75d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824692
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s = \"\"\n    for i in 0..<lst.count {\n        if i % 2 == 0 {\n   \
    \         s += lst[i]\n        } else {\n            s = lst[i] + s\n        }\n\
    \    }\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n         \
    \   cnt += 1\n        } else {\n            cnt -= 1\n        }\n        if cnt\
    \ < 0 {\n            return \"No\"\n        }\n    }\n    return cnt == 0 ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp13eozult/tmp13eozult.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8059a02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80596f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80596f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80596f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp13eozult                        0x00005626c219c926 <unavailable> + 6438

    5    libc.so.6                          0x00002b8059bee460 __libc_start_main +
    245

    6    tmp13eozult                        0x00005626c219c509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659824694
