language: swift
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let asciiValue = char.asciiValue!\n        if asciiValue >= 97 && asciiValue\
    \ <= 122 {\n            let newAsciiValue = asciiValue + 2 * 2\n            if\
    \ newAsciiValue > 122 {\n                let difference = newAsciiValue - 122\n\
    \                let newChar = Character(UnicodeScalar(97 + difference - 1)!)\n\
    \                encryptedString.append(newChar)\n            } else {\n     \
    \           let newChar = Character(UnicodeScalar(newAsciiValue)!)\n         \
    \       encryptedString.append(newChar)\n            }\n        } else {\n   \
    \         encryptedString.append(char)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptlil4g_u.swift:23:75: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + difference - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                          \n\
    /tmp/tmptlil4g_u.swift:26:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(newAsciiValue)!)\n\
    \                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n     \
    \                                                               \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ encrypted.append(Character(UnicodeScalar(UInt8(char.asciiValue!) + 2 * 2)!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp89dn1ie9.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encrypted.append(Character(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if let index = index\
    \ {\n            encryptedString.append(alphabet[(index + 2 * 2) % alphabet.count])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc7u5dbeb.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpc7u5dbeb.swift:20:36: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString.append(alphabet[(index + 2 * 2) % alphabet.count])\n   \
    \                                ^~~~~~~~\n/tmp/tmpc7u5dbeb.swift:20:63: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[(index\
    \ + 2 * 2) % alphabet.count])\n                                              \
    \                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let shifted = unicode\
    \ + (2 * 2)\n        let shiftedChar = UnicodeScalar(UInt8(shifted))\n       \
    \ encrypted.append(Character(shiftedChar!))\n    }\n    return encrypted\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6yxrcuw3.swift:21:47: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encrypted.append(Character(shiftedChar!))\n\
    \                                   ~~~~~~~~~~~^\n                           \
    \                   \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var newString = \"\"\n    for char in s {\n       \
    \ let index = alphabet.firstIndex(of: char)\n        if index == nil {\n     \
    \       newString += String(char)\n        } else {\n            let newIndex\
    \ = (index! + 2) * 2\n            newString += String(alphabet[newIndex])\n  \
    \      }\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpm4dicd39.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpm4dicd39.swift:23:33: error: cannot find 'alphabet' in scope\n       \
    \     newString += String(alphabet[newIndex])\n                              \
    \  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        var shiftedUnicode = unicode\
    \ + (2 * 2)\n        if shiftedUnicode > 122 {\n            shiftedUnicode = shiftedUnicode\
    \ - 26\n        }\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result.append(shiftedCharacter)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = String(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n        encryptedString += encryptedChar\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0y3v2kr6.swift:19:68: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = String(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                   \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n   \
    \     result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpokrwxz68/tmpokrwxz68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb91cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb919cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb919cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb919cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokrwxz68                        0x000055e6d4845b7e <unavailable> + 7038

    5    libc.so.6                          0x00002abb91ec2460 __libc_start_main +
    245

    6    tmpokrwxz68                        0x000055e6d4845379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpnxr59zfn/tmpnxr59zfn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bc8db3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bc8aaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bc8aaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bc8aa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxr59zfn                        0x00005565c31c8b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3bc8f9f460 __libc_start_main +
    245

    6    tmpnxr59zfn                        0x00005565c31c8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let newIndex =\
    \ (charIndex! + (2 * 2)) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbdr5ea4d.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpbdr5ea4d.swift:19:49: error: cannot find 'alphabet' in scope\n\
    \        let newIndex = (charIndex! + (2 * 2)) % alphabet.count\n            \
    \                                    ^~~~~~~~\n/tmp/tmpbdr5ea4d.swift:20:32: error:\
    \ cannot find 'alphabet' in scope\n        encryptedString.append(alphabet[newIndex])\n\
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       encryptedString.append(char.shifted(by: 2 * 2))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4_4wnit6.swift:18:37: error: value of type 'Character' has no member\
    \ 'shifted'\n        encryptedString.append(char.shifted(by: 2 * 2))\n       \
    \                        ~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n \
    \       let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpqp7y_y.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shifted = unicode +\
    \ (2 * 2)\n        let shiftedChar = UnicodeScalar(UInt8(shifted))\n        result.append(Character(shiftedChar!))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2734pjb.swift:21:44: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result.append(Character(shiftedChar!))\n\
    \                                ~~~~~~~~~~~^\n                              \
    \             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = alphabet.firstIndex(of: char)\n        let newCharIndex\
    \ = (charIndex! + 2 * 2) % alphabet.count\n        encryptedString.append(alphabet[newCharIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoe2t7r8k.swift:18:25: error: cannot find 'alphabet' in scope\n\
    \        let charIndex = alphabet.firstIndex(of: char)\n                     \
    \   ^~~~~~~~\n/tmp/tmpoe2t7r8k.swift:19:51: error: cannot find 'alphabet' in scope\n\
    \        let newCharIndex = (charIndex! + 2 * 2) % alphabet.count\n          \
    \                                        ^~~~~~~~\n/tmp/tmpoe2t7r8k.swift:20:32:\
    \ error: cannot find 'alphabet' in scope\n        encryptedString.append(alphabet[newCharIndex])\n\
    \                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.advanced(by: 2)\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6uev9q_l.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let newCharIndex = charIndex\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n \
    \       encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpewx4hyy4.swift:20:60: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n              \
    \                                             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        if newIndex > 25 {\n            let newIndex = newIndex - 26\n\
    \            encryptedString.append(alphabet[newIndex])\n        } else {\n  \
    \          encryptedString.append(alphabet[newIndex])\n        }\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqcu2mzt3.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpqcu2mzt3.swift:22:36: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString.append(alphabet[newIndex])\n                           \
    \        ^~~~~~~~\n/tmp/tmpqcu2mzt3.swift:24:36: error: cannot find 'alphabet'\
    \ in scope\n            encryptedString.append(alphabet[newIndex])\n         \
    \                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)\n\
    \        encrypted.append(Character(encryptedChar!))\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpzs674v4r/tmpzs674v4r.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6038908c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60385ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60385ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60385fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzs674v4r                        0x0000561a0d6beb7e <unavailable> + 7038

    5    libc.so.6                          0x00002b6038af4460 __libc_start_main +
    245

    6    tmpzs674v4r                        0x0000561a0d6be379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let index = alphabet.firstIndex(of: char)\n        let newIndex = index! + 2\
    \ * 2\n        if newIndex > 25 {\n            let newIndex = newIndex - 26\n\
    \            encrypted.append(alphabet[newIndex])\n        } else {\n        \
    \    encrypted.append(alphabet[newIndex])\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp__ewp4jm.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp__ewp4jm.swift:22:30: error: cannot find 'alphabet' in scope\n       \
    \     encrypted.append(alphabet[newIndex])\n                             ^~~~~~~~\n\
    /tmp/tmp__ewp4jm.swift:24:30: error: cannot find 'alphabet' in scope\n       \
    \     encrypted.append(alphabet[newIndex])\n                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let unicodeString = String(unicode,\
    \ radix: 16)\n        let unicodeInt = Int(unicodeString, radix: 16)!\n      \
    \  let newUnicode = unicodeInt + 2 * 2\n        let newUnicodeString = String(newUnicode,\
    \ radix: 16)\n        let newChar = Character(UnicodeScalar(UInt32(newUnicodeString,\
    \ radix: 16)!)!)\n        result.append(newChar)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpzvt8r2nh/tmpzvt8r2nh.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30a266ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30a2361b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30a2361988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30a23607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzvt8r2nh                        0x0000561d0ebc5e3e <unavailable> + 7742

    5    libc.so.6                          0x00002b30a2856460 __libc_start_main +
    245

    6    tmpzvt8r2nh                        0x0000561d0ebc5639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + (2 * 2)\n\
    \        let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsgbvxymm.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       encryptedString.append(String(char).unicodeScalars.map { UnicodeScalar(($0.value\
    \ + 2 * 2) % 26 + 65) }.map { Character($0) }.first!)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqsjcf30z.swift:18:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        encryptedString.append(String(char).unicodeScalars.map\
    \ { UnicodeScalar(($0.value + 2 * 2) % 26 + 65) }.map { Character($0) }.first!)\n\
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824890
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = alphabet.firstIndex(of: char)!\n        let newIndex = (index + (2 *\
    \ 2)) % alphabet.count\n        result.append(alphabet[newIndex])\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_amnu0ty.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)!\n                    ^~~~~~~~\n\
    /tmp/tmp_amnu0ty.swift:19:44: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index + (2 * 2)) % alphabet.count\n                        \
    \                   ^~~~~~~~\n/tmp/tmp_amnu0ty.swift:20:23: error: cannot find\
    \ 'alphabet' in scope\n        result.append(alphabet[newIndex])\n           \
    \           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphg9d16db.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            let newIndex\
    \ = index + (2 * 2)\n            if newIndex > alphabet.count - 1 {\n        \
    \        let newIndex = newIndex - alphabet.count\n                encryptedString.append(alphabet[newIndex])\n\
    \            } else {\n                encryptedString.append(alphabet[newIndex])\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5brr4j_0.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmp5brr4j_0.swift:20:27: error: cannot find 'alphabet' in scope\n\
    \            if newIndex > alphabet.count - 1 {\n                          ^~~~~~~~\n\
    /tmp/tmp5brr4j_0.swift:21:43: error: cannot find 'alphabet' in scope\n       \
    \         let newIndex = newIndex - alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp5brr4j_0.swift:22:40: error: cannot find 'alphabet'\
    \ in scope\n                encryptedString.append(alphabet[newIndex])\n     \
    \                                  ^~~~~~~~\n/tmp/tmp5brr4j_0.swift:24:40: error:\
    \ cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n   \
    \     result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpokrwxz68/tmpokrwxz68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb91cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb919cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb919cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb919cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokrwxz68                        0x000055e6d4845b7e <unavailable> + 7038

    5    libc.so.6                          0x00002abb91ec2460 __libc_start_main +
    245

    6    tmpokrwxz68                        0x000055e6d4845379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2) * 2\n        let newChar = alphabet[newIndex]\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplv49y2w_.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmplv49y2w_.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex]\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = UnicodeScalar(encryptedUnicode)\n\
    \        encryptedString.append(Character(encryptedLetter!))\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpki6pxa73/tmpki6pxa73.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2e417cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2e3e73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2e3e73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2e3e727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpki6pxa73                        0x00005650da39cb7e <unavailable> + 7038

    5    libc.so.6                          0x00002ae2e4368460 __libc_start_main +
    245

    6    tmpki6pxa73                        0x00005650da39c379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2 * 2) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1p1bxran.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp1p1bxran.swift:19:43: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + 2 * 2) % alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp1p1bxran.swift:20:32: error: cannot find 'alphabet'\
    \ in scope\n        encryptedString.append(alphabet[newIndex])\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n\
    \            encryptedString.append(Character(UnicodeScalar(ascii + 2)!))\n  \
    \      } else if ascii >= 65 && ascii <= 90 {\n            encryptedString.append(Character(UnicodeScalar(ascii\
    \ + 2)!))\n        } else {\n            encryptedString.append(char)\n      \
    \  }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbu4ks2cq.swift:20:70: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            encryptedString.append(Character(UnicodeScalar(ascii\
    \ + 2)!))\n                                             ~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                     \n/tmp/tmpbu4ks2cq.swift:22:70:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            encryptedString.append(Character(UnicodeScalar(ascii + 2)!))\n  \
    \                                           ~~~~~~~~~~~~~~~~~~~~~~~~^\n      \
    \                                                               \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for char in s {\n        let index = alphabet.index(of: char)\n        let\
    \ newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpn41qbd4_/tmpn41qbd4_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69564fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69561f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69561f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69561f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn41qbd4_                        0x000056197113b687 <unavailable> + 5767

    5    libc.so.6                          0x00002b69566e8460 __libc_start_main +
    245

    6    tmpn41qbd4_                        0x000056197113b2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let newCharIndex = (charIndex\
    \ + 2 * 2) % 26\n        let newChar = Character(UnicodeScalar(newCharIndex +\
    \ 97)!)\n        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe0okevf.swift:20:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let encryptedAlphabet = \"cdefghijklmnopqrstuvwxyzab\"\n    var encryptedString\
    \ = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            encryptedString.append(encryptedAlphabet[index])\n    \
    \    }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpzv2j0qa_/tmpzv2j0qa_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f646c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f643beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f643be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f643bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv2j0qa_                        0x00005574660f6587 <unavailable> + 5511

    5    libc.so.6                          0x00002b7f648b3460 __libc_start_main +
    245

    6    tmpzv2j0qa_                        0x00005574660f61c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_eh_t9qu.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2\n    \
    \                       ^\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if let index = index\
    \ {\n            let newIndex = (index + (2 * 2)) % alphabet.count\n         \
    \   encryptedString.append(alphabet[newIndex])\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpgxsomds1.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpgxsomds1.swift:20:48: error: cannot find 'alphabet' in scope\n       \
    \     let newIndex = (index + (2 * 2)) % alphabet.count\n                    \
    \                           ^~~~~~~~\n/tmp/tmpgxsomds1.swift:21:36: error: cannot\
    \ find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 4\n            if\
    \ newIndex < alphabet.count {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex - alphabet.count)])\n            }\n        }\n    }\n  \
    \  return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let index = alphabet.firstIndex(of: char)\n        let newIndex = (index! +\
    \ 2 * 2) % alphabet.count\n        encrypted.append(alphabet[newIndex])\n    }\n\
    \    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0wcjqnfb.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp0wcjqnfb.swift:19:43: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + 2 * 2) % alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp0wcjqnfb.swift:20:26: error: cannot find 'alphabet'\
    \ in scope\n        encrypted.append(alphabet[newIndex])\n                   \
    \      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for letter in s {\n        let\
    \ unicode = letter.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpxqn95uv3/tmpxqn95uv3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21f4303c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21f3ffab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21f3ffa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21f3ff97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxqn95uv3                        0x000055e7a71a0d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b21f44ef460 __libc_start_main +
    245

    6    tmpxqn95uv3                        0x000055e7a71a0549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2 * 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n \
    \   return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfc07hir9.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpfc07hir9.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + (2 * 2)) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn8ekra5k.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpn8ekra5k.swift:19:45: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + (2 * 2)) % alphabet.count\n                       \
    \                     ^~~~~~~~\n/tmp/tmpn8ekra5k.swift:20:32: error: cannot find\
    \ 'alphabet' in scope\n        encryptedString.append(alphabet[newIndex])\n  \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let asciiValue = char.asciiValue {\n            let newAsciiValue =\
    \ asciiValue + (2 * 2)\n            if let newChar = UnicodeScalar(newAsciiValue)\
    \ {\n                encryptedString.append(Character(newChar))\n            }\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyg6b2_yp.swift:20:16: error: initializer for conditional binding\
    \ must have Optional type, not 'UnicodeScalar' (aka 'Unicode.Scalar')\n      \
    \      if let newChar = UnicodeScalar(newAsciiValue) {\n               ^     \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index + 2 * 2\n            if newIndex >\
    \ 25 {\n                let newIndex = newIndex - 26\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwf6oobk6.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2\n            encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n        }\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp_58_5888/tmp_58_5888.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d63d39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d63a30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d63a30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d63a2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_58_5888                        0x0000562e0f1496a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b8d63f25460 __libc_start_main +
    245

    6    tmp_58_5888                        0x0000562e0f1492e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedChar = (charIndex\
    \ + 2) % 26 + 97\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplo4hx4kq.swift:20:70: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n    \
    \                                                                 \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2)))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmppfk2qn3j/tmppfk2qn3j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad419de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad419adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad419adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad419ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppfk2qn3j                        0x000055ec1a956b9e <unavailable> + 7070

    5    libc.so.6                          0x00002ad419fd0460 __libc_start_main +
    245

    6    tmppfk2qn3j                        0x000055ec1a956399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + (2 * 2)) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn8ekra5k.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpn8ekra5k.swift:19:45: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + (2 * 2)) % alphabet.count\n                       \
    \                     ^~~~~~~~\n/tmp/tmpn8ekra5k.swift:20:32: error: cannot find\
    \ 'alphabet' in scope\n        encryptedString.append(alphabet[newIndex])\n  \
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2 * 2\n            if newIndex\
    \ > alphabet.count - 1 {\n                let newIndex = newIndex - alphabet.count\n\
    \                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc6s2xxa_.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphg9d16db.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            if index +\
    \ 2 * 2 > alphabet.count - 1 {\n                let newIndex = (index + 2 * 2)\
    \ - alphabet.count\n                encryptedString.append(alphabet[newIndex])\n\
    \            } else {\n                encryptedString.append(alphabet[index +\
    \ 2 * 2])\n            }\n        }\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpe9vwaf9e.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpe9vwaf9e.swift:19:32: error: cannot find 'alphabet' in scope\n\
    \            if index + 2 * 2 > alphabet.count - 1 {\n                       \
    \        ^~~~~~~~\n/tmp/tmpe9vwaf9e.swift:20:50: error: cannot find 'alphabet'\
    \ in scope\n                let newIndex = (index + 2 * 2) - alphabet.count\n\
    \                                                 ^~~~~~~~\n/tmp/tmpe9vwaf9e.swift:21:40:\
    \ error: cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n/tmp/tmpe9vwaf9e.swift:23:40:\
    \ error: cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[index\
    \ + 2 * 2])\n                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fi9xnk.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpl6fi9xnk.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0qxg1lpb/tmp0qxg1lpb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b0069dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b00394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b00394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b003937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0qxg1lpb                        0x00005647b471f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6b00889460 __libc_start_main +
    245

    6    tmp0qxg1lpb                        0x00005647b471ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + (2 * 2)\n        let newChar = alphabet[newIndex % alphabet.count]\n     \
    \   encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqrmds887.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpqrmds887.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpqrmds887.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + (2 * 2)\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9lp6j989.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp9lp6j989.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n   \
    \     result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpokrwxz68/tmpokrwxz68.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb91cd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb919cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb919cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb919cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokrwxz68                        0x000055e6d4845b7e <unavailable> + 7038

    5    libc.so.6                          0x00002abb91ec2460 __libc_start_main +
    245

    6    tmpokrwxz68                        0x000055e6d4845379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fi9xnk.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpl6fi9xnk.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpnxr59zfn/tmpnxr59zfn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bc8db3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bc8aaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bc8aaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bc8aa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxr59zfn                        0x00005565c31c8b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3bc8f9f460 __libc_start_main +
    245

    6    tmpnxr59zfn                        0x00005565c31c8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let asciiValue = char.asciiValue!\n        let encryptedAsciiValue = asciiValue\
    \ + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedAsciiValue)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp371zdctx.swift:20:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedAsciiValue)!)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let unicodeString = String(unicode,\
    \ radix: 16)\n        let unicodeInt = Int(unicodeString, radix: 16)!\n      \
    \  let newUnicodeInt = unicodeInt + (2 * 2)\n        let newUnicodeString = String(newUnicodeInt,\
    \ radix: 16)\n        let newUnicode = UnicodeScalar(Int(newUnicodeString, radix:\
    \ 16)!)\n        result.append(Character(newUnicode!))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjkdzo4gh/tmpjkdzo4gh.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ce3659c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ce3350b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ce3350988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ce334f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjkdzo4gh                        0x0000556950022dde <unavailable> + 7646

    5    libc.so.6                          0x00002b5ce3845460 __libc_start_main +
    245

    6    tmpjkdzo4gh                        0x00005569500225d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let unicodeString = String(unicode,\
    \ radix: 16)\n        let unicodeInt = Int(unicodeString, radix: 16)!\n      \
    \  let newUnicode = unicodeInt + (2 * 2)\n        let newUnicodeString = String(newUnicode,\
    \ radix: 16)\n        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString,\
    \ radix: 16)!)\n        result.append(Character(newUnicodeScalar))\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp83kquwrz.swift:24:33: error: value of optional type 'Unicode.Scalar?'\
    \ must be unwrapped to a value of type 'Unicode.Scalar'\n        result.append(Character(newUnicodeScalar))\n\
    \                                ^\n/tmp/tmp83kquwrz.swift:23:13: note: short-circuit\
    \ using 'guard' to exit this function early if the optional value contains 'nil'\n\
    \        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString, radix: 16)!)\n\
    \            ^\n        guard                                                \
    \                   else { return <#default value#> }\n/tmp/tmp83kquwrz.swift:23:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString, radix:\
    \ 16)!)\n                               ^\n                                  \
    \                                              ?? <#default value#>\n/tmp/tmp83kquwrz.swift:23:32:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let newUnicodeScalar = UnicodeScalar(Int(newUnicodeString, radix:\
    \ 16)!)\n                               ^\n                                  \
    \                                             !\n/tmp/tmp83kquwrz.swift:24:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result.append(Character(newUnicodeScalar))\n                \
    \                ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmp83kquwrz.swift:24:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result.append(Character(newUnicodeScalar))\n\
    \                                ^\n                                         \
    \       !\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let newCharIndex = charIndex\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n \
    \       encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpewx4hyy4.swift:20:60: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n              \
    \                                             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedCharacter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp0bnlwzag/tmp0bnlwzag.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b15ed97dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15ed674b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15ed674988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15ed6737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0bnlwzag                        0x000055cf66086b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b15edb69460 __libc_start_main +
    245

    6    tmp0bnlwzag                        0x000055cf66086379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for letter in s {\n     \
    \   var unicode = letter.unicodeScalars.first!.value\n        unicode += 2 * 2\n\
    \        let encryptedLetter = UnicodeScalar(unicode)\n        encrypted.append(Character(encryptedLetter!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpmqwhwpia/tmpmqwhwpia.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b536adacc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b536aaa3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b536aaa3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b536aaa27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmqwhwpia                        0x000055cbe0bb2b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b536af98460 __libc_start_main +
    245

    6    tmpmqwhwpia                        0x000055cbe0bb2379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let index = alphabet.firstIndex(of: char)\n        let newIndex = (index! +\
    \ 2 * 2) % alphabet.count\n        encrypted.append(alphabet[newIndex])\n    }\n\
    \    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0wcjqnfb.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp0wcjqnfb.swift:19:43: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + 2 * 2) % alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp0wcjqnfb.swift:20:26: error: cannot find 'alphabet'\
    \ in scope\n        encrypted.append(alphabet[newIndex])\n                   \
    \      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n\
    \            let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n \
    \               let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encryptedString.append(newChar)\n           \
    \ } else {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                encryptedString.append(newChar)\n            }\n        } else\
    \ {\n            encryptedString.append(char)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8s8j0f9r.swift:23:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmp8s8j0f9r.swift:26:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            encryptedString.append(alphabet[(index\
    \ + 2 * 2) % alphabet.count])\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjpm3t005.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpjpm3t005.swift:19:36: error: cannot find 'alphabet' in scope\n\
    \            encryptedString.append(alphabet[(index + 2 * 2) % alphabet.count])\n\
    \                                   ^~~~~~~~\n/tmp/tmpjpm3t005.swift:19:63: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[(index\
    \ + 2 * 2) % alphabet.count])\n                                              \
    \                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2 * 2) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1p1bxran.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp1p1bxran.swift:19:43: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + 2 * 2) % alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp1p1bxran.swift:20:32: error: cannot find 'alphabet'\
    \ in scope\n        encryptedString.append(alphabet[newIndex])\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 2 * 2\n        \
    \    let newLetter = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex\
    \ % alphabet.count)]\n            encrypted.append(newLetter)\n        }\n   \
    \ }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let alphabetArray = Array(alphabet)\n    var encryptedString = \"\"\n    for\
    \ char in s {\n        if let index = alphabetArray.firstIndex(of: char) {\n \
    \           let newIndex = (index + 2) % alphabetArray.count\n            encryptedString.append(alphabetArray[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp7gu1oys0/tmp7gu1oys0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0448e55c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0448b4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0448b4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0448b4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7gu1oys0                        0x00005637c76a0757 <unavailable> + 5975

    5    libc.so.6                          0x00002b0449041460 __libc_start_main +
    245

    6    tmp7gu1oys0                        0x00005637c76a0399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        let newAscii = ascii + (2 * 2)\n     \
    \   let newChar = Character(UnicodeScalar(newAscii)!)\n        encrypted.append(newChar)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp99qj20uz.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            let newIndex\
    \ = index + (2 * 2)\n            let newChar = alphabet[newIndex % alphabet.count]\n\
    \            encryptedString.append(newChar)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjndsol7a.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpjndsol7a.swift:20:27: error: cannot find 'alphabet' in scope\n\
    \            let newChar = alphabet[newIndex % alphabet.count]\n             \
    \             ^~~~~~~~\n/tmp/tmpjndsol7a.swift:20:47: error: cannot find 'alphabet'\
    \ in scope\n            let newChar = alphabet[newIndex % alphabet.count]\n  \
    \                                            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(c.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppws61o25.swift:18:79: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(c.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \  \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let letterIndex = alphabet.firstIndex(of: letter)\n        let newLetterIndex\
    \ = letterIndex! + 2 * 2\n        let newLetter = alphabet[newLetterIndex % alphabet.count]\n\
    \        encryptedString.append(newLetter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6pld3vcg.swift:18:27: error: cannot find 'alphabet' in scope\n\
    \        let letterIndex = alphabet.firstIndex(of: letter)\n                 \
    \         ^~~~~~~~\n/tmp/tmp6pld3vcg.swift:20:25: error: cannot find 'alphabet'\
    \ in scope\n        let newLetter = alphabet[newLetterIndex % alphabet.count]\n\
    \                        ^~~~~~~~\n/tmp/tmp6pld3vcg.swift:20:51: error: cannot\
    \ find 'alphabet' in scope\n        let newLetter = alphabet[newLetterIndex %\
    \ alphabet.count]\n                                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = alphabet.firstIndex(of: char)!\n        let newIndex = (index + 2 *\
    \ 2) % alphabet.count\n        result.append(alphabet[newIndex])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fwcsiqd.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)!\n                    ^~~~~~~~\n\
    /tmp/tmp9fwcsiqd.swift:19:42: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index + 2 * 2) % alphabet.count\n                          \
    \               ^~~~~~~~\n/tmp/tmp9fwcsiqd.swift:20:23: error: cannot find 'alphabet'\
    \ in scope\n        result.append(alphabet[newIndex])\n                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2)))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmppfk2qn3j/tmppfk2qn3j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad419de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad419adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad419adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad419ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppfk2qn3j                        0x000055ec1a956b9e <unavailable> + 7070

    5    libc.so.6                          0x00002ad419fd0460 __libc_start_main +
    245

    6    tmppfk2qn3j                        0x000055ec1a956399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        if newIndex > 25 {\n            let newIndex = newIndex - 26\n\
    \            encryptedString.append(alphabet[newIndex])\n        } else {\n  \
    \          encryptedString.append(alphabet[newIndex])\n        }\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqcu2mzt3.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpqcu2mzt3.swift:22:36: error: cannot find 'alphabet' in scope\n       \
    \     encryptedString.append(alphabet[newIndex])\n                           \
    \        ^~~~~~~~\n/tmp/tmpqcu2mzt3.swift:24:36: error: cannot find 'alphabet'\
    \ in scope\n            encryptedString.append(alphabet[newIndex])\n         \
    \                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            let newIndex\
    \ = (index + (2 * 2)) % alphabet.count\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjfh5ptlz.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpjfh5ptlz.swift:19:48: error: cannot find 'alphabet' in scope\n\
    \            let newIndex = (index + (2 * 2)) % alphabet.count\n             \
    \                                  ^~~~~~~~\n/tmp/tmpjfh5ptlz.swift:20:36: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[newIndex])\n\
    \                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedLetter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpbgw0wi8d/tmpbgw0wi8d.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b305cf22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b305cc19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b305cc19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b305cc187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbgw0wi8d                        0x0000563e344e5d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b305d10e460 __libc_start_main +
    245

    6    tmpbgw0wi8d                        0x0000563e344e5549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        encryptedString +=\
    \ alphabet[(index! + 2 * 2) % 26]\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpe733qr4g.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpe733qr4g.swift:19:28: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString += alphabet[(index! + 2 * 2) % 26]\n                       \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for character in s {\n  \
    \      let unicode = character.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpoesoywde/tmpoesoywde.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c892f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c88feab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c88fea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c88fe97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoesoywde                        0x000055b629a9cd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b8c894df460 __libc_start_main +
    245

    6    tmpoesoywde                        0x000055b629a9c549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp39eqodxo/tmp39eqodxo.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca7370fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca73406b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca73406988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca734057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp39eqodxo                        0x000055ac5e9fc687 <unavailable> + 5767

    5    libc.so.6                          0x00002aca738fb460 __libc_start_main +
    245

    6    tmp39eqodxo                        0x000055ac5e9fc2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedLetter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpbgw0wi8d/tmpbgw0wi8d.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b305cf22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b305cc19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b305cc19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b305cc187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbgw0wi8d                        0x0000563e344e5d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b305d10e460 __libc_start_main +
    245

    6    tmpbgw0wi8d                        0x0000563e344e5549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 2)\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwvu0epow.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        let newChar = alphabet[newIndex % alphabet.count]\n       \
    \ encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpys5ftp7j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpys5ftp7j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = alphabet.firstIndex(of: char)!\n        let newIndex = index + 2 * 2\n\
    \        let newChar = alphabet[newIndex % alphabet.count]\n        result.append(newChar)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpl8hxz2_j.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)!\n                    ^~~~~~~~\n\
    /tmp/tmpl8hxz2_j.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpl8hxz2_j.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = (index! + 2) % alphabet.count\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpilo94w82.swift:19:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: letter)\n     \
    \                        ^\n/tmp/tmpilo94w82.swift:19:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: letter)\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpilo94w82.swift:20:30:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = (index! + 2) % alphabet.count\n              \
    \               ^\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedChar = (charIndex\
    \ + 2 * 2) % 26 + 97\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvxb57u4w.swift:20:70: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(encryptedChar)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n    \
    \                                                                 \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 4\n            if\
    \ newIndex < alphabet.count {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex - alphabet.count)])\n            }\n        }\n    }\n  \
    \  return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n\
    \            let newAscii = ascii + 2\n            if newAscii > 122 {\n     \
    \           let diff = newAscii - 122\n                let newAscii = 97 + diff\
    \ - 1\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \            } else {\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \            }\n        } else if ascii >= 65 && ascii <= 90 {\n            let\
    \ newAscii = ascii + 2\n            if newAscii > 90 {\n                let diff\
    \ = newAscii - 90\n                let newAscii = 65 + diff - 1\n            \
    \    encryptedString.append(Character(UnicodeScalar(newAscii)!))\n           \
    \ } else {\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \            }\n        } else {\n            encryptedString.append(char)\n \
    \       }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6f2dl4ir.swift:24:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n/tmp/tmp6f2dl4ir.swift:26:73:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n/tmp/tmp6f2dl4ir.swift:33:73:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n/tmp/tmp6f2dl4ir.swift:35:73:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                encryptedString.append(Character(UnicodeScalar(newAscii)!))\n\
    \                                                 ~~~~~~~~~~~~~~~~~~~~~~~^\n \
    \                                                                       \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index + 2 * 2\n            if newIndex <\
    \ alphabet.count {\n                encrypted.append(alphabet[newIndex])\n   \
    \         } else {\n                encrypted.append(alphabet[newIndex - alphabet.count])\n\
    \            }\n        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpm7zwowc6.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = alphabet.index(index, offsetBy: 2)\n \
    \           encryptedString.append(alphabet[newIndex])\n        }\n    }\n   \
    \ return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpoqhmehns/tmpoqhmehns.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a6d0bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a6cdb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a6cdb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a6cdb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoqhmehns                        0x000055a55930b5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002b0a6d2aa460 __libc_start_main +
    245

    6    tmpoqhmehns                        0x000055a55930b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)!\n\
    \        encrypted.append(Character(encryptedChar))\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmps0w594g1/tmps0w594g1.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0aeabf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0aea8edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0aea8ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0aea8ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0w594g1                        0x0000565210876b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b0aeade2460 __libc_start_main +
    245

    6    tmps0w594g1                        0x0000565210876379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ if let index = alphabet.firstIndex(of: char) {\n            let newIndex = (index\
    \ + (2 * 2)) % alphabet.count\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp01ukeiqg.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmp01ukeiqg.swift:19:48: error: cannot find 'alphabet' in scope\n\
    \            let newIndex = (index + (2 * 2)) % alphabet.count\n             \
    \                                  ^~~~~~~~\n/tmp/tmp01ukeiqg.swift:20:30: error:\
    \ cannot find 'alphabet' in scope\n            encrypted.append(alphabet[newIndex])\n\
    \                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        let unicode = letter.unicodeScalars.first!.value\n        var newUnicode\
    \ = unicode + (2 * 2)\n        if newUnicode > 122 {\n            newUnicode =\
    \ newUnicode - 26\n        }\n        let newLetter = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newLetter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let charEncrypted = UnicodeScalar(unicodeEncrypted)!\n\
    \        encryptedString.append(Character(charEncrypted))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgmrr1fc/tmpvgmrr1fc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4a077dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4a0474b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4a0474988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4a04737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgmrr1fc                        0x0000556fd4d67b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ac4a0969460 __libc_start_main +
    245

    6    tmpvgmrr1fc                        0x0000556fd4d67379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 4)\n            encryptedString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpip063htw.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 4)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let unicodeString = String(unicode,\
    \ radix: 16)\n        let unicodeInt = Int(unicodeString, radix: 16)!\n      \
    \  let newUnicodeInt = unicodeInt + (2 * 2)\n        let newUnicodeString = String(newUnicodeInt,\
    \ radix: 16)\n        let newUnicode = UnicodeScalar(UInt32(newUnicodeString,\
    \ radix: 16)!)\n        result.append(Character(newUnicode!))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpyz05kerr/tmpyz05kerr.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057e760c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057e457b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057e457988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057e4567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyz05kerr                        0x0000564874c85e3e <unavailable> + 7742

    5    libc.so.6                          0x00002b057e94c460 __libc_start_main +
    245

    6    tmpyz05kerr                        0x0000564874c85639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + (2 * 2)\n        let newChar = alphabet[newIndex % alphabet.count]\n     \
    \   encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpqrmds887.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpqrmds887.swift:20:23: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                      ^~~~~~~~\n\
    /tmp/tmpqrmds887.swift:20:43: error: cannot find 'alphabet' in scope\n       \
    \ let newChar = alphabet[newIndex % alphabet.count]\n                        \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(c.asciiValue! + 2 * 2))!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wn2g89p.swift:18:79: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(c.asciiValue!\
    \ + 2 * 2))!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \  \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let ascii = char.asciiValue!\n        if ascii >= 97 && ascii <= 122 {\n   \
    \         let newAscii = ascii + 2 * 2\n            if newAscii > 122 {\n    \
    \            let diff = newAscii - 122\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                encrypted.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAscii)!)\n     \
    \           encrypted.append(newChar)\n            }\n        } else {\n     \
    \       encrypted.append(char)\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1q82uolc.swift:23:69: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(97\
    \ + diff - 1)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmp1q82uolc.swift:26:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAscii)!)\n         \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 2 *\
    \ 2) % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n  \
    \      encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9c6apol.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2 * 2\n          \
    \  let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n\
    \            encryptedString.append(newChar)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a33a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a3375a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a3375a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a3375a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a33759bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b1a3388dec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b1a33846660 String.subscript.getter
    + 34

    7    tmp5qmz90b_                        0x000056432868d0ef <unavailable> + 8431

    8    tmp5qmz90b_                        0x000056432868c9fd <unavailable> + 6653

    9    libc.so.6                          0x00002b1a33c4f460 __libc_start_main +
    245

    10   tmp5qmz90b_                        0x000056432868c2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        if let index = index\
    \ {\n            let newIndex = index + 2 * 2\n            if newIndex > 25 {\n\
    \                let newIndex = newIndex - 26\n                encryptedString.append(alphabet[newIndex])\n\
    \            } else {\n                encryptedString.append(alphabet[newIndex])\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmph2cp7ew0.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmph2cp7ew0.swift:23:40: error: cannot find 'alphabet' in scope\n       \
    \         encryptedString.append(alphabet[newIndex])\n                       \
    \                ^~~~~~~~\n/tmp/tmph2cp7ew0.swift:25:40: error: cannot find 'alphabet'\
    \ in scope\n                encryptedString.append(alphabet[newIndex])\n     \
    \                                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       encryptedString.append(encrypt(char: char))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpm67jnnin.swift:18:39: error: incorrect argument label in call (have\
    \ 'char:', expected 's:')\n        encryptedString.append(encrypt(char: char))\n\
    \                                      ^~~~~\n                               \
    \        s\n/tmp/tmpm67jnnin.swift:18:46: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n        encryptedString.append(encrypt(char:\
    \ char))\n                                             ^\n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let newCharIndex = (charIndex\
    \ + 2 * 2) % 26\n        let newChar = Character(UnicodeScalar(newCharIndex +\
    \ 97)!)\n        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe0okevf.swift:20:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedCharIndex\
    \ = (charIndex + 2 * 2) % 26\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex\
    \ + 97)!)\n        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa84j8z7y.swift:20:77: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex\
    \ + 97)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n\
    \        encryptedString.append(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpnxr59zfn/tmpnxr59zfn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bc8db3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bc8aaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bc8aaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bc8aa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnxr59zfn                        0x00005565c31c8b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b3bc8f9f460 __libc_start_main +
    245

    6    tmpnxr59zfn                        0x00005565c31c8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let unicodeEncrypted\
    \ = unicode + (2 * 2)\n        let encryptedChar = UnicodeScalar(unicodeEncrypted)\n\
    \        encryptedString.append(Character(encryptedChar!))\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpflok1xw_/tmpflok1xw_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcf888cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcf8583b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcf8583988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcf85827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpflok1xw_                        0x0000558c13224b7e <unavailable> + 7038

    5    libc.so.6                          0x00002adcf8a78460 __libc_start_main +
    245

    6    tmpflok1xw_                        0x0000558c13224379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue! - 97\n        let encryptedIndex = (charIndex\
    \ + 4) % 26\n        let encryptedChar = Character(UnicodeScalar(encryptedIndex\
    \ + 97)!)\n        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmps820irf7.swift:20:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedIndex\
    \ + 97)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                        \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx8kt2mim.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpx8kt2mim.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode\
    \ = unicode + (2 * 2)\n        let shiftedChar = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        encryptedString += shiftedChar\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp9ic4lm9b/tmp9ic4lm9b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab213b84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab21387bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab21387b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab21387a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ic4lm9b                        0x000056296d1c1d4e <unavailable> + 7502

    5    libc.so.6                          0x00002ab213d70460 __libc_start_main +
    245

    6    tmp9ic4lm9b                        0x000056296d1c1549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 2)\
    \ % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n     \
    \   encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpj7dr_8t2.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if char == \"z\" {\n            encryptedString.append(\"b\")\n      \
    \  } else if char == \"y\" {\n            encryptedString.append(\"a\")\n    \
    \    } else {\n            encryptedString.append(String(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2))))\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpj9eq6s6s/tmpj9eq6s6s.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba98f5aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba98f2a1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba98f2a1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba98f2a07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj9eq6s6s                        0x000056503c5fc837 <unavailable> + 6199

    5    libc.so.6                          0x00002ba98f796460 __libc_start_main +
    245

    6    tmpj9eq6s6s                        0x000056503c5fc479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2 * 2) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1p1bxran.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp1p1bxran.swift:19:43: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + 2 * 2) % alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp1p1bxran.swift:20:32: error: cannot find 'alphabet'\
    \ in scope\n        encryptedString.append(alphabet[newIndex])\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n        encryptedString.append(encryptedChar)\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppogvysvb.swift:19:71: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                      \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let newCharIndex = charIndex\
    \ + (2 * 2)\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n \
    \       encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpewx4hyy4.swift:20:60: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n              \
    \                                             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let newUnicode\
    \ = unicode + (2 * 2)\n        let newChar = UnicodeScalar(newUnicode)\n     \
    \   encryptedString.append(Character(newChar!))\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp64fu_p3b/tmp64fu_p3b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b18570b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1856dabb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1856dab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1856daa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp64fu_p3b                        0x000055b912e77b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b18572a0460 __libc_start_main +
    245

    6    tmp64fu_p3b                        0x000055b912e77379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n        encryptedString.append(encryptedChar)\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppogvysvb.swift:19:71: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(charIndex\
    \ + 2 * 2)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                      \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.advanced(by: 2)\n            encrypted.append(alphabet[newIndex])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpcbhkhapp.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmplj31s0r7/tmplj31s0r7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1e681fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1e6516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1e6516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1e65157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj31s0r7                        0x00005627ffb7bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002ad1e6a0b460 __libc_start_main +
    245

    6    tmplj31s0r7                        0x00005627ffb7b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = index!\
    \ + 2 * 2\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpl6fi9xnk.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpl6fi9xnk.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2)))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmppfk2qn3j/tmppfk2qn3j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad419de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad419adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad419adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad419ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppfk2qn3j                        0x000055ec1a956b9e <unavailable> + 7070

    5    libc.so.6                          0x00002ad419fd0460 __libc_start_main +
    245

    6    tmppfk2qn3j                        0x000055ec1a956399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = (index.encodedOffset + 4) % alphabet.count\n\
    \            let newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)]\n            encryptedString.append(newChar)\n        }\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        let index\
    \ = c.asciiValue! - 97\n        let newIndex = (index + 2 * 2) % 26\n        let\
    \ newChar = Character(UnicodeScalar(newIndex + 97)!)\n        result.append(newChar)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpu93jg5yu.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shiftedUnicode = unicode\
    \ + (2 * 2)\n        let shiftedCharacter = String(UnicodeScalar(UInt8(shiftedUnicode)))\n\
    \        result += shiftedCharacter\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmplj31s0r7/tmplj31s0r7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1e681fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1e6516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1e6516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1e65157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj31s0r7                        0x00005627ffb7bd4e <unavailable> + 7502

    5    libc.so.6                          0x00002ad1e6a0b460 __libc_start_main +
    245

    6    tmplj31s0r7                        0x00005627ffb7b549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shifted = unicode +\
    \ (2 * 2)\n        let shiftedChar = Character(UnicodeScalar(UInt8(shifted)))\n\
    \        result.append(shiftedChar)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpliahoofk/tmpliahoofk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89adff8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89adcefb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89adcef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89adcee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpliahoofk                        0x000055db71fced4e <unavailable> + 7502

    5    libc.so.6                          0x00002b89ae1e4460 __libc_start_main +
    245

    6    tmpliahoofk                        0x000055db71fce549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n \
    \       let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpqp7y_y.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = index! + 2\n        let newChar = alphabet[newIndex]\n\
    \        encryptedString += String(newChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbwqtp29j.swift:19:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = alphabet.index(of: char)\n       \
    \                      ^\n/tmp/tmpbwqtp29j.swift:19:30: note: use 'firstIndex(of:)'\
    \ instead\n        let index = alphabet.index(of: char)\n                    \
    \         ^~~~~\n                             firstIndex\n/tmp/tmpbwqtp29j.swift:20:29:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n        let newIndex = index! + 2\n                            ^\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2))!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppynlzjo3.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2 * 2))!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let shifted = unicode +\
    \ (2 * 2)\n        let shiftedChar = UnicodeScalar(UInt8(shifted))\n        result.append(Character(shiftedChar!))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpg2734pjb.swift:21:44: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result.append(Character(shiftedChar!))\n\
    \                                ~~~~~~~~~~~^\n                              \
    \             \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ unicodeEncrypted = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(unicodeEncrypted)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp92udw6ad/tmp92udw6ad.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca34a0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca34706b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca34706988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca347057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92udw6ad                        0x0000559079ff0d4e <unavailable> + 7502

    5    libc.so.6                          0x00002aca34bfb460 __libc_start_main +
    245

    6    tmp92udw6ad                        0x0000559079ff0549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2 * 2\n          \
    \  encrypted.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)])\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002aafdd459c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafdd150561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafdd150286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafdd15013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafdd14fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002aafdd283ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002aafdd23c660 String.subscript.getter
    + 34

    7    tmp_bd6pb7x                        0x0000563fef8410dc <unavailable> + 8412

    8    tmp_bd6pb7x                        0x0000563fef8409fd <unavailable> + 6653

    9    libc.so.6                          0x00002aafdd645460 __libc_start_main +
    245

    10   tmp_bd6pb7x                        0x0000563fef8402e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2 * 2\n          \
    \  if newIndex < alphabet.count {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex - alphabet.count)])\n            }\n        }\n    }\n  \
    \  return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index + 2 * 2\n            if newIndex <\
    \ alphabet.count {\n                encryptedString.append(alphabet[newIndex])\n\
    \            } else {\n                encryptedString.append(alphabet[newIndex\
    \ - alphabet.count])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpt9x0n_sp.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n      \
    \  encryptedString.append(alphabet[newIndex])\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpdsi7vsla/tmpdsi7vsla.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af35cb0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af35c805b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af35c805988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af35c8047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdsi7vsla                        0x000055d9d2902687 <unavailable> + 5767

    5    libc.so.6                          0x00002af35ccfa460 __libc_start_main +
    245

    6    tmpdsi7vsla                        0x000055d9d29022c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted.append(encryptedCharacter)\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmph2q57fx4/tmph2q57fx4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5964617c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b596430eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b596430e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b596430d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph2q57fx4                        0x0000558cf6c95d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b5964803460 __libc_start_main +
    245

    6    tmph2q57fx4                        0x0000558cf6c95549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 4)\
    \ % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n     \
    \   encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpavm0lw2x.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824752
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = char.asciiValue! - 97\n        let newIndex = (index + 4) % 26\n   \
    \     let newChar = Character(UnicodeScalar(newIndex + 97)!)\n        result.append(newChar)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpch9pdcyn.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2) % 26\n        encryptedString.append(alphabet[newIndex])\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx8kt2mim.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmpx8kt2mim.swift:20:32: error: cannot find 'alphabet' in scope\n       \
    \ encryptedString.append(alphabet[newIndex])\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvgq5nxjq/tmpvgq5nxjq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5990ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba598df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba598df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba598df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgq5nxjq                        0x000055611b6e7307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5992eb460 __libc_start_main +
    245

    6    tmpvgq5nxjq                        0x000055611b6e6f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let lowercased = s.lowercased()\n    var encrypted = \"\"\n    for letter in\
    \ lowercased {\n        if let index = alphabet.firstIndex(of: letter) {\n   \
    \         let newIndex = index.advanced(by: 2)\n            let newLetter = alphabet[newIndex]\n\
    \            encrypted.append(newLetter)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkn9ca1ss.swift:21:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let encryptedChar = String(UnicodeScalar(ascii\
    \ + 2 * 2)!)\n        encryptedString += encryptedChar\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphm9wyoq8.swift:19:64: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = String(UnicodeScalar(ascii\
    \ + 2 * 2)!)\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                               \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.advanced(by: 2)\n            let\
    \ newLetter = alphabet[newIndex]\n            encryptedString.append(newLetter)\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppoi22qcm.swift:20:34: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            let newIndex = index.advanced(by: 2)\n      \
    \                     ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2))!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppynlzjo3.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2 * 2))!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(UnicodeScalar(UInt8(char.asciiValue! + 2 * 2)))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmppfk2qn3j/tmppfk2qn3j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad419de4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad419adbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad419adb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad419ada7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppfk2qn3j                        0x000055ec1a956b9e <unavailable> + 7070

    5    libc.so.6                          0x00002ad419fd0460 __libc_start_main +
    245

    6    tmppfk2qn3j                        0x000055ec1a956399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            let newIndex\
    \ = index + 2 * 2\n            if newIndex > alphabet.count - 1 {\n          \
    \      let index = newIndex - alphabet.count\n                encryptedString.append(alphabet[index])\n\
    \            } else {\n                encryptedString.append(alphabet[newIndex])\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmcfnnt3b.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpmcfnnt3b.swift:20:27: error: cannot find 'alphabet' in scope\n\
    \            if newIndex > alphabet.count - 1 {\n                          ^~~~~~~~\n\
    /tmp/tmpmcfnnt3b.swift:21:40: error: cannot find 'alphabet' in scope\n       \
    \         let index = newIndex - alphabet.count\n                            \
    \           ^~~~~~~~\n/tmp/tmpmcfnnt3b.swift:22:40: error: cannot find 'alphabet'\
    \ in scope\n                encryptedString.append(alphabet[index])\n        \
    \                               ^~~~~~~~\n/tmp/tmpmcfnnt3b.swift:24:40: error:\
    \ cannot find 'alphabet' in scope\n                encryptedString.append(alphabet[newIndex])\n\
    \                                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = char.asciiValue! - 97\n        let newIndex = (index + 2 *\
    \ 2) % 26\n        let newChar = Character(UnicodeScalar(newIndex + 97)!)\n  \
    \      encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9c6apol.swift:20:61: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newIndex\
    \ + 97)!)\n                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n   \
    \                                                         \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted\
    \ += String(alphabet[newIndex])\n    }\n    return encrypted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmptr45nmd3/tmptr45nmd3.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5083e29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5083b20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5083b20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5083b1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptr45nmd3                        0x000056362432f6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002b5084015460 __libc_start_main +
    245

    6    tmptr45nmd3                        0x000056362432f319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 4\n            if\
    \ newIndex > 25 {\n                let newIndex = newIndex - 26\n            \
    \    encryptedString.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let encryptedCharIndex = charIndex\
    \ + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpev_fryjf.swift:20:72: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = Character(UnicodeScalar(encryptedCharIndex)!)\n\
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charIndex = char.asciiValue!\n        let newCharIndex = charIndex\
    \ + 2 * 2\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n   \
    \     encryptedString.append(newChar)\n    }\n    return encryptedString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ibn77cj.swift:20:60: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newCharIndex)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n              \
    \                                             \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ unicode = char.unicodeScalars.first!.value\n        let newUnicode = unicode\
    \ + 2 * 2\n        let newChar = Character(UnicodeScalar(newUnicode)!)\n     \
    \   result.append(newChar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp58ir0pde/tmp58ir0pde.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e741d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e73ecab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e73eca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e73ec97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp58ir0pde                        0x000055ec0f941b7e <unavailable> + 7038

    5    libc.so.6                          0x00002b9e743bf460 __libc_start_main +
    245

    6    tmp58ir0pde                        0x000055ec0f941379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.unicodeScalars.first!.value + 2 * 2)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpjchbcw8q/tmpjchbcw8q.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae056f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae056c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae056c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae056c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjchbcw8q                        0x000055d96311e787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae057173460 __libc_start_main +
    245

    6    tmpjchbcw8q                        0x000055d96311e3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index.encodedOffset + 4\n            let\
    \ newLetter = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex\
    \ % alphabet.count)]\n            encryptedString.append(newLetter)\n        }\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for letter in s {\n     \
    \   let unicode = letter.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedLetter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted += encryptedLetter\n    }\n    return encrypted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmphp86uelk/tmphp86uelk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b36d8987c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b36d867eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b36d867e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b36d867d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphp86uelk                        0x000055ff60117d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b36d8b73460 __libc_start_main +
    245

    6    tmphp86uelk                        0x000055ff60117549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedChar = Character(UnicodeScalar(encryptedUnicode)!)\n\
    \        encryptedString.append(encryptedChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2961kn2e/tmp2961kn2e.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace2d037c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace2cd2eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace2cd2e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace2cd2d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2961kn2e                        0x0000563937038b7e <unavailable> + 7038

    5    libc.so.6                          0x00002ace2d223460 __libc_start_main +
    245

    6    tmp2961kn2e                        0x0000563937038379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let ascii = char.asciiValue!\n        let newAscii = ascii + 2 * 2\n \
    \       let newChar = Character(UnicodeScalar(newAscii)!)\n        encryptedString.append(newChar)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpqp7y_y.swift:20:56: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let newChar = Character(UnicodeScalar(newAscii)!)\n\
    \                                ~~~~~~~~~~~~~~~~~~~~~~~^\n                  \
    \                                     \n"
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for letter in s {\n        if let index = alphabet.firstIndex(of: letter)\
    \ {\n            let newIndex = index.encodedOffset + 2 * 2\n            let newLetter\
    \ = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n      \
    \      encryptedString.append(newLetter)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b73343d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73340d0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b73340d0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b73340d013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b73340cfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b7334203ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b73341bc660 String.subscript.getter
    + 34

    7    tmpfyviqst3                        0x0000560608b550ef <unavailable> + 8431

    8    tmpfyviqst3                        0x0000560608b549fd <unavailable> + 6653

    9    libc.so.6                          0x00002b73345c5460 __libc_start_main +
    245

    10   tmpfyviqst3                        0x0000560608b542e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index.encodedOffset + 2\n            let\
    \ newChar = alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)]\n\
    \            encrypted.append(newChar)\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp92u2xrb9/tmp92u2xrb9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc9c8d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc9c5ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc9c5cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc9c5cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92u2xrb9                        0x000055ea39daf6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002afc9cac1460 __libc_start_main +
    245

    6    tmp92u2xrb9                        0x000055ea39daf2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       if let index = alphabet.firstIndex(of: char) {\n            encryptedString.append(alphabet[(index\
    \ + 2 * 2) % alphabet.count])\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjpm3t005.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmpjpm3t005.swift:19:36: error: cannot find 'alphabet' in scope\n\
    \            encryptedString.append(alphabet[(index + 2 * 2) % alphabet.count])\n\
    \                                   ^~~~~~~~\n/tmp/tmpjpm3t005.swift:19:63: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[(index\
    \ + 2 * 2) % alphabet.count])\n                                              \
    \                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index + 2 * 2\n            if newIndex >\
    \ alphabet.count - 1 {\n                let difference = newIndex - alphabet.count\n\
    \                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: difference)])\n            } else {\n                encrypted.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpdw9_h4fp.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz5sipapw/tmpz5sipapw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9444940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9444637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9444637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94446367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5sipapw                        0x000055794fa0a687 <unavailable> + 5767

    5    libc.so.6                          0x00002b9444b2c460 __libc_start_main +
    245

    6    tmpz5sipapw                        0x000055794fa0a2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(c.asciiValue!) + 2 * 2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmppws61o25.swift:18:79: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(c.asciiValue!)\
    \ + 2 * 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \  \n"
  stdout: ''
  timestamp: 1659824754
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: Implement this function\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp__468su4/tmp__468su4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ca182c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c9e79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c9e79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c9e787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__468su4                        0x000055c896c6d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b04ca36e460 __libc_start_main +
    245

    6    tmp__468su4                        0x000055c896c6cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let index = alphabet.firstIndex(of: char)\n        let newIndex = (index!\
    \ + 2 * 2) % alphabet.count\n        encryptedString.append(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1p1bxran.swift:18:21: error: cannot find 'alphabet' in scope\n\
    \        let index = alphabet.firstIndex(of: char)\n                    ^~~~~~~~\n\
    /tmp/tmp1p1bxran.swift:19:43: error: cannot find 'alphabet' in scope\n       \
    \ let newIndex = (index! + 2 * 2) % alphabet.count\n                         \
    \                 ^~~~~~~~\n/tmp/tmp1p1bxran.swift:20:32: error: cannot find 'alphabet'\
    \ in scope\n        encryptedString.append(alphabet[newIndex])\n             \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824868
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let asciiValue = char.asciiValue!\n        if asciiValue >= 97 && asciiValue\
    \ <= 122 {\n            let newAsciiValue = asciiValue + 2 * 2\n            if\
    \ newAsciiValue > 122 {\n                let newChar = Character(UnicodeScalar(newAsciiValue\
    \ - 26)!)\n                encryptedString.append(newChar)\n            } else\
    \ {\n                let newChar = Character(UnicodeScalar(newAsciiValue)!)\n\
    \                encryptedString.append(newChar)\n            }\n        } else\
    \ {\n            encryptedString.append(char)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt1xvkpr.swift:22:74: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                let newChar = Character(UnicodeScalar(newAsciiValue\
    \ - 26)!)\n                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                         \n/tmp/tmpkt1xvkpr.swift:25:69:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \                let newChar = Character(UnicodeScalar(newAsciiValue)!)\n    \
    \                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n         \
    \                                                           \n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let newChar = char.unicodeScalars.first!.value + (2 * 2)\n        encryptedString.append(Character(UnicodeScalar(newChar)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp1bd0m104/tmp1bd0m104.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7a76c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7a73bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7a73bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7a73ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bd0m104                        0x00005565550adb7e <unavailable> + 7038

    5    libc.so.6                          0x00002ae7a78b0460 __libc_start_main +
    245

    6    tmp1bd0m104                        0x00005565550ad379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ encryptedUnicode = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encryptedString += encryptedCharacter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppw30rh82/tmppw30rh82.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bfe780c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bfe477b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bfe477988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bfe4767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw30rh82                        0x00005627c724fd4e <unavailable> + 7502

    5    libc.so.6                          0x00002b1bfe96c460 __libc_start_main +
    245

    6    tmppw30rh82                        0x00005627c724f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824753
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ let unicode = char.unicodeScalars.first!.value\n        let encryptedUnicode\
    \ = unicode + (2 * 2)\n        let encryptedCharacter = String(UnicodeScalar(UInt8(encryptedUnicode)))\n\
    \        encrypted += encryptedCharacter\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpd42x1ag4/tmpd42x1ag4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f08fb4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f08cabb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f08cab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f08caa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd42x1ag4                        0x0000559644d79d4e <unavailable> + 7502

    5    libc.so.6                          0x00002b0f091a0460 __libc_start_main +
    245

    6    tmpd42x1ag4                        0x0000559644d79549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659824869
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let index = alphabet.firstIndex(of:\
    \ char) {\n            let newIndex = index + 2 * 2\n            if newIndex >\
    \ alphabet.count - 1 {\n                let newIndex = newIndex - alphabet.count\n\
    \                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: newIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwse5g2ng.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2 * 2\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1659824869
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        let newIndex = alphabet.index(index!, offsetBy: 2)\n      \
    \  encrypted.append(alphabet[newIndex])\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpke_9y62g/tmpke_9y62g.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77f239dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77f2094b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77f2094988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77f20937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpke_9y62g                        0x0000563ff4157687 <unavailable> + 5767

    5    libc.so.6                          0x00002b77f2589460 __libc_start_main +
    245

    6    tmpke_9y62g                        0x0000563ff41572c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824869
