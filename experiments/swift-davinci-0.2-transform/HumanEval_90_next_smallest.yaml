name: HumanEval_90_next_smallest
language: swift
prompt: "\n/// You are given a list of integers.\n/// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n/// Return None if there is\
  \ no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n/// >>>\
  \ next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: [] as [Int])\n\
  /// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst: [Int])\
  \ -> Int? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\n\
  assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as\
  \ [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
  \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
  \ [-35, 34, 12, -45]) == -35)"
completions: ["    guard lst.count > 1 else { return nil }\n    let sorted = lst.sorted()\n\
    \    return sorted[1]", "    guard lst.count > 1 else { return nil }\n    var\
    \ min = lst[0]\n    var secondMin = Int.max\n    for i in 1..<lst.count {\n  \
    \      if lst[i] < min {\n            secondMin = min\n            min = lst[i]\n\
    \        } else if lst[i] < secondMin {\n            secondMin = lst[i]\n    \
    \    }\n    }\n    return secondMin == Int.max ? nil : secondMin", "    if lst.count\
    \ < 2 {\n        return nil\n    }\n    var min = lst[0]\n    var secondMin =\
    \ lst[1]\n    if min > secondMin {\n        min = lst[1]\n        secondMin =\
    \ lst[0]\n    }\n    for i in 2..<lst.count {\n        if lst[i] < min {\n   \
    \         secondMin = min\n            min = lst[i]\n        } else if lst[i]\
    \ < secondMin {\n            secondMin = lst[i]\n        }\n    }\n    return\
    \ secondMin", "    if lst.count < 2 {\n        return nil\n    }\n    var smallest\
    \ = lst[0]\n    var secondSmallest = lst[1]\n    for i in 2..<lst.count {\n  \
    \      if lst[i] < smallest {\n            secondSmallest = smallest\n       \
    \     smallest = lst[i]\n        } else if lst[i] < secondSmallest {\n       \
    \     secondSmallest = lst[i]\n        }\n    }\n    return secondSmallest", " \
    \   guard lst.count > 1 else { return nil }\n    var min = lst[0]\n    var secondMin\
    \ = Int.max\n    for i in 1..<lst.count {\n        if lst[i] < min {\n       \
    \     secondMin = min\n            min = lst[i]\n        } else if lst[i] < secondMin\
    \ {\n            secondMin = lst[i]\n        }\n    }\n    return secondMin ==\
    \ Int.max ? nil : secondMin", "    if lst.count < 2 {\n        return nil\n  \
    \  }\n    let sorted = lst.sorted()\n    return sorted[1]", "    guard lst.count\
    \ > 1 else { return nil }\n    let sorted = lst.sorted()\n    for i in 1..<sorted.count\
    \ {\n        if sorted[i] != sorted[i - 1] {\n            return sorted[i]\n \
    \       }\n    }\n    return nil", "    var min = Int.max\n    var secondMin =\
    \ Int.max\n    for i in lst {\n        if i < min {\n            secondMin = min\n\
    \            min = i\n        } else if i < secondMin {\n            secondMin\
    \ = i\n        }\n    }\n    return secondMin == Int.max ? nil : secondMin", " \
    \   guard lst.count > 1 else { return nil }\n    let sorted = lst.sorted()\n \
    \   var previous = sorted[0]\n    for i in 1..<sorted.count {\n        if sorted[i]\
    \ != previous {\n            return sorted[i]\n        }\n        previous = sorted[i]\n\
    \    }\n    return nil", "    var min = lst[0]\n    var secondMin = Int.max\n\
    \    for i in lst {\n        if i < min {\n            secondMin = min\n     \
    \       min = i\n        } else if i < secondMin && i != min {\n            secondMin\
    \ = i\n        }\n    }\n    return secondMin == Int.max ? nil : secondMin", " \
    \   if lst.count < 2 {\n        return nil\n    }\n    var min = lst[0]\n    var\
    \ secondMin = lst[1]\n    for i in 2..<lst.count {\n        if lst[i] < min {\n\
    \            secondMin = min\n            min = lst[i]\n        } else if lst[i]\
    \ < secondMin {\n            secondMin = lst[i]\n        }\n    }\n    return\
    \ secondMin", "    guard lst.count > 1 else { return nil }\n    var lst = lst\n\
    \    lst.sort()\n    for i in 1..<lst.count {\n        if lst[i] != lst[i-1] {\n\
    \            return lst[i]\n        }\n    }\n    return nil", "    guard lst.count\
    \ > 1 else { return nil }\n    var smallest = lst[0]\n    var secondSmallest =\
    \ Int.max\n    for num in lst {\n        if num < smallest {\n            secondSmallest\
    \ = smallest\n            smallest = num\n        } else if num < secondSmallest\
    \ && num != smallest {\n            secondSmallest = num\n        }\n    }\n \
    \   return secondSmallest == Int.max ? nil : secondSmallest", "    if lst.count\
    \ < 2 {\n        return nil\n    }\n    var min = lst[0]\n    var secondMin =\
    \ lst[1]\n    for i in 2..<lst.count {\n        if lst[i] < min {\n          \
    \  secondMin = min\n            min = lst[i]\n        } else if lst[i] < secondMin\
    \ {\n            secondMin = lst[i]\n        }\n    }\n    return secondMin",
  "    guard lst.count > 1 else { return nil }\n    var smallest = lst[0]\n    var\
    \ secondSmallest = lst[1]\n    if smallest > secondSmallest {\n        smallest\
    \ = lst[1]\n        secondSmallest = lst[0]\n    }\n    for i in 2..<lst.count\
    \ {\n        if lst[i] < smallest {\n            secondSmallest = smallest\n \
    \           smallest = lst[i]\n        } else if lst[i] < secondSmallest {\n \
    \           secondSmallest = lst[i]\n        }\n    }\n    return secondSmallest",
  "    guard lst.count > 1 else { return nil }\n    var smallest = lst[0]\n    var\
    \ secondSmallest = lst[1]\n    for i in 1..<lst.count {\n        if lst[i] < smallest\
    \ {\n            secondSmallest = smallest\n            smallest = lst[i]\n  \
    \      } else if lst[i] < secondSmallest {\n            secondSmallest = lst[i]\n\
    \        }\n    }\n    return smallest == secondSmallest ? nil : secondSmallest",
  "    guard lst.count > 1 else { return nil }\n    var smallest = lst[0]\n    var\
    \ secondSmallest = lst[1]\n    for i in 2..<lst.count {\n        if lst[i] < smallest\
    \ {\n            secondSmallest = smallest\n            smallest = lst[i]\n  \
    \      } else if lst[i] < secondSmallest {\n            secondSmallest = lst[i]\n\
    \        }\n    }\n    return secondSmallest", "    guard lst.count > 1 else {\
    \ return nil }\n    var min = lst[0]\n    var secondMin = Int.max\n    for i in\
    \ 1..<lst.count {\n        if lst[i] < min {\n            secondMin = min\n  \
    \          min = lst[i]\n        } else if lst[i] < secondMin {\n            secondMin\
    \ = lst[i]\n        }\n    }\n    return secondMin == Int.max ? nil : secondMin",
  "    if lst.count < 2 {\n        return nil\n    }\n    var min = lst[0]\n    var\
    \ secondMin = lst[1]\n    for i in lst {\n        if i < min {\n            secondMin\
    \ = min\n            min = i\n        } else if i < secondMin {\n            secondMin\
    \ = i\n        }\n    }\n    return secondMin", "    if lst.count < 2 {\n    \
    \    return nil\n    }\n    var min = lst[0]\n    var secondMin = lst[1]\n   \
    \ if min > secondMin {\n        min = lst[1]\n        secondMin = lst[0]\n   \
    \ }\n    for i in 2..<lst.count {\n        if lst[i] < min {\n            secondMin\
    \ = min\n            min = lst[i]\n        } else if lst[i] < secondMin {\n  \
    \          secondMin = lst[i]\n        }\n    }\n    return secondMin"]
stop_tokens:
- "\n}"
