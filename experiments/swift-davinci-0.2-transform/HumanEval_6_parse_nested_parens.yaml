name: HumanEval_6_parse_nested_parens
language: swift
prompt: "\n/// Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n/// For each of the group, output the\
  \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
  \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
  \ String) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()())\
  \ ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
  \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
  \ \"(()(())((())))\") == [4])"
completions: ["    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_nesting_level = 0\n\
    \        var current_nesting_level = 0\n        for char in group {\n        \
    \    if char == \"(\" {\n                current_nesting_level += 1\n        \
    \    } else if char == \")\" {\n                current_nesting_level -= 1\n \
    \           }\n            if current_nesting_level > max_nesting_level {\n  \
    \              max_nesting_level = current_nesting_level\n            }\n    \
    \    }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var result: [Int] = []\n    var current_max: Int =\
    \ 0\n    var current_level: Int = 0\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            current_level += 1\n            if current_level\
    \ > current_max {\n                current_max = current_level\n            }\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(current_max)\n          \
    \  current_max = 0\n            current_level = 0\n        }\n    }\n    result.append(current_max)\n\
    \    return result", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for paren in paren_group {\n            if paren == \"(\" {\n       \
    \         current_nesting_level += 1\n            } else if paren == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_depth_list = [Int]()\n  \
    \  var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            current_depth += 1\n            if\
    \ current_depth > max_depth {\n                max_depth = current_depth\n   \
    \         }\n        } else if char == \")\" {\n            current_depth -= 1\n\
    \            if current_depth == 0 {\n                max_depth_list.append(max_depth)\n\
    \                max_depth = 0\n            }\n        }\n    }\n    return max_depth_list",
  "    var result = [Int]()\n    let groups = paren_string.split(separator: \" \"\
    )\n    for group in groups {\n        var max_depth = 0\n        var depth = 0\n\
    \        for char in group {\n            if char == \"(\" {\n               \
    \ depth += 1\n            } else if char == \")\" {\n                depth -=\
    \ 1\n            }\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        }\n        result.append(max_depth)\n    }\n\
    \    return result", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for paren in paren_group {\n            if paren == \"(\" {\n       \
    \         current_nesting_level += 1\n            } else if paren == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_nesting_levels = [Int]()\n\
    \    let groups = paren_string.split(separator: \" \")\n    for group in groups\
    \ {\n        var nesting_level = 0\n        var max_nesting_level = 0\n      \
    \  for paren in group {\n            if paren == \"(\" {\n                nesting_level\
    \ += 1\n            } else if paren == \")\" {\n                nesting_level\
    \ -= 1\n            }\n            if nesting_level > max_nesting_level {\n  \
    \              max_nesting_level = nesting_level\n            }\n        }\n \
    \       max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels",
  "    var result: [Int] = []\n    var current_max = 0\n    var current_count = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_count\
    \ += 1\n            if current_count > current_max {\n                current_max\
    \ = current_count\n            }\n        } else if char == \")\" {\n        \
    \    current_count -= 1\n        } else if char == \" \" {\n            result.append(current_max)\n\
    \            current_max = 0\n            current_count = 0\n        }\n    }\n\
    \    result.append(current_max)\n    return result", "    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            depth += 1\n            max_depth = max(max_depth,\
    \ depth)\n        } else if char == \")\" {\n            depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_nesting = 0\n    var current_nesting = 0\n \
    \   var result = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result", "    var result: [Int] = []\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_depth = 0\n        var current_depth\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       current_depth += 1\n            } else if char == \")\" {\n          \
    \      current_depth -= 1\n            }\n            if current_depth > max_depth\
    \ {\n                max_depth = current_depth\n            }\n        }\n   \
    \     result.append(max_depth)\n    }\n    return result", "    var result = [Int]()\n\
    \    let groups = paren_string.split(separator: \" \")\n    for group in groups\
    \ {\n        var max_depth = 0\n        var depth = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                depth += 1\n            }\
    \ else if char == \")\" {\n                depth -= 1\n            }\n       \
    \     if depth > max_depth {\n                max_depth = depth\n            }\n\
    \        }\n        result.append(max_depth)\n    }\n    return result", "   \
    \ var max_depth = 0\n    var curr_depth = 0\n    var result = [Int]()\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            curr_depth +=\
    \ 1\n            max_depth = max(max_depth, curr_depth)\n        } else if char\
    \ == \")\" {\n            curr_depth -= 1\n        } else if char == \" \" {\n\
    \            result.append(max_depth)\n            max_depth = 0\n           \
    \ curr_depth = 0\n        }\n    }\n    result.append(max_depth)\n    return result",
  "    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        result.append(parse_nested_parens_helper(paren_string:\
    \ group))\n    }\n    return result", "    var max_nesting = [Int]()\n    var\
    \ current_nesting = 0\n    var max_current_nesting = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            current_nesting += 1\n          \
    \  if current_nesting > max_current_nesting {\n                max_current_nesting\
    \ = current_nesting\n            }\n        } else if char == \")\" {\n      \
    \      current_nesting -= 1\n        } else if char == \" \" {\n            max_nesting.append(max_current_nesting)\n\
    \            max_current_nesting = 0\n            current_nesting = 0\n      \
    \  }\n    }\n    max_nesting.append(max_current_nesting)\n    return max_nesting",
  "    var result: [Int] = []\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        result.append(parse_nested_parens_helper(paren_group:\
    \ paren_group))\n    }\n    return result", "    var result = [Int]()\n    let\
    \ groups = paren_string.components(separatedBy: \" \")\n    for group in groups\
    \ {\n        var max_nesting = 0\n        var current_nesting = 0\n        for\
    \ char in group {\n            if char == \"(\" {\n                current_nesting\
    \ += 1\n            } else if char == \")\" {\n                current_nesting\
    \ -= 1\n            }\n            if current_nesting > max_nesting {\n      \
    \          max_nesting = current_nesting\n            }\n        }\n        result.append(max_nesting)\n\
    \    }\n    return result", "    var max_nesting_levels = [Int]()\n    let groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in groups {\n \
    \       var max_nesting_level = 0\n        var current_nesting_level = 0\n   \
    \     for char in group {\n            if char == \"(\" {\n                current_nesting_level\
    \ += 1\n            } else if char == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [Int]()\n    for paren_group in paren_groups {\n  \
    \      result.append(parse_nested_parens_helper(paren_group: paren_group))\n \
    \   }\n    return result", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_levels = [Int]()\n    for group in groups {\n        var\
    \ level = 0\n        var max_level = 0\n        for char in group {\n        \
    \    if char == \"(\" {\n                level += 1\n            } else if char\
    \ == \")\" {\n                level -= 1\n            }\n            if level\
    \ > max_level {\n                max_level = level\n            }\n        }\n\
    \        max_levels.append(max_level)\n    }\n    return max_levels"]
stop_tokens:
- "\n}"
