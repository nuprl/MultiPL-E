language: d
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    \n    for(int i = 1; i < factors.length; i++)\n\
    \    {\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = n;\n    return factors;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis code doesn't work for `factorize(8L)` which should return `[2L,\
    \ 2L, 2L]` but returns `[1L, 1L, 1L]`\n<|/ c |>\n<| c |>\nIt works for me. `factorize(8L)`\
    \ returns `[2L, 2L, 2L]`\n<|/ c |>\n<| c |>\nIt works for me too. `factorize(8L)`\
    \ returns `[2L, 2L, 2L]`\n<|/ c |>\n<| c |>\nIt works for me too. `factorize(8L)`\
    \ returns `[2L, 2L, 2L]`\n<|/ c |>\n<| c |>\nIt works for me too. `factorize(8L)`\
    \ returns `[2L, 2L, 2L]`\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static int[]\
    \ factorize(long n) {\n    int[] factors = new int[(int) Math.sqrt(n)];\n    int\
    \ factor = 1;\n    int factorCount = 0;\n    for (int i = 1; i < factors.length;\
    \ i++) {\n        while (n % factor == 0) {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,java\
    \ |>\n<| c |>\nThis code doesn't work for `factorize(8L)` which should return\
    \ `[2L, 2L, 2L]` but returns `[1L, 1L, 1L]`\n<|/ c |>\n<| c |>\nIt works for me.\
    \ `factorize(8L)` returns `[2L, 2L, 2L]`\n<|/ c |>\n<| c |>\nIt works for me too.\
    \ `factorize(8L)` returns `[2L, 2L, 2L]`\n<|/ c |>\n<| c |>\nIt works for me too.\
    \ `factorize(8L)` returns `[2L, 2L, 2L]`\n<|/ c |>\n<|\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgf0mh_l9.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpgf0mh_l9.d(33):
    Error: declaration expected, not `<`\n/tmp/tmpgf0mh_l9.d(36): Error: unterminated
    character constant\n/tmp/tmpgf0mh_l9.d(56): Error: declaration expected, not `for`\n/tmp/tmpgf0mh_l9.d(56):
    Error: no identifier for declarator `i`\n/tmp/tmpgf0mh_l9.d(56): Error: declaration
    expected, not `<`\n/tmp/tmpgf0mh_l9.d(56): Error: no identifier for declarator
    `i`\n/tmp/tmpgf0mh_l9.d(56): Error: declaration expected, not `++`\n/tmp/tmpgf0mh_l9.d(59):
    Error: no identifier for declarator `n`\n/tmp/tmpgf0mh_l9.d(59): Error: declaration
    expected, not `/=`\n/tmp/tmpgf0mh_l9.d(60): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgf0mh_l9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n); i++) {\n   \
    \     while(n % i == 0) {\n            factors[factorCount] = i;\n           \
    \ n /= i;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=java,primes,algorithm |>\n\
    <| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi_ivbv5f.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpi_ivbv5f.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpi_ivbv5f.d(30): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_ivbv5f.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)];\n    long p = n;\n    long\
    \ factor = 1;\n    long factor_count = 1;\n    long i = 1;\n    \n    while(p\
    \ != 1)\n    {\n        while(p % i == 0)\n        {\n            factors[factor_count]\
    \ = i;\n            factor_count++;\n            p /= i;\n        }\n        i++;\n\
    \    }\n    \n    factors[factor_count] = 1;\n    factor_count++;\n    \n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorization_type)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)];\n    long p = n;\n    long\
    \ factor = 1;\n    long factor_count = 1;\n    long i = 1;\n    \n    while(p\
    \ != 1)\n    {\n        while(p % i == 0)\n        {\n            factors[factor_count]\
    \ = i;\n            factor_count++;\n            p /= i;\n        }\n        i++;\n\
    \    }\n    \n    factors[factor_count] = 1;\n    factor_count++;\n    \n    return\
    \ factors;\n}\n/*\n Return list of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be listed number of\
    \ times corresponding to how many times it appeares in factorization.\n    Input\
    \ number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorization_type,\
    \ int max_factorization) \n{\n    long[] factors = new long[(int)sqrt(n)];\n \
    \   long p = n;\n    long factor = 1;\n    long factor_count = 1;\n    long i\
    \ = 1;\n    \n    while(p != 1)\n    {\n        while(p % i == 0)\n        {\n\
    \            factors[factor_count] = i;\n            factor_count++;\n       \
    \     p /= i;\n        }\n        i++;\n    }\n    \n    factors[factor_count]\
    \ = 1;\n\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9bvhfcpo.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp9bvhfcpo.d(53):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp9bvhfcpo.d(89): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp9bvhfcpo.d(108): Error:
    found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp9bvhfcpo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long factorCount = 0;\n    \n    for(int i = 0; i <=\
    \ (int)Math.sqrt(n); i++) {\n        while(p % factor == 0) {\n            factors[factorCount]\
    \ = factor;\n            factorCount++;\n            p /= factor;\n        }\n\
    \        factor *= i;\n    }\n    factors[factorCount] = p;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long p = n;\n   \
    \ long factor = 1;\n    long factorCount = 0;\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(p % factor == 0) {\n            factors[factorCount] =\
    \ factor;\n            factorCount++;\n            p /= factor;\n        }\n \
    \       factor *= i;\n    }\n    factors[factorCount] = p;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors, int factorCount) \n{\n   \
    \ long p = n;\n    long factor = 1;\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(p % factor == 0) {\n            factors[factorCount] =\
    \ factor;\n            factorCount++;\n            p /= factor;\n        }\n \
    \       factor *= i;\n    }\n    factors[factorCount] = p;\n    return factors;\n\
    }\n/*\n Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppqk3y4ce.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppqk3y4ce.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppqk3y4ce.d(51):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppqk3y4ce.d(79):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppqk3y4ce.d(90):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqk3y4ce.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    \n    for(int i = 1; i < factors.length; i++)\n  \
    \  {\n        while(n % factor == 0)\n        {\n            factors[counter]\
    \ = factor;\n            n /= factor;\n            counter++;\n        }\n   \
    \     factor++;\n    }\n    \n    factors[counter] = n;\n    return factors;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxhybo70p.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpxhybo70p.d(35):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxhybo70p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            factor *= i;\n     \
    \       factorCount++;\n            n /= i;\n        }\n        result[(int)i]\
    \ = factor;\n    }\n    if(n > 1)\n    {\n        factor *= n;\n        factorCount++;\n\
    \    }\n    result[(int)Math.sqrt(n)] = factor;\n    return Arrays.copyOf(result,\
    \ factorCount);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,primes,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6um8zv44.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp6um8zv44.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp6um8zv44.d(28):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp6um8zv44.d(35): Error:
    C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp6um8zv44.d(38): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6um8zv44.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorsRemaining = n;\n    \n    for(int\
    \ i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factorsRemaining % i\
    \ == 0)\n        {\n            factorsRemaining /= i;\n            factorCount++;\n\
    \        }\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n   \
    \ {\n        if(factorsRemaining % i == 0)\n        {\n            factorsRemaining\
    \ /= i;\n            factorCount++;\n            result[factorCount] = i;\n  \
    \      }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpradvytxr.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpradvytxr.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpradvytxr.d(31):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpradvytxr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        if(n % i == 0) {\n            factors[factorCount] = i;\n           \
    \ factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp64ajytsa.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp64ajytsa.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp64ajytsa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n   \
    \     while(p % i == 0) {\n            factors[factor++] = i;\n            p /=\
    \ i;\n        }\n    }\n    factors[factor++] = p;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd6_kjm2i.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpd6_kjm2i.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpd6_kjm2i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    for(int i = 1; i\
    \ <= (int)Math.sqrt(n); i++)\n    {\n        factors[factor_index] = i;\n    \
    \    factor_index++;\n        while(n % i == 0)\n        {\n            factors[factor_index]\
    \ = i;\n            factor_index++;\n            n /= i;\n        }\n    }\n \
    \   for(int i = 0; i <= factor_index; i++)\n    {\n        factors[i] = factor_count;\n\
    \        factor_count *= factors[i];\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n \
    \   long factor_count = 1;\n    long factor_index = 0;\n    for(int i = 1; i <=\
    \ (int)Math.sqrt(n); i++)\n    {\n        factors[factor_index] = i;\n       \
    \ factor_index++;\n        while(n % i == 0)\n        {\n            factors[factor_index]\
    \ = i;\n            factor_index++;\n            n /= i;\n        }\n    }\n \
    \   for(int i = 0; i <= factor_index; i++)\n    {\n        factors[i] = factor_count;\n\
    \        factor_count *= factors[i];\n    }\n    return factors;\n}\n/*\n Return\
    \ list of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be listed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long factor\
    \ = 1;\n    long factor_count = 1;\n    long factor_index = 0;\n    for(int i\
    \ = start; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[factor_index]\
    \ = i;\n        factor_index++;\n        while(n % i == 0)\n        {\n      \
    \      factors[factor_index] = i;\n            factor_index++;\n            n\
    \ /= \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzsd1zdov.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzsd1zdov.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzsd1zdov.d(56):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzsd1zdov.d(91):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzsd1zdov.d(100):
    Error: expression expected, not `unittest`\n/tmp/tmpzsd1zdov.d(101): Error: found
    `{` when expecting `;` following statement\n/tmp/tmpzsd1zdov.d(113): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmpzsd1zdov.d(113):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzsd1zdov.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n  \
    \      while(n % factor == 0) {\n            result[counter] = factor;\n     \
    \       n /= factor;\n            counter++;\n        }\n        factor++;\n \
    \   }\n    result[counter] = n;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp_vaopsv.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpp_vaopsv.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp_vaopsv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    long maxFactorization\
    \ = 1;\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n       \
    \ factors[i] = factor;\n        factor *= i;\n        factorization *= i;\n  \
    \  }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        while(factorization\
    \ % factors[i] == 0)\n        {\n            factorization = factorization/factors[i];\n\
    \            counter++;\n        }\n        factors[i] = counter;\n        counter\
    \ = 1;\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        factors[i] = factors[i];\n        factors[i] = factors[i];\n    }\n \
    \   \n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i]\
    \ == 1)\n        {\n            factors[i] = maxFactorization;\n            maxFactorization\
    \ *= i;\n        }\n    }\n    \n    return factors;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=algorithm,primes,c#,factorization |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppybqz78h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppybqz78h.d(23):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppybqz78h.d(30):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppybqz78h.d(41):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppybqz78h.d(47):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppybqz78h.d(58):
    Error: declaration expected, not `<`\n/tmp/tmppybqz78h.d(63): Error: semicolon
    expected, not `.`\n/tmp/tmppybqz78h.d(63): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmppybqz78h.d(64): Error: semicolon expected, not
    `.`\n/tmp/tmppybqz78h.d(64): Error: no identifier for declarator `.Linq`\n/tmp/tmppybqz78h.d(65):
    Error: semicolon expected, not `.`\n/tmp/tmppybqz78h.d(65): Error: no identifier
    for declarator `.Text`\n/tmp/tmppybqz78h.d(66): Error: semicolon expected, not
    `.`\n/tmp/tmppybqz78h.d(66): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppybqz78h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\
    \    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long\
    \ o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n\
    \    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long\
    \ x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n\
    \    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long\
    \ g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr5v07sr7.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpr5v07sr7.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpr5v07sr7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long i = 2;\n    while(i <= n)\n    {\n     \
    \   while(n % i == 0)\n        {\n            factors[factor_count] = i;\n   \
    \         factor_count++;\n            n /= i;\n        }\n        i++;\n    }\n\
    \    factors[factor_count] = n;\n    return factors;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI like this solution, however it fails for large numbers. I tested with\
    \ n = 10^9 and it took about a minute to complete. With n = 10^10 it took about\
    \ a minute and a half. With n = 10^11 it took about a minute and a half. With\
    \ n = 10^12 it took about a minute and a half. With n = 10^13 it took about a\
    \ minute and a half. With n = 10^14 it took about a minute and a half. With n\
    \ = 10^15 it took about a minute and a half. With n = 10^16 it took about a minute\
    \ and a half. With n = 10^17 it took about a minute and a half. With n = 10^18\
    \ it took about a minute and a half. With n = 10^19 it took about a minute and\
    \ a half. With n = 10^20 it took about a minute and a half. With n = 10^21 it\
    \ took about a minute and a half. With n = 10^22 it took about a minute and a\
    \ half. With n = 10^23 it took about a minute and a half. With n = 10^24 it took\
    \ about a minute and a half. With n = 10^25 it took about a minute and a half.\
    \ With n = 10^26 it took about a minute and a half. With n = 10^27 it took about\
    \ a minute and a half. With n = 10^28 it took about a minute and a half. With\
    \ n = 10^29 it took about a minute and a half. With n = 10^30 it took about a\
    \ minute and a half. With n = 10^31 it took about a minute and a half. With n\
    \ = 10^32 it took about a minute and a half. With n = 10^33 it took about a minute\
    \ and a half. With n = 10^34 it took about a minute and a half. With n = 10^35\
    \ it took about a minute and a half. With n = 10^36 it took about a minute and\
    \ a half. With n = 10^37 it took \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpljh95op9.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpljh95op9.d(34):
    Error: declaration expected, not `<`\n/tmp/tmpljh95op9.d(42): Error: declaration
    expected, not `assert`\n/tmp/tmpljh95op9.d(43): Error: declaration expected, not
    `assert`\n/tmp/tmpljh95op9.d(44): Error: declaration expected, not `assert`\n/tmp/tmpljh95op9.d(45):
    Error: declaration expected, not `assert`\n/tmp/tmpljh95op9.d(46): Error: declaration
    expected, not `assert`\n/tmp/tmpljh95op9.d(47): Error: declaration expected, not
    `assert`\n/tmp/tmpljh95op9.d(48): Error: declaration expected, not `assert`\n/tmp/tmpljh95op9.d(49):
    Error: declaration expected, not `assert`\n/tmp/tmpljh95op9.d(50): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpljh95op9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            n /= i;\n            factorCount++;\n\
    \        }\n        result[i] = factor;\n        factor += factorCount;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpguln6yr_.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpguln6yr_.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpguln6yr_.d(30):
    Error: declaration expected, not `<`\n/tmp/tmpguln6yr_.d(35): Error: identifier
    expected following `package`\n/tmp/tmpguln6yr_.d(35): Error: `;` expected\n/tmp/tmpguln6yr_.d(36):
    Error: identifier expected following `package`\n/tmp/tmpguln6yr_.d(36): Error:
    `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpguln6yr_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long factorCount = 0;\n    for(int i = 1; i <\
    \ factors.length; i++)\n    {\n        factors[i] = factor;\n        factor *=\
    \ i;\n        counter = 1;\n        while(n % factor == 0)\n        {\n      \
    \      n /= factor;\n            counter++;\n        }\n        factors[i] = counter;\n\
    \    }\n    return factors;\n}\n/*\n Return list of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be listed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n  \
    \  long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n   \
    \ long counter = 1;\n    long factorCount = 0;\n    for(int i = 1; i < factors.length;\
    \ i++)\n    {\n        factors[i] = factor;\n        factor *= i;\n        counter\
    \ = 1;\n        while(n % factor == 0)\n        {\n            n /= factor;\n\
    \            counter++;\n        }\n        factors[i] = counter;\n        if(factorCount\
    \ < maxFactors)\n        {\n            factorCount++;\n        }\n    }\n   \
    \ return factors;\n}\n/*\n Return list of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be listed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long factorCount = 0;\n    for(int i = 1; i <\
    \ factors.length; i++)\n    {\n        factors[i] = factor;\n        factor *=\
    \ i;\n        counter = 1;\n        while(n % factor == 0)\n        {\n      \
    \      n /= factor;\n            counter++;\n        }\n        factors[i] = counter;\n\
    \        if(factorCount < maxFactors)\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3630teb3.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3630teb3.d(49):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3630teb3.d(85):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3630teb3.d(102):
    Error: found `unittest` instead of statement\n/tmp/tmp3630teb3.d(115): Error:
    found `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3630teb3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCountIndex\
    \ = 0;\n    long factorCountMax = 0;\n    long factorCountMaxIndex = 0;\n    \n\
    \    for(long i = 2; i <= n; i++)\n    {\n        factors[factorIndex] = i;\n\
    \        factorCount++;\n        factorCountMax = factorCount;\n        factorCountMaxIndex\
    \ = factorIndex;\n        factorIndex++;\n        \n        for(long j = i; j\
    \ <= n; j++)\n        {\n            if(j % i == 0)\n            {\n         \
    \       factors[factorIndex] = j;\n                factorCount++;\n          \
    \      factorCountMax = factorCount;\n                factorCountMaxIndex = factorIndex;\n\
    \                factorIndex++;\n            }\n        }\n    }\n    \n    factors[factorCountMaxIndex]\
    \ = n;\n    factorCountMax++;\n    \n    for(long i = 0; i < factorCountMax; i++)\n\
    \    {\n        if(factors[i] == 1)\n        {\n            factorCount--;\n \
    \       }\n    }\n    \n    factors[factorCountMaxIndex] = n;\n    factorCountMax++;\n\
    \    \n    for(long i = 0; i < factorCountMax; i++)\n    {\n        if(factors[i]\
    \ == 1)\n        {\n            factorCount--;\n        }\n    }\n    \n    for(long\
    \ i = 0; i < factorCountMax; i++)\n    {\n        if(factors[i] == 1)\n      \
    \  {\n            factorCount--;\n        }\n    }\n    \n    for(long i = 0;\
    \ i < factorCountMax; i++)\n    {\n        if(factors[i] == 1)\n        {\n  \
    \          factorCount--;\n        }\n    }\n    \n    for(long i = 0; i < factorCountMax;\
    \ i++)\n    {\n        if(factors[i] == 1)\n        {\n            factorCount--;\n\
    \        }\n    }\n    \n    for(long i = 0; i < factorCountMax; i++)\n    {\n\
    \        if(factors[i] == 1)\n        {\n            factorCount--;\n        }\n\
    \    }\n    \n    for(long i = 0; i < factorCountMax; i++)\n    {\n        if(factors[i]\
    \ == 1)\n        {\n            factorCount--;\n        }\n    }\n    \n    for(long\
    \ i = 0; i < factorCountMax; i++)\n    {\n        if(factors[i] == 1)\n      \
    \  {\n            factorCount--;\n        }\n    }\n    \n    for(long i = 0;\
    \ i < factorCountMax; i++)\n    {\n        if(factors[i] == 1)\n        {\n  \
    \          factorCount--;\n        }\n    }\n    \n    for(long i = 0; i < factorCountMax;\
    \ i++)\n    {\n        if(factors[i] == 1)\n        {\n            factorCount--;\n\
    \        }\n    }\n    \n    for(long i = 0; i < factorCount\nunittest\n{\n  \
    \  alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwopvw0tc.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpwopvw0tc.d(133):
    Error: found `unittest` when expecting `;` following `for` condition\n/tmp/tmpwopvw0tc.d(146):
    Error: found `void` when expecting `)`\n/tmp/tmpwopvw0tc.d(146): Error: found
    `{` when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpwopvw0tc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    \n    while(p < r)\n    {\n        while(p < r)\n        {\n   \
    \         while(p < r)\n            {\n                while(p < r)\n        \
    \        {\n                    while(p < r)\n                    {\n        \
    \                while(p < r)\n                        {\n                   \
    \         while(p < r)\n                            {\n                      \
    \          while(p < r)\n                                {\n                 \
    \                   while(p < r)\n                                    {\n    \
    \                                    while(p < r)\n                          \
    \              {\n                                            while(p < r)\n \
    \                                           {\n                              \
    \                  while(p < r)\n                                            \
    \    {\n                                                    while(p < r)\n   \
    \                                                 {\n                        \
    \                                while(p < r)\n                              \
    \                          {\n                                               \
    \             while(p < r)\n                                                 \
    \           {\n                                                              \
    \  while(p < r)\n                                                            \
    \    {\n                                                                    while(p\
    \ < r)\n                                                                    {\n\
    \                                                                        while(p\
    \ < r)\n                                                                     \
    \   {\n                                                                      \
    \      while(p < r)\n                                                        \
    \                    {\n                                                     \
    \                           while(p < r)\n                                   \
    \                                             {\n                            \
    \                                                        while(p < r)\n      \
    \                                                                            \
    \  {\n                                                                       \
    \                 while(p < r)\n                                             \
    \                                           {\n                              \
    \                                                              while(p < r)\n\
    \                                                                            \
    \                {\n                                                         \
    \                                       while(p < r)\n                       \
    \                                                                         {\n\
    \                                                                            \
    \                        while(p < r)\n                                      \
    \                                                              {\n           \
    \                                                                            \
    \                 while(p < r)\n                                             \
    \                                                           {\n              \
    \                                                                            \
    \                  while(p < r)\n                                            \
    \                                                                {\n         \
    \                                                                            \
    \                           while(p < r)\n                                   \
    \                                                                            \
    \ {\n                                                                        \
    \                                            while(p < r)\n                  \
    \                                                                            \
    \                      {\n                                                   \
    \                                                                     while(p\
    \ < r)\n                                                                     \
    \                                                   {\n                      \
    \                                                                            \
    \                          while(p < r)\n                                    \
    \                                                                            \
    \            {\n                                                             \
    \                                                                   while(p <\
    \ r)\n                                                                       \
    \                                                         {\n                \
    \                                                                            \
    \                                        while(p < r)\n                      \
    \                                                                            \
    \                                  {\n                                       \
    \                                                                            \
    \                     while(p < r)\n                                         \
    \                                                                            \
    \                   {\n                                                      \
    \                                                                            \
    \          while(p < r)\n                                                    \
    \                                                                            \
    \            {\n                                                             \
    \                                                                            \
    \       while(p < r)\n                                                       \
    \                                                                            \
    \             {\n                                                            \
    \                                                                            \
    \            while(p < r)\n                                                  \
    \                                                                            \
    \                      {\n                                                   \
    \                                                                            \
    \                         while(p < r)\n                                     \
    \                                                                            \
    \                                       {\n                                  \
    \                                                                            \
    \                                              while(p < r)\n                \
    \                                                                            \
    \                                                                {\n         \
    \                                                                            \
    \                                                                           while(p\
    \ < r)\n                                                                     \
    \                                                                            \
    \               {\n                                                          \
    \                                                                            \
    \                              while(p < r)\n                                \
    \                                                                            \
    \                                                        {\n                 \
    \                                                                            \
    \                                                                           while(p\
    \ < r)\n                                                                     \
    \                                                                            \
    \                       {\n                                                  \
    \              \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa2f7qwm5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpa2f7qwm5.d(115):
    Error: found `unittest` instead of statement\n/tmp/tmpa2f7qwm5.d(128): Error:
    found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa2f7qwm5.d(128):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2f7qwm5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long count = 0;\n    long i = 1;\n    while(factor <= n && i <= factors.length)\n\
    \    {\n        if(n % factor == 0)\n        {\n            factors[count] = factor;\n\
    \            count++;\n            n = n / factor;\n        }\n        factor++;\n\
    \        i++;\n    }\n    factors[count] = n;\n    return factors;\n}\n</code>\n\
    <|/ a tags=primes,algorithm,c#,factorization |>\n<| c |>\nThis code is not correct.\
    \ For example, factorize(8L) returns [2, 2, 2] instead of [2, 2, 2, 2]. Also,\
    \ factorize(25L) returns [5, 5] instead of [5, 5]. Also, factorize(70L) returns\
    \ [2, 2, 5, 7] instead of [2, 2, 5, 7, 7].\n<|/ c |>\n<| c |>\nI tested it on\
    \ C# and it works. I used the code from http://stackoverflow.com/questions/127704/algorithm-to-return-all-factors-of-a-given-number\n\
    <|/ c |>\n<| c |>\nI tested it on C# and it works. I used the code from http://stackoverflow.com/questions/127704/algorithm-to-return-all-factors-of-a-given-number\n\
    <|/ c |>\n<| c |>\nI tested it on C# and it works. I used the code from http://stackoverflow.com/questions/127704/algorithm-to-return-all-factors-of-a-given-number\n\
    <|/ c |>\n<| c |>\nI tested it on C# and it works. I used the code from http://stackoverflow.com/questions/127704/algorithm-to-return-all-factors-of-a-given-number\n\
    <|/ c |>\n<| a dscore=5 |>\nI wrote a C# program to solve this problem in O(sqrt(n))\
    \ time. \n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5o40me5b.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp5o40me5b.d(35):
    Error: declaration expected, not `<`\n/tmp/tmp5o40me5b.d(56): Error: semicolon
    expected, not `.`\n/tmp/tmp5o40me5b.d(56): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmp5o40me5b.d(57): Error: semicolon expected, not
    `.`\n/tmp/tmp5o40me5b.d(57): Error: no identifier for declarator `.Linq`\n/tmp/tmp5o40me5b.d(58):
    Error: semicolon expected, not `.`\n/tmp/tmp5o40me5b.d(58): Error: no identifier
    for declarator `.Text`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5o40me5b.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i<factors.Length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor++;\n    }\n \
    \   return factors;\n}\n</code>\n<|/ a tags=algorithm,c#,primes,math |>\n<| c\
    \ |>\nThis algorithm is very inefficient for large numbers. For example, factorize(8L)\
    \ returns [2, 2, 2], while factorize(25L) returns [5, 5].\n<|/ c |>\n<| c |>\n\
    Yes, I agree with you. But the question was about finding prime factors. I believe\
    \ that it is enough for OP to understand how to implement the algorithm and how\
    \ to find prime factors.\n<|/ c |>\n<| c |>\nI agree with you, but I believe that\
    \ OP wants to understand how to implement the algorithm and how to find prime\
    \ factors. Your algorithm is very inefficient for large numbers. For example,\
    \ factorize(8L) returns [2, 2, 2], while factorize(25L) returns [5, 5].\n<|/ c\
    \ |>\n<| c |>\nI agree with you, but I believe that OP wants to understand how\
    \ to implement the algorithm and how to find prime factors. Your algorithm is\
    \ very inefficient for large numbers. For example, factorize(8L) returns [2, 2,\
    \ 2], while factorize(25L) returns [5, 5].\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but I believe that OP wants to understand how to implement the algorithm and\
    \ how to find prime factors. Your algorithm is very inefficient for large numbers.\
    \ For example, factorize(8L) returns [2, 2, 2], while factorize(25L) returns [5,\
    \ 5].\n<|/ c |>\n<| a tags=algorithm,c#,primes,math |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfg4lo3fx.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpfg4lo3fx.d(31):
    Error: declaration expected, not `<`\n/tmp/tmpfg4lo3fx.d(51): Error: semicolon
    expected, not `.`\n/tmp/tmpfg4lo3fx.d(51): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmpfg4lo3fx.d(52): Error: semicolon expected, not
    `.`\n/tmp/tmpfg4lo3fx.d(52): Error: no identifier for declarator `.Linq`\n/tmp/tmpfg4lo3fx.d(53):
    Error: semicolon expected, not `.`\n/tmp/tmpfg4lo3fx.d(53): Error: no identifier
    for declarator `.Text`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfg4lo3fx.d",
    "-I/tmp"]\n'''
  stdout: b''
