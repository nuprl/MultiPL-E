language: d
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkw8wqy_m.d(27): Error: no identifier for declarator `i`\n/tmp/tmpkw8wqy_m.d(27):
    Error: found `-` when expecting `;`\n/tmp/tmpkw8wqy_m.d(27): Error: expression
    expected, not `>`\n/tmp/tmpkw8wqy_m.d(27): Error: found `foreach` when expecting
    `)`\n/tmp/tmpkw8wqy_m.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpkw8wqy_m.d(27):
    Error: found `if` when expecting `)`\n/tmp/tmpkw8wqy_m.d(29): Error: found `res`
    when expecting `;` following statement\n/tmp/tmpkw8wqy_m.d(30): Error: declaration
    expected, not `)`\n/tmp/tmpkw8wqy_m.d(32): Error: function declaration without
    return type. (Note that constructors are always named `this`)\n/tmp/tmpkw8wqy_m.d(32):
    Error: no identifier for declarator `sort(res)`\n/tmp/tmpkw8wqy_m.d(34): Error:
    declaration expected, not `return`\n/tmp/tmpkw8wqy_m.d(35): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkw8wqy_m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6zh7hmcx.d(27): Error: no identifier for declarator `i`\n/tmp/tmp6zh7hmcx.d(27):
    Error: found `-` when expecting `;`\n/tmp/tmp6zh7hmcx.d(27): Error: expression
    expected, not `>`\n/tmp/tmp6zh7hmcx.d(27): Error: found `foreach` when expecting
    `)`\n/tmp/tmp6zh7hmcx.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp6zh7hmcx.d(27):
    Error: found `if` when expecting `)`\n/tmp/tmp6zh7hmcx.d(29): Error: found `res`
    when expecting `;` following statement\n/tmp/tmp6zh7hmcx.d(30): Error: declaration
    expected, not `)`\n/tmp/tmp6zh7hmcx.d(32): Error: function declaration without
    return type. (Note that constructors are always named `this`)\n/tmp/tmp6zh7hmcx.d(32):
    Error: no identifier for declarator `sort(res)`\n/tmp/tmp6zh7hmcx.d(34): Error:
    declaration expected, not `return`\n/tmp/tmp6zh7hmcx.d(35): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zh7hmcx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[i] = j;\n                res[i + 1] = i;\n              \
    \  return Tuple!(long, long)[](res);\n            }\n        }\n    }\n    return\
    \ Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuypje_qw.d(36): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`\n/tmp/tmpuypje_qw.d(40): Error: function
    expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuypje_qw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        if (lst[i][j] == x) {\n            result ~= Tuple!(i, j);\n \
    \       }\n    }), range(0, size(lst)));\n    \n    sort(result, (a, b) => a.first\
    \ > b.first ? 1 : a.first < b.first ? -1 : 0);\n    sort(result, (a, b) => a.second\
    \ > b.second ? 1 : a.second < b.second ? -1 : 0);\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdogg450v.d(27): Error: no identifier for declarator `i`\n/tmp/tmpdogg450v.d(27):
    Error: found `-` when expecting `;`\n/tmp/tmpdogg450v.d(27): Error: expression
    expected, not `>`\n/tmp/tmpdogg450v.d(27): Error: found `foreach` when expecting
    `)`\n/tmp/tmpdogg450v.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpdogg450v.d(27):
    Error: found `if` when expecting `)`\n/tmp/tmpdogg450v.d(28): Error: found `{`
    when expecting `;` following statement\n/tmp/tmpdogg450v.d(31): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdogg450v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length\
    \ == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n     \
    \       {\n                if(lst[i][j] == x)\n                {\n           \
    \         result.add(Tuple!(i, j));\n                }\n            }\n      \
    \  }\n    }\n    \n    result.sort(function(a, b){return a.first > b.first;});\n\
    \    result.sort(function(a, b){return a.second > b.second;});\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp052ngzsn.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `Tuple!(long, long)[]`\''s\n/tmp/tmp052ngzsn.d(35):
    Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmp052ngzsn.d(41):
    Error: no property `sort` for type `Tuple!(long, long)[]`\n/tmp/tmp052ngzsn.d(42):
    Error: no property `sort` for type `Tuple!(long, long)[]`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp052ngzsn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n\
    \                break;\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, descending);\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpexo4lwkf.d(27): Error: no identifier for declarator `lst`\n/tmp/tmpexo4lwkf.d(27):
    Error: found `)` when expecting `;`\n/tmp/tmpexo4lwkf.d(29): Error: no identifier
    for declarator `row`\n/tmp/tmpexo4lwkf.d(29): Error: found `)` when expecting
    `;`\n/tmp/tmpexo4lwkf.d(37): Error: found `}` when expecting `)`\n/tmp/tmpexo4lwkf.d(44):
    Error: found `unittest` when expecting `)`\n/tmp/tmpexo4lwkf.d(55): Error: found
    `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpexo4lwkf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) \n            res[res.length]\
    \ = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    sort(res);\n    sort(res,\
    \ (a, b) -> -cmp(a.i, b.i));\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa28f9skf.d(26): Error: no identifier for declarator `i`\n/tmp/tmpa28f9skf.d(26):
    Error: found `-` when expecting `;`\n/tmp/tmpa28f9skf.d(26): Error: expression
    expected, not `>`\n/tmp/tmpa28f9skf.d(26): Error: found `foreach` when expecting
    `)`\n/tmp/tmpa28f9skf.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmpa28f9skf.d(26):
    Error: found `if` when expecting `)`\n/tmp/tmpa28f9skf.d(28): Error: found `res`
    when expecting `;` following statement\n/tmp/tmpa28f9skf.d(29): Error: declaration
    expected, not `)`\n/tmp/tmpa28f9skf.d(30): Error: function declaration without
    return type. (Note that constructors are always named `this`)\n/tmp/tmpa28f9skf.d(30):
    Error: no identifier for declarator `sort(res)`\n/tmp/tmpa28f9skf.d(31): Error:
    unexpected `(` in declarator\n/tmp/tmpa28f9skf.d(31): Error: basic type expected,
    not `(`\n/tmp/tmpa28f9skf.d(31): Error: function declaration without return type.
    (Note that constructors are always named `this`)\n/tmp/tmpa28f9skf.d(31): Error:
    found `-` when expecting `)`\n/tmp/tmpa28f9skf.d(31): Error: no identifier for
    declarator `sort(res, _error_(a, b))`\n/tmp/tmpa28f9skf.d(31): Error: semicolon
    expected following function declaration\n/tmp/tmpa28f9skf.d(31): Error: declaration
    expected, not `>`\n/tmp/tmpa28f9skf.d(32): Error: declaration expected, not `return`\n/tmp/tmpa28f9skf.d(33):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa28f9skf.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res = Tuple!(long, long)[](Tuple!(0, i),\
    \ Tuple!(0, j));\n                break;\n            }\n        }\n        if(res\
    \ != null)\n            break;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeumhvkjw.d(26): Error: no identifier for declarator `i`\n/tmp/tmpeumhvkjw.d(26):
    Error: found `:` when expecting `;`\n/tmp/tmpeumhvkjw.d(28): Error: no identifier
    for declarator `j`\n/tmp/tmpeumhvkjw.d(28): Error: found `:` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeumhvkjw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n\
    \            if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, (a, b) => a.first > b.first);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprgz25f5u.d(27): Error: no identifier for declarator `row`\n/tmp/tmprgz25f5u.d(27):
    Error: found `:` when expecting `;`\n/tmp/tmprgz25f5u.d(29): Error: no identifier
    for declarator `col`\n/tmp/tmprgz25f5u.d(29): Error: found `:` when expecting
    `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprgz25f5u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(row:\
    \ lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n        if(res != null)\n       \
    \     break;\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6nd7ccw4.d(27): Error: no identifier for declarator `row`\n/tmp/tmp6nd7ccw4.d(27):
    Error: found `:` when expecting `;`\n/tmp/tmp6nd7ccw4.d(29): Error: no identifier
    for declarator `col`\n/tmp/tmp6nd7ccw4.d(29): Error: found `:` when expecting
    `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nd7ccw4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    for(int i = 0; i < lst.length;\
    \ i++){\n        if(lst[i][0] == x){\n            Tuple!(long, long)[] temp =\
    \ new Tuple!(long, long)[];\n            for(int j = 0; j < lst[i].length; j++){\n\
    \                if(lst[i][j] == x){\n                    temp.add(new Tuple!(j,\
    \ i));\n                }\n            }\n            res = temp;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ozy0nuf.d(28): Error: new can only create structs, dynamic
    arrays or class objects, not `Tuple!(long, long)[]`\''s\n/tmp/tmp_ozy0nuf.d(31):
    Error: no property `add` for type `Tuple!(long, long)[]`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_ozy0nuf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqb48yee8.d(26): Error: no identifier for declarator `row`\n/tmp/tmpqb48yee8.d(26):
    Error: found `:` when expecting `;`\n/tmp/tmpqb48yee8.d(26): Error: expression
    expected, not `:`\n/tmp/tmpqb48yee8.d(26): Error: found `lst` when expecting `)`\n/tmp/tmpqb48yee8.d(26):
    Error: found `)` instead of statement\n/tmp/tmpqb48yee8.d(35): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqb48yee8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.push(Tuple!(i, j));\n            }\n        }\n \
    \   }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpom1ad_hc.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `Tuple!(long, long)[]`\''s\n/tmp/tmpom1ad_hc.d(33):
    Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmpom1ad_hc.d(38):
    Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpom1ad_hc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res.push(Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9v4ra03o.d(25): Error: new can only create structs, dynamic
    arrays or class objects, not `Tuple!(long, long)[]`\''s\n/tmp/tmp9v4ra03o.d(32):
    Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp9v4ra03o.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n\
    \            if(col == x) \n            {\n                result.add(Tuple!(long,\
    \ long)(0, col));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) \n    {\n        return a.1 < b.1;\n    });\n    \n    result.sort(function(a,\
    \ b) \n    {\n        return a.2 < b.2;\n    });\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpurrmjtgv.d(27): Error: no identifier for declarator `row`\n/tmp/tmpurrmjtgv.d(27):
    Error: found `:` when expecting `;`\n/tmp/tmpurrmjtgv.d(29): Error: no identifier
    for declarator `col`\n/tmp/tmpurrmjtgv.d(29): Error: found `:` when expecting
    `;`\n/tmp/tmpurrmjtgv.d(40): Error: found `0.1` when expecting `;` following `return`
    statement\n/tmp/tmpurrmjtgv.d(40): Error: found `<` instead of statement\n/tmp/tmpurrmjtgv.d(45):
    Error: found `0.2` when expecting `;` following `return` statement\n/tmp/tmpurrmjtgv.d(45):
    Error: found `<` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpurrmjtgv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst,\
    \ i: 0) {\n        foreach(col: row, j: 0) {\n            if(col == x) {\n   \
    \             res = Tuple!(long, long)[i, j];\n            }\n        }\n    }\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp32_js2ba.d(26): Error: no identifier for declarator `row`\n/tmp/tmp32_js2ba.d(26):
    Error: found `:` when expecting `;`\n/tmp/tmp32_js2ba.d(26): Error: found `:`
    when expecting `)`\n/tmp/tmp32_js2ba.d(26): Error: found `)` when expecting `;`
    following statement\n/tmp/tmp32_js2ba.d(27): Error: no identifier for declarator
    `col`\n/tmp/tmp32_js2ba.d(27): Error: found `:` when expecting `;`\n/tmp/tmp32_js2ba.d(27):
    Error: found `:` when expecting `)`\n/tmp/tmp32_js2ba.d(27): Error: found `)`
    when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp32_js2ba.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {Tuple!(i +\
    \ 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][j])\n\
    \                {\n                    Tuple!(long, long)[] tuple2 = new Tuple!(long,\
    \ long)[] {Tuple!(i, k)};\n                    foreach(l -> {\n              \
    \          if(lst[k][l] > lst[i][j])\n                        {\n            \
    \                tuple2.push(Tuple!(l, k));\n                        }\n     \
    \               });\n                    tuple.push(tuple2);\n               \
    \ }\n            });\n            result.push(tuple);\n        }\n    }), range(0,\
    \ lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] ==\
    \ x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[]\
    \ {Tuple!(i + 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k]\
    \ > lst[i][j])\n                {\n                    Tuple!(long, long)[] tuple2\
    \ = new Tuple!(long, long)[] {Tuple!(i, k)};\n                    foreach(l ->\
    \ {\n                        if(lst[k][l] > lst[i][j])\n                     \
    \   {\n                            tuple2.push(Tuple!(l, k));\n              \
    \          }\n                    });\n                    tuple.push(tuple2);\n\
    \                }\n            });\n            result.push(tuple);\n       \
    \ }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n \
    \       if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple\
    \ = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k ->\
    \ {\n                if(lst[i][k] > lst[i][j])\n                {\n          \
    \          Tuple!(long, long)[] tuple2 = new Tuple!(long, long)[] {Tuple!(i, k)};\n\
    \                    foreach(l -> {\n                        if(lst[k][l] > lst[i][j])\n\
    \                        {\n                            tuple2.push(Tuple!(l,\
    \ k));\n                        }\n                    });\n                 \
    \   tuple.push(tuple2);\n                }\n            });\n            result.push(tuple);\n\
    \        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j ->\
    \ {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple\
    \ = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k ->\
    \ {\n                if(lst[i][k] > lst[i][j])\n                {\n          \
    \          Tuple!(long, long)[] tuple2 = new Tuple!(long, \nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0dd_nird.d(27): Error: no identifier for declarator `i`\n/tmp/tmp0dd_nird.d(27):
    Error: found `-` when expecting `;`\n/tmp/tmp0dd_nird.d(27): Error: expression
    expected, not `>`\n/tmp/tmp0dd_nird.d(27): Error: found `foreach` when expecting
    `)`\n/tmp/tmp0dd_nird.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp0dd_nird.d(27):
    Error: found `if` when expecting `)`\n/tmp/tmp0dd_nird.d(29): Error: found `{`
    when expecting `;` following statement\n/tmp/tmp0dd_nird.d(30): Error: semicolon
    expected, not `{`\n/tmp/tmp0dd_nird.d(30): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp0dd_nird.d(30): Deprecation: use `{ }` for an empty
    statement, not `;`\n/tmp/tmp0dd_nird.d(31): Error: no identifier for declarator
    `k`\n/tmp/tmp0dd_nird.d(31): Error: found `-` when expecting `;`\n/tmp/tmp0dd_nird.d(31):
    Error: expression expected, not `>`\n/tmp/tmp0dd_nird.d(31): Error: found `{`
    when expecting `)`\n/tmp/tmp0dd_nird.d(34): Error: semicolon expected, not `{`\n/tmp/tmp0dd_nird.d(34):
    Error: found `}` when expecting `;` following statement\n/tmp/tmp0dd_nird.d(34):
    Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp0dd_nird.d(35):
    Error: no identifier for declarator `l`\n/tmp/tmp0dd_nird.d(35): Error: found
    `-` when expecting `;`\n/tmp/tmp0dd_nird.d(35): Error: expression expected, not
    `>`\n/tmp/tmp0dd_nird.d(35): Error: found `{` when expecting `)`\n/tmp/tmp0dd_nird.d(40):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp0dd_nird.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                Tuple!(long, long)[] coord = Tuple!(i,\
    \ j);\n                \n                if(coord.x < 0)\n                   \
    \ coord.x += lst[i].length;\n                if(coord.y < 0)\n               \
    \     coord.y += lst[0].length;\n                \n                res.push(coord);\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm88yjbyq.d(27): Error: no identifier for declarator `i`\n/tmp/tmpm88yjbyq.d(27):
    Error: found `:` when expecting `;`\n/tmp/tmpm88yjbyq.d(29): Error: no identifier
    for declarator `j`\n/tmp/tmpm88yjbyq.d(29): Error: found `:` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm88yjbyq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n   \
    \         {\n                foreach(k -> \n                {\n              \
    \      if(lst[i][j] == x)\n                    {\n                        res.add((i,\
    \ j));\n                    }\n                });\n            }\n          \
    \  else\n            {\n                foreach(k -> \n                {\n   \
    \                 if(lst[i][j] == x)\n                    {\n                \
    \        res.add((i, j));\n                    }\n                });\n      \
    \      }\n        }), range(0, lst.length));\n    \n    sort(res);\n    \n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd_gi5nxj.d(27): Error: no identifier for declarator `i`\n/tmp/tmpd_gi5nxj.d(27):
    Error: found `-` when expecting `;`\n/tmp/tmpd_gi5nxj.d(27): Error: expression
    expected, not `>`\n/tmp/tmpd_gi5nxj.d(27): Error: found `foreach` when expecting
    `)`\n/tmp/tmpd_gi5nxj.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmpd_gi5nxj.d(27):
    Error: found `if` when expecting `)`\n/tmp/tmpd_gi5nxj.d(30): Error: found `{`
    when expecting `;` following statement\n/tmp/tmpd_gi5nxj.d(31): Error: no identifier
    for declarator `k`\n/tmp/tmpd_gi5nxj.d(31): Error: found `-` when expecting `;`\n/tmp/tmpd_gi5nxj.d(31):
    Error: expression expected, not `>`\n/tmp/tmpd_gi5nxj.d(32): Error: found `{`
    when expecting `)`\n/tmp/tmpd_gi5nxj.d(37): Error: declaration expected, not `)`\n/tmp/tmpd_gi5nxj.d(38):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_gi5nxj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res.push(Tuple!(long, long)((row,col)));\n\
    \            }\n        }\n    }\n    sort(res,fun(x1,x2) -> x1.1 > x2.1);\n \
    \   sort(res,fun(x1,x2) -> x1.2 > x2.2);\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpny7lkagd.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpny7lkagd.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpny7lkagd.d(28): Error: no identifier
    for declarator `row`\n/tmp/tmpny7lkagd.d(28): Error: found `)` when expecting
    `;`\n/tmp/tmpny7lkagd.d(35): Error: found `}` when expecting `)`\n/tmp/tmpny7lkagd.d(36):
    Error: expression expected, not `>`\n/tmp/tmpny7lkagd.d(36): Error: found `x1`
    when expecting `,`\n/tmp/tmpny7lkagd.d(36): Error: found `0.1` when expecting
    `,`\n/tmp/tmpny7lkagd.d(37): Error: expression expected, not `>`\n/tmp/tmpny7lkagd.d(37):
    Error: found `x1` when expecting `,`\n/tmp/tmpny7lkagd.d(37): Error: found `0.2`
    when expecting `,`\n/tmp/tmpny7lkagd.d(40): Error: found `unittest` when expecting
    `)`\n/tmp/tmpny7lkagd.d(51): Error: found `End of File` when expecting `}` following
    compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpny7lkagd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n   \
    \         {\n                foreach(k -> \n                {\n              \
    \      if(k == 0)\n                    {\n                        if(lst[i][j]\
    \ == x)\n                        {\n                            res.add(new Tuple!(i,\
    \ j));\n                        }\n                    }\n                   \
    \ else\n                    {\n                        if(lst[i][j] > lst[i-1][k])\n\
    \                        {\n                            res.add(new Tuple!(i,\
    \ j));\n                        }\n                    }\n                });\n\
    \            }\n            else\n            {\n                foreach(k ->\
    \ \n                {\n                    if(k == 0)\n                    {\n\
    \                        if(lst[i][j] > lst[i-1][k])\n                       \
    \ {\n                            res.add(new Tuple!(i, j));\n                \
    \        }\n                    }\n                    else\n                \
    \    {\n                        if(lst[i][j] > lst[i-1][k])\n                \
    \        {\n                            res.add(new Tuple!(i, j));\n         \
    \               }\n                    }\n                });\n            }\n\
    \        }), range(0, lst.length - 1));\n    \n    sort(res);\n    sort(res, (a,\
    \ b) -> a.first > b.first);\n    \n    return res;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa01jqcjq.d(27): Error: no identifier for declarator i\n/tmp/tmpa01jqcjq.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpa01jqcjq.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpa01jqcjq.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpa01jqcjq.d(27): Error: expression expected, not \''>\''\n/tmp/tmpa01jqcjq.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpa01jqcjq.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpa01jqcjq.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpa01jqcjq.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpa01jqcjq.d(29): Error: found \''0\'' when
    expecting \'';\'' following statement\n/tmp/tmpa01jqcjq.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpa01jqcjq.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa01jqcjq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     result.push((i, j));\n        }\n    }), range(0, lst.length));\n    \n\
    \    result.sort(function(a, b) {\n        if(a[0] == b[0]) {\n            return\
    \ a[1] - b[1];\n        } else {\n            return a[0] - b[0];\n        }\n\
    \    });\n    \n    result.sort(function(a, b) {\n        if(a[1] == b[1]) {\n\
    \            return a[0] - b[0];\n        } else {\n            return a[1] -\
    \ b[1];\n        }\n    });\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4xhxck3x.d(27): Error: no identifier for declarator i\n/tmp/tmp4xhxck3x.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp4xhxck3x.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp4xhxck3x.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp4xhxck3x.d(27): Error: expression expected, not \''>\''\n/tmp/tmp4xhxck3x.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp4xhxck3x.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp4xhxck3x.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp4xhxck3x.d(28): Error: missing
    { ... } for function literal\n/tmp/tmp4xhxck3x.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp4xhxck3x.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmp4xhxck3x.d(31): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xhxck3x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length\
    \ == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n     \
    \       {\n                if(lst[i][j] == x)\n                {\n           \
    \         ret.add(new Tuple!(i, j));\n                }\n            }\n     \
    \   }\n    }\n    \n    sort(ret, (a, b) -> a.first > b.first ? 1 : a.first <\
    \ b.first ? -1 : 0);\n    sort(ret, (a, b) -> a.second > b.second ? 1 : a.second\
    \ < b.second ? -1 : 0);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp22vxyuui.d(41): Error: expression expected, not \''>\''\n/tmp/tmp22vxyuui.d(41):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmp22vxyuui.d(42): Error: expression
    expected, not \''>\''\n/tmp/tmp22vxyuui.d(42): Error: found \''a\'' when expecting
    \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp22vxyuui.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] tmp = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            long r = i / j;\n\
    \            long c = i % j;\n            long r = r * j + c;\n            long\
    \ c = r - j;\n            if(r == x)\n                tmp.add(new Tuple!(r, j));\n\
    \        });\n        if(tmp.length > 0)\n            res.add(tmp);\n    }), lst);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmbhtejsm.d(27): Error: no identifier for declarator i\n/tmp/tmpmbhtejsm.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpmbhtejsm.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpmbhtejsm.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpmbhtejsm.d(27): Error: expression expected, not \''>\''\n/tmp/tmpmbhtejsm.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpmbhtejsm.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmpmbhtejsm.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmpmbhtejsm.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmpmbhtejsm.d(28):
    Error: found \''tmp\'' when expecting \'';\'' following statement\n/tmp/tmpmbhtejsm.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmpmbhtejsm.d(29): Error: no identifier
    for declarator k\n/tmp/tmpmbhtejsm.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmpmbhtejsm.d(29): Error: expression expected, not \''>\''\n/tmp/tmpmbhtejsm.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpmbhtejsm.d(36): Error: Declaration
    expected, not \'')\''\n/tmp/tmpmbhtejsm.d(37): Error: Declaration expected, not
    \''if\''\n/tmp/tmpmbhtejsm.d(39): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmbhtejsm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            ret.push((i, j));\n        }\n    }), std.range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n\
    \            ret.push((i, j));\n        }\n    }), std.range(0, lst.length));\n\
    \    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvfr967nv.d(27): Error: no identifier for declarator i\n/tmp/tmpvfr967nv.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpvfr967nv.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpvfr967nv.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpvfr967nv.d(27): Error: expression expected, not \''>\''\n/tmp/tmpvfr967nv.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpvfr967nv.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpvfr967nv.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpvfr967nv.d(28): Error: missing
    { ... } for function literal\n/tmp/tmpvfr967nv.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpvfr967nv.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmpvfr967nv.d(32): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfr967nv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\
    \ \n    {\n        foreach(col,row) \n        {\n            if(col == x) \n \
    \           {\n                if(res == null) \n                {\n         \
    \           res = Tuple!(long, long)[](row,col);\n                }\n        \
    \        else \n                {\n                    res = Tuple!(long, long)[](row,col);\n\
    \                    foreach(row2,lst) \n                    {\n             \
    \           foreach(col2,row2) \n                        {\n                 \
    \           if(col2 == col) \n                            {\n                \
    \                res = Tuple!(long, long)[](row,col);\n                      \
    \          break;\n                            }\n                        }\n\
    \                    }\n                }\n                break;\n          \
    \  }\n        }\n    }\n    return res;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpijavx8zf.d(26): Error: no identifier for declarator lst\n/tmp/tmpijavx8zf.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpijavx8zf.d(28): Error: no
    identifier for declarator row\n/tmp/tmpijavx8zf.d(28): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpijavx8zf.d(39): Error: no identifier for declarator
    lst\n/tmp/tmpijavx8zf.d(39): Error: found \'')\'' when expecting \'';\''\n/tmp/tmpijavx8zf.d(41):
    Error: no identifier for declarator row2\n/tmp/tmpijavx8zf.d(41): Error: found
    \'')\'' when expecting \'';\''\n/tmp/tmpijavx8zf.d(49): Error: found \''}\'' when
    expecting \'')\''\n/tmp/tmpijavx8zf.d(50): Error: found \''}\'' instead of statement\n/tmp/tmpijavx8zf.d(51):
    Error: found \''break\'' when expecting \'')\''\n/tmp/tmpijavx8zf.d(51): Error:
    use \''{ }\'' for an empty statement, not a \'';\''\n/tmp/tmpijavx8zf.d(55): Error:
    found \''return\'' when expecting \'')\''\n/tmp/tmpijavx8zf.d(57): Error: unterminated
    /* */ comment\n/tmp/tmpijavx8zf.d(69): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpijavx8zf.d(69):
    Error: found \''EOF\'' instead of statement\n/tmp/tmpijavx8zf.d(69): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpijavx8zf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n\
    \        {\n            if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)(i + 1, j + 1));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second\
    \ > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqjexgnjr.d(27): Error: no identifier for declarator row\n/tmp/tmpqjexgnjr.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpqjexgnjr.d(27): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpqjexgnjr.d(27): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmpqjexgnjr.d(29): Error: no identifier
    for declarator col\n/tmp/tmpqjexgnjr.d(29): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmpqjexgnjr.d(29): Error: found \'':\'' when expecting \'')\''\n/tmp/tmpqjexgnjr.d(29):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpqjexgnjr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n     \
    \       for(int j = 0; j < lst[i].length; j++){\n                if(lst[i][j]\
    \ == x){\n                    res.push(new Tuple!(i, j));\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpowkwf_lu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                result.push(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b)\
    \ {\n        if(a.0 < b.0)\n        {\n            return -1;\n        }\n   \
    \     if(a.0 > b.0)\n        {\n            return 1;\n        }\n        return\
    \ 0;\n    });\n    \n    foreach(i : 0..result.length-1)\n    {\n        result.sort(function(a,\
    \ b) {\n            if(a.1 < b.1)\n            {\n                return -1;\n\
    \            }\n            if(a.1 > b.1)\n            {\n                return\
    \ 1;\n            }\n            return 0;\n        });\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4o06zvl2.d(27): Error: no identifier for declarator i\n/tmp/tmp4o06zvl2.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp4o06zvl2.d(29): Error: no
    identifier for declarator j\n/tmp/tmp4o06zvl2.d(29): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmp4o06zvl2.d(39): Error: found \''0.00000\'' when expecting
    \'')\''\n/tmp/tmp4o06zvl2.d(39): Error: found \''<\'' instead of statement\n/tmp/tmp4o06zvl2.d(43):
    Error: found \''if\'' when expecting \'',\''\n/tmp/tmp4o06zvl2.d(43): Error: found
    \''0.00000\'' when expecting \'')\''\n/tmp/tmp4o06zvl2.d(43): Error: missing {
    ... } for function literal\n/tmp/tmp4o06zvl2.d(43): Error: found \''0.00000\''
    when expecting \'',\''\n/tmp/tmp4o06zvl2.d(44): Error: found \''{\'' when expecting
    \'';\'' following statement\n/tmp/tmp4o06zvl2.d(47): Error: Declaration expected,
    not \''return\''\n/tmp/tmp4o06zvl2.d(48): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4o06zvl2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {i, j};\n        \
    \    foreach(k -> {\n                if(lst[i][k] > lst[k][j]) {\n           \
    \         tuple = tuple + new Tuple!(long, long)[] {k, j};\n                }\n\
    \            });\n            res = res + tuple;\n        }\n    }), range(0,\
    \ lst.length));\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu61hu8l8.d(27): Error: no identifier for declarator i\n/tmp/tmpu61hu8l8.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpu61hu8l8.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpu61hu8l8.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpu61hu8l8.d(27): Error: expression expected, not \''>\''\n/tmp/tmpu61hu8l8.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpu61hu8l8.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpu61hu8l8.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpu61hu8l8.d(28): Error: missing
    { ... } for function literal\n/tmp/tmpu61hu8l8.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpu61hu8l8.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmpu61hu8l8.d(30): Error: Declaration expected, not
    \''foreach\''\n/tmp/tmpu61hu8l8.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu61hu8l8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res.push(Tuple!(long, long)((row,col)));\n\
    \            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjp25atsm.d(26): Error: no identifier for declarator lst\n/tmp/tmpjp25atsm.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpjp25atsm.d(28): Error: no
    identifier for declarator row\n/tmp/tmpjp25atsm.d(28): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpjp25atsm.d(35): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpjp25atsm.d(39): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpjp25atsm.d(50):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjp25atsm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n\
    \    sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n   \
    \     if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr9k3dwcw.d(27): Error: no identifier for declarator i\n/tmp/tmpr9k3dwcw.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpr9k3dwcw.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpr9k3dwcw.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpr9k3dwcw.d(27): Error: expression expected, not \''>\''\n/tmp/tmpr9k3dwcw.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpr9k3dwcw.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpr9k3dwcw.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpr9k3dwcw.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpr9k3dwcw.d(32): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpr9k3dwcw.d(32):
    Error: no identifier for declarator sort(res)\n/tmp/tmpr9k3dwcw.d(33): Error:
    unexpected ( in declarator\n/tmp/tmpr9k3dwcw.d(33): Error: basic type expected,
    not (\n/tmp/tmpr9k3dwcw.d(33): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpr9k3dwcw.d(33):
    Error: found \''-\'' when expecting \'')\''\n/tmp/tmpr9k3dwcw.d(33): Error: no
    identifier for declarator sort(res, int(a, b))\n/tmp/tmpr9k3dwcw.d(33): Error:
    semicolon expected following function declaration\n/tmp/tmpr9k3dwcw.d(33): Error:
    Declaration expected, not \''>\''\n/tmp/tmpr9k3dwcw.d(36): Error: Declaration
    expected, not \''if\''\n/tmp/tmpr9k3dwcw.d(38): Error: Declaration expected, not
    \''return\''\n/tmp/tmpr9k3dwcw.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9k3dwcw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\
    \ \n    {\n        foreach(column: row) \n        {\n            if(column ==\
    \ x) \n            {\n                result ~= Tuple!(row, column);\n       \
    \     }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a, b) =>\
    \ a.1 < b.1);\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprlbwd8hc.d(27): Error: no identifier for declarator row\n/tmp/tmprlbwd8hc.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmprlbwd8hc.d(29): Error: no
    identifier for declarator column\n/tmp/tmprlbwd8hc.d(29): Error: found \'':\''
    when expecting \'';\''\n/tmp/tmprlbwd8hc.d(39): Error: found \''0.1\'' when expecting
    \'',\''\n/tmp/tmprlbwd8hc.d(39): Error: expression expected, not \''<\''\n/tmp/tmprlbwd8hc.d(39):
    Error: found \''b\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprlbwd8hc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    \n   \
    \ sort(res);\n    sort(res, (a, b) => a[1] > b[1]);\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphhxd0ont.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n\
    \                ret.add(new Tuple!(i, j));\n            }\n        }\n    }\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmvtk46z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res = Tuple!(long, long)[](row, col);\n            \
    \    break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg0u8xgw7.d(27): Error: no identifier for declarator lst\n/tmp/tmpg0u8xgw7.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpg0u8xgw7.d(29): Error: no
    identifier for declarator row\n/tmp/tmpg0u8xgw7.d(29): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpg0u8xgw7.d(37): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpg0u8xgw7.d(41): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpg0u8xgw7.d(52):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0u8xgw7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res[res.length] = Tuple!(i, j);\n            }\n    \
    \    }\n    }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hmbi0a3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row,lst)\
    \ \n    {\n        foreach(column,row)\n        {\n            if(column == x)\n\
    \            {\n                result ~= Tuple!(row,column);\n            }\n\
    \        }\n    }\n    \n    sort(result);\n    sort(result, descending);\n  \
    \  \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgwvvw4lq.d(27): Error: no identifier for declarator lst\n/tmp/tmpgwvvw4lq.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpgwvvw4lq.d(29): Error: no
    identifier for declarator row\n/tmp/tmpgwvvw4lq.d(29): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpgwvvw4lq.d(36): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpgwvvw4lq.d(43): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpgwvvw4lq.d(54):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgwvvw4lq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i]\
    \ = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col, (x, y) => Comparer<long>.Default.Compare(x,\
    \ y));\n    Array.Sort(row, col, (x, y) => Comparer<long>.Default.Compare(y, x));\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == x)\n        {\n   \
    \         res[i] = Tuple!(long, long)[i, col[i]];\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcq2gmu38.d(32): Error: found \''>\'' when expecting \''.\''
    following long\n/tmp/tmpcq2gmu38.d(32): Error: found \''.\'' when expecting identifier
    following \''long.\''\n/tmp/tmpcq2gmu38.d(32): Error: found \''Default\'' when
    expecting \'',\''\n/tmp/tmpcq2gmu38.d(33): Error: found \''>\'' when expecting
    \''.\'' following long\n/tmp/tmpcq2gmu38.d(33): Error: found \''.\'' when expecting
    identifier following \''long.\''\n/tmp/tmpcq2gmu38.d(33): Error: found \''Default\''
    when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcq2gmu38.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\
    \ {\n        foreach(col: row) {\n            if(col == x) {\n               \
    \ res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n   \
    \ \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb1721kb0.d(26): Error: no identifier for declarator row\n/tmp/tmpb1721kb0.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpb1721kb0.d(27): Error: no
    identifier for declarator col\n/tmp/tmpb1721kb0.d(27): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1721kb0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n\
    \    {\n        foreach(column: row)\n        {\n            if(column == x)\n\
    \            {\n                result ~= Tuple!(row, column);\n            }\n\
    \        }\n    }\n    \n    result.sort(by=byRow);\n    result.sort(by=byColumn);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx9rifz3y.d(27): Error: no identifier for declarator row\n/tmp/tmpx9rifz3y.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpx9rifz3y.d(29): Error: no
    identifier for declarator column\n/tmp/tmpx9rifz3y.d(29): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx9rifz3y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.push(Tuple!(i, j));\n            }\n        }\n \
    \   }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhq2g4_k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[]\
    \ col = new Tuple!(long, long)[];\n            foreach(m -> {\n              \
    \  Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.x\
    \ = i;\n                coord.y = j;\n                col.x = k;\n           \
    \     col.y = m;\n                row.push(coord);\n            });\n        \
    \    row.push(col);\n        });\n        res.push(row);\n    }));\n    \n   \
    \ foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long,\
    \ long)[];\n        foreach(k -> {\n            Tuple!(long, long)[] col = new\
    \ Tuple!(long, long)[];\n            foreach(m -> {\n                Tuple!(long,\
    \ long)[] coord = new Tuple!(long, long)[];\n                coord.x = i;\n  \
    \              coord.y = j;\n                col.x = k;\n                col.y\
    \ = m;\n                row.push(coord);\n            });\n            row.push(col);\n\
    \        });\n        res.push(row);\n    }));\n    \n    foreach(i -> foreach(j\
    \ -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n       \
    \ foreach(k -> {\n            Tuple!(long, long)[] col = new Tuple!(long, long)[];\n\
    \            foreach(m -> {\n                Tuple!(long, long)[] coord = new\
    \ Tuple!(long, long)[];\n                coord.x = i;\n                coord.y\
    \ = j;\n                col.x = k;\n                col.y = m;\n             \
    \   row.push(coord);\n            });\n            row.push(col);\n        });\n\
    \        res.push(row);\n    }));\n    \n    foreach(i -> foreach(j -> {\n   \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k\
    \ -> {\n            Tuple!(long, long)[] col = new Tuple!(long, long)[];\n   \
    \         foreach(m -> {\n                Tuple!(long, long)[] coord = new Tuple!(long,\
    \ long)[];\n                coord.x = i;\n                coord.y = j;\n     \
    \           col.x = k;\n                col.y = m;\n                row.push(coord);\n\
    \            });\n            row.push(col);\n        });\n        res.push(row);\n\
    \    }));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row = new Tuple!(long, long)[];\n        foreach(k -> \nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0zmpg3er.d(27): Error: no identifier for declarator i\n/tmp/tmp0zmpg3er.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp0zmpg3er.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp0zmpg3er.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp0zmpg3er.d(27): Error: expression expected, not \''>\''\n/tmp/tmp0zmpg3er.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp0zmpg3er.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp0zmpg3er.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp0zmpg3er.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp0zmpg3er.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmp0zmpg3er.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmp0zmpg3er.d(29): Error: no identifier
    for declarator k\n/tmp/tmp0zmpg3er.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmp0zmpg3er.d(29): Error: expression expected, not \''>\''\n/tmp/tmp0zmpg3er.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp0zmpg3er.d(31): Error: no
    identifier for declarator m\n/tmp/tmp0zmpg3er.d(31): Error: found \''-\'' when
    expecting \'';\''\n/tmp/tmp0zmpg3er.d(31): Error: expression expected, not \''>\''\n/tmp/tmp0zmpg3er.d(31):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp0zmpg3er.d(38): Error: Declaration
    expected, not \'')\''\n/tmp/tmp0zmpg3er.d(39): Error: function declaration without
    return type. (Note that constructors are always named \''this\'')\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp0zmpg3er.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k\
    \ -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n\
    \                }\n            });\n            res.add(row);\n        }\n  \
    \  }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9kueb00g.d(27): Error: no identifier for declarator i\n/tmp/tmp9kueb00g.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp9kueb00g.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp9kueb00g.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp9kueb00g.d(27): Error: expression expected, not \''>\''\n/tmp/tmp9kueb00g.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp9kueb00g.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp9kueb00g.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp9kueb00g.d(28): Error: missing
    { ... } for function literal\n/tmp/tmp9kueb00g.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp9kueb00g.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmp9kueb00g.d(30): Error: no identifier for declarator
    k\n/tmp/tmp9kueb00g.d(30): Error: found \''-\'' when expecting \'';\''\n/tmp/tmp9kueb00g.d(30):
    Error: expression expected, not \''>\''\n/tmp/tmp9kueb00g.d(30): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmp9kueb00g.d(34): Error: Declaration expected,
    not \'')\''\n/tmp/tmp9kueb00g.d(35): Error: function declaration without return
    type. (Note that constructors are always named \''this\'')\n/tmp/tmp9kueb00g.d(35):
    Error: no identifier for declarator res.add(row)\n/tmp/tmp9kueb00g.d(36): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9kueb00g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length]\
    \ = Tuple!(i, j);\n    }), 0..lst.length-1);\n    sort(res);\n    return res;\n\
    }\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpghnxpmgk.d(26): Error: no identifier for declarator i\n/tmp/tmpghnxpmgk.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpghnxpmgk.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmpghnxpmgk.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpghnxpmgk.d(26): Error: expression expected, not \''>\''\n/tmp/tmpghnxpmgk.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpghnxpmgk.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpghnxpmgk.d(28): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpghnxpmgk.d(29):
    Error: Declaration expected, not \'')\''\n/tmp/tmpghnxpmgk.d(30): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpghnxpmgk.d(30):
    Error: no identifier for declarator sort(res)\n/tmp/tmpghnxpmgk.d(31): Error:
    Declaration expected, not \''return\''\n/tmp/tmpghnxpmgk.d(32): Error: unrecognized
    declaration\n/tmp/tmpghnxpmgk.d(33): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghnxpmgk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    \n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_inxw80.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1,\
    \ row)];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_i4kdcas.d(26): Error: no identifier for declarator row\n/tmp/tmp_i4kdcas.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp_i4kdcas.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmp_i4kdcas.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmp_i4kdcas.d(26): Error: found \'')\'' instead of statement\n/tmp/tmp_i4kdcas.d(34):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_i4kdcas.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n\
    \    sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n   \
    \     if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr9k3dwcw.d(27): Error: no identifier for declarator i\n/tmp/tmpr9k3dwcw.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpr9k3dwcw.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpr9k3dwcw.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpr9k3dwcw.d(27): Error: expression expected, not \''>\''\n/tmp/tmpr9k3dwcw.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpr9k3dwcw.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpr9k3dwcw.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpr9k3dwcw.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpr9k3dwcw.d(32): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpr9k3dwcw.d(32):
    Error: no identifier for declarator sort(res)\n/tmp/tmpr9k3dwcw.d(33): Error:
    unexpected ( in declarator\n/tmp/tmpr9k3dwcw.d(33): Error: basic type expected,
    not (\n/tmp/tmpr9k3dwcw.d(33): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpr9k3dwcw.d(33):
    Error: found \''-\'' when expecting \'')\''\n/tmp/tmpr9k3dwcw.d(33): Error: no
    identifier for declarator sort(res, int(a, b))\n/tmp/tmpr9k3dwcw.d(33): Error:
    semicolon expected following function declaration\n/tmp/tmpr9k3dwcw.d(33): Error:
    Declaration expected, not \''>\''\n/tmp/tmpr9k3dwcw.d(36): Error: Declaration
    expected, not \''if\''\n/tmp/tmpr9k3dwcw.d(38): Error: Declaration expected, not
    \''return\''\n/tmp/tmpr9k3dwcw.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9k3dwcw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804062
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n        \
    \    foreach(k -> {\n                if(lst[i][k] > lst[i][k+1]) {\n         \
    \           Tuple!(long, long)[] coord2 = new Tuple!(long, long)[] {i, k};\n \
    \                   foreach(l -> {\n                        if(lst[k][l] > lst[k+1][l])\
    \ {\n                            Tuple!(long, long)[] coord3 = new Tuple!(long,\
    \ long)[] {k, l};\n                            foreach(m -> {\n              \
    \                  if(lst[m][j] > lst[m+1][j]) {\n                           \
    \         coord = coord.concat(coord2);\n                                    coord2\
    \ = coord3;\n                                }\n                             \
    \   else {\n                                    coord = coord.concat(coord3);\n\
    \                                    coord3 = coord2;\n                      \
    \          }\n                            });\n                        }\n   \
    \                     else {\n                            coord = coord.concat(coord2);\n\
    \                            coord2 = coord;\n                        }\n    \
    \                });\n                }\n                else {\n            \
    \        coord = coord.concat(coord2);\n                    coord2 = coord;\n\
    \                }\n            });\n            res = res.concat(coord);\n  \
    \      }\n    }));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j]\
    \ == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i,\
    \ j};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][k+1])\
    \ {\n                    Tuple!(long, long)[] coord2 = new Tuple!(long, long)[]\
    \ {i, k};\n                    foreach(l -> {\n                        if(lst[k][l]\
    \ > lst[k+1][l]) {\n                            Tuple!(long, long)[] coord3 =\
    \ new Tuple!(long, long)[] {k, l};\n                            foreach(m -> {\n\
    \                                if(lst[m][j] > lst[m+1][j]) {\n             \
    \                       coord = coord.concat(coord2);\n                      \
    \              coord2 = coord3;\n                                }\n         \
    \                       else {\n                                    coord = coord.concat(coord3);\n\
    \                                    coord3 = coord2;\n                      \
    \          }\n                            });\n                        }\n   \
    \                     else {\n                            coord = coord.concat(coord2);\n\
    \                            coord2 = coord;\n                        }\n    \
    \                });\n                }\n                else {\n            \
    \        coord = coord.concat(coord2);\n                    coord2 = coord;\n\
    \                }\n            });\n            res = res.concat(coord);\n  \
    \      }\n    }));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j]\
    \ == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcr2xay9a.d(27): Error: no identifier for declarator i\n/tmp/tmpcr2xay9a.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpcr2xay9a.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpcr2xay9a.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpcr2xay9a.d(27): Error: expression expected, not \''>\''\n/tmp/tmpcr2xay9a.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpcr2xay9a.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpcr2xay9a.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpcr2xay9a.d(28): Error: missing
    { ... } for function literal\n/tmp/tmpcr2xay9a.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpcr2xay9a.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmpcr2xay9a.d(30): Error: Declaration expected, not
    \''foreach\''\n/tmp/tmpcr2xay9a.d(33): Error: Declaration expected, not \''foreach\''\n/tmp/tmpcr2xay9a.d(36):
    Error: Declaration expected, not \''foreach\''\n/tmp/tmpcr2xay9a.d(39): Error:
    no identifier for declarator coord2\n/tmp/tmpcr2xay9a.d(39): Error: Declaration
    expected, not \''=\''\n/tmp/tmpcr2xay9a.d(40): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcr2xay9a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[Tuple!(0, row), Tuple!(1,\
    \ col)];\n                break;\n            }\n        }\n    }\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpntvef0cr.d(27): Error: no identifier for declarator row\n/tmp/tmpntvef0cr.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpntvef0cr.d(27): Error: expression
    expected, not \'':\''\n/tmp/tmpntvef0cr.d(27): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmpntvef0cr.d(27): Error: found \'')\'' instead of statement\n/tmp/tmpntvef0cr.d(36):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntvef0cr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k\
    \ -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n\
    \                }\n            });\n            res.add(row);\n        }\n  \
    \  }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n       \
    \ if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long,\
    \ long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n\
    \                    row.add(k);\n                }\n            });\n       \
    \     res.add(row);\n        }\n    }), range(0, lst[0].length));\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps3ei18ix.d(27): Error: no identifier for declarator i\n/tmp/tmps3ei18ix.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmps3ei18ix.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmps3ei18ix.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmps3ei18ix.d(27): Error: expression expected, not \''>\''\n/tmp/tmps3ei18ix.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmps3ei18ix.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmps3ei18ix.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmps3ei18ix.d(28): Error: missing
    { ... } for function literal\n/tmp/tmps3ei18ix.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmps3ei18ix.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmps3ei18ix.d(30): Error: no identifier for declarator
    k\n/tmp/tmps3ei18ix.d(30): Error: found \''-\'' when expecting \'';\''\n/tmp/tmps3ei18ix.d(30):
    Error: expression expected, not \''>\''\n/tmp/tmps3ei18ix.d(30): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmps3ei18ix.d(34): Error: Declaration expected,
    not \'')\''\n/tmp/tmps3ei18ix.d(35): Error: function declaration without return
    type. (Note that constructors are always named \''this\'')\n/tmp/tmps3ei18ix.d(35):
    Error: no identifier for declarator res.add(row)\n/tmp/tmps3ei18ix.d(36): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3ei18ix.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n\
    \                if(lst[i][j] == x)\n                {\n                    ret.push_back(new\
    \ Tuple!(i, j));\n                }\n            }\n        }\n    }\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5o_ka97.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long,\
    \ long)[] t = new Tuple!(long, long)[];\n            t[0] = i;\n            t[1]\
    \ = j;\n            res.add(t);\n        }\n    }), std.range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n        \
    \    Tuple!(long, long)[] t = new Tuple!(long, long)[];\n            t[0] = i;\n\
    \            t[1] = j;\n            res.add(t);\n        }\n    }), std.range(0,\
    \ lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0t3242ds.d(26): Error: no identifier for declarator i\n/tmp/tmp0t3242ds.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp0t3242ds.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmp0t3242ds.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp0t3242ds.d(26): Error: expression expected, not \''>\''\n/tmp/tmp0t3242ds.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp0t3242ds.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp0t3242ds.d(27): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp0t3242ds.d(27): Error: missing
    { ... } for function literal\n/tmp/tmp0t3242ds.d(27): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp0t3242ds.d(27): Error: found \'')\''
    instead of statement\n/tmp/tmp0t3242ds.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0t3242ds.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst){\n\
    \        foreach(col,row){\n            if(col == x){\n                res = Tuple!(long,\
    \ long)[Tuple!(long, long)[row, col]];\n            }\n        }\n    }\n    sort(res);\n\
    \    sort(res,1,-1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbsgnpj9d.d(26): Error: no identifier for declarator lst\n/tmp/tmpbsgnpj9d.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpbsgnpj9d.d(27): Error: no
    identifier for declarator row\n/tmp/tmpbsgnpj9d.d(27): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpbsgnpj9d.d(32): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpbsgnpj9d.d(37): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpbsgnpj9d.d(48):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbsgnpj9d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n  \
    \  sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n     \
    \   if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n\
    \    sort(res, (a, b) -> {\n        if(a.c > b.c)\n            return 1;\n   \
    \     if(a.c < b.c)\n            return -1;\n        return 0;\n    });\n    \n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpthx3j0up.d(27): Error: no identifier for declarator i\n/tmp/tmpthx3j0up.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpthx3j0up.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpthx3j0up.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpthx3j0up.d(27): Error: expression expected, not \''>\''\n/tmp/tmpthx3j0up.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpthx3j0up.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpthx3j0up.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpthx3j0up.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpthx3j0up.d(32): Error: unexpected
    ( in declarator\n/tmp/tmpthx3j0up.d(32): Error: basic type expected, not (\n/tmp/tmpthx3j0up.d(32):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpthx3j0up.d(32): Error: found \''-\'' when expecting
    \'')\''\n/tmp/tmpthx3j0up.d(32): Error: no identifier for declarator sort(res,
    int(a, b))\n/tmp/tmpthx3j0up.d(32): Error: semicolon expected following function
    declaration\n/tmp/tmpthx3j0up.d(32): Error: Declaration expected, not \''>\''\n/tmp/tmpthx3j0up.d(35):
    Error: Declaration expected, not \''if\''\n/tmp/tmpthx3j0up.d(37): Error: Declaration
    expected, not \''return\''\n/tmp/tmpthx3j0up.d(38): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpthx3j0up.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n   \
    \         long c = i;\n            long d = k;\n            \n            if(r\
    \ == x)\n                row.push((r, c));\n            \n            if(c ==\
    \ x)\n                row.push((r, d));\n            \n            if(r == x &&\
    \ c == x)\n                row.push((r, d));\n            \n            if(r ==\
    \ x && c == x && d == x)\n                row.push((r, d));\n            \n  \
    \          if(r == x && c == x && d == x && k == x)\n                row.push((r,\
    \ d));\n            \n            if(r == x && c == x && d == x && k == x && l\
    \ == x)\n                row.push((r, d));\n            \n            if(r ==\
    \ x && c == x && d == x && k == x && l == x && m == x)\n                row.push((r,\
    \ d));\n            \n            if(r == x && c == x && d == x && k == x && l\
    \ == x && m == x && n == x)\n                row.push((r, d));\n            \n\
    \            if(r == x && c == x && d == x && k == x && l == x && m == x && n\
    \ == x && o == x)\n                row.push((r, d));\n            \n         \
    \   if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o\
    \ == x && p == x)\n                row.push((r, d));\n            \n         \
    \   if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o\
    \ == x && p == x && q == x)\n                row.push((r, d));\n            \n\
    \            if(r == x && c == x && d == x && k == x && l == x && m == x && n\
    \ == x && o == x && p == x && q == x && r == x)\n                row.push((r,\
    \ d));\n            \n            if(r == x && c == x && d == x && k == x && l\
    \ == x && m == x && n == x && o == x && p == x && q == x && r == x && s == x)\n\
    \                row.push((r, d));\n            \n\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp74zhbz81.d(27): Error: no identifier for declarator i\n/tmp/tmp74zhbz81.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp74zhbz81.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp74zhbz81.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp74zhbz81.d(27): Error: expression expected, not \''>\''\n/tmp/tmp74zhbz81.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp74zhbz81.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp74zhbz81.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp74zhbz81.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp74zhbz81.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmp74zhbz81.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmp74zhbz81.d(29): Error: no identifier
    for declarator k\n/tmp/tmp74zhbz81.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmp74zhbz81.d(29): Error: expression expected, not \''>\''\n/tmp/tmp74zhbz81.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp74zhbz81.d(74): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp74zhbz81.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n\
    \    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res = Tuple!(long, long)[]((i, j), Tuple!(long,\
    \ long)((i, j)));\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcrbphtmy.d(26): Error: no identifier for declarator i\n/tmp/tmpcrbphtmy.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpcrbphtmy.d(28): Error: no
    identifier for declarator j\n/tmp/tmpcrbphtmy.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrbphtmy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\
    \ {\n        foreach(col,row) {\n            if(col == x) {\n                res\
    \ = Tuple!(long, long)[](row,col);\n            }\n        }\n    }\n    \n  \
    \  foreach(row,lst) {\n        foreach(col,row) {\n            if(col != x) {\n\
    \                res = Tuple!(long, long)[](row,col);\n            }\n       \
    \ }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4tm148hz.d(26): Error: no identifier for declarator lst\n/tmp/tmp4tm148hz.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4tm148hz.d(27): Error: no
    identifier for declarator row\n/tmp/tmp4tm148hz.d(27): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp4tm148hz.d(32): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp4tm148hz.d(34): Error: no identifier for declarator lst\n/tmp/tmp4tm148hz.d(34):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4tm148hz.d(35): Error: no
    identifier for declarator row\n/tmp/tmp4tm148hz.d(35): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp4tm148hz.d(40): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp4tm148hz.d(44): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp4tm148hz.d(55):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmp4tm148hz.d(55):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp4tm148hz.d(55): Error:
    found \''EOF\'' instead of statement\n/tmp/tmp4tm148hz.d(55): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4tm148hz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\
    \ \n    {\n        foreach(col: row) \n        {\n            if (col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \      }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu06rmpvq.d(26): Error: no identifier for declarator row\n/tmp/tmpu06rmpvq.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpu06rmpvq.d(28): Error: no
    identifier for declarator col\n/tmp/tmpu06rmpvq.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu06rmpvq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n   \
    \         tt.push((i, j));\n            res.push(tt);\n        }\n    }), std.range(0,\
    \ lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j]\
    \ > x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n\
    \            tt.push((i, j));\n            res.push(tt);\n        }\n    }), std.range(0,\
    \ lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwtk5edks.d(27): Error: no identifier for declarator i\n/tmp/tmpwtk5edks.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpwtk5edks.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpwtk5edks.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpwtk5edks.d(27): Error: expression expected, not \''>\''\n/tmp/tmpwtk5edks.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpwtk5edks.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpwtk5edks.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpwtk5edks.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpwtk5edks.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpwtk5edks.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpwtk5edks.d(35): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwtk5edks.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\
    \ {\n        foreach(col,row) {\n            if(col == x) {\n                res\
    \ = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg0hr5_lu.d(26): Error: no identifier for declarator lst\n/tmp/tmpg0hr5_lu.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpg0hr5_lu.d(27): Error: no
    identifier for declarator row\n/tmp/tmpg0hr5_lu.d(27): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpg0hr5_lu.d(32): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpg0hr5_lu.d(35): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpg0hr5_lu.d(46):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0hr5_lu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n\
    \        }\n    }), range(0, lst.len));\n    \n    foreach(i -> foreach(j -> {\n\
    \        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n     \
    \   }\n    }), range(1, lst.len));\n    \n    foreach(i -> foreach(j -> {\n  \
    \      if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n       \
    \ }\n    }), range(2, lst.len));\n    \n    foreach(i -> foreach(j -> {\n    \
    \    if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n\
    \    }), range(3, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j]\
    \ == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(4,\
    \ lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n\
    \        {\n            result = [(i, j)];\n        }\n    }), range(5, lst.len));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            result = [(i, j)];\n        }\n    }), range(6, lst.len));\n    \n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n    \
    \        result = [(i, j)];\n        }\n    }), range(7, lst.len));\n    \n  \
    \  foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n      \
    \      result = [(i, j)];\n        }\n    }), range(8, lst.len));\n    \n    foreach(i\
    \ -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result\
    \ = [(i, j)];\n        }\n    }), range(9, lst.len));\n    \n    foreach(i ->\
    \ foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result =\
    \ [(i, j)];\n        }\n    }), range(10, lst.len));\n    \n    foreach(i -> foreach(j\
    \ -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n\
    \        }\n    }), range(11, lst.len));\n    \n    foreach(i -> foreach(j ->\
    \ {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n \
    \       }\n    }), range(12, lst.len));\n    \n    foreach(i -> foreach(j \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbz1vl7rh.d(27): Error: no identifier for declarator i\n/tmp/tmpbz1vl7rh.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpbz1vl7rh.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpbz1vl7rh.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpbz1vl7rh.d(27): Error: expression expected, not \''>\''\n/tmp/tmpbz1vl7rh.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpbz1vl7rh.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpbz1vl7rh.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpbz1vl7rh.d(28): Error: missing
    { ... } for function literal\n/tmp/tmpbz1vl7rh.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpbz1vl7rh.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmpbz1vl7rh.d(32): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz1vl7rh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long i, j;\n    Tuple!(long, long)[] res;\n    \n    for(i = 0; i < n; i++)\
    \ {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n    \
    \            res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n\
    \    \n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second\
    \ > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvp5whx6q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst, i: int)\n    {\n        foreach(col: row, j: int)\n\
    \        {\n            if(col == x)\n            {\n                result.add(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    sort!(result, (a, b) => (a.1\
    \ < b.1) || (a.1 == b.1 && b.1 < a.1));\n    sort!(result, (a, b) => (a.2 < b.2)\
    \ || (a.2 == b.2 && b.2 < a.2));\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_x_128nh.d(27): Error: no identifier for declarator row\n/tmp/tmp_x_128nh.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp_x_128nh.d(27): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmp_x_128nh.d(27): Error: no identifier for
    declarator int\n/tmp/tmp_x_128nh.d(27): Error: found \'')\'' instead of statement\n/tmp/tmp_x_128nh.d(35):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_x_128nh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row:\
    \ lst) {\n        foreach(col: row) {\n            if(col == x) {\n          \
    \      result = Tuple!(long, long)[](row, col);\n                break;\n    \
    \        }\n        }\n        if(result != null) break;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfl8obfoh.d(26): Error: no identifier for declarator row\n/tmp/tmpfl8obfoh.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpfl8obfoh.d(27): Error: no
    identifier for declarator col\n/tmp/tmpfl8obfoh.d(27): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfl8obfoh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n\
    \    sort(res, (a, b) -> {\n        if(a.first < b.first)\n            return\
    \ -1;\n        if(a.first > b.first)\n            return 1;\n        if(a.second\
    \ < b.second)\n            return -1;\n        if(a.second > b.second)\n     \
    \       return 1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkp_9z81t.d(27): Error: no identifier for declarator i\n/tmp/tmpkp_9z81t.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpkp_9z81t.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpkp_9z81t.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpkp_9z81t.d(27): Error: expression expected, not \''>\''\n/tmp/tmpkp_9z81t.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpkp_9z81t.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpkp_9z81t.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpkp_9z81t.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpkp_9z81t.d(32): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpkp_9z81t.d(32):
    Error: no identifier for declarator sort(res)\n/tmp/tmpkp_9z81t.d(33): Error:
    unexpected ( in declarator\n/tmp/tmpkp_9z81t.d(33): Error: basic type expected,
    not (\n/tmp/tmpkp_9z81t.d(33): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpkp_9z81t.d(33):
    Error: found \''-\'' when expecting \'')\''\n/tmp/tmpkp_9z81t.d(33): Error: no
    identifier for declarator sort(res, int(a, b))\n/tmp/tmpkp_9z81t.d(33): Error:
    semicolon expected following function declaration\n/tmp/tmpkp_9z81t.d(33): Error:
    Declaration expected, not \''>\''\n/tmp/tmpkp_9z81t.d(36): Error: Declaration
    expected, not \''if\''\n/tmp/tmpkp_9z81t.d(38): Error: Declaration expected, not
    \''if\''\n/tmp/tmpkp_9z81t.d(40): Error: Declaration expected, not \''if\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkp_9z81t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkjwevrcg.d(26): Error: no identifier for declarator row\n/tmp/tmpkjwevrcg.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpkjwevrcg.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmpkjwevrcg.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmpkjwevrcg.d(26): Error: found \'')\'' instead of statement\n/tmp/tmpkjwevrcg.d(35):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjwevrcg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n   \
    \         tt.push((i, j));\n            res.push(tt);\n        }\n    }), range(0,\
    \ lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j]\
    \ == x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n\
    \            tt.push((i, j));\n            res.push(tt);\n        }\n    }), range(0,\
    \ lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfo1311yi.d(27): Error: no identifier for declarator i\n/tmp/tmpfo1311yi.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpfo1311yi.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpfo1311yi.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpfo1311yi.d(27): Error: expression expected, not \''>\''\n/tmp/tmpfo1311yi.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpfo1311yi.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpfo1311yi.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpfo1311yi.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpfo1311yi.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpfo1311yi.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpfo1311yi.d(35): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfo1311yi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     res[res.length] = Tuple!(i, j);\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(1, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(2, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     res[res.length] = Tuple!(i, j);\n        }\n    }), range(3, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(4, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(5, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     res[res.length] = Tuple!(i, j);\n        }\n    }), range(6, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(7, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(8, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     res[res.length] = Tuple!(i, j);\n        }\n    }), range(9, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(10, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n        \
    \    res[res.length] = Tuple!(i, j);\n        }\n    }), range(11, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps2e69ki1.d(27): Error: no identifier for declarator i\n/tmp/tmps2e69ki1.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmps2e69ki1.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmps2e69ki1.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmps2e69ki1.d(27): Error: expression expected, not \''>\''\n/tmp/tmps2e69ki1.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmps2e69ki1.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmps2e69ki1.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmps2e69ki1.d(28): Error: missing
    { ... } for function literal\n/tmp/tmps2e69ki1.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmps2e69ki1.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmps2e69ki1.d(31): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2e69ki1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i] == x)\n   \
    \     {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n \
    \               res[lst[i].length * i + j] = Tuple!(long, long)((int)i, (int)j);\n\
    \            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxaekjcod.d(32): Error: C style cast illegal, use cast(int)i\n/tmp/tmpxaekjcod.d(32):
    Error: C style cast illegal, use cast(int)j\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxaekjcod.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {i,\
    \ j};\n            foreach(k -> foreach(l -> \n            {\n               \
    \ if(lst[i][k] == x && lst[k][j] == x)\n                {\n                  \
    \  tuple.push(Tuple!(long, long)[] {k, l});\n                }\n            }));\n\
    \            res.push(tuple);\n        }\n    }));\n    \n    foreach(i -> foreach(j\
    \ -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long,\
    \ long)[] tuple = new Tuple!(long, long)[] {i, j};\n            foreach(k -> foreach(l\
    \ -> \n            {\n                if(lst[i][k] == x && lst[k][j] == x)\n \
    \               {\n                    tuple.push(Tuple!(long, long)[] {l, k});\n\
    \                }\n            }));\n            res.push(tuple);\n        }\n\
    \    }));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] ==\
    \ x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[]\
    \ {i, j};\n            foreach(k -> foreach(l -> \n            {\n           \
    \     if(lst[i][k] == x && lst[k][j] == x)\n                {\n              \
    \      tuple.push(Tuple!(long, long)[] {j, l});\n                }\n         \
    \   }));\n            res.push(tuple);\n        }\n    }));\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpstsvs_cd.d(27): Error: no identifier for declarator i\n/tmp/tmpstsvs_cd.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpstsvs_cd.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpstsvs_cd.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpstsvs_cd.d(27): Error: expression expected, not \''>\''\n/tmp/tmpstsvs_cd.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpstsvs_cd.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpstsvs_cd.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpstsvs_cd.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpstsvs_cd.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpstsvs_cd.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpstsvs_cd.d(32): Error: Declaration expected, not
    \''foreach\''\n/tmp/tmpstsvs_cd.d(37): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpstsvs_cd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpltsifz3j.d(27): Error: no identifier for declarator i\n/tmp/tmpltsifz3j.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpltsifz3j.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpltsifz3j.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpltsifz3j.d(27): Error: expression expected, not \''>\''\n/tmp/tmpltsifz3j.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpltsifz3j.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpltsifz3j.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpltsifz3j.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpltsifz3j.d(32): Error: Declaration
    expected, not \''return\''\n/tmp/tmpltsifz3j.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltsifz3j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i]\
    \ = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col, Comparer<int>.Create((x,\
    \ y) => { return lst[x].CompareTo(lst[y]); }));\n    Array.Sort(col, row, Comparer<int>.Create((x,\
    \ y) => { return lst[y].CompareTo(lst[x]); }));\n    List<Tuple<long, long>> res\
    \ = new List<Tuple<long, long>>();\n    for(int i = 0; i < row.Length; i++)\n\
    \    {\n        res.Add(new Tuple<long, long>(row[i], col[i]));\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgccfyj1u.d(32): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpgccfyj1u.d(32): Error: found \''.\'' when expecting identifier
    following \''int.\''\n/tmp/tmpgccfyj1u.d(32): Error: found \''Create\'' when expecting
    \'',\''\n/tmp/tmpgccfyj1u.d(33): Error: found \''>\'' when expecting \''.\'' following
    int\n/tmp/tmpgccfyj1u.d(33): Error: found \''.\'' when expecting identifier following
    \''int.\''\n/tmp/tmpgccfyj1u.d(33): Error: found \''Create\'' when expecting \'',\''\n/tmp/tmpgccfyj1u.d(34):
    Error: found \''<\'' when expecting \'';\'' following statement\n/tmp/tmpgccfyj1u.d(34):
    Error: no identifier for declarator long\n/tmp/tmpgccfyj1u.d(34): Error: found
    \'',\'' instead of statement\n/tmp/tmpgccfyj1u.d(37): Error: found \'',\'' when
    expecting \''.\'' following long\n/tmp/tmpgccfyj1u.d(37): Error: found \''long\''
    when expecting identifier following \''long.\''\n/tmp/tmpgccfyj1u.d(37): Error:
    found \''>\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpgccfyj1u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\
    \ \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzaf969p2.d(26): Error: no identifier for declarator row\n/tmp/tmpzaf969p2.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpzaf969p2.d(28): Error: no
    identifier for declarator col\n/tmp/tmpzaf969p2.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzaf969p2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i, row) \n    {\n        foreach(j, col) \n        {\n          \
    \  if(row[j] == x)\n            {\n                res[res.length] = Tuple!(i,\
    \ j);\n            }\n        }\n    }\n    \n    foreach(tuple, tuple2) \n  \
    \  {\n        foreach(tuple3, tuple4) \n        {\n            if(tuple2.first\
    \ == tuple4.first && tuple2.second == tuple4.second)\n            {\n        \
    \        res[res.length] = tuple;\n            }\n        }\n    }\n    \n   \
    \ foreach(tuple, tuple2) \n    {\n        foreach(tuple3, tuple4) \n        {\n\
    \            if(tuple2.first == tuple4.first && tuple2.second > tuple4.second)\n\
    \            {\n                res[res.length] = tuple;\n            }\n    \
    \    }\n    }\n    \n    foreach(tuple, tuple2) \n    {\n        foreach(tuple3,\
    \ tuple4) \n        {\n            if(tuple2.first == tuple4.first && tuple2.second\
    \ < tuple4.second)\n            {\n                res[res.length] = tuple;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\n/*\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeojzjb6u.d(26): Error: no identifier for declarator row\n/tmp/tmpeojzjb6u.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpeojzjb6u.d(28): Error: no
    identifier for declarator col\n/tmp/tmpeojzjb6u.d(28): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpeojzjb6u.d(35): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpeojzjb6u.d(37): Error: no identifier for declarator tuple2\n/tmp/tmpeojzjb6u.d(37):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpeojzjb6u.d(39): Error: no
    identifier for declarator tuple4\n/tmp/tmpeojzjb6u.d(39): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpeojzjb6u.d(46): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpeojzjb6u.d(48): Error: no identifier for declarator tuple2\n/tmp/tmpeojzjb6u.d(48):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpeojzjb6u.d(50): Error: no
    identifier for declarator tuple4\n/tmp/tmpeojzjb6u.d(50): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpeojzjb6u.d(57): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpeojzjb6u.d(59): Error: no identifier for declarator tuple2\n/tmp/tmpeojzjb6u.d(59):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpeojzjb6u.d(61): Error: no
    identifier for declarator tuple4\n/tmp/tmpeojzjb6u.d(61): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpeojzjb6u.d(68): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpeojzjb6u.d(72): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpeojzjb6u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res.push(Tuple!(long, long)((row,col)));\n\
    \            }\n        }\n    }\n    sort(res);\n    sort(res,true);\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp74sehm9g.d(26): Error: no identifier for declarator lst\n/tmp/tmp74sehm9g.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp74sehm9g.d(28): Error: no
    identifier for declarator row\n/tmp/tmp74sehm9g.d(28): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmp74sehm9g.d(35): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmp74sehm9g.d(40): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp74sehm9g.d(51):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp74sehm9g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    \n   \
    \ sort(res, (a, b) => (a.first > b.first) ? 1 : -1);\n    sort(res, (a, b) =>\
    \ (a.second > b.second) ? 1 : -1);\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc5zcgdl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n     \
    \       if(column == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row), column));\n            }\n        }\n    }\n    sort(result);\n\
    \    sort(result, (a, b) => a.first > b.first);\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcxofnz09.d(26): Error: no identifier for declarator row\n/tmp/tmpcxofnz09.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpcxofnz09.d(28): Error: no
    identifier for declarator column\n/tmp/tmpcxofnz09.d(28): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxofnz09.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row:\
    \ lst)\n    {\n        foreach(column: row)\n        {\n            if(column\
    \ == x)\n            {\n                if(result == null)\n                {\n\
    \                    result = Tuple!(long, long)[](row, column);\n           \
    \     }\n                else\n                {\n                    result =\
    \ Tuple!(long, long)[](row, column);\n                }\n            }\n     \
    \   }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz1gdzxd1.d(27): Error: no identifier for declarator row\n/tmp/tmpz1gdzxd1.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpz1gdzxd1.d(29): Error: no
    identifier for declarator column\n/tmp/tmpz1gdzxd1.d(29): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz1gdzxd1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            ret.add(new Tuple!(i, j));\n        }\n    }), 0);\n    \n    sort(ret,\
    \ (x, y) -> {\n        if(x._1 == y._1)\n        {\n            return x._2 <\
    \ y._2;\n        }\n        else\n        {\n            return x._1 < y._1;\n\
    \        }\n    });\n    \n    sort(ret, (x, y) -> {\n        if(x._1 == y._1)\n\
    \        {\n            return x._2 < y._2;\n        }\n        else\n       \
    \ {\n            return x._1 < y._1;\n        }\n    });\n    \n    return ret;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprlhwl2sd.d(27): Error: no identifier for declarator i\n/tmp/tmprlhwl2sd.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmprlhwl2sd.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmprlhwl2sd.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmprlhwl2sd.d(27): Error: expression expected, not \''>\''\n/tmp/tmprlhwl2sd.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmprlhwl2sd.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmprlhwl2sd.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmprlhwl2sd.d(28): Error: missing
    { ... } for function literal\n/tmp/tmprlhwl2sd.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmprlhwl2sd.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmprlhwl2sd.d(32): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprlhwl2sd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.length];\n    int[] col = new\
    \ int[lst[0].length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n\
    \        row[i] = i;\n        for(int j = 0; j < lst[i].length; j++)\n       \
    \     col[j] = j;\n    }\n    \n    Arrays.sort(row);\n    Arrays.sort(col);\n\
    \    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n  \
    \  \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j\
    \ < lst[i].length; j++)\n        {\n            if(col[j] == x)\n            \
    \    res[i] = Tuple!(row[i], j);\n        }\n    }\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpraxngmpn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        if(lst[i][j] == x)\n            res = [(i, j)];\n    }), range(0,\
    \ lst.length));\n    \n    sort(res, (i, j) => (lst[i][j].compareTo(x)));\n  \
    \  sort(res, (i, j) => (lst[j][i].compareTo(x)));\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_h8eybzx.d(27): Error: no identifier for declarator i\n/tmp/tmp_h8eybzx.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp_h8eybzx.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp_h8eybzx.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp_h8eybzx.d(27): Error: expression expected, not \''>\''\n/tmp/tmp_h8eybzx.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp_h8eybzx.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp_h8eybzx.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmp_h8eybzx.d(29):
    Error: found \''=\'' instead of statement\n/tmp/tmp_h8eybzx.d(30): Error: Declaration
    expected, not \'')\''\n/tmp/tmp_h8eybzx.d(32): Error: unexpected ( in declarator\n/tmp/tmp_h8eybzx.d(32):
    Error: basic type expected, not (\n/tmp/tmp_h8eybzx.d(32): Error: function declaration
    without return type. (Note that constructors are always named \''this\'')\n/tmp/tmp_h8eybzx.d(32):
    Error: found \''=>\'' when expecting \'')\''\n/tmp/tmp_h8eybzx.d(32): Error: no
    identifier for declarator sort(res, int(i, j))\n/tmp/tmp_h8eybzx.d(32): Error:
    semicolon expected following function declaration\n/tmp/tmp_h8eybzx.d(32): Error:
    Declaration expected, not \''(\''\n/tmp/tmp_h8eybzx.d(33): Error: unexpected (
    in declarator\n/tmp/tmp_h8eybzx.d(33): Error: basic type expected, not (\n/tmp/tmp_h8eybzx.d(33):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmp_h8eybzx.d(33): Error: found \''=>\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_h8eybzx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.add(new Tuple!(i, j));\n            }\n        }\n\
    \    }\n    \n    sort(res);\n    sort(res, (a, b) -> a.first > b.first);\n  \
    \  \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpof2ggj4c.d(39): Error: expression expected, not \''>\''\n/tmp/tmpof2ggj4c.d(39):
    Error: found \''a\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpof2ggj4c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n  \
    \          foreach(k -> \n            {\n                if(lst[i][k] == x)\n\
    \                {\n                    row.add(k);\n                }\n     \
    \       });\n            res.add(row);\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n  \
    \          foreach(k -> \n            {\n                if(lst[i][k] == x)\n\
    \                {\n                    row.add(k);\n                }\n     \
    \       });\n            res.add(row);\n        }\n    }), range(0, lst[0].length));\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjqn2bt5k.d(27): Error: no identifier for declarator i\n/tmp/tmpjqn2bt5k.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpjqn2bt5k.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpjqn2bt5k.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpjqn2bt5k.d(27): Error: expression expected, not \''>\''\n/tmp/tmpjqn2bt5k.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjqn2bt5k.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpjqn2bt5k.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpjqn2bt5k.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpjqn2bt5k.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpjqn2bt5k.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpjqn2bt5k.d(32): Error: no identifier for declarator
    k\n/tmp/tmpjqn2bt5k.d(32): Error: found \''-\'' when expecting \'';\''\n/tmp/tmpjqn2bt5k.d(32):
    Error: expression expected, not \''>\''\n/tmp/tmpjqn2bt5k.d(33): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmpjqn2bt5k.d(38): Error: Declaration expected,
    not \'')\''\n/tmp/tmpjqn2bt5k.d(39): Error: function declaration without return
    type. (Note that constructors are always named \''this\'')\n/tmp/tmpjqn2bt5k.d(39):
    Error: no identifier for declarator res.add(row)\n/tmp/tmpjqn2bt5k.d(40): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjqn2bt5k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long i, j;\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n\
    \    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n\
    \    \n    for(i = 0; i < n; i++)\n    {\n        for(j = m-1; j >= 0; j--)\n\
    \        {\n            if(lst[i][j] > x)\n            {\n                res[i]\
    \ = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphlx3y4b6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    foreach(i -> foreach(j\
    \ -> res = append(res, Tuple!(i, j), Tuple!(0, 0))), lst);\n    sort(res);\n \
    \   sort(res, (a, b) -> b._1 - a._1);\n    sort(res, (a, b) -> b._2 - a._2);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmivh8zbb.d(26): Error: no identifier for declarator i\n/tmp/tmpmivh8zbb.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpmivh8zbb.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmpmivh8zbb.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpmivh8zbb.d(26): Error: expression expected, not \''>\''\n/tmp/tmpmivh8zbb.d(26):
    Error: found \''res\'' when expecting \'')\''\n/tmp/tmpmivh8zbb.d(26): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpmivh8zbb.d(26):
    Error: found \'',\'' instead of statement\n/tmp/tmpmivh8zbb.d(28): Error: expression
    expected, not \''>\''\n/tmp/tmpmivh8zbb.d(28): Error: found \''b\'' when expecting
    \'',\''\n/tmp/tmpmivh8zbb.d(29): Error: expression expected, not \''>\''\n/tmp/tmpmivh8zbb.d(29):
    Error: found \''b\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmivh8zbb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\
    \ \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzaf969p2.d(26): Error: no identifier for declarator row\n/tmp/tmpzaf969p2.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpzaf969p2.d(28): Error: no
    identifier for declarator col\n/tmp/tmpzaf969p2.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzaf969p2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i -> foreach(j\
    \ -> {\n        if(lst[i][j] == x)\n            res = Tuple!(long, long)!(x, i);\n\
    \    }), 0..lst.length-1);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkkg633ta.d(26): Error: no identifier for declarator i\n/tmp/tmpkkg633ta.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpkkg633ta.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmpkkg633ta.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpkkg633ta.d(26): Error: expression expected, not \''>\''\n/tmp/tmpkkg633ta.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpkkg633ta.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpkkg633ta.d(28): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpkkg633ta.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmpkkg633ta.d(29): Error: Declaration
    expected, not \'')\''\n/tmp/tmpkkg633ta.d(30): Error: Declaration expected, not
    \''return\''\n/tmp/tmpkkg633ta.d(31): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkkg633ta.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, true);\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdw_lbfm7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            long r = i;\n   \
    \         long c = j;\n            long k = k;\n            \n            if(r\
    \ == x && c == x)\n            {\n                row.push((k, k));\n        \
    \    }\n            \n            if(r > x && c > x)\n            {\n        \
    \        row.push((k, k));\n            }\n            \n            if(r < x\
    \ && c < x)\n            {\n                row.push((k, k));\n            }\n\
    \            \n            if(r == x && c == x)\n            {\n             \
    \   row.push((k, k));\n            }\n            \n            if(r > x && c\
    \ > x)\n            {\n                row.push((k, k));\n            }\n    \
    \        \n            if(r < x && c < x)\n            {\n                row.push((k,\
    \ k));\n            }\n            \n            if(r == x && c == x)\n      \
    \      {\n                row.push((k, k));\n            }\n            \n   \
    \         if(r > x && c > x)\n            {\n                row.push((k, k));\n\
    \            }\n            \n            if(r < x && c < x)\n            {\n\
    \                row.push((k, k));\n            }\n            \n            if(r\
    \ == x && c == x)\n            {\n                row.push((k, k));\n        \
    \    }\n            \n            if(r > x && c > x)\n            {\n        \
    \        row.push((k, k));\n            }\n            \n            if(r < x\
    \ && c < x)\n            {\n                row.push((k, k));\n            }\n\
    \            \n            if(r == x && c == x)\n            {\n             \
    \   row.push((k, k));\n            }\n            \n            if(r > x && c\
    \ > x)\n            {\n                row.push((k, k));\n            }\n    \
    \        \n            if(r < x && c < x)\n            {\n                row.push((k,\
    \ k));\n            }\n            \n            if(r == x && c == x)\n      \
    \      {\n                row.push((k, k));\n            }\n            \n   \
    \         if(r > x && c > x)\n            {\n                row.push((k, k));\n\
    \            }\n            \n            if(r < x && c < x)\n            {\n\
    \                row.push((k, k));\n            }\n            \n            if(r\
    \ == x && c == x)\n            {\n                row.push((k, k));\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjci_lsz6.d(27): Error: no identifier for declarator i\n/tmp/tmpjci_lsz6.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpjci_lsz6.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpjci_lsz6.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpjci_lsz6.d(27): Error: expression expected, not \''>\''\n/tmp/tmpjci_lsz6.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjci_lsz6.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmpjci_lsz6.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmpjci_lsz6.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmpjci_lsz6.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmpjci_lsz6.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmpjci_lsz6.d(29): Error: no identifier
    for declarator k\n/tmp/tmpjci_lsz6.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmpjci_lsz6.d(29): Error: expression expected, not \''>\''\n/tmp/tmpjci_lsz6.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjci_lsz6.d(127): Error: found
    \''unittest\'' instead of statement\n/tmp/tmpjci_lsz6.d(138): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjci_lsz6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ {\n        foreach(col::row) {\n            if(col == x) {\n               \
    \ res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0020iohf.d(26): Error: no identifier for declarator row\n/tmp/tmp0020iohf.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp0020iohf.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmp0020iohf.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmp0020iohf.d(26): Error: found \'')\'' instead of statement\n/tmp/tmp0020iohf.d(31):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0020iohf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n   \
    \ \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n       \
    \     if (lst[i][j] == x) {\n                res[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    sort(res,\
    \ (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9c3by5c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(row:\
    \ lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x)\
    \ \n            {\n                res = Tuple!(long, long)[](row, col);\n   \
    \             break;\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoc52pdp_.d(27): Error: no identifier for declarator row\n/tmp/tmpoc52pdp_.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpoc52pdp_.d(29): Error: no
    identifier for declarator col\n/tmp/tmpoc52pdp_.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoc52pdp_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ sort(res);\n    sort(res, (a, b) -> Tuple!(b._1, a._2));\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwz607ttf.d(27): Error: no identifier for declarator i\n/tmp/tmpwz607ttf.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpwz607ttf.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpwz607ttf.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpwz607ttf.d(27): Error: expression expected, not \''>\''\n/tmp/tmpwz607ttf.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpwz607ttf.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpwz607ttf.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpwz607ttf.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpwz607ttf.d(32): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpwz607ttf.d(32):
    Error: no identifier for declarator sort(res)\n/tmp/tmpwz607ttf.d(33): Error:
    unexpected ( in declarator\n/tmp/tmpwz607ttf.d(33): Error: basic type expected,
    not (\n/tmp/tmpwz607ttf.d(33): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpwz607ttf.d(33):
    Error: found \''-\'' when expecting \'')\''\n/tmp/tmpwz607ttf.d(33): Error: no
    identifier for declarator sort(res, int(a, b))\n/tmp/tmpwz607ttf.d(33): Error:
    semicolon expected following function declaration\n/tmp/tmpwz607ttf.d(33): Error:
    Declaration expected, not \''>\''\n/tmp/tmpwz607ttf.d(35): Error: Declaration
    expected, not \''return\''\n/tmp/tmpwz607ttf.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwz607ttf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n    \
    \        if(col == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    sort(result, 1, result.length - 1);\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa_0mop_g.d(27): Error: no identifier for declarator lst\n/tmp/tmpa_0mop_g.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpa_0mop_g.d(29): Error: no
    identifier for declarator row\n/tmp/tmpa_0mop_g.d(29): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpa_0mop_g.d(36): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpa_0mop_g.d(43): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpa_0mop_g.d(54):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_0mop_g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \      }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7zk2z0f5.d(26): Error: no identifier for declarator row\n/tmp/tmp7zk2z0f5.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp7zk2z0f5.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmp7zk2z0f5.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmp7zk2z0f5.d(26): Error: found \'')\'' instead of statement\n/tmp/tmp7zk2z0f5.d(34):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zk2z0f5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n\
    \    {\n        foreach(column: row)\n        {\n            if(column == x)\n\
    \            {\n                result.push(Tuple!(long, long)((row), column));\n\
    \            }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a,\
    \ b) => a.first > b.first);\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgtdzd374.d(27): Error: no identifier for declarator row\n/tmp/tmpgtdzd374.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpgtdzd374.d(29): Error: no
    identifier for declarator column\n/tmp/tmpgtdzd374.d(29): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgtdzd374.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                ret.add(new Tuple!(i, j));\n            }\n        }\n\
    \    }\n    \n    sort(ret, (a, b) -> a.first > b.first ? 1 : -1);\n    sort(ret,\
    \ (a, b) -> a.second > b.second ? 1 : -1);\n    \n    return ret;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8shiq_jk.d(38): Error: expression expected, not \''>\''\n/tmp/tmp8shiq_jk.d(38):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmp8shiq_jk.d(39): Error: expression
    expected, not \''>\''\n/tmp/tmp8shiq_jk.d(39): Error: found \''a\'' when expecting
    \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8shiq_jk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] temp = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[]\
    \ temp2 = new Tuple!(long, long)[];\n            foreach(l -> {\n            \
    \    Tuple!(long, long)[] temp3 = new Tuple!(long, long)[];\n                foreach(m\
    \ -> {\n                    Tuple!(long, long)[] temp4 = new Tuple!(long, long)[];\n\
    \                    foreach(n -> {\n                        Tuple!(long, long)[]\
    \ temp5 = new Tuple!(long, long)[];\n                        foreach(o -> {\n\
    \                            Tuple!(long, long)[] temp6 = new Tuple!(long, long)[];\n\
    \                            foreach(p -> {\n                                Tuple!(long,\
    \ long)[] temp7 = new Tuple!(long, long)[];\n                                foreach(q\
    \ -> {\n                                    Tuple!(long, long)[] temp8 = new Tuple!(long,\
    \ long)[];\n                                    foreach(r -> {\n             \
    \                           Tuple!(long, long)[] temp9 = new Tuple!(long, long)[];\n\
    \                                        foreach(s -> {\n                    \
    \                        Tuple!(long, long)[] temp10 = new Tuple!(long, long)[];\n\
    \                                            foreach(t -> {\n                \
    \                                Tuple!(long, long)[] temp11 = new Tuple!(long,\
    \ long)[];\n                                                foreach(u -> {\n \
    \                                                   Tuple!(long, long)[] temp12\
    \ = new Tuple!(long, long)[];\n                                              \
    \      foreach(v -> {\n                                                      \
    \  Tuple!(long, long)[] temp13 = new Tuple!(long, long)[];\n                 \
    \                                       foreach(w -> {\n                     \
    \                                       Tuple!(long, long)[] temp14 = new Tuple!(long,\
    \ long)[];\n                                                            foreach(x\
    \ -> {\n                                                                Tuple!(long,\
    \ long)[] temp15 = new Tuple!(long, long)[];\n                               \
    \                                 foreach(y -> {\n                           \
    \                                         Tuple!(long, long)[] temp16 = new Tuple!(long,\
    \ long)[];\n                                                                 \
    \   foreach(z -> {\n                                                         \
    \               Tuple!(long, long)[] temp17 = new Tuple!(long, long)[];\n    \
    \                                                                    foreach(a\
    \ -> {\n                                                                     \
    \       Tuple!(long, long)[] temp18 = new Tuple!(long, long)[];\n            \
    \                                                                foreach(b ->\
    \ {\n                                                                        \
    \        Tuple!(long, long)[] temp19 = new Tuple!(long, long)[];\n           \
    \                                                                     foreach(c\
    \ -> {\n                                                                     \
    \               Tuple!(long, long)[] temp20 = new Tuple!(long, long)[];\n    \
    \                                                                            \
    \    foreach(d -> {\n                                                        \
    \                                Tuple!(long, long)[] temp21 = new Tuple!(long,\
    \ long)[];\n                                                                 \
    \                       foreach(e -> {\n                                     \
    \                                                       Tuple!(long, long)[] temp22\
    \ = new Tuple!(long, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjwt4ott3.d(27): Error: no identifier for declarator i\n/tmp/tmpjwt4ott3.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpjwt4ott3.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpjwt4ott3.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpjwt4ott3.d(27): Error: expression expected, not \''>\''\n/tmp/tmpjwt4ott3.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjwt4ott3.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmpjwt4ott3.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmpjwt4ott3.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmpjwt4ott3.d(28):
    Error: found \''temp\'' when expecting \'';\'' following statement\n/tmp/tmpjwt4ott3.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmpjwt4ott3.d(29): Error: no identifier
    for declarator k\n/tmp/tmpjwt4ott3.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmpjwt4ott3.d(29): Error: expression expected, not \''>\''\n/tmp/tmpjwt4ott3.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjwt4ott3.d(31): Error: no
    identifier for declarator l\n/tmp/tmpjwt4ott3.d(31): Error: found \''-\'' when
    expecting \'';\''\n/tmp/tmpjwt4ott3.d(31): Error: expression expected, not \''>\''\n/tmp/tmpjwt4ott3.d(31):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjwt4ott3.d(33): Error: no
    identifier for declarator m\n/tmp/tmpjwt4ott3.d(33): Error: found \''-\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwt4ott3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n        \
    \    if(col == x)\n            {\n                res.push(Tuple!(long, long)((row),\
    \ col));\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b)\
    \ => a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcg9xo1hr.d(26): Error: no identifier for declarator row\n/tmp/tmpcg9xo1hr.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpcg9xo1hr.d(28): Error: no
    identifier for declarator col\n/tmp/tmpcg9xo1hr.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcg9xo1hr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n   \
    \         tt[0] = i;\n            tt[1] = j;\n            res.add(tt);\n     \
    \   }\n    }), range(0, lst.Length));\n    \n    foreach(i -> foreach(j -> \n\
    \    {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[]\
    \ tt = new Tuple!(long, long)[];\n            tt[0] = i;\n            tt[1] =\
    \ j;\n            res.add(tt);\n        }\n    }), range(1, lst.Length));\n  \
    \  \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] < x)\n      \
    \  {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n      \
    \      tt[0] = i;\n            tt[1] = j;\n            res.add(tt);\n        }\n\
    \    }), range(0, lst.Length - 1));\n    \n    return res;\n}\n/*\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0qeklbdw.d(27): Error: no identifier for declarator i\n/tmp/tmp0qeklbdw.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp0qeklbdw.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp0qeklbdw.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp0qeklbdw.d(27): Error: expression expected, not \''>\''\n/tmp/tmp0qeklbdw.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp0qeklbdw.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp0qeklbdw.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp0qeklbdw.d(29): Error: missing
    { ... } for function literal\n/tmp/tmp0qeklbdw.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp0qeklbdw.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmp0qeklbdw.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0qeklbdw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    sort(res);\n\
    \    sort(res, (a, b) -> a.first > b.first ? 1 : -1);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfvmo24v2.d(37): Error: expression expected, not \''>\''\n/tmp/tmpfvmo24v2.d(37):
    Error: found \''a\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfvmo24v2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n\
    \            if(column == x)\n            {\n                result.add(Tuple!(long,\
    \ long)((row, column)));\n            }\n        }\n    }\n    \n    result.sort(compareByDescending);\n\
    \    \n    foreach(row: result)\n    {\n        foreach(column: row)\n       \
    \ {\n            foreach(coord: column)\n            {\n                coord.swap();\n\
    \            }\n        }\n    }\n    \n    result.sort(compareByDescending);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8lv30j0p.d(27): Error: no identifier for declarator row\n/tmp/tmp8lv30j0p.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp8lv30j0p.d(29): Error: no
    identifier for declarator column\n/tmp/tmp8lv30j0p.d(29): Error: found \'':\''
    when expecting \'';\''\n/tmp/tmp8lv30j0p.d(40): Error: no identifier for declarator
    row\n/tmp/tmp8lv30j0p.d(40): Error: found \'':\'' when expecting \'';\''\n/tmp/tmp8lv30j0p.d(42):
    Error: no identifier for declarator column\n/tmp/tmp8lv30j0p.d(42): Error: found
    \'':\'' when expecting \'';\''\n/tmp/tmp8lv30j0p.d(44): Error: no identifier for
    declarator coord\n/tmp/tmp8lv30j0p.d(44): Error: found \'':\'' when expecting
    \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8lv30j0p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr1iuf2ud.d(26): Error: no identifier for declarator row\n/tmp/tmpr1iuf2ud.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpr1iuf2ud.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmpr1iuf2ud.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmpr1iuf2ud.d(26): Error: found \'')\'' instead of statement\n/tmp/tmpr1iuf2ud.d(35):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr1iuf2ud.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6qn3vus_.d(27): Error: no identifier for declarator i\n/tmp/tmp6qn3vus_.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp6qn3vus_.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp6qn3vus_.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp6qn3vus_.d(27): Error: expression expected, not \''>\''\n/tmp/tmp6qn3vus_.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp6qn3vus_.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp6qn3vus_.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmp6qn3vus_.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmp6qn3vus_.d(32): Error: Declaration
    expected, not \''return\''\n/tmp/tmp6qn3vus_.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qn3vus_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n      \
    \      if(col == x) \n            {\n                result.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    result.sort(compareByDescending);\n\
    \    result.sort(compareByDescending);\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq53_u0t2.d(26): Error: no identifier for declarator row\n/tmp/tmpq53_u0t2.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpq53_u0t2.d(28): Error: no
    identifier for declarator col\n/tmp/tmpq53_u0t2.d(28): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmpq53_u0t2.d(40): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq53_u0t2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.push(Tuple!(i, j));\n            }\n        }\n \
    \   }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n   \
    \ sort(res, (a, b) => a.second > b.second);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gnsevvx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n\
    \    {\n        foreach(column: row)\n        {\n            if(column == x)\n\
    \            {\n                foreach(coord: Tuple!(long, long)[])\n       \
    \         {\n                    if(coord.0 == row)\n                    {\n \
    \                       result.push(coord);\n                    }\n         \
    \       }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long,\
    \ long)[])\n    {\n        if(coord.0 > result.length)\n        {\n          \
    \  result.push(coord);\n        }\n    }\n    \n    foreach(coord: Tuple!(long,\
    \ long)[])\n    {\n        if(coord.1 < result.length)\n        {\n          \
    \  int row = coord.0;\n            int column = coord.1;\n            \n     \
    \       foreach(row: lst)\n            {\n                foreach(column: row)\n\
    \                {\n                    if(column == row)\n                  \
    \  {\n                        result.push(coord);\n                    }\n   \
    \             }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long,\
    \ long)[])\n    {\n        if(coord.1 < result.length)\n        {\n          \
    \  int row = coord.0;\n            int column = coord.1;\n            \n     \
    \       foreach(row: lst)\n            {\n                foreach(column: row)\n\
    \                {\n                    if(column == row)\n                  \
    \  {\n                        result.push(coord);\n                    }\n   \
    \             }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long,\
    \ long)[])\n    {\n        if(coord.1 < result.length)\n        {\n          \
    \  int row = coord.0;\n            int column = coord.1;\n            \n     \
    \       foreach(row: lst)\n            {\n                foreach(column: row)\n\
    \                {\n                    if(column == row)\n                  \
    \  {\n                        result.push(coord);\n                    }\n   \
    \             }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long,\
    \ long)[])\n    {\n        if(coord.1 < result.length)\n        {\n          \
    \  int row = coord.0;\n            int column = coord.1;\n            \n     \
    \       foreach(row: lst)\n            {\n                foreach(column: row)\n\
    \                {\n                    if(column == row)\n                  \
    \  {\n                        result.push(coord);\n                    }\n   \
    \             }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long,\
    \ long)[])\n    {\n        if(coord.1 < result.length)\n        {\n          \
    \  int row = coord.0;\n            int column = coord.1;\n            \n     \
    \       foreach(row: lst)\n            {\n                foreach(column: row)\n\
    \                {\n                    if(column == row)\n                  \
    \  {\n                        result.push(\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpicqa_htv.d(27): Error: no identifier for declarator row\n/tmp/tmpicqa_htv.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpicqa_htv.d(29): Error: no
    identifier for declarator column\n/tmp/tmpicqa_htv.d(29): Error: found \'':\''
    when expecting \'';\''\n/tmp/tmpicqa_htv.d(33): Error: no identifier for declarator
    coord\n/tmp/tmpicqa_htv.d(33): Error: found \'':\'' when expecting \'';\''\n/tmp/tmpicqa_htv.d(35):
    Error: found \''0.00000\'' when expecting \'')\''\n/tmp/tmpicqa_htv.d(35): Error:
    found \''==\'' instead of statement\n/tmp/tmpicqa_htv.d(44): Error: Declaration
    expected, not \''foreach\''\n/tmp/tmpicqa_htv.d(49): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpicqa_htv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n          \
    \  if(i == k) {\n                row = new Tuple!(long, long)[];\n           \
    \     foreach(l -> {\n                    if(j == l) {\n                     \
    \   row.push((i, j));\n                    }\n                });\n          \
    \  }\n        }), lst);\n        result.push(row);\n    }), 0);\n    \n    foreach(i\
    \ -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n\
    \            if(i == k) {\n                row = new Tuple!(long, long)[];\n \
    \               foreach(l -> {\n                    if(j == l) {\n           \
    \             row.push((i, j));\n                    }\n                });\n\
    \            }\n        }), result);\n        result.push(row);\n    }), 0);\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n  \
    \      foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long,\
    \ long)[];\n                foreach(l -> {\n                    if(j == l) {\n\
    \                        row.push((i, j));\n                    }\n          \
    \      });\n            }\n        }), result);\n        result.push(row);\n \
    \   }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row;\n        foreach(k -> {\n            if(i == k) {\n                row\
    \ = new Tuple!(long, long)[];\n                foreach(l -> {\n              \
    \      if(j == l) {\n                        row.push((i, j));\n             \
    \       }\n                });\n            }\n        }), result);\n        result.push(row);\n\
    \    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row;\n        foreach(k -> {\n            if(i == k) {\n                row\
    \ = new Tuple!(long, long)[];\n                foreach(l -> {\n              \
    \      if(j == l) {\n                        row.push((i, j));\n             \
    \       }\n                });\n            }\n        }), result);\n        result.push(row);\n\
    \    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row;\n        foreach(k -> {\n            if(i == k) {\n                row\
    \ = new Tuple!(long, long)[];\n                foreach(l -> {\n              \
    \      if(j == l) {\n                        row.push((i, j));\n             \
    \       }\n                });\n            }\n        }), result);\n        result.push(row);\n\
    \    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_pqioru4.d(27): Error: no identifier for declarator i\n/tmp/tmp_pqioru4.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp_pqioru4.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp_pqioru4.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp_pqioru4.d(27): Error: expression expected, not \''>\''\n/tmp/tmp_pqioru4.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp_pqioru4.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp_pqioru4.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp_pqioru4.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp_pqioru4.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmp_pqioru4.d(29):
    Error: no identifier for declarator k\n/tmp/tmp_pqioru4.d(29): Error: found \''-\''
    when expecting \'';\''\n/tmp/tmp_pqioru4.d(29): Error: expression expected, not
    \''>\''\n/tmp/tmp_pqioru4.d(29): Error: found \''{\'' when expecting \'')\''\n/tmp/tmp_pqioru4.d(32):
    Error: no identifier for declarator l\n/tmp/tmp_pqioru4.d(32): Error: found \''-\''
    when expecting \'';\''\n/tmp/tmp_pqioru4.d(32): Error: expression expected, not
    \''>\''\n/tmp/tmp_pqioru4.d(32): Error: found \''{\'' when expecting \'')\''\n/tmp/tmp_pqioru4.d(36):
    Error: found \'')\'' instead of statement\n/tmp/tmp_pqioru4.d(38): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_pqioru4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res.add((i, j));\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr3m5429k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j\
    \ -> res = append(res, Tuple!(long, long)((i, j), lst[i][j]))), 0 .. lst.length\
    \ - 1)\n    \n    sort(res, (i, j) -> j > i);\n    sort(res, (i, j) -> j > i);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbj9axcm4.d(27): Error: no identifier for declarator i\n/tmp/tmpbj9axcm4.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpbj9axcm4.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpbj9axcm4.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpbj9axcm4.d(27): Error: expression expected, not \''>\''\n/tmp/tmpbj9axcm4.d(27):
    Error: found \''res\'' when expecting \'')\''\n/tmp/tmpbj9axcm4.d(27): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpbj9axcm4.d(27):
    Error: found \'',\'' instead of statement\n/tmp/tmpbj9axcm4.d(30): Error: expression
    expected, not \''>\''\n/tmp/tmpbj9axcm4.d(30): Error: found \''j\'' when expecting
    \'',\''\n/tmp/tmpbj9axcm4.d(30): Error: expression expected, not \''>\''\n/tmp/tmpbj9axcm4.d(30):
    Error: found \''i\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbj9axcm4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] == x){\n                res.add((i, j));\n \
    \           }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4j1owjiv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    for(int i = 0; i\
    \ < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long,\
    \ long)[] row = get_row(lst[i], x);\n                Tuple!(long, long)[] col\
    \ = get_row(lst[j], x);\n                \n                res = Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0bn875we.d(37): Error: expression expected, not \''unittest\''\n/tmp/tmp0bn875we.d(38):
    Error: found \''{\'' when expecting \'')\'' following template argument list\n/tmp/tmp0bn875we.d(39):
    Error: found \''alias\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(39): Error:
    found \'';\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(41): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmp0bn875we.d(42): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp0bn875we.d(43): Error: found \'';\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(44):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(45): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(46): Error: found \'';\'' when
    expecting \'',\''\n/tmp/tmp0bn875we.d(47): Error: expression expected, not \''}\''\n/tmp/tmp0bn875we.d(48):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(48): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(48): Error: expression
    expected, not \''}\''\n/tmp/tmp0bn875we.d(48): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp0bn875we.d(48): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp0bn875we.d(48):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp0bn875we.d(48): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmp0bn875we.d(48): Error: found \''EOF\''
    when expecting \'',\''\n/tmp/tmp0bn875we.d(48): Error: found \''EOF\'' when expecting
    \'')\''\n/tmp/tmp0bn875we.d(48): Error: found \''EOF\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0bn875we.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n  \
    \  sort(res, (i, j) -> {\n        if(i < j)\n            return 1;\n        else\
    \ if(i > j)\n            return -1;\n        else\n            return 0;\n   \
    \ });\n    \n    sort(res, (i, j) -> {\n        if(i < j)\n            return\
    \ -1;\n        else if(i > j)\n            return 1;\n        else\n         \
    \   return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwa10xh79.d(27): Error: no identifier for declarator i\n/tmp/tmpwa10xh79.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpwa10xh79.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpwa10xh79.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpwa10xh79.d(27): Error: expression expected, not \''>\''\n/tmp/tmpwa10xh79.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpwa10xh79.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpwa10xh79.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpwa10xh79.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpwa10xh79.d(32): Error: unexpected
    ( in declarator\n/tmp/tmpwa10xh79.d(32): Error: basic type expected, not (\n/tmp/tmpwa10xh79.d(32):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpwa10xh79.d(32): Error: found \''-\'' when expecting
    \'')\''\n/tmp/tmpwa10xh79.d(32): Error: no identifier for declarator sort(res,
    int(i, j))\n/tmp/tmpwa10xh79.d(32): Error: semicolon expected following function
    declaration\n/tmp/tmpwa10xh79.d(32): Error: Declaration expected, not \''>\''\n/tmp/tmpwa10xh79.d(35):
    Error: Declaration expected, not \''else\''\n/tmp/tmpwa10xh79.d(37): Error: Declaration
    expected, not \''else\''\n/tmp/tmpwa10xh79.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwa10xh79.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n  \
    \          if(col == x)\n            {\n                res.push(Tuple!(long,\
    \ long)(x-1, row));\n            }\n        }\n    }\n    \n    foreach(row: lst)\n\
    \    {\n        foreach(col: row)\n        {\n            if(col != x)\n     \
    \       {\n                res.push(Tuple!(long, long)(x, col-1));\n         \
    \   }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8yjof9fj.d(27): Error: no identifier for declarator row\n/tmp/tmp8yjof9fj.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp8yjof9fj.d(29): Error: no
    identifier for declarator col\n/tmp/tmp8yjof9fj.d(29): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmp8yjof9fj.d(38): Error: no identifier for declarator
    row\n/tmp/tmp8yjof9fj.d(38): Error: found \'':\'' when expecting \'';\''\n/tmp/tmp8yjof9fj.d(40):
    Error: no identifier for declarator col\n/tmp/tmp8yjof9fj.d(40): Error: found
    \'':\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8yjof9fj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row:\
    \ lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x)\
    \ \n            {\n                result = Tuple!(long, long)[Tuple!(long, long)[row,\
    \ col]];\n                break;\n            }\n        }\n        if(result\
    \ != null) break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjnki0xh2.d(26): Error: no identifier for declarator row\n/tmp/tmpjnki0xh2.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpjnki0xh2.d(28): Error: no
    identifier for declarator col\n/tmp/tmpjnki0xh2.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjnki0xh2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) \n\
    \    {\n        foreach(column) \n        {\n            if(column == x) \n  \
    \          {\n                result ~= Tuple!(row, column);\n            }\n\
    \        }\n    }\n    \n    sort(result);\n    sort(result, descending);\n  \
    \  \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpesgui40t.d(27): Error: no identifier for declarator row\n/tmp/tmpesgui40t.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpesgui40t.d(29): Error: no
    identifier for declarator column\n/tmp/tmpesgui40t.d(29): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpesgui40t.d(36): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpesgui40t.d(43): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpesgui40t.d(54):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpesgui40t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] t = new Tuple!(long, long)[]; \n   \
    \         t[0] = i; \n            t[1] = j; \n            res.add(t);\n      \
    \  }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> \n \
    \   {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[]\
    \ t = new Tuple!(long, long)[]; \n            t[0] = i; \n            t[1] = j;\
    \ \n            res.add(t);\n        }\n    }), range(0, lst[0].length));\n  \
    \  \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpptsop7ea.d(27): Error: no identifier for declarator i\n/tmp/tmpptsop7ea.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpptsop7ea.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpptsop7ea.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpptsop7ea.d(27): Error: expression expected, not \''>\''\n/tmp/tmpptsop7ea.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpptsop7ea.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpptsop7ea.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpptsop7ea.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpptsop7ea.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpptsop7ea.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpptsop7ea.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptsop7ea.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            result.add((i, j));\n        }\n    }), range(0, lst.length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n\
    \            result.add((i, j));\n        }\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0uxbkj4y.d(27): Error: no identifier for declarator i\n/tmp/tmp0uxbkj4y.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp0uxbkj4y.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp0uxbkj4y.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp0uxbkj4y.d(27): Error: expression expected, not \''>\''\n/tmp/tmp0uxbkj4y.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp0uxbkj4y.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp0uxbkj4y.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp0uxbkj4y.d(28): Error: missing
    { ... } for function literal\n/tmp/tmp0uxbkj4y.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp0uxbkj4y.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmp0uxbkj4y.d(32): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0uxbkj4y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row:\
    \ lst) \n    {\n        foreach(column: row) \n        {\n            if(column\
    \ == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n\
    \                break;\n            }\n        }\n        if(result != null)\
    \ break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1rpngmgc.d(26): Error: no identifier for declarator row\n/tmp/tmp1rpngmgc.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp1rpngmgc.d(28): Error: no
    identifier for declarator column\n/tmp/tmp1rpngmgc.d(28): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1rpngmgc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n   \
    \ for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n \
    \           if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n        if(j\
    \ == m)\n        {\n            res[i] = Tuple!(long, long)[i, j];\n        }\n\
    \    }\n    sort(res);\n    sort(res, (a, b) => -cmp(b.1, a.1));\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm8udrcvj.d(45): Error: found \''0.1\'' when expecting \'',\''\n/tmp/tmpm8udrcvj.d(45):
    Error: expression expected, not \'',\''\n/tmp/tmpm8udrcvj.d(45): Error: found
    \''a\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8udrcvj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row:\
    \ lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n\
    \            {\n                if(result == null)\n                {\n      \
    \              result = Tuple!(long, long)[](row, col);\n                }\n \
    \               else\n                {\n                    result = Tuple!(long,\
    \ long)[](row, col);\n                    result.push(result);\n             \
    \   }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnhdo5iyw.d(26): Error: no identifier for declarator row\n/tmp/tmpnhdo5iyw.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpnhdo5iyw.d(28): Error: no
    identifier for declarator col\n/tmp/tmpnhdo5iyw.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnhdo5iyw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\n\
    \    {\n        foreach(col: row)\n        {\n            if(col == x)\n     \
    \       {\n                res = Tuple!(long, long)[Tuple!(long, long)[row, col]];\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgavlu79c.d(26): Error: no identifier for declarator row\n/tmp/tmpgavlu79c.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpgavlu79c.d(28): Error: no
    identifier for declarator col\n/tmp/tmpgavlu79c.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgavlu79c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                if(res == null)\n                    res\
    \ = Tuple!(long, long)[]();\n                res[res.length-1] = Tuple!(i, j);\n\
    \            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) -> a.first\
    \ > b.first);\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxo48svzb.d(26): Error: no identifier for declarator i\n/tmp/tmpxo48svzb.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpxo48svzb.d(28): Error: no
    identifier for declarator j\n/tmp/tmpxo48svzb.d(28): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmpxo48svzb.d(39): Error: expression expected, not \''>\''\n/tmp/tmpxo48svzb.d(39):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmpxo48svzb.d(42): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxo48svzb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                res[lst[i].length - 1 - j] = (i, j);\n            }\n       \
    \ }\n    }\n    \n    sort(res);\n    sort(res, (a, b) -> a.first > b.first ?\
    \ 1 : -1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb19gl4gd.d(38): Error: expression expected, not \''>\''\n/tmp/tmpb19gl4gd.d(38):
    Error: found \''a\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpb19gl4gd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    for(long i = 0; i < lst.length; i++)\n    {\n        for(long j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                ret.add(new Tuple!(i, j));\n            }\n        }\n\
    \    }\n    \n    ret.sort(function(a, b) -> a.first > b.first);\n    ret.sort(function(a,\
    \ b) -> a.second > b.second);\n    \n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd9_6ctix.d(38): Error: missing { ... } for function literal\n/tmp/tmpd9_6ctix.d(38):
    Error: expression expected, not \''>\''\n/tmp/tmpd9_6ctix.d(38): Error: found
    \''a\'' when expecting \'',\''\n/tmp/tmpd9_6ctix.d(39): Error: missing { ... }
    for function literal\n/tmp/tmpd9_6ctix.d(39): Error: expression expected, not
    \''>\''\n/tmp/tmpd9_6ctix.d(39): Error: found \''a\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9_6ctix.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length]\
    \ = Tuple!(i, j);\n    }), 0..lst.length-1);\n    foreach(i -> foreach(j -> {\n\
    \        if(lst[i][j] > x)\n            res[res.length] = Tuple!(i, j);\n    }),\
    \ 0..lst.length-1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvne8edli.d(26): Error: no identifier for declarator i\n/tmp/tmpvne8edli.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpvne8edli.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmpvne8edli.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpvne8edli.d(26): Error: expression expected, not \''>\''\n/tmp/tmpvne8edli.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpvne8edli.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpvne8edli.d(28): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpvne8edli.d(29):
    Error: Declaration expected, not \'')\''\n/tmp/tmpvne8edli.d(30): Error: Declaration
    expected, not \''foreach\''\n/tmp/tmpvne8edli.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvne8edli.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        Tuple!(long, long)[] row = get_row(lst[i], x);\n        foreach(k\
    \ -> {\n            Tuple!(long, long)[] col = get_row(lst[j], k);\n         \
    \   foreach(l -> {\n                res.push(Tuple!(long, long)((i, j), (k, l)));\n\
    \            });\n        });\n    }));\n    \n    sort(res, (i, j) -> {\n   \
    \     Tuple!(long, long)[] row = get_row(lst[i], x);\n        Tuple!(long, long)[]\
    \ col = get_row(lst[j], x);\n        return row[0] > col[0];\n    });\n    \n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp702enmpw.d(27): Error: no identifier for declarator i\n/tmp/tmp702enmpw.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp702enmpw.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp702enmpw.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp702enmpw.d(27): Error: expression expected, not \''>\''\n/tmp/tmp702enmpw.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp702enmpw.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp702enmpw.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp702enmpw.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp702enmpw.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmp702enmpw.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmp702enmpw.d(29): Error: no identifier
    for declarator k\n/tmp/tmp702enmpw.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmp702enmpw.d(29): Error: expression expected, not \''>\''\n/tmp/tmp702enmpw.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp702enmpw.d(31): Error: no
    identifier for declarator l\n/tmp/tmp702enmpw.d(31): Error: found \''-\'' when
    expecting \'';\''\n/tmp/tmp702enmpw.d(31): Error: expression expected, not \''>\''\n/tmp/tmp702enmpw.d(31):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp702enmpw.d(33): Error: Declaration
    expected, not \'')\''\n/tmp/tmp702enmpw.d(34): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp702enmpw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) {\n            Tuple!(long,\
    \ long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n      \
    \          row.add((i, j));\n            });\n            res.add((i, row));\n\
    \        }\n    }), range(0, lst.length));\n    sort(res, (i, j) -> {\n      \
    \  if (i == 0) return 1;\n        if (j == 0) return -1;\n        return lst[i][j]\
    \ - lst[i - 1][j];\n    });\n    sort(res, (i, j) -> {\n        if (i == 0) return\
    \ -1;\n        if (j == 0) return 1;\n        return lst[i][j] - lst[i - 1][j];\n\
    \    });\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps0515rip.d(26): Error: no identifier for declarator i\n/tmp/tmps0515rip.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmps0515rip.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmps0515rip.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmps0515rip.d(26): Error: expression expected, not \''>\''\n/tmp/tmps0515rip.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmps0515rip.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmps0515rip.d(27): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmps0515rip.d(27): Error: missing
    { ... } for function literal\n/tmp/tmps0515rip.d(27): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmps0515rip.d(27): Error: found \'')\''
    instead of statement\n/tmp/tmps0515rip.d(29): Error: no identifier for declarator
    k\n/tmp/tmps0515rip.d(29): Error: found \''-\'' when expecting \'';\''\n/tmp/tmps0515rip.d(29):
    Error: expression expected, not \''>\''\n/tmp/tmps0515rip.d(29): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmps0515rip.d(31): Error: Declaration expected,
    not \'')\''\n/tmp/tmps0515rip.d(32): Deprecation: C-style function pointer and
    pointer to array syntax is deprecated. Use \''function\'' to declare function
    pointers\n/tmp/tmps0515rip.d(32): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmps0515rip.d(32):
    Error: no identifier for declarator res.add(i, row)\n/tmp/tmps0515rip.d(33): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0515rip.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(i\
    \ : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n       \
    \ {\n            if(lst[i][j] == x)\n            {\n                if(res ==\
    \ null)\n                    res = make_tuple(i, j);\n                else\n \
    \                   res = make_tuple(i, j) + res;\n            }\n        }\n\
    \    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpplc5hri3.d(27): Error: no identifier for declarator i\n/tmp/tmpplc5hri3.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpplc5hri3.d(29): Error: no
    identifier for declarator j\n/tmp/tmpplc5hri3.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpplc5hri3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i] == x)\n   \
    \     {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n \
    \               res.push((i, j));\n            }\n        }\n    }\n    \n   \
    \ sort(res, (a, b) => a.first < b.first ? -1 : a.first > b.first ? 1 : 0);\n \
    \   sort(res, (a, b) => a.second > b.second ? -1 : a.second < b.second ? 1 : 0);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3lky8k58.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n\
    \            if(column == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row), column));\n            }\n        }\n    }\n    \n    result.sort(compareByDescending);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg00_m3q3.d(27): Error: no identifier for declarator row\n/tmp/tmpg00_m3q3.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpg00_m3q3.d(29): Error: no
    identifier for declarator column\n/tmp/tmpg00_m3q3.d(29): Error: found \'':\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg00_m3q3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] == x){\n                ret.add(new Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    sort(ret, (a, b) -> a.first\
    \ > b.first ? 1 : -1);\n    sort(ret, (a, b) -> a.second > b.second ? 1 : -1);\n\
    \    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppimhhpi2.d(35): Error: expression expected, not \''>\''\n/tmp/tmppimhhpi2.d(35):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmppimhhpi2.d(36): Error: expression
    expected, not \''>\''\n/tmp/tmppimhhpi2.d(36): Error: found \''a\'' when expecting
    \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppimhhpi2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n\
    \            if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row), col));\n            }\n        }\n    }\n    \n    sort(res, (row1,\
    \ row2) => row1._1 > row2._1);\n    sort(res, (row1, row2) => row1._2 > row2._2);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp10lw9ai.d(27): Error: no identifier for declarator row\n/tmp/tmpp10lw9ai.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpp10lw9ai.d(29): Error: no
    identifier for declarator col\n/tmp/tmpp10lw9ai.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp10lw9ai.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long,\
    \ long)[] coord = new Tuple!(long, long)[] {i, j};\n            foreach(k -> {\n\
    \                if(lst[i][k] > lst[i][k + 1]) {\n                    Tuple!(long,\
    \ long)[] coord2 = new Tuple!(long, long)[] {i, k};\n                    foreach(l\
    \ -> {\n                        if(lst[k][l] > lst[k + 1][l]) {\n            \
    \                Tuple!(long, long)[] coord3 = new Tuple!(long, long)[] {k, l};\n\
    \                            foreach(m -> {\n                                if(lst[l][m]\
    \ > lst[k][m]) {\n                                    coord = coord.concat(coord2);\n\
    \                                    coord2 = coord3;\n                      \
    \          }\n                            });\n                        }\n   \
    \                 });\n                }\n            });\n            res = res.concat(coord);\n\
    \        }\n    }));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2feuis8k.d(26): Error: no identifier for declarator i\n/tmp/tmp2feuis8k.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp2feuis8k.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmp2feuis8k.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp2feuis8k.d(26): Error: expression expected, not \''>\''\n/tmp/tmp2feuis8k.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp2feuis8k.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp2feuis8k.d(27): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp2feuis8k.d(27): Error: missing
    { ... } for function literal\n/tmp/tmp2feuis8k.d(27): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp2feuis8k.d(27): Error: found \'')\''
    instead of statement\n/tmp/tmp2feuis8k.d(29): Error: Declaration expected, not
    \''foreach\''\n/tmp/tmp2feuis8k.d(32): Error: Declaration expected, not \''foreach\''\n/tmp/tmp2feuis8k.d(35):
    Error: Declaration expected, not \''foreach\''\n/tmp/tmp2feuis8k.d(38): Error:
    no identifier for declarator coord2\n/tmp/tmp2feuis8k.d(38): Error: Declaration
    expected, not \''=\''\n/tmp/tmp2feuis8k.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2feuis8k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(i\
    \ : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n  \
    \          if(lst[i][j] == x)\n            {\n                res = Tuple!(long,\
    \ long)[](Tuple!(i + 1, j), Tuple!(i + 1, j + 1));\n            }\n        }\n\
    \    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzicwqiti.d(27): Error: no identifier for declarator i\n/tmp/tmpzicwqiti.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpzicwqiti.d(29): Error: no
    identifier for declarator j\n/tmp/tmpzicwqiti.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzicwqiti.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n        \
    \    sort(coord);\n            sort(coord, (x, y) -> -y);\n            foreach(k\
    \ -> {\n                res[k.0].add(k.1);\n            });\n        }\n    }),\
    \ range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp86txssoa.d(27): Error: no identifier for declarator i\n/tmp/tmp86txssoa.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp86txssoa.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp86txssoa.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp86txssoa.d(27): Error: expression expected, not \''>\''\n/tmp/tmp86txssoa.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp86txssoa.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp86txssoa.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp86txssoa.d(28): Error: missing
    { ... } for function literal\n/tmp/tmp86txssoa.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp86txssoa.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmp86txssoa.d(30): Error: function declaration without
    return type. (Note that constructors are always named \''this\'')\n/tmp/tmp86txssoa.d(30):
    Error: no identifier for declarator sort(coord)\n/tmp/tmp86txssoa.d(31): Error:
    unexpected ( in declarator\n/tmp/tmp86txssoa.d(31): Error: basic type expected,
    not (\n/tmp/tmp86txssoa.d(31): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmp86txssoa.d(31):
    Error: found \''-\'' when expecting \'')\''\n/tmp/tmp86txssoa.d(31): Error: no
    identifier for declarator sort(coord, int(x, y))\n/tmp/tmp86txssoa.d(31): Error:
    semicolon expected following function declaration\n/tmp/tmp86txssoa.d(31): Error:
    Declaration expected, not \''>\''\n/tmp/tmp86txssoa.d(32): Error: Declaration
    expected, not \''foreach\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp86txssoa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] == x){\n                res[res.length] = Tuple!(i,\
    \ j);\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2hk8o5d8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.push(Tuple!(i, j));\n            }\n        }\n \
    \   }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycion3xr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst, i: int)\n    {\n        foreach(column: row, j: int)\n\
    \        {\n            if(column == x)\n            {\n                result.add((i,\
    \ j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b)\
    \ -> a.0 < b.0 ? -1 : a.0 > b.0 ? 1 : 0);\n    result.sort(function(a, b) -> a.1\
    \ < b.0 ? -1 : a.1 > b.0 ? 1 : 0);\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps22f94rl.d(27): Error: no identifier for declarator row\n/tmp/tmps22f94rl.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmps22f94rl.d(27): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmps22f94rl.d(27): Error: no identifier for
    declarator int\n/tmp/tmps22f94rl.d(27): Error: found \'')\'' instead of statement\n/tmp/tmps22f94rl.d(35):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps22f94rl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n   \
    \     row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        if(lst[i][col[i]] == x)\n        {\n            Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[row.Length];\n            for(int j = 0;\
    \ j < row.Length; j++)\n            {\n                res[j] = (row[j], col[j]);\n\
    \            }\n            return res;\n        }\n    }\n    return new Tuple!(long,\
    \ long)[0];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11vcx2tz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res = Tuple!(long, long)[](row,col);\n            }\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvg5dre_8.d(26): Error: no identifier for declarator lst\n/tmp/tmpvg5dre_8.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpvg5dre_8.d(28): Error: no
    identifier for declarator row\n/tmp/tmpvg5dre_8.d(28): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpvg5dre_8.d(35): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpvg5dre_8.d(38): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpvg5dre_8.d(49):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvg5dre_8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        long row = 0;\n        long col\
    \ = 0;\n        \n        if(lst[i][j] == x) {\n            row = i;\n       \
    \     col = j;\n        }\n        \n        Tuple!(long, long)[] tuple = new\
    \ Tuple!(row, col);\n        \n        result.push(tuple);\n    }), range(0, lst.length));\n\
    \    \n    sort(result, (a, b) => a.first - b.first);\n    sort(result, (a, b)\
    \ => b.second - a.second);\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpca8ng_0c.d(27): Error: no identifier for declarator i\n/tmp/tmpca8ng_0c.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpca8ng_0c.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpca8ng_0c.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpca8ng_0c.d(27): Error: expression expected, not \''>\''\n/tmp/tmpca8ng_0c.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpca8ng_0c.d(28): Error: found
    \''long\'' when expecting \'';\'' following statement\n/tmp/tmpca8ng_0c.d(39):
    Error: Declaration expected, not \'')\''\n/tmp/tmpca8ng_0c.d(41): Error: unexpected
    ( in declarator\n/tmp/tmpca8ng_0c.d(41): Error: basic type expected, not (\n/tmp/tmpca8ng_0c.d(41):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpca8ng_0c.d(41): Error: found \''=>\'' when expecting
    \'')\''\n/tmp/tmpca8ng_0c.d(41): Error: no identifier for declarator sort(result,
    int(a, b))\n/tmp/tmpca8ng_0c.d(41): Error: semicolon expected following function
    declaration\n/tmp/tmpca8ng_0c.d(41): Error: no identifier for declarator a.first\n/tmp/tmpca8ng_0c.d(41):
    Error: Declaration expected, not \''-\''\n/tmp/tmpca8ng_0c.d(42): Error: unexpected
    ( in declarator\n/tmp/tmpca8ng_0c.d(42): Error: basic type expected, not (\n/tmp/tmpca8ng_0c.d(42):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpca8ng_0c.d(42): Error: found \''=>\'' when expecting
    \'')\''\n/tmp/tmpca8ng_0c.d(42): Error: no identifier for declarator sort(result,
    int(a, b))\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpca8ng_0c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n   \
    \         {\n                res[j].x = j;\n                res[j].y = 0;\n  \
    \          }\n            else if(j == 0)\n            {\n                res[j].x\
    \ = i;\n                res[j].y = i;\n            }\n            else\n     \
    \       {\n                if(lst[i][j] == x)\n                {\n           \
    \         res[j].x = i;\n                    res[j].y = j;\n                }\n\
    \            }\n        }), 0);\n    \n    foreach(i -> foreach(j -> \n      \
    \  {\n            if(i == 0)\n            {\n                res[j].x = j;\n \
    \               res[j].y = i;\n            }\n            else if(j == 0)\n  \
    \          {\n                res[j].x = i;\n                res[j].y = j;\n \
    \           }\n            else\n            {\n                if(lst[i][j] >\
    \ lst[i][j + 1])\n                {\n                    res[j].x = i;\n     \
    \               res[j].y = j;\n                }\n            }\n        }), 0);\n\
    \    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n   \
    \         {\n                res[j].x = j;\n                res[j].y = i;\n  \
    \          }\n            else if(j == 0)\n            {\n                res[j].x\
    \ = i;\n                res[j].y = j;\n            }\n            else\n     \
    \       {\n                if(lst[i][j] < lst[i][j + 1])\n                {\n\
    \                    res[j].x = i;\n                    res[j].y = j;\n      \
    \          }\n            }\n        }), 0);\n    \n    foreach(i -> foreach(j\
    \ -> \n        {\n            if(i == 0)\n            {\n                res[j].x\
    \ = j;\n                res[j].y = i;\n            }\n            else if(j ==\
    \ 0)\n            {\n                res[j].x = i;\n                res[j].y =\
    \ j;\n            }\n            else\n            {\n                if(lst[i][j]\
    \ > lst[i][j + 1])\n                {\n                    res[j].x = i;\n   \
    \                 res[j].y = j;\n                }\n            }\n        }),\
    \ 0);\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n\
    \            {\n                res[j].x = j;\n                res[j].y = i;\n\
    \            }\n            else if(j == 0)\n            {\n                res[j].x\
    \ = i;\n                res[j].y = j;\n            }\n            else\n     \
    \       {\n                if(lst[i][j] < lst[i][j + 1])\n                {\n\
    \                    res[j].x = i;\n                    \nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg9kd21f2.d(27): Error: no identifier for declarator i\n/tmp/tmpg9kd21f2.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpg9kd21f2.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpg9kd21f2.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpg9kd21f2.d(27): Error: expression expected, not \''>\''\n/tmp/tmpg9kd21f2.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpg9kd21f2.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpg9kd21f2.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpg9kd21f2.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpg9kd21f2.d(29): Error: found \''0\'' when
    expecting \'';\'' following statement\n/tmp/tmpg9kd21f2.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpg9kd21f2.d(34): Error: Declaration expected, not
    \''else\''\n/tmp/tmpg9kd21f2.d(37): Error: no identifier for declarator res[j]\n/tmp/tmpg9kd21f2.d(37):
    Error: no identifier for declarator .y\n/tmp/tmpg9kd21f2.d(37): Error: Declaration
    expected, not \''=\''\n/tmp/tmpg9kd21f2.d(38): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9kd21f2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ sort(res);\n    sort(res, (a, b) -> -cmp(a.i, b.i));\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppxflj4ru.d(27): Error: no identifier for declarator i\n/tmp/tmppxflj4ru.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmppxflj4ru.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmppxflj4ru.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmppxflj4ru.d(27): Error: expression expected, not \''>\''\n/tmp/tmppxflj4ru.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmppxflj4ru.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmppxflj4ru.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmppxflj4ru.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmppxflj4ru.d(32): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmppxflj4ru.d(32):
    Error: no identifier for declarator sort(res)\n/tmp/tmppxflj4ru.d(33): Error:
    unexpected ( in declarator\n/tmp/tmppxflj4ru.d(33): Error: basic type expected,
    not (\n/tmp/tmppxflj4ru.d(33): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmppxflj4ru.d(33):
    Error: found \''-\'' when expecting \'')\''\n/tmp/tmppxflj4ru.d(33): Error: no
    identifier for declarator sort(res, int(a, b))\n/tmp/tmppxflj4ru.d(33): Error:
    semicolon expected following function declaration\n/tmp/tmppxflj4ru.d(33): Error:
    Declaration expected, not \''>\''\n/tmp/tmppxflj4ru.d(35): Error: Declaration
    expected, not \''return\''\n/tmp/tmppxflj4ru.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppxflj4ru.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i].Length\
    \ > 0)\n        {\n            row[i] = i;\n            col[i] = lst[i].Length\
    \ - 1;\n        }\n        else\n        {\n            row[i] = 0;\n        \
    \    col[i] = 0;\n        }\n    }\n    Array.Sort(row);\n    Array.Sort(col);\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == 0)\n        {\n   \
    \         res[i] = Tuple!(long, long)(0, 0);\n        }\n        else\n      \
    \  {\n            res[i] = Tuple!(long, long)(row[i], col[i]);\n        }\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzss_uau3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(i == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n \
    \   \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n \
    \   \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n \
    \   \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n \
    \   \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i,\
    \ j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjl13189s.d(27): Error: no identifier for declarator i\n/tmp/tmpjl13189s.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpjl13189s.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpjl13189s.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpjl13189s.d(27): Error: expression expected, not \''>\''\n/tmp/tmpjl13189s.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjl13189s.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmpjl13189s.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmpjl13189s.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmpjl13189s.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmpjl13189s.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmpjl13189s.d(29): Error: no identifier
    for declarator k\n/tmp/tmpjl13189s.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmpjl13189s.d(29): Error: expression expected, not \''>\''\n/tmp/tmpjl13189s.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpjl13189s.d(31): Error: Declaration
    expected, not \'')\''\n/tmp/tmpjl13189s.d(32): Error: function declaration without
    return type. (Note that constructors are always named \''this\'')\n/tmp/tmpjl13189s.d(32):
    Error: no identifier for declarator res.add(row)\n/tmp/tmpjl13189s.d(33): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjl13189s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i]\
    \ = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col, (x, y) => Comparer<int>.Default.Compare(x,\
    \ y));\n    Array.Sort(col, row, (x, y) => Comparer<int>.Default.Compare(y, x));\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == x)\n        {\n   \
    \         res[i] = Tuple!(long, long)[i, col[i]];\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a tags=algorithm,c#,sorting,list |>\n<| c |>\nThis doesn't\
    \ seem to work. `get_row([[], [1L], [1L, 2L, 3L]], 3L)` returns `[tuple(2L, 2L)]`\
    \ instead of `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L,\
    \ 0L)]`\n<|/ c |>\n<| c |>\nI tested it and it works fine. `get_row([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)` returns\
    \ `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]`\n\
    <|/ c |>\n<| c |>\nI tested it again and it works fine. `get_row([[1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)` returns\
    \ `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]`\n\
    <|/ c |>\n<| c |>\nI tested it again and it works fine. `get_row([[1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)` returns\
    \ `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), \nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpof0eif7j.d(32): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpof0eif7j.d(32): Error: found \''.\'' when expecting identifier
    following \''int.\''\n/tmp/tmpof0eif7j.d(32): Error: found \''Default\'' when
    expecting \'',\''\n/tmp/tmpof0eif7j.d(33): Error: found \''>\'' when expecting
    \''.\'' following int\n/tmp/tmpof0eif7j.d(33): Error: found \''.\'' when expecting
    identifier following \''int.\''\n/tmp/tmpof0eif7j.d(33): Error: found \''Default\''
    when expecting \'',\''\n/tmp/tmpof0eif7j.d(44): Error: Declaration expected, not
    \''<\''\n/tmp/tmpof0eif7j.d(47): Error: unterminated character constant\n/tmp/tmpof0eif7j.d(56):
    Error: unterminated string constant starting at /tmp/tmpof0eif7j.d(56)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpof0eif7j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(0,\
    \ lst.length));\n    \n    sort(res, (i, j) -> Tuple!(i, j).f0);\n    sort(res,\
    \ (i, j) -> Tuple!(i, j).f1);\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph8rj41m3.d(27): Error: no identifier for declarator i\n/tmp/tmph8rj41m3.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmph8rj41m3.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmph8rj41m3.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmph8rj41m3.d(27): Error: expression expected, not \''>\''\n/tmp/tmph8rj41m3.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmph8rj41m3.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmph8rj41m3.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmph8rj41m3.d(29): Error: missing
    { ... } for function literal\n/tmp/tmph8rj41m3.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmph8rj41m3.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmph8rj41m3.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8rj41m3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[];\n\
    \            tuple[0] = i;\n            tuple[1] = j;\n            res.add(tuple);\n\
    \        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j ->\
    \ \n    {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[]\
    \ tuple = new Tuple!(long, long)[];\n            tuple[0] = i;\n            tuple[1]\
    \ = j;\n            res.add(tuple);\n        }\n    }), range(0, lst[0].length));\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpskl0wror.d(27): Error: no identifier for declarator i\n/tmp/tmpskl0wror.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpskl0wror.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpskl0wror.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpskl0wror.d(27): Error: expression expected, not \''>\''\n/tmp/tmpskl0wror.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpskl0wror.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpskl0wror.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpskl0wror.d(29): Error: missing
    { ... } for function literal\n/tmp/tmpskl0wror.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpskl0wror.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmpskl0wror.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpskl0wror.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i,\
    \ j};\n            sort(coord, (a, b) => a.first > b.first);\n            sort(coord,\
    \ (a, b) => a.second > b.second);\n            foreach(coord -> res.push(coord));\n\
    \        }\n    }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprlumswc9.d(27): Error: no identifier for declarator i\n/tmp/tmprlumswc9.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmprlumswc9.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmprlumswc9.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmprlumswc9.d(27): Error: expression expected, not \''>\''\n/tmp/tmprlumswc9.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmprlumswc9.d(29): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmprlumswc9.d(29): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmprlumswc9.d(29): Error: missing
    { ... } for function literal\n/tmp/tmprlumswc9.d(29): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmprlumswc9.d(29): Error: found \'')\''
    instead of statement\n/tmp/tmprlumswc9.d(32): Error: unexpected ( in declarator\n/tmp/tmprlumswc9.d(32):
    Error: basic type expected, not (\n/tmp/tmprlumswc9.d(32): Error: function declaration
    without return type. (Note that constructors are always named \''this\'')\n/tmp/tmprlumswc9.d(32):
    Error: found \''=>\'' when expecting \'')\''\n/tmp/tmprlumswc9.d(32): Error: no
    identifier for declarator sort(coord, int(a, b))\n/tmp/tmprlumswc9.d(32): Error:
    semicolon expected following function declaration\n/tmp/tmprlumswc9.d(32): Error:
    no identifier for declarator a.first\n/tmp/tmprlumswc9.d(32): Error: Declaration
    expected, not \''>\''\n/tmp/tmprlumswc9.d(33): Error: unexpected ( in declarator\n/tmp/tmprlumswc9.d(33):
    Error: basic type expected, not (\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprlumswc9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row: lst, i: 0, row.length)\n    {\n        foreach(col: row, j:\
    \ 0, row.length)\n        {\n            if(col == x)\n            {\n       \
    \         res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n \
    \   sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1qo5yyv_.d(26): Error: no identifier for declarator row\n/tmp/tmp1qo5yyv_.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp1qo5yyv_.d(26): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmp1qo5yyv_.d(26): Error: found \'')\'' when
    expecting \'';\'' following statement\n/tmp/tmp1qo5yyv_.d(28): Error: no identifier
    for declarator col\n/tmp/tmp1qo5yyv_.d(28): Error: found \'':\'' when expecting
    \'';\''\n/tmp/tmp1qo5yyv_.d(28): Error: found \'':\'' when expecting \'')\''\n/tmp/tmp1qo5yyv_.d(28):
    Error: found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1qo5yyv_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res = Tuple!(long, long)[Tuple!(i,j)];\n\
    \                break;\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxkutf24p.d(27): Error: no identifier for declarator i\n/tmp/tmpxkutf24p.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpxkutf24p.d(29): Error: no
    identifier for declarator j\n/tmp/tmpxkutf24p.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkutf24p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res = append(res, Tuple!(i, j));\n   \
    \         }\n        }\n    }\n    \n    sort(res);\n    sort(res, fun(Tuple!(long,\
    \ long)) -> Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return\
    \ Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long,\
    \ long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool\
    \ {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return \n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn_d6_ezs.d(27): Error: no identifier for declarator i\n/tmp/tmpn_d6_ezs.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpn_d6_ezs.d(29): Error: no
    identifier for declarator j\n/tmp/tmpn_d6_ezs.d(29): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected, not \''>\''\n/tmp/tmpn_d6_ezs.d(39):
    Error: found \''Tuple\'' when expecting \'',\''\n/tmp/tmpn_d6_ezs.d(39): Error:
    found \'',\'' when expecting \''.\'' following long\n/tmp/tmpn_d6_ezs.d(39): Error:
    found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmpn_d6_ezs.d(39):
    Error: expression expected, not \''>\''\n/tmp/tmpn_d6_ezs.d(39): Error: found
    \''bool\'' when expecting \'',\''\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected,
    not \''>\''\n/tmp/tmpn_d6_ezs.d(39): Error: found \''bool\'' when expecting \'';\''
    following return statement\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected,
    not \''>\''\n/tmp/tmpn_d6_ezs.d(39): Error: found \''bool\'' when expecting \'';\''
    following return statement\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected,
    not \''>\''\n/tmp/tmpn_d6_ezs.d(39): Error: found \''bool\'' when expecting \'';\''
    following return statement\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected,
    not \''>\''\n/tmp/tmpn_d6_ezs.d(39): Error: found \''bool\'' when expecting \'';\''
    following return statement\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected,
    not \''>\''\n/tmp/tmpn_d6_ezs.d(39): Error: found \''bool\'' when expecting \'';\''
    following return statement\n/tmp/tmpn_d6_ezs.d(39): Error: expression expected,
    not \''>\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_d6_ezs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        Tuple!(long, long)[] temp;\n        foreach(k -> {\n         \
    \   if(i == k) {\n                temp += Tuple!(long, long)[](Tuple!(x, j), Tuple!(x,\
    \ k));\n            }\n        });\n        res += temp;\n    }), range(0, lst.length));\n\
    \    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9xdlivym.d(27): Error: no identifier for declarator i\n/tmp/tmp9xdlivym.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp9xdlivym.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp9xdlivym.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp9xdlivym.d(27): Error: expression expected, not \''>\''\n/tmp/tmp9xdlivym.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp9xdlivym.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp9xdlivym.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp9xdlivym.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp9xdlivym.d(28):
    Error: found \''temp\'' when expecting \'';\'' following statement\n/tmp/tmp9xdlivym.d(29):
    Error: no identifier for declarator k\n/tmp/tmp9xdlivym.d(29): Error: found \''-\''
    when expecting \'';\''\n/tmp/tmp9xdlivym.d(29): Error: expression expected, not
    \''>\''\n/tmp/tmp9xdlivym.d(29): Error: found \''{\'' when expecting \'')\''\n/tmp/tmp9xdlivym.d(33):
    Error: Declaration expected, not \'')\''\n/tmp/tmp9xdlivym.d(34): Error: no identifier
    for declarator res\n/tmp/tmp9xdlivym.d(34): Error: Declaration expected, not \''+=\''\n/tmp/tmp9xdlivym.d(35):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xdlivym.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row,lst)\
    \ \n    {\n        foreach(col,row)\n        {\n            if(col == x)\n   \
    \         {\n                result ~= Tuple!(row,col);\n            }\n     \
    \   }\n    }\n    \n    sort(result);\n    sort(result, descending);\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpigthwkqh.d(27): Error: no identifier for declarator lst\n/tmp/tmpigthwkqh.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpigthwkqh.d(29): Error: no
    identifier for declarator row\n/tmp/tmpigthwkqh.d(29): Error: found \'')\'' when
    expecting \'';\''\n/tmp/tmpigthwkqh.d(36): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpigthwkqh.d(42): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpigthwkqh.d(53):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpigthwkqh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i].length == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                if(lst[i][j] == x)\n                {\n                    res.push(Tuple!(i,\
    \ j));\n                }\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, (a, b) => b._1 - a._1);\n    sort(res, (a, b) => b._2 - a._2);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19fqryo7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n\
    \            if(col == x) \n            {\n                result.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkxyr801i.d(27): Error: no identifier for declarator row\n/tmp/tmpkxyr801i.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpkxyr801i.d(29): Error: no
    identifier for declarator col\n/tmp/tmpkxyr801i.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkxyr801i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n  \
    \          if(col == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row), col));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppftxcx0p.d(27): Error: no identifier for declarator row\n/tmp/tmppftxcx0p.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmppftxcx0p.d(29): Error: no
    identifier for declarator col\n/tmp/tmppftxcx0p.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppftxcx0p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\
    \ \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzaf969p2.d(26): Error: no identifier for declarator row\n/tmp/tmpzaf969p2.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpzaf969p2.d(28): Error: no
    identifier for declarator col\n/tmp/tmpzaf969p2.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzaf969p2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] == x){\n                res.add((i, j));\n \
    \           }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) -> -cmp(a.first,\
    \ b.first));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjdjhtf9f.d(34): Error: expression expected, not \''>\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjdjhtf9f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n\
    \    {\n        foreach(col: row)\n        {\n            if(col == x)\n     \
    \       {\n                result.push(Tuple!(long, long)((row, col)));\n    \
    \        }\n        }\n    }\n    \n    result.sort(byDescending);\n    foreach(tuple:\
    \ result)\n    {\n        tuple.sort(byDescending);\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw5j44p7p.d(27): Error: no identifier for declarator row\n/tmp/tmpw5j44p7p.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpw5j44p7p.d(29): Error: no
    identifier for declarator col\n/tmp/tmpw5j44p7p.d(29): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmpw5j44p7p.d(39): Error: no identifier for declarator
    tuple\n/tmp/tmpw5j44p7p.d(39): Error: found \'':\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5j44p7p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a,\
    \ b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n \
    \   \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpilhusp92.d(27): Error: no identifier for declarator i\n/tmp/tmpilhusp92.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpilhusp92.d(29): Error: no
    identifier for declarator j\n/tmp/tmpilhusp92.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilhusp92.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n  \
    \          if(col == x)\n            {\n                res.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, (a, b) => a.first > b.first);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqzfz5j6y.d(27): Error: no identifier for declarator row\n/tmp/tmpqzfz5j6y.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpqzfz5j6y.d(29): Error: no
    identifier for declarator col\n/tmp/tmpqzfz5j6y.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqzfz5j6y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] t = (i, j);\n            foreach(k -> {\n         \
    \       if(lst[i][k] > lst[k][j]) {\n                    t = swap(t, (j, k));\n\
    \                }\n            });\n            foreach(k -> {\n            \
    \    if(lst[i][k] < lst[k][j]) {\n                    t = swap(t, (j, k));\n \
    \               }\n            });\n            res.add(t);\n        }\n    }),\
    \ range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmvln1gwg.d(27): Error: no identifier for declarator i\n/tmp/tmpmvln1gwg.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpmvln1gwg.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpmvln1gwg.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpmvln1gwg.d(27): Error: expression expected, not \''>\''\n/tmp/tmpmvln1gwg.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpmvln1gwg.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpmvln1gwg.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpmvln1gwg.d(28): Error: missing
    { ... } for function literal\n/tmp/tmpmvln1gwg.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpmvln1gwg.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmpmvln1gwg.d(30): Error: no identifier for declarator
    k\n/tmp/tmpmvln1gwg.d(30): Error: found \''-\'' when expecting \'';\''\n/tmp/tmpmvln1gwg.d(30):
    Error: expression expected, not \''>\''\n/tmp/tmpmvln1gwg.d(30): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmpmvln1gwg.d(34): Error: Declaration expected,
    not \'')\''\n/tmp/tmpmvln1gwg.d(35): Error: Declaration expected, not \''foreach\''\n/tmp/tmpmvln1gwg.d(38):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmvln1gwg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long i, j, k, r, c;\n    Tuple!(long, long)[] res;\n    \n    res = new();\n\
    \    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n    \
    \        if (lst[i][j] == x) {\n                for (k = i; k < n; k++) {\n  \
    \                  r = lst[k][i];\n                    c = lst[k][i];\n      \
    \              for (; k < n; k++) {\n                        c = lst[k][j];\n\
    \                        if (c < r) {\n                            r = c;\n  \
    \                      }\n                    }\n                    res[res.length]\
    \ = Tuple!(r, j);\n                }\n            }\n        }\n    }\n    \n\
    \    sort(res, fun(x) -> x.1);\n    sort(res, fun(x) -> -x.1);\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp95zf8htz.d(30): Error: basic type expected, not ;\n/tmp/tmp95zf8htz.d(50):
    Error: expression expected, not \''>\''\n/tmp/tmp95zf8htz.d(50): Error: found
    \''x\'' when expecting \'',\''\n/tmp/tmp95zf8htz.d(51): Error: expression expected,
    not \''>\''\n/tmp/tmp95zf8htz.d(51): Error: found \''0.1\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95zf8htz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i].length == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                if(lst[i][j] == x)\n                {\n                    ret.push_back(new\
    \ Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n \
    \   sort(ret.begin(), ret.end(), [](Tuple!(long, long)& a, Tuple!(long, long)&\
    \ b) -> bool \n    {\n        return a.first < b.first;\n    });\n    \n    sort(ret.begin(),\
    \ ret.end(), [](Tuple!(long, long)& a, Tuple!(long, long)& b) -> bool \n    {\n\
    \        return a.second > b.second;\n    });\n    \n    return ret;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2n6tshoz.d(40): Error: expression expected, not \''>\''\n/tmp/tmp2n6tshoz.d(40):
    Error: found \''bool\'' when expecting \'',\''\n/tmp/tmp2n6tshoz.d(45): Error:
    expression expected, not \''>\''\n/tmp/tmp2n6tshoz.d(45): Error: found \''bool\''
    when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2n6tshoz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            res.add(new\
    \ Tuple!(i, j));\n        }\n    }), range(0, lst.length));\n    sort(res);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpetepe074.d(26): Error: no identifier for declarator i\n/tmp/tmpetepe074.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpetepe074.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmpetepe074.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpetepe074.d(26): Error: expression expected, not \''>\''\n/tmp/tmpetepe074.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpetepe074.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpetepe074.d(27): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmpetepe074.d(27): Error: missing
    { ... } for function literal\n/tmp/tmpetepe074.d(27): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmpetepe074.d(27): Error: found \'')\''
    instead of statement\n/tmp/tmpetepe074.d(30): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpetepe074.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n\
    \                if(lst[i][j] == x)\n                {\n                    res.push(Tuple!(i,\
    \ j));\n                }\n            }\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpybfv5_6r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n   \
    \     row[i] = i;\n        col[i] = 0;\n    }\n    \n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        if(lst[i][col[i]] == x)\n        {\n            return\
    \ Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[]\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8evkovd_.d(39): Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error: expression
    expected, not \''}\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp8evkovd_.d(50):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\''
    when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting
    \'')\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp8evkovd_.d(50): Error:
    found \''EOF\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\''
    when expecting \'')\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp8evkovd_.d(50):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\''
    when expecting \'',\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting
    \'')\''\n/tmp/tmp8evkovd_.d(50): Error: found \''EOF\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8evkovd_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n   \
    \         long c = i;\n            if(r == x)\n            {\n               \
    \ row.push((r, c));\n            }\n        });\n        res.push(row);\n    }),\
    \ lst);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row\
    \ = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n\
    \            long c = i;\n            if(r != x)\n            {\n            \
    \    row.push((r, c));\n            }\n        });\n        res.push(row);\n \
    \   }), res);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r\
    \ = j;\n            long c = i;\n            if(c != x)\n            {\n     \
    \           row.push((r, c));\n            }\n        });\n        res.push(row);\n\
    \    }), res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl962xk67.d(27): Error: no identifier for declarator i\n/tmp/tmpl962xk67.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpl962xk67.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpl962xk67.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpl962xk67.d(27): Error: expression expected, not \''>\''\n/tmp/tmpl962xk67.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpl962xk67.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmpl962xk67.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmpl962xk67.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmpl962xk67.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmpl962xk67.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmpl962xk67.d(29): Error: no identifier
    for declarator k\n/tmp/tmpl962xk67.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmpl962xk67.d(29): Error: expression expected, not \''>\''\n/tmp/tmpl962xk67.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpl962xk67.d(36): Error: Declaration
    expected, not \'')\''\n/tmp/tmpl962xk67.d(37): Error: function declaration without
    return type. (Note that constructors are always named \''this\'')\n/tmp/tmpl962xk67.d(37):
    Error: no identifier for declarator res.push(row)\n/tmp/tmpl962xk67.d(38): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl962xk67.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] == x){\n                res.add((i, j));\n \
    \           }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) ->\
    \ a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk7nzvy8q.d(35): Error: expression expected, not \''>\''\n/tmp/tmpk7nzvy8q.d(35):
    Error: found \''a\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpk7nzvy8q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j\
    \ -> {\n        if(lst[i][j] == x)\n        {\n            res = [(i, j)];\n \
    \       }\n    }), range(0, lst.length));\n    \n    sort(res);\n    sort(res,\
    \ (a, b) -> {\n        if(res[a][0] == res[b][0])\n        {\n            return\
    \ res[a][1] > res[b][1] ? 1 : -1;\n        }\n        else\n        {\n      \
    \      return res[a][0] > res[b][0] ? 1 : -1;\n        }\n    });\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6wrpui9z.d(27): Error: no identifier for declarator i\n/tmp/tmp6wrpui9z.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp6wrpui9z.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp6wrpui9z.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp6wrpui9z.d(27): Error: expression expected, not \''>\''\n/tmp/tmp6wrpui9z.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp6wrpui9z.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp6wrpui9z.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp6wrpui9z.d(28): Error: missing
    { ... } for function literal\n/tmp/tmp6wrpui9z.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp6wrpui9z.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmp6wrpui9z.d(32): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wrpui9z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) \n       \
    \     res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n\
    \    sort(res, (i, j) -> {\n        if (i == 0) \n            return 1;\n    \
    \    if (j == 0) \n            return -1;\n        return lst[i][j] - lst[i-1][j];\n\
    \    });\n    \n    sort(res, (i, j) -> {\n        if (i == 0) \n            return\
    \ -1;\n        if (j == 0) \n            return 1;\n        return lst[i][j] -\
    \ lst[i-1][j];\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz_up1rf2.d(27): Error: no identifier for declarator i\n/tmp/tmpz_up1rf2.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpz_up1rf2.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpz_up1rf2.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpz_up1rf2.d(27): Error: expression expected, not \''>\''\n/tmp/tmpz_up1rf2.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpz_up1rf2.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpz_up1rf2.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpz_up1rf2.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpz_up1rf2.d(32): Error: unexpected
    ( in declarator\n/tmp/tmpz_up1rf2.d(32): Error: basic type expected, not (\n/tmp/tmpz_up1rf2.d(32):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpz_up1rf2.d(32): Error: found \''-\'' when expecting
    \'')\''\n/tmp/tmpz_up1rf2.d(32): Error: no identifier for declarator sort(res,
    int(i, j))\n/tmp/tmpz_up1rf2.d(32): Error: semicolon expected following function
    declaration\n/tmp/tmpz_up1rf2.d(32): Error: Declaration expected, not \''>\''\n/tmp/tmpz_up1rf2.d(35):
    Error: Declaration expected, not \''if\''\n/tmp/tmpz_up1rf2.d(37): Error: Declaration
    expected, not \''return\''\n/tmp/tmpz_up1rf2.d(38): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_up1rf2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) \n\
    \    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach(column) \n        {\n            if(row[0] == x && column[0]\
    \ == x) \n            {\n                result.push(Tuple!(long, long)((row[0],\
    \ column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n  \
    \  {\n        foreach\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwm8v22iv.d(27): Error: no identifier for declarator row\n/tmp/tmpwm8v22iv.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpwm8v22iv.d(29): Error: no
    identifier for declarator column\n/tmp/tmpwm8v22iv.d(29): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpwm8v22iv.d(36): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpwm8v22iv.d(38): Error: no identifier for declarator row\n/tmp/tmpwm8v22iv.d(38):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpwm8v22iv.d(40): Error: no
    identifier for declarator column\n/tmp/tmpwm8v22iv.d(40): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpwm8v22iv.d(47): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpwm8v22iv.d(49): Error: no identifier for declarator row\n/tmp/tmpwm8v22iv.d(49):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpwm8v22iv.d(51): Error: no
    identifier for declarator column\n/tmp/tmpwm8v22iv.d(51): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpwm8v22iv.d(58): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpwm8v22iv.d(60): Error: no identifier for declarator row\n/tmp/tmpwm8v22iv.d(60):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpwm8v22iv.d(62): Error: no
    identifier for declarator column\n/tmp/tmpwm8v22iv.d(62): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpwm8v22iv.d(69): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpwm8v22iv.d(71): Error: no identifier for declarator row\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwm8v22iv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     result.add(new Tuple!(i, j));\n            }\n        }\n    }\n    result.sort(0,\
    \ true);\n    result.sort(1, false);\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrpgy64r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n  \
    \  long[][] result = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                result[i][j] = i;\n                result[i][m\
    \ - 1] = j;\n                result[n - 1][j] = i;\n                result[n -\
    \ 1][m - 1] = j;\n            }\n        }\n    }\n    Arrays.sort(result, (a,\
    \ b) -> {\n        if(a[0] == b[0])\n            return a[1] > b[1];\n       \
    \ return a[0] > b[0];\n    });\n    Arrays.sort(result, (a, b) -> {\n        if(a[0]\
    \ == b[0])\n            return a[2] > b[2];\n        return a[0] > b[0];\n   \
    \ });\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1pdgm5w5.d(41): Error: expression expected, not \''>\''\n/tmp/tmp1pdgm5w5.d(41):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmp1pdgm5w5.d(42): Error: expression
    expected, not \''if\''\n/tmp/tmp1pdgm5w5.d(43): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmp1pdgm5w5.d(43): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp1pdgm5w5.d(44): Error: expression expected, not \''return\''\n/tmp/tmp1pdgm5w5.d(44):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmp1pdgm5w5.d(44): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmp1pdgm5w5.d(45): Error: expression expected,
    not \''}\''\n/tmp/tmp1pdgm5w5.d(46): Error: expression expected, not \''>\''\n/tmp/tmp1pdgm5w5.d(46):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmp1pdgm5w5.d(47): Error: expression
    expected, not \''if\''\n/tmp/tmp1pdgm5w5.d(48): Error: found \''return\'' when
    expecting \'',\''\n/tmp/tmp1pdgm5w5.d(48): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp1pdgm5w5.d(49): Error: expression expected, not \''return\''\n/tmp/tmp1pdgm5w5.d(49):
    Error: found \''a\'' when expecting \'',\''\n/tmp/tmp1pdgm5w5.d(49): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmp1pdgm5w5.d(50): Error: expression expected,
    not \''}\''\n/tmp/tmp1pdgm5w5.d(53): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pdgm5w5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res.push(Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvezz5b3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    \n   \
    \ sort(res);\n    sort(res, (a, b) => -cmp(a, b));\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4rh9efj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                ret.add(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    sort(ret);\n    sort(ret, true);\n\
    \    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb_cnopj3.d(27): Error: no identifier for declarator i\n/tmp/tmpb_cnopj3.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpb_cnopj3.d(29): Error: no
    identifier for declarator j\n/tmp/tmpb_cnopj3.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_cnopj3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(i == k) {\n  \
    \              row.push((i, j));\n            }\n        });\n        if(row.contains((x,\
    \ j))) {\n            res.push(row);\n        }\n    }), lst);\n    \n    foreach(i\
    \ -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n\
    \        foreach(k -> {\n            if(i == k) {\n                row.push((i,\
    \ j));\n            }\n        });\n        if(row.contains((x, j))) {\n     \
    \       res.push(row);\n        }\n    }), res);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1lhofw3u.d(27): Error: no identifier for declarator i\n/tmp/tmp1lhofw3u.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp1lhofw3u.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp1lhofw3u.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp1lhofw3u.d(27): Error: expression expected, not \''>\''\n/tmp/tmp1lhofw3u.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp1lhofw3u.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp1lhofw3u.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp1lhofw3u.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp1lhofw3u.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmp1lhofw3u.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmp1lhofw3u.d(29): Error: no identifier
    for declarator k\n/tmp/tmp1lhofw3u.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmp1lhofw3u.d(29): Error: expression expected, not \''>\''\n/tmp/tmp1lhofw3u.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp1lhofw3u.d(33): Error: Declaration
    expected, not \'')\''\n/tmp/tmp1lhofw3u.d(34): Error: Declaration expected, not
    \''if\''\n/tmp/tmp1lhofw3u.d(36): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1lhofw3u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            long rowI = i;\n\
    \            long rowJ = j;\n            long rowK = k;\n            \n      \
    \      long colI = rowI;\n            long colJ = rowJ;\n            long colK\
    \ = rowK;\n            \n            if(colJ == x) {\n                row.add(Tuple!(rowI,\
    \ rowK));\n            }\n            \n            if(colK == x) {\n        \
    \        row.add(Tuple!(rowI, rowJ));\n            }\n            \n         \
    \   if(colI == x) {\n                row.add(Tuple!(rowK, rowJ));\n          \
    \  }\n            \n            if(colJ == x && colK == x) {\n               \
    \ row.add(Tuple!(rowI, rowK));\n            }\n            \n            if(colI\
    \ == x && colJ == x) {\n                row.add(Tuple!(rowI, rowJ));\n       \
    \     }\n            \n            if(colK == x && colI == x) {\n            \
    \    row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colJ\
    \ == x && colK == x && colI == x) {\n                row.add(Tuple!(rowI, rowK));\n\
    \            }\n            \n            if(colI == x && colJ == x && colK ==\
    \ x) {\n                row.add(Tuple!(rowI, rowJ));\n            }\n        \
    \    \n            if(colK == x && colI == x && colJ == x) {\n               \
    \ row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colI\
    \ == x && colJ == x && colK == x && colI == x) {\n                row.add(Tuple!(rowI,\
    \ rowK));\n            }\n            \n            if(colK == x && colI == x\
    \ && colJ == x && colK == x) {\n                row.add(Tuple!(rowK, rowJ));\n\
    \            }\n            \n            if(colI == x && colJ == x && colK ==\
    \ x && colI == x && colJ == x) {\n                row.add(Tuple!(rowI, rowK));\n\
    \            }\n            \n            if(colK == x && colI == x && colJ ==\
    \ x && colK == x && colI == x && colJ == x) {\n                row.add(Tuple!(rowK,\
    \ rowJ));\n            }\n            \n            if(colI == x && colJ == x\
    \ && colK == x && \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3rwj737d.d(27): Error: no identifier for declarator i\n/tmp/tmp3rwj737d.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp3rwj737d.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp3rwj737d.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp3rwj737d.d(27): Error: expression expected, not \''>\''\n/tmp/tmp3rwj737d.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp3rwj737d.d(28): Error: found
    \''Tuple\'' when expecting \'';\'' following statement\n/tmp/tmp3rwj737d.d(28):
    Error: found \'',\'' when expecting \''.\'' following long\n/tmp/tmp3rwj737d.d(28):
    Error: found \''long\'' when expecting identifier following \''long.\''\n/tmp/tmp3rwj737d.d(28):
    Error: found \''row\'' when expecting \'';\'' following statement\n/tmp/tmp3rwj737d.d(28):
    Error: found \''=\'' instead of statement\n/tmp/tmp3rwj737d.d(29): Error: no identifier
    for declarator k\n/tmp/tmp3rwj737d.d(29): Error: found \''-\'' when expecting
    \'';\''\n/tmp/tmp3rwj737d.d(29): Error: expression expected, not \''>\''\n/tmp/tmp3rwj737d.d(29):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp3rwj737d.d(91): Error: expression
    expected, not \''unittest\''\n/tmp/tmp3rwj737d.d(92): Error: found \''{\'' when
    expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rwj737d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    for(int i = 0; i\
    \ < lst.length; i++){\n        if(lst[i] == x)\n            return Tuple!(long,\
    \ long)[](Tuple!(0, i));\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2z8_o60c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    \n    if(res == null)\
    \ \n    {\n        foreach(row::lst) \n        {\n            foreach(col::row)\
    \ \n            {\n                if(col != x) \n                {\n        \
    \            res = Tuple!(long, long)[](row, col);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjsw3y98_.d(26): Error: no identifier for declarator row\n/tmp/tmpjsw3y98_.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpjsw3y98_.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmpjsw3y98_.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmpjsw3y98_.d(26): Error: found \'')\'' instead of statement\n/tmp/tmpjsw3y98_.d(35):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjsw3y98_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \      }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7zk2z0f5.d(26): Error: no identifier for declarator row\n/tmp/tmp7zk2z0f5.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp7zk2z0f5.d(26): Error: expression
    expected, not \'':\''\n/tmp/tmp7zk2z0f5.d(26): Error: found \''lst\'' when expecting
    \'')\''\n/tmp/tmp7zk2z0f5.d(26): Error: found \'')\'' instead of statement\n/tmp/tmp7zk2z0f5.d(34):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zk2z0f5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) \n\
    \    {\n        foreach(column) \n        {\n            if(column == x) \n  \
    \          {\n                result.push(Tuple!(long, long)((row), column));\n\
    \            }\n        }\n    }\n    \n    sort(result);\n    sort(result, 1,\
    \ descending);\n    return result;\n}\n/*\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi15uelf6.d(27): Error: no identifier for declarator row\n/tmp/tmpi15uelf6.d(27):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpi15uelf6.d(29): Error: no
    identifier for declarator column\n/tmp/tmpi15uelf6.d(29): Error: found \'')\''
    when expecting \'';\''\n/tmp/tmpi15uelf6.d(36): Error: found \''}\'' when expecting
    \'')\''\n/tmp/tmpi15uelf6.d(42): Error: unterminated /* */ comment\n/tmp/tmpi15uelf6.d(54):
    Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpi15uelf6.d(54): Error:
    found \''EOF\'' instead of statement\n/tmp/tmpi15uelf6.d(54): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpi15uelf6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.push((i, j));\n            }\n        }\n    }\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2lftl1z4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i : 0..lst.length - 1, j : 0..lst[i].length - 1)\n    {\n       \
    \ if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long,\
    \ long)[];\n            foreach(j : 0..lst[i].length - 1)\n            {\n   \
    \             row.push(Tuple!(long, long)[i, j]);\n            }\n           \
    \ res.push(row);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmply5vgdba.d(26): Error: no identifier for declarator i\n/tmp/tmply5vgdba.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmply5vgdba.d(26): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmply5vgdba.d(26): Error: found \''..\''
    when expecting \'';\'' following statement\n/tmp/tmply5vgdba.d(26): Error: found
    \'')\'' when expecting \'';\'' following statement\n/tmp/tmply5vgdba.d(31): Error:
    no identifier for declarator j\n/tmp/tmply5vgdba.d(31): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmply5vgdba.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] t = new Tuple!(long, long)[]; \n            t[0] =\
    \ i; \n            t[1] = j; \n            res.add(t);\n        }\n    }), range(0,\
    \ lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_dev59tq.d(27): Error: no identifier for declarator i\n/tmp/tmp_dev59tq.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp_dev59tq.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmp_dev59tq.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp_dev59tq.d(27): Error: expression expected, not \''>\''\n/tmp/tmp_dev59tq.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp_dev59tq.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp_dev59tq.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmp_dev59tq.d(28): Error: missing
    { ... } for function literal\n/tmp/tmp_dev59tq.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmp_dev59tq.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmp_dev59tq.d(34): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_dev59tq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n      \
    \      if(col == x) \n            {\n                res.push(Tuple!(long, long)((row,\
    \ col)));\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a,\
    \ b) => a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj6a5pkrn.d(26): Error: no identifier for declarator row\n/tmp/tmpj6a5pkrn.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpj6a5pkrn.d(28): Error: no
    identifier for declarator col\n/tmp/tmpj6a5pkrn.d(28): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6a5pkrn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k\
    \ -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n\
    \                }\n            });\n            res.add(row);\n        }\n  \
    \  }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n       \
    \ if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long,\
    \ long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n\
    \                    row.add(k);\n                }\n            });\n       \
    \     res.add(row);\n        }\n    }), range(0, lst[0].length));\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps3ei18ix.d(27): Error: no identifier for declarator i\n/tmp/tmps3ei18ix.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmps3ei18ix.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmps3ei18ix.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmps3ei18ix.d(27): Error: expression expected, not \''>\''\n/tmp/tmps3ei18ix.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmps3ei18ix.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmps3ei18ix.d(28): Error:
    found \''==\'' when expecting \'')\''\n/tmp/tmps3ei18ix.d(28): Error: missing
    { ... } for function literal\n/tmp/tmps3ei18ix.d(28): Error: found \''x\'' when
    expecting \'';\'' following statement\n/tmp/tmps3ei18ix.d(28): Error: found \'')\''
    instead of statement\n/tmp/tmps3ei18ix.d(30): Error: no identifier for declarator
    k\n/tmp/tmps3ei18ix.d(30): Error: found \''-\'' when expecting \'';\''\n/tmp/tmps3ei18ix.d(30):
    Error: expression expected, not \''>\''\n/tmp/tmps3ei18ix.d(30): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmps3ei18ix.d(34): Error: Declaration expected,
    not \'')\''\n/tmp/tmps3ei18ix.d(35): Error: function declaration without return
    type. (Note that constructors are always named \''this\'')\n/tmp/tmps3ei18ix.d(35):
    Error: no identifier for declarator res.add(row)\n/tmp/tmps3ei18ix.d(36): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3ei18ix.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) \n            res[res.length]\
    \ = Tuple!(i, j);\n    }), range(0, lst.length));\n    sort(res, (a, b) => a.first\
    \ < b.first ? 1 : a.first == b.first ? 0 : -1);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcm7wvr7v.d(26): Error: no identifier for declarator i\n/tmp/tmpcm7wvr7v.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpcm7wvr7v.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmpcm7wvr7v.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpcm7wvr7v.d(26): Error: expression expected, not \''>\''\n/tmp/tmpcm7wvr7v.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpcm7wvr7v.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpcm7wvr7v.d(28): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpcm7wvr7v.d(29):
    Error: Declaration expected, not \'')\''\n/tmp/tmpcm7wvr7v.d(30): Error: unexpected
    ( in declarator\n/tmp/tmpcm7wvr7v.d(30): Error: basic type expected, not (\n/tmp/tmpcm7wvr7v.d(30):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpcm7wvr7v.d(30): Error: found \''=>\'' when expecting
    \'')\''\n/tmp/tmpcm7wvr7v.d(30): Error: no identifier for declarator sort(res,
    int(a, b))\n/tmp/tmpcm7wvr7v.d(30): Error: semicolon expected following function
    declaration\n/tmp/tmpcm7wvr7v.d(30): Error: no identifier for declarator a.first\n/tmp/tmpcm7wvr7v.d(30):
    Error: Declaration expected, not \''<\''\n/tmp/tmpcm7wvr7v.d(31): Error: Declaration
    expected, not \''return\''\n/tmp/tmpcm7wvr7v.d(32): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm7wvr7v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n  \
    \  sort(res, (a, b) -> {\n        if(a.first < b.first)\n            return -1;\n\
    \        if(a.first > b.first)\n            return 1;\n        return 0;\n   \
    \ });\n    \n    sort(res, (a, b) -> {\n        if(a.second < b.second)\n    \
    \        return -1;\n        if(a.second > b.second)\n            return 1;\n\
    \        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzsk_l04i.d(27): Error: no identifier for declarator i\n/tmp/tmpzsk_l04i.d(27):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmpzsk_l04i.d(27): Error: expression
    expected, not \''>\''\n/tmp/tmpzsk_l04i.d(27): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmpzsk_l04i.d(27): Error: expression expected, not \''>\''\n/tmp/tmpzsk_l04i.d(27):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpzsk_l04i.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpzsk_l04i.d(29): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmpzsk_l04i.d(30):
    Error: Declaration expected, not \'')\''\n/tmp/tmpzsk_l04i.d(32): Error: unexpected
    ( in declarator\n/tmp/tmpzsk_l04i.d(32): Error: basic type expected, not (\n/tmp/tmpzsk_l04i.d(32):
    Error: function declaration without return type. (Note that constructors are always
    named \''this\'')\n/tmp/tmpzsk_l04i.d(32): Error: found \''-\'' when expecting
    \'')\''\n/tmp/tmpzsk_l04i.d(32): Error: no identifier for declarator sort(res,
    int(a, b))\n/tmp/tmpzsk_l04i.d(32): Error: semicolon expected following function
    declaration\n/tmp/tmpzsk_l04i.d(32): Error: Declaration expected, not \''>\''\n/tmp/tmpzsk_l04i.d(35):
    Error: Declaration expected, not \''if\''\n/tmp/tmpzsk_l04i.d(37): Error: Declaration
    expected, not \''return\''\n/tmp/tmpzsk_l04i.d(38): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzsk_l04i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] ==\
    \ x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n        \
    \    {\n                result.add((i, j));\n            }\n        }\n    }\n\
    \    \n    result.sort(function(a, b) -> a.first > b.first);\n    result.sort(function(a,\
    \ b) -> a.second > b.second);\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzh9iduah.d(38): Error: missing { ... } for function literal\n/tmp/tmpzh9iduah.d(38):
    Error: expression expected, not \''>\''\n/tmp/tmpzh9iduah.d(38): Error: found
    \''a\'' when expecting \'',\''\n/tmp/tmpzh9iduah.d(39): Error: missing { ... }
    for function literal\n/tmp/tmpzh9iduah.d(39): Error: expression expected, not
    \''>\''\n/tmp/tmpzh9iduah.d(39): Error: found \''a\'' when expecting \'',\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzh9iduah.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res.push(Tuple!(i, j));\n            }\n        }\n \
    \   }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycion3xr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdib5bdn7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(row: lst, i: int) \n    {\n        foreach(col: row, j: int) \n \
    \       {\n            if(col == x) \n            {\n                res.push(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx4jow2vh.d(26): Error: no identifier for declarator row\n/tmp/tmpx4jow2vh.d(26):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpx4jow2vh.d(26): Error: found
    \'':\'' when expecting \'')\''\n/tmp/tmpx4jow2vh.d(26): Error: no identifier for
    declarator int\n/tmp/tmpx4jow2vh.d(26): Error: found \'')\'' instead of statement\n/tmp/tmpx4jow2vh.d(34):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx4jow2vh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst){\n\
    \        if(row.length == x){\n            res = row;\n            break;\n  \
    \      }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphf2c94d4.d(26): Error: no identifier for declarator lst\n/tmp/tmphf2c94d4.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmphf2c94d4.d(32): Error: found
    \''return\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmphf2c94d4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n\
    \            if(col == x) \n            {\n                result.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkxyr801i.d(27): Error: no identifier for declarator row\n/tmp/tmpkxyr801i.d(27):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpkxyr801i.d(29): Error: no
    identifier for declarator col\n/tmp/tmpkxyr801i.d(29): Error: found \'':\'' when
    expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkxyr801i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length]\
    \ = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    sort(res);\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_pwxouro.d(26): Error: no identifier for declarator i\n/tmp/tmp_pwxouro.d(26):
    Error: found \''-\'' when expecting \'';\''\n/tmp/tmp_pwxouro.d(26): Error: expression
    expected, not \''>\''\n/tmp/tmp_pwxouro.d(26): Error: found \''foreach\'' when
    expecting \'')\''\n/tmp/tmp_pwxouro.d(26): Error: expression expected, not \''>\''\n/tmp/tmp_pwxouro.d(26):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp_pwxouro.d(27): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmp_pwxouro.d(28): Error:
    found \''res\'' when expecting \'';\'' following statement\n/tmp/tmp_pwxouro.d(29):
    Error: Declaration expected, not \'')\''\n/tmp/tmp_pwxouro.d(30): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmp_pwxouro.d(30):
    Error: no identifier for declarator sort(res)\n/tmp/tmp_pwxouro.d(31): Error:
    Declaration expected, not \''return\''\n/tmp/tmp_pwxouro.d(32): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_pwxouro.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659804063
