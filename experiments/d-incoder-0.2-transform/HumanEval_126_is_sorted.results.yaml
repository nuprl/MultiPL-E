language: d
name: HumanEval_126_is_sorted
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    bool result =\
    \ true;\n    foreach(long x, lst)\n    {\n        if(prev > x)\n        {\n  \
    \          result = false;\n            break;\n        }\n        prev = x;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu332qamg.d(32): Error: no identifier for declarator `lst`\n/tmp/tmpu332qamg.d(32):
    Error: found `)` when expecting `;`\n/tmp/tmpu332qamg.d(41): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu332qamg.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = 0;\n    bool sorted =\
    \ false;\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i] !=\
    \ last)\n        {\n            last = lst[i];\n            sorted = true;\n \
    \       }\n    }\n    return sorted;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm\
    \ |>\n<| c |>\nThis is not an efficient solution. Sorting algorithms usually have\
    \ O(nlogn) complexity, where n is the number of elements in the list. Your solution\
    \ has O(n^2) complexity. Also, your solution does not take into account the fact\
    \ that there may be duplicates in the list.\n<|/ c |>\n<| c |>\nI agree with you\
    \ that this is an inefficient solution, but I believe that it is still the best\
    \ solution for most practical purposes. I believe that it is also the best solution\
    \ for most practical purposes. I believe that it is also the best solution for\
    \ most practical purposes. I believe that it is also the best solution for most\
    \ practical purposes. I believe that it is also the best solution for most practical\
    \ purposes. I believe that it is also the best solution for most practical purposes.\
    \ I believe that it is also the best solution for most practical purposes. I believe\
    \ that it is also the best solution for most practical purposes. I believe that\
    \ it is also the best solution for most practical purposes. I believe that it\
    \ is also the best solution for most practical purposes. I believe that it is\
    \ also the best solution for most practical purposes. I believe that it is also\
    \ the best solution for most practical purposes. I believe that it is also the\
    \ best solution for most practical purposes. I believe that it is also the best\
    \ solution for most practical purposes. I believe that it is also the best solution\
    \ for most practical purposes. I believe that it is also the best solution for\
    \ most practical purposes. I believe that it is also the best solution for most\
    \ practical purposes. I believe that it is also the best solution for most practical\
    \ purposes. I believe that it is also the best solution for most practical purposes.\
    \ I believe that it is also the best solution for most practical purposes. I believe\
    \ that it is also the best solution for most practical purposes. I believe that\
    \ it is also the best solution for most practical purposes. I believe that it\
    \ is also the best solution for most practical purposes. I believe that it is\
    \ also the best solution for most practical purposes. I believe that it is \n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgbgk622t.d(42): Error: declaration expected, not `<`\n/tmp/tmpgbgk622t.d(53):
    Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(54): Error: declaration
    expected, not `assert`\n/tmp/tmpgbgk622t.d(55): Error: declaration expected, not
    `assert`\n/tmp/tmpgbgk622t.d(56): Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmpgbgk622t.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmpgbgk622t.d(60): Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmpgbgk622t.d(63): Error: declaration expected, not
    `assert`\n/tmp/tmpgbgk622t.d(64): Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(65):
    Error: declaration expected, not `assert`\n/tmp/tmpgbgk622t.d(66): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgbgk622t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    bool sorted\
    \ = false;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ < last)\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        else\n        {\n            last = lst[i];\n        }\n    }\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3h96ba7c.d(32): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3h96ba7c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    long curr = lst[0];\n\
    \    bool result = true;\n    for(int i = 1; i < lst.size(); i++)\n    {\n   \
    \     if(curr > lst[i])\n        {\n            result = false;\n            break;\n\
    \        }\n        else if(curr == prev)\n        {\n            result = false;\n\
    \            break;\n        }\n        prev = curr;\n        curr = lst[i];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,sorting,algorithm\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpim1vo3j7.d(50): Error: declaration expected, not `<`\n/tmp/tmpim1vo3j7.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpim1vo3j7.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpim1vo3j7.d(61): Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpim1vo3j7.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmpim1vo3j7.d(65): Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(67): Error: declaration
    expected, not `assert`\n/tmp/tmpim1vo3j7.d(68): Error: declaration expected, not
    `assert`\n/tmp/tmpim1vo3j7.d(69): Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(70):
    Error: declaration expected, not `assert`\n/tmp/tmpim1vo3j7.d(71): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpim1vo3j7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    bool sorted\
    \ = false;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ < last)\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        last = lst[i];\n    }\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpckd1lko9.d(32): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckd1lko9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    bool sorted\
    \ = false;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ < last)\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        last = lst[i];\n    }\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpckd1lko9.d(32): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckd1lko9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    long curr = lst[0];\n\
    \    bool result = true;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n   \
    \     if(curr > lst[i])\n        {\n            result = false;\n            break;\n\
    \        }\n        else if(curr == prev)\n        {\n            result = false;\n\
    \            break;\n        }\n        prev = curr;\n        curr = lst[i];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwna7dzg.d(33): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwna7dzg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    bool sorted =\
    \ false;\n    foreach(long x, lst)\n    {\n        if (prev > x)\n        {\n\
    \            sorted = true;\n            break;\n        }\n        prev = x;\n\
    \    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwi1kcy4_.d(32): Error: no identifier for declarator `lst`\n/tmp/tmpwi1kcy4_.d(32):
    Error: found `)` when expecting `;`\n/tmp/tmpwi1kcy4_.d(41): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwi1kcy4_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    bool sorted\
    \ = false;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ < last)\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        last = lst[i];\n    }\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpckd1lko9.d(32): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckd1lko9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int i, j, k;\n    bool sorted = true;\n\
    \    \n    for(i = 0; i < lst.size(); ++i)\n    {\n        for(j = i + 1; j <\
    \ lst.size(); ++j)\n        {\n            if(lst[i] > lst[j])\n            {\n\
    \                sorted = false;\n                break;\n            }\n    \
    \    }\n        if(!sorted)\n        {\n            break;\n        }\n    }\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4iftbllj.d(33): Error: no property `size` for type `long[]`\n/tmp/tmp4iftbllj.d(35):
    Error: no property `size` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4iftbllj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    bool sorted =\
    \ false;\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i] <\
    \ prev)\n        {\n            sorted = false;\n            break;\n        }\n\
    \        prev = lst[i];\n    }\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9p2yhkh9.d(32): Error: no property `Length` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9p2yhkh9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    bool sorted\
    \ = false;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ < last)\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        last = lst[i];\n    }\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpckd1lko9.d(32): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckd1lko9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    long curr = lst[0];\n\
    \    bool result = true;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n   \
    \     if(curr > lst[i])\n        {\n            result = false;\n            break;\n\
    \        }\n        else if(curr == prev)\n        {\n            result = false;\n\
    \            break;\n        }\n        prev = curr;\n        curr = lst[i];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=sorting,c++ |>\n<| c |>\nThis\
    \ doesn't work if the array is sorted in reverse order. For example, `is_sorted([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L])` returns `true` instead of `false`.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work because you assume that `lst[0]` is the first element in\
    \ the array. That's not always the case. For example, `is_sorted([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L])` returns `true` instead of `false`.\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I've updated my answer to fix this issue.\n<|/ c |>\n<| c |>\n\
    This doesn't work if the array is sorted in reverse order. For example, `is_sorted([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L])` returns `true` instead of `false`.\n<|/ c |>\n<| c\
    \ |>\nI see what you mean. I've updated my answer to fix this issue.\n<|/ c |>\n\
    <| a tags=sorting,c++ |>\n<code>\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9hviaa7_.d(50): Error: declaration expected, not `<`\n/tmp/tmp9hviaa7_.d(53):
    Error: unterminated character constant\n/tmp/tmp9hviaa7_.d(56): Error: unterminated
    character constant\n/tmp/tmp9hviaa7_.d(56): Error: unterminated character constant\n/tmp/tmp9hviaa7_.d(59):
    Error: unterminated character constant\n/tmp/tmp9hviaa7_.d(62): Error: unterminated
    character constant\n/tmp/tmp9hviaa7_.d(65): Error: unterminated character constant\n/tmp/tmp9hviaa7_.d(73):
    Error: declaration expected, not `assert`\n/tmp/tmp9hviaa7_.d(74): Error: declaration
    expected, not `assert`\n/tmp/tmp9hviaa7_.d(75): Error: declaration expected, not
    `assert`\n/tmp/tmp9hviaa7_.d(76): Error: declaration expected, not `assert`\n/tmp/tmp9hviaa7_.d(77):
    Error: declaration expected, not `assert`\n/tmp/tmp9hviaa7_.d(78): Error: declaration
    expected, not `assert`\n/tmp/tmp9hviaa7_.d(79): Error: declaration expected, not
    `assert`\n/tmp/tmp9hviaa7_.d(80): Error: declaration expected, not `assert`\n/tmp/tmp9hviaa7_.d(81):
    Error: declaration expected, not `assert`\n/tmp/tmp9hviaa7_.d(82): Error: declaration
    expected, not `assert`\n/tmp/tmp9hviaa7_.d(83): Error: declaration expected, not
    `assert`\n/tmp/tmp9hviaa7_.d(84): Error: declaration expected, not `assert`\n/tmp/tmp9hviaa7_.d(85):
    Error: declaration expected, not `assert`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp9hviaa7_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    bool sorted\
    \ = false;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ < last)\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        else\n        {\n            sorted = true;\n        }\n       \
    \ last = lst[i];\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpec6y755u.d(32): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpec6y755u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    long curr = lst[0];\n\
    \    bool sorted = false;\n    for(int i = 1; i < lst.size(); i++)\n    {\n  \
    \      if(curr > lst[i])\n        {\n            sorted = true;\n            break;\n\
    \        }\n        else if(curr == lst[i])\n        {\n            prev = lst[i];\n\
    \        }\n        else\n        {\n            if(prev > curr)\n           \
    \ {\n                sorted = true;\n                break;\n            }\n \
    \           else\n            {\n                sorted = false;\n           \
    \ }\n        }\n    }\n    return sorted;\n}\n</code>\n<|/ a tags=sorting,c++\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the list.\n<|/ c |>\n\
    <| c |>\n: It does work if there are duplicates in the list. Try it yourself.\n\
    <|/ c |>\n<| c |>\n: It does work if there are duplicates in the list. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\n: It does work if there are duplicates in the\
    \ list. Try it yourself.\n<|/ c |>\n<| c |>\n: It does work if there are duplicates\
    \ in the list. Try it yourself.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include\
    \ <iostream>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9dawa8v.d(59): Error: declaration expected, not `<`\n/tmp/tmpe9dawa8v.d(62):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpe9dawa8v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    long curr = lst[0];\n\
    \    bool result = true;\n    for(int i = 1; i < lst.size(); i++){\n        if(curr\
    \ > lst[i]){\n            result = false;\n            break;\n        }\n   \
    \     else if(curr == prev){\n            result = false;\n            break;\n\
    \        }\n        prev = curr;\n        curr = lst[i];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi73s6hvw.d(33): Error: no property `size` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi73s6hvw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    bool result =\
    \ true;\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i] !=\
    \ prev)\n        {\n            result = false;\n            break;\n        }\n\
    \        prev = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd7s5j7ca.d(32): Error: no property `Length` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd7s5j7ca.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = 0;\n    bool result =\
    \ true;\n    foreach(long x, lst) {\n        if (prev > x) {\n            result\
    \ = false;\n            break;\n        }\n        prev = x;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk8umr6fo.d(32): Error: no identifier for declarator `lst`\n/tmp/tmpk8umr6fo.d(32):
    Error: found `)` when expecting `;`\n/tmp/tmpk8umr6fo.d(39): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk8umr6fo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last;\n    bool result = true;\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        last = lst[i];\n    \
    \    for(int j = i + 1; j < lst.Length; j++)\n        {\n            if(lst[j]\
    \ < last)\n            {\n                result = false;\n                break;\n\
    \            }\n        }\n        if(!result)\n            break;\n    }\n  \
    \  return result;\n}\n</code>\n<|/ a tags=sorting,c#,arrays |>\n<| a tags=sorting,c#,arrays\
    \ |>\n<code>\npublic static bool IsSorted(int[] array)\n{\n    if (array.Length\
    \ < 2)\n        return true;\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwyk9yhkm.d(48): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwyk9yhkm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given a list of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If list has more\
    \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
    \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n   \
    \ >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int n = lst.Length;\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        long curr = lst[i];\n        for(int j = i\
    \ + 1; j < n; j++)\n        {\n            if(curr > lst[j])\n               \
    \ return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm\
    \ |>\n<| c |>\nThis is not the most efficient solution. Sorting algorithms are\
    \ O(n log n), so this algorithm is O(n^2). Also, your solution doesn't take into\
    \ account that two numbers can be the same.\n<|/ c |>\n<| c |>\n: I agree with\
    \ you. My solution was a quick and dirty solution to solve the problem at hand.\
    \ I'm sure there are better solutions than mine. I'll try to improve my answer\
    \ as soon as I can.\n<|/ c |>\n<| c |>\n: I added a more efficient solution that\
    \ doesn't require sorting.\n<|/ c |>\n<| c |>\n: I added a more efficient solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| c |>\n: I added a more efficient\
    \ solution that doesn't require sorting.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm3ykv1ei.d(42): Error: declaration expected, not `<`\n/tmp/tmpm3ykv1ei.d(45):
    Error: unterminated character constant\n/tmp/tmpm3ykv1ei.d(48): Error: unterminated
    character constant\n/tmp/tmpm3ykv1ei.d(48): Error: unterminated character constant\n/tmp/tmpm3ykv1ei.d(51):
    Error: unterminated character constant\n/tmp/tmpm3ykv1ei.d(54): Error: unterminated
    character constant\n/tmp/tmpm3ykv1ei.d(57): Error: unterminated character constant\n/tmp/tmpm3ykv1ei.d(65):
    Error: declaration expected, not `assert`\n/tmp/tmpm3ykv1ei.d(66): Error: declaration
    expected, not `assert`\n/tmp/tmpm3ykv1ei.d(67): Error: declaration expected, not
    `assert`\n/tmp/tmpm3ykv1ei.d(68): Error: declaration expected, not `assert`\n/tmp/tmpm3ykv1ei.d(69):
    Error: declaration expected, not `assert`\n/tmp/tmpm3ykv1ei.d(70): Error: declaration
    expected, not `assert`\n/tmp/tmpm3ykv1ei.d(71): Error: declaration expected, not
    `assert`\n/tmp/tmpm3ykv1ei.d(72): Error: declaration expected, not `assert`\n/tmp/tmpm3ykv1ei.d(73):
    Error: declaration expected, not `assert`\n/tmp/tmpm3ykv1ei.d(74): Error: declaration
    expected, not `assert`\n/tmp/tmpm3ykv1ei.d(75): Error: declaration expected, not
    `assert`\n/tmp/tmpm3ykv1ei.d(76): Error: declaration expected, not `assert`\n/tmp/tmpm3ykv1ei.d(77):
    Error: declaration expected, not `assert`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpm3ykv1ei.d", "-I/tmp"]\n'''
  stdout: b''
