language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long max_level = 0;\n    long level = 0;\n\
    \    long levels_of_nesting = 0;\n    long current_level = 0;\n    long current_level_of_nesting\
    \ = 0;\n    long current_level_of_nesting_count = 0;\n    bool is_first_group\
    \ = true;\n    bool is_last_group = true;\n    bool is_first_group_of_current_level\
    \ = true;\n    bool is_last_group_of_current_level = true;\n    bool is_first_group_of_current_level_of_nesting\
    \ = true;\n    bool is_last_group_of_current_level_of_nesting = true;\n    bool\
    \ is_first_group_of_current_level_of_nesting_count = true;\n    bool is_last_group_of_current_level_of_nesting_count\
    \ = true;\n    bool is_first_group_of_current_level_of_nesting_count_plus_one\
    \ = true;\n    bool is_last_group_of_current_level_of_nesting_count_plus_one =\
    \ true;\n    bool is_first_group_of_current_level_of_nesting_count_plus_two =\
    \ true;\n    bool is_last_group_of_current_level_of_nesting_count_plus_two = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_three = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_three = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_four = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_four = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_five = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_five = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_six = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_six = true;\n \
    \   bool is_first_group_of_current_level_of_nesting_count_plus_seven = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_seven = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_eight = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_eight = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_nine = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_nine = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_ten = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_ten = true;\n \
    \   bool is_first_group_of_current_level_of_nesting_count_plus_eleven = true;\n\
    \    bool is_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfbyh6ok8.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpfbyh6ok8.d(52):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfbyh6ok8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_or_closing = false;\n\
    \    bool is_opening_or_closing_or_opening = false;\n    bool is_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening =\
    \ false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4b_dksle.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp4b_dksle.d(33): Error: semicolon expected,
    not `unittest`\n/tmp/tmp4b_dksle.d(33): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4b_dksle.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_index = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_clo\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppg2va0my.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmppg2va0my.d(66): Error:
    semicolon expected, not `unittest`\n/tmp/tmppg2va0my.d(66): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppg2va0my.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   long paren_levels[] = new long[paren_string.length()];\n    long paren_level_index\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index = 0;\n \
    \   long paren_level_max_index2 = 0;\n    long paren_level_max_index3 = 0;\n \
    \   long paren_level_max_index4 = 0;\n    long paren_level_max_index5 = 0;\n \
    \   long paren_level_max_index6 = 0;\n    long paren_level_max_index7 = 0;\n \
    \   long paren_level_max_index8 = 0;\n    long paren_level_max_index9 = 0;\n \
    \   long paren_level_max_index10 = 0;\n    long paren_level_max_index11 = 0;\n\
    \    long paren_level_max_index12 = 0;\n    long paren_level_max_index13 = 0;\n\
    \    long paren_level_max_index14 = 0;\n    long paren_level_max_index15 = 0;\n\
    \    long paren_level_max_index16 = 0;\n    long paren_level_max_index17 = 0;\n\
    \    long paren_level_max_index18 = 0;\n    long paren_level_max_index19 = 0;\n\
    \    long paren_level_max_index20 = 0;\n    long paren_level_max_index21 = 0;\n\
    \    long paren_level_max_index22 = 0;\n    long paren_level_max_index23 = 0;\n\
    \    long paren_level_max_index24 = 0;\n    long paren_level_max_index25 = 0;\n\
    \    long paren_level_max_index26 = 0;\n    long paren_level_max_index27 = 0;\n\
    \    long paren_level_max_index28 = 0;\n    long paren_level_max_index29 = 0;\n\
    \    long paren_level_max_index30 = 0;\n    long paren_level_max_index31 = 0;\n\
    \    long paren_level_max_index32 = 0;\n    long paren_level_max_index33 = 0;\n\
    \    long paren_level_max_index34 = 0;\n    long paren_level_max_index35 = 0;\n\
    \    long paren_level_max_index36 = 0;\n    long paren_level_max_index37 = 0;\n\
    \    long paren_level_max_index38 = 0;\n    long paren_level_max_index39 = 0;\n\
    \    long paren_level_max_index40 = 0;\n    long paren_level_max_index41 = 0;\n\
    \    long paren_level_max_index42 = 0;\n    long paren_level_max_index43 = 0;\n\
    \    long paren_level_max_index44 = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9silyee.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpe9silyee.d(20): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmpe9silyee.d(68):
    Error: no identifier for declarator `long`\n/tmp/tmpe9silyee.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9silyee.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren = false;\n    bool in_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren = false;\n \
    \   bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote = false;\n    bool\
    \ in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren = false;\n  \
    \  bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmrztpud1.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpmrztpud1.d(37): Error: semicolon expected,
    not `unittest`\n/tmp/tmpmrztpud1.d(37): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmrztpud1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; i++) \n    {\n        if(paren_chars[i] == \"(\") \n \
    \       {\n            level++;\n        }\n        else if(paren_chars[i] ==\
    \ \")\") \n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level) \n        {\n            max_level = level;\n \
    \       }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7tdy2yd3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp7tdy2yd3.d(17): Deprecation: instead of
    C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmp7tdy2yd3.d(16):
    Error: no property `length` for type `string`\n/tmp/tmp7tdy2yd3.d(17): Error:
    no property `split` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp7tdy2yd3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    paren_stack = paren_string;\n    paren_levels[paren_level] = 0;\n    long\
    \ paren_levels_index = 0;\n    bool paren_stack_empty = true;\n    long paren_levels_index2\
    \ = 0;\n    bool paren_levels_index2_empty = true;\n    long paren_levels_index3\
    \ = 0;\n    bool paren_levels_index3_empty = true;\n    long paren_levels_index4\
    \ = 0;\n    bool paren_levels_index4_empty = true;\n    long paren_levels_index5\
    \ = 0;\n    bool paren_levels_index5_empty = true;\n    long paren_levels_index6\
    \ = 0;\n    bool paren_levels_index6_empty = true;\n    long paren_levels_index7\
    \ = 0;\n    bool paren_levels_index7_empty = true;\n    long paren_levels_index8\
    \ = 0;\n    bool paren_levels_index8_empty = true;\n    long paren_levels_index9\
    \ = 0;\n    bool paren_levels_index9_empty = true;\n    long paren_levels_index10\
    \ = 0;\n    bool paren_levels_index10_empty = true;\n    long paren_levels_index11\
    \ = 0;\n    bool paren_levels_index11_empty = true;\n    long paren_levels_index12\
    \ = 0;\n    bool paren_levels_index12_empty = true;\n    long paren_levels_index13\
    \ = 0;\n    bool paren_levels_index13_empty = true;\n    long paren_levels_index14\
    \ = 0;\n    bool paren_levels_index14_empty = true;\n    long paren_levels_index15\
    \ = 0;\n    bool paren_levels_index15_empty = true;\n    long paren_levels_index16\
    \ = 0;\n    bool paren_levels_index16_empty = true;\n    long paren_levels_index17\
    \ = 0;\n    bool paren_levels_index17_empty = true;\n    long paren_levels_index18\
    \ = 0;\n    bool paren_levels_index18_empty = true;\n    long paren_levels_index19\
    \ = 0;\n    bool paren_levels_index19_empty = true;\n    long paren_levels_index20\
    \ = 0;\n    bool paren_levels_index20_empty = true;\n    long paren_levels_index21\
    \ = 0;\n    bool paren_levels_index21_empty = true;\n    long paren_levels_index22\
    \ = 0;\n    bool paren_levels_index22_empty = true;\n    long paren_levels_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzkodcu2.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] paren_levels`\n/tmp/tmpvzkodcu2.d(64): Error:
    semicolon expected, not `unittest`\n/tmp/tmpvzkodcu2.d(64): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzkodcu2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_opener\
    \ = false;\n    bool in_group_closer = false;\n    bool in_group_opener_close\
    \ = false;\n    bool in_group_closer_close = false;\n    bool in_group_opener_open\
    \ = false;\n    bool in_group_closer_open = false;\n    bool in_group_opener_opener\
    \ = false;\n    bool in_group_closer_opener = false;\n    bool in_group_opener_closer\
    \ = false;\n    bool in_group_closer_closer = false;\n    bool in_group_opener_opener\
    \ = false;\n    bool in_group_closer_opener = false;\n    bool in_group_closer_closer\
    \ = false;\n    bool in_group_opener_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_to9qwsr.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp_to9qwsr.d(64): Error: semicolon expected,
    not `unittest`\n/tmp/tmp_to9qwsr.d(64): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_to9qwsr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_b\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzxk4fnh6.d(48): Error: semicolon expected, not `unittest`\n/tmp/tmpzxk4fnh6.d(48):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzxk4fnh6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9c6pjr3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmph9c6pjr3.d(51): Error: semicolon expected,
    not `unittest`\n/tmp/tmph9c6pjr3.d(51): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9c6pjr3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    long level_size = 0;\n    long level_pointer\
    \ = 0;\n    long level_pointer_pointer = 0;\n    long level_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer = 0;\n    long level_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer = 0;\n\
    \    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer = 0;\n\
    \    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqtt5k5ix.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmpqtt5k5ix.d(39): Error:
    semicolon expected, not `unittest`\n/tmp/tmpqtt5k5ix.d(39): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtt5k5ix.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_group\
    \ = false;\n    bool in_quote_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_quote_group_open = false;\n    bool in_paren_group_closed = false;\n\
    \    bool in_quote_group_closed = false;\n    bool in_paren_group_open_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote = false;\n    bool in_paren_group_closed_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote = false;\n    bool in_paren_group_open_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren = false;\n\
    \    bool in_paren_group_closed_inside_quote_inside_paren = false;\n    bool in_quote_group_closed_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_closed_inside_quote_in\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqao78qff.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpqao78qff.d(48): Error: semicolon expected,
    not `unittest`\n/tmp/tmpqao78qff.d(48): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqao78qff.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long index = 0;\n    bool is_open =\
    \ false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n  \
    \  bool is_closing_paren = false;\n    bool is_opening_curly = false;\n    bool\
    \ is_closing_curly = false;\n    bool is_opening_square = false;\n    bool is_closing_square\
    \ = false;\n    bool is_opening_angle = false;\n    bool is_closing_angle = false;\n\
    \    bool is_opening_paren_or_curly = false;\n    bool is_closing_paren_or_curly\
    \ = false;\n    bool is_opening_paren_or_angle = false;\n    bool is_closing_paren_or_angle\
    \ = false;\n    bool is_opening_square_or_angle = false;\n    bool is_closing_square_or_angle\
    \ = false;\n    bool is_opening_curly_or_angle = false;\n    bool is_closing_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly = false;\n    bool is_closing_square_or_curly\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplk0403cf.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmplk0403cf.d(60):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmplk0403cf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool has_left_paren = false;\n    bool has_right_paren\
    \ = false;\n    bool has_left_bracket = false;\n    bool has_right_bracket = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_square = false;\n    bool has_right_square\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_square = false;\n    bool has_right_square = false;\n    bool has_left_curly\
    \ = false;\n    bool has_right_curly = false;\n    bool has_left_brace = false;\n\
    \    bool has_right_brace = false;\n    bool has_left_square = false;\n    bool\
    \ has_right_square = false;\n    bool has_left_curly = false;\n    bool has_right_curly\
    \ = false;\n    bool has_left_brace = false;\n    bool has_right_brace = false;\n\
    \    bool has_left_square = false;\n    bool has_right_square = false;\n    bool\
    \ has_left_curly = false;\n    bool has_right_curly = false;\n    bool has_left_brace\
    \ = false;\n    bool has_right_brace = false;\n    bool has_left_square = false;\n\
    \    bool has_right_square = false;\n    bool has_left_curly = false;\n    bool\
    \ has_right_curly = false;\n    bool has_left_brace = false;\n    bool has_right_brace\
    \ = false;\n    bool has_left_square = false;\n    bool has_right_square = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_square = false;\n    bool has_right_square\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_square = false;\n    bool has_right_square = false;\n    bool has_left_curly\
    \ = false;\n    bool has_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqyf5z3ug.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpqyf5z3ug.d(84): Error: semicolon expected,
    not `unittest`\n/tmp/tmpqyf5z3ug.d(84): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqyf5z3ug.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long pos = 0;\n    long i = 0;\n    while(pos < paren_string.length()) {\n\
    \        char c = paren_string[pos];\n        if(c == '(') {\n            levels[pos]\
    \ = level;\n            level++;\n        } else if(c == ')') {\n            level--;\n\
    \            if(level == 0) {\n                level = levels[pos];\n        \
    \        levels[pos] = level;\n            }\n        } else if(c == ' ') {\n\
    \            levels[pos] = level;\n        }\n        pos++;\n        i++;\n \
    \   }\n    for(i = 0; i < paren_string.length(); i++) {\n        if(levels[i]\
    \ != level) {\n            max_level = max(max_level, levels[i]);\n        }\n\
    \    }\n    return max_level;\n}\n</code>\n<|/ a tags=algorithm,string,c++ |>\n\
    <| c |>\nThis is not an answer. Just a bunch of code. Could you please explain\
    \ how this solves the problem?\n<|/ c |>\n<| c |>\nThis code will give the maximum\
    \ level of nesting of a string with parentheses.\n<|/ c |>\n<| c |>\nThis code\
    \ does not give the maximum level of nesting of a string with parentheses.\n<|/\
    \ c |>\n<| c |>\nThis code gives the maximum level of nesting of a string with\
    \ parentheses.\n<|/ c |>\n<| c |>\nThis code gives the maximum level of nesting\
    \ of a string with parentheses.\n<|/ c |>\n<| a tags=algorithm,string,c++ |>\n\
    <code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3xdbuulb.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp3xdbuulb.d(43): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3xdbuulb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbkym_5jl.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmpbkym_5jl.d(45):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbkym_5jl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.ToCharArray();\n    for(int i = 0; i\
    \ < paren_string.length(); i++)\n    {\n        if(paren_chars[i] == '(')\n  \
    \      {\n            level++;\n        }\n        else if(paren_chars[i] == ')')\n\
    \        {\n            level--;\n        }\n        levels[i] = level;\n    \
    \    if(level > max_level)\n        {\n            max_level = level;\n      \
    \  }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c#,parentheses\
    \ |>\n<| a tags=algorithm,c#,parentheses |>\n<code>\npublic static void Main(string[]\
    \ args)\n{\n    string input = \"(()()) ((())) () ((())()())\";\n    List<int>\
    \ levels = new List<int>();\n    List<int> levelsCount = new List<int>();\n  \
    \  List<int> levelsCount2 = new List<int>();\n    List<int> levelsCount3 = new\
    \ List<int>();\n    List<int> levelsCount4 = new List<int>();\n    List<int> levelsCount5\
    \ = new List<int>();\n    List<int> levelsCount6 = new List<int>();\n    List<int>\
    \ levelsCount7 = new List<int>();\n    List<int> levelsCount8 = new List<int>();\n\
    \    List<int> levelsCount9 = new List<int>();\n    List<int> levelsCount10 =\
    \ new List<int>();\n    List<int> levelsCount11 = new List<int>();\n    List<int>\
    \ levelsCount12 = new List<int>();\n    List<int> levelsCount13 = new List<int>();\n\
    \    List<int> levelsCount14 = new List<int>();\n    List<int> levelsCount15 =\
    \ new List<int>();\n    List<int> levelsCount16 = new List<int>();\n    List<int>\
    \ levelsCount17 = new List<int>();\n    List<int> levelsCount18 = new List<int>();\n\
    \    List<int> levelsCount19 = new List<int>();\n    List<int> levelsCount20 =\
    \ new List<int>();\n    List<int> levelsCount21 = new List<int>();\n    List<int>\
    \ levelsCount22 = new List<int>();\n    List<int> levelsCount23 = new List<int>();\n\
    \    List<int> levelsCount24 = new List<int>();\n    List<int> levelsCount25 =\
    \ new List<int>();\n    List<int> level\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk8yfz6rf.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpk8yfz6rf.d(17): Deprecation: instead of
    C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmpk8yfz6rf.d(36):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(43): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(43): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(44): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(44):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(45): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(45): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(46): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(46):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(47): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(47): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(48): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(48):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(49): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(49): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(50): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(50):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(51): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(51): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(52): Error: no identifier for declarator `List`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk8yfz6rf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool has_parens = false;\n    bool has_space = false;\n\
    \    bool has_comma = false;\n    bool has_opening_bracket = false;\n    bool\
    \ has_closing_bracket = false;\n    bool has_opening_paren = false;\n    bool\
    \ has_closing_paren = false;\n    bool has_opening_curly = false;\n    bool has_closing_curly\
    \ = false;\n    bool has_opening_square = false;\n    bool has_closing_square\
    \ = false;\n    bool has_opening_angle = false;\n    bool has_closing_angle =\
    \ false;\n    bool has_opening_plus = false;\n    bool has_closing_plus = false;\n\
    \    bool has_opening_minus = false;\n    bool has_closing_minus = false;\n  \
    \  bool has_opening_comma = false;\n    bool has_closing_comma = false;\n    bool\
    \ has_opening_colon = false;\n    bool has_closing_colon = false;\n    bool has_opening_semicolon\
    \ = false;\n    bool has_closing_semicolon = false;\n    bool has_opening_colon2\
    \ = false;\n    bool has_closing_colon2 = false;\n    bool has_opening_semicolon2\
    \ = false;\n    bool has_closing_semicolon2 = false;\n    bool has_opening_colon3\
    \ = false;\n    bool has_closing_colon3 = false;\n    bool has_opening_semicolon3\
    \ = false;\n    bool has_closing_semicolon3 = false;\n    bool has_opening_colon4\
    \ = false;\n    bool has_closing_colon4 = false;\n    bool has_opening_semicolon4\
    \ = false;\n    bool has_closing_semicolon4 = false;\n    bool has_opening_colon5\
    \ = false;\n    bool has_closing_colon5 = false;\n    bool has_opening_semicolon5\
    \ = false;\n    bool has_closing_semicolon5 = false;\n    bool has_opening_colon6\
    \ = false;\n    bool has_closing_colon6 = false;\n    bool has_opening_semicolon6\
    \ = false;\n    bool has_closing_semicolon6 = false;\n    bool has_opening_colon7\
    \ = false;\n    bool has_closing_colon7 = false;\n    bool has_opening_semicolon7\
    \ = false;\n    bool has_closing_semicolon7 = false;\n    bool has_opening_colon8\
    \ = false;\n    bool has_closing_colon8 = false;\n    bool has_opening_semicolon8\
    \ = false;\n    bool has_closing_semicolon8 = false;\n    bool has_opening_colon9\
    \ = false;\n    bool has_closing_colon9 = false;\n    bool has_opening_semicolon9\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq7a3co8p.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpq7a3co8p.d(72): Error: semicolon expected,
    not `unittest`\n/tmp/tmpq7a3co8p.d(72): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7a3co8p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly = false;\n\
    \    bool is_closing_curly = false;\n    bool is_opening_square = false;\n   \
    \ bool is_closing_square = false;\n    bool is_opening_curly_square = false;\n\
    \    bool is_closing_curly_square = false;\n    bool is_opening_paren_square =\
    \ false;\n    bool is_closing_paren_square = false;\n    bool is_opening_curly_curly\
    \ = false;\n    bool is_closing_curly_curly = false;\n    bool is_opening_square_curly\
    \ = false;\n    bool is_closing_square_curly = false;\n    bool is_opening_paren_curly\
    \ = false;\n    bool is_closing_paren_curly = false;\n    bool is_opening_curly_paren\
    \ = false;\n    bool is_closing_curly_paren = false;\n    bool is_opening_square_paren\
    \ = false;\n    bool is_closing_square_paren = false;\n    bool is_opening_paren_paren\
    \ = false;\n    bool is_closing_paren_paren = false;\n    bool is_opening_curly_curly_paren\
    \ = false;\n    bool is_closing_curly_curly_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    bool is_opening_paren_curly_paren\
    \ = false;\n    bool is_closing_paren_curly_paren = false;\n    bool is_opening_curly_square_paren\
    \ = false;\n    bool is_closing_curly_square_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    bool is_opening_paren_curly_square\
    \ = false;\n    bool is_closing_paren_curly_square = false;\n    bool is_opening_square_curly_square\
    \ = false;\n    bool is_closing_square_curly_square = false;\n    bool is_opening_paren_curly_curly\
    \ = false;\n    bool is_closing_paren_curly_curly = false;\n    bool is_opening_square_curly_curly\
    \ = false;\n    bool is_closing_square_curly_curly = false;\n    bool is_opening_paren_curly_paren\
    \ = false;\n    bool is_closing_paren_curly_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwm2owqva.d(64): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwm2owqva.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
