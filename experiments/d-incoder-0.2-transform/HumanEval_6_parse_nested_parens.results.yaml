language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long max_level = 0;\n    long level = 0;\n\
    \    long levels_of_nesting = 0;\n    long current_level = 0;\n    long current_level_of_nesting\
    \ = 0;\n    long current_level_of_nesting_count = 0;\n    bool is_first_group\
    \ = true;\n    bool is_last_group = true;\n    bool is_first_group_of_current_level\
    \ = true;\n    bool is_last_group_of_current_level = true;\n    bool is_first_group_of_current_level_of_nesting\
    \ = true;\n    bool is_last_group_of_current_level_of_nesting = true;\n    bool\
    \ is_first_group_of_current_level_of_nesting_count = true;\n    bool is_last_group_of_current_level_of_nesting_count\
    \ = true;\n    bool is_first_group_of_current_level_of_nesting_count_plus_one\
    \ = true;\n    bool is_last_group_of_current_level_of_nesting_count_plus_one =\
    \ true;\n    bool is_first_group_of_current_level_of_nesting_count_plus_two =\
    \ true;\n    bool is_last_group_of_current_level_of_nesting_count_plus_two = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_three = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_three = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_four = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_four = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_five = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_five = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_six = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_six = true;\n \
    \   bool is_first_group_of_current_level_of_nesting_count_plus_seven = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_seven = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_eight = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_eight = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_nine = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_nine = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_ten = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_ten = true;\n \
    \   bool is_first_group_of_current_level_of_nesting_count_plus_eleven = true;\n\
    \    bool is_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfbyh6ok8.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpfbyh6ok8.d(52):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfbyh6ok8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_or_closing = false;\n\
    \    bool is_opening_or_closing_or_opening = false;\n    bool is_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening =\
    \ false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4b_dksle.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp4b_dksle.d(33): Error: semicolon expected,
    not `unittest`\n/tmp/tmp4b_dksle.d(33): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4b_dksle.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_index = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_clo\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppg2va0my.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmppg2va0my.d(66): Error:
    semicolon expected, not `unittest`\n/tmp/tmppg2va0my.d(66): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppg2va0my.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   long paren_levels[] = new long[paren_string.length()];\n    long paren_level_index\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index = 0;\n \
    \   long paren_level_max_index2 = 0;\n    long paren_level_max_index3 = 0;\n \
    \   long paren_level_max_index4 = 0;\n    long paren_level_max_index5 = 0;\n \
    \   long paren_level_max_index6 = 0;\n    long paren_level_max_index7 = 0;\n \
    \   long paren_level_max_index8 = 0;\n    long paren_level_max_index9 = 0;\n \
    \   long paren_level_max_index10 = 0;\n    long paren_level_max_index11 = 0;\n\
    \    long paren_level_max_index12 = 0;\n    long paren_level_max_index13 = 0;\n\
    \    long paren_level_max_index14 = 0;\n    long paren_level_max_index15 = 0;\n\
    \    long paren_level_max_index16 = 0;\n    long paren_level_max_index17 = 0;\n\
    \    long paren_level_max_index18 = 0;\n    long paren_level_max_index19 = 0;\n\
    \    long paren_level_max_index20 = 0;\n    long paren_level_max_index21 = 0;\n\
    \    long paren_level_max_index22 = 0;\n    long paren_level_max_index23 = 0;\n\
    \    long paren_level_max_index24 = 0;\n    long paren_level_max_index25 = 0;\n\
    \    long paren_level_max_index26 = 0;\n    long paren_level_max_index27 = 0;\n\
    \    long paren_level_max_index28 = 0;\n    long paren_level_max_index29 = 0;\n\
    \    long paren_level_max_index30 = 0;\n    long paren_level_max_index31 = 0;\n\
    \    long paren_level_max_index32 = 0;\n    long paren_level_max_index33 = 0;\n\
    \    long paren_level_max_index34 = 0;\n    long paren_level_max_index35 = 0;\n\
    \    long paren_level_max_index36 = 0;\n    long paren_level_max_index37 = 0;\n\
    \    long paren_level_max_index38 = 0;\n    long paren_level_max_index39 = 0;\n\
    \    long paren_level_max_index40 = 0;\n    long paren_level_max_index41 = 0;\n\
    \    long paren_level_max_index42 = 0;\n    long paren_level_max_index43 = 0;\n\
    \    long paren_level_max_index44 = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe9silyee.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpe9silyee.d(20): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmpe9silyee.d(68):
    Error: no identifier for declarator `long`\n/tmp/tmpe9silyee.d(68): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9silyee.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren = false;\n    bool in_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren = false;\n \
    \   bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote = false;\n    bool\
    \ in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren = false;\n  \
    \  bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmrztpud1.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpmrztpud1.d(37): Error: semicolon expected,
    not `unittest`\n/tmp/tmpmrztpud1.d(37): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmrztpud1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; i++) \n    {\n        if(paren_chars[i] == \"(\") \n \
    \       {\n            level++;\n        }\n        else if(paren_chars[i] ==\
    \ \")\") \n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level) \n        {\n            max_level = level;\n \
    \       }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7tdy2yd3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp7tdy2yd3.d(17): Deprecation: instead of
    C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmp7tdy2yd3.d(16):
    Error: no property `length` for type `string`\n/tmp/tmp7tdy2yd3.d(17): Error:
    no property `split` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp7tdy2yd3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    paren_stack = paren_string;\n    paren_levels[paren_level] = 0;\n    long\
    \ paren_levels_index = 0;\n    bool paren_stack_empty = true;\n    long paren_levels_index2\
    \ = 0;\n    bool paren_levels_index2_empty = true;\n    long paren_levels_index3\
    \ = 0;\n    bool paren_levels_index3_empty = true;\n    long paren_levels_index4\
    \ = 0;\n    bool paren_levels_index4_empty = true;\n    long paren_levels_index5\
    \ = 0;\n    bool paren_levels_index5_empty = true;\n    long paren_levels_index6\
    \ = 0;\n    bool paren_levels_index6_empty = true;\n    long paren_levels_index7\
    \ = 0;\n    bool paren_levels_index7_empty = true;\n    long paren_levels_index8\
    \ = 0;\n    bool paren_levels_index8_empty = true;\n    long paren_levels_index9\
    \ = 0;\n    bool paren_levels_index9_empty = true;\n    long paren_levels_index10\
    \ = 0;\n    bool paren_levels_index10_empty = true;\n    long paren_levels_index11\
    \ = 0;\n    bool paren_levels_index11_empty = true;\n    long paren_levels_index12\
    \ = 0;\n    bool paren_levels_index12_empty = true;\n    long paren_levels_index13\
    \ = 0;\n    bool paren_levels_index13_empty = true;\n    long paren_levels_index14\
    \ = 0;\n    bool paren_levels_index14_empty = true;\n    long paren_levels_index15\
    \ = 0;\n    bool paren_levels_index15_empty = true;\n    long paren_levels_index16\
    \ = 0;\n    bool paren_levels_index16_empty = true;\n    long paren_levels_index17\
    \ = 0;\n    bool paren_levels_index17_empty = true;\n    long paren_levels_index18\
    \ = 0;\n    bool paren_levels_index18_empty = true;\n    long paren_levels_index19\
    \ = 0;\n    bool paren_levels_index19_empty = true;\n    long paren_levels_index20\
    \ = 0;\n    bool paren_levels_index20_empty = true;\n    long paren_levels_index21\
    \ = 0;\n    bool paren_levels_index21_empty = true;\n    long paren_levels_index22\
    \ = 0;\n    bool paren_levels_index22_empty = true;\n    long paren_levels_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzkodcu2.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] paren_levels`\n/tmp/tmpvzkodcu2.d(64): Error:
    semicolon expected, not `unittest`\n/tmp/tmpvzkodcu2.d(64): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzkodcu2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_opener\
    \ = false;\n    bool in_group_closer = false;\n    bool in_group_opener_close\
    \ = false;\n    bool in_group_closer_close = false;\n    bool in_group_opener_open\
    \ = false;\n    bool in_group_closer_open = false;\n    bool in_group_opener_opener\
    \ = false;\n    bool in_group_closer_opener = false;\n    bool in_group_opener_closer\
    \ = false;\n    bool in_group_closer_closer = false;\n    bool in_group_opener_opener\
    \ = false;\n    bool in_group_closer_opener = false;\n    bool in_group_closer_closer\
    \ = false;\n    bool in_group_opener_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_to9qwsr.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp_to9qwsr.d(64): Error: semicolon expected,
    not `unittest`\n/tmp/tmp_to9qwsr.d(64): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_to9qwsr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_b\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzxk4fnh6.d(48): Error: semicolon expected, not `unittest`\n/tmp/tmpzxk4fnh6.d(48):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzxk4fnh6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9c6pjr3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmph9c6pjr3.d(51): Error: semicolon expected,
    not `unittest`\n/tmp/tmph9c6pjr3.d(51): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9c6pjr3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    long level_size = 0;\n    long level_pointer\
    \ = 0;\n    long level_pointer_pointer = 0;\n    long level_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer = 0;\n    long level_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer = 0;\n\
    \    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer = 0;\n\
    \    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqtt5k5ix.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmpqtt5k5ix.d(39): Error:
    semicolon expected, not `unittest`\n/tmp/tmpqtt5k5ix.d(39): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtt5k5ix.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_group\
    \ = false;\n    bool in_quote_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_quote_group_open = false;\n    bool in_paren_group_closed = false;\n\
    \    bool in_quote_group_closed = false;\n    bool in_paren_group_open_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote = false;\n    bool in_paren_group_closed_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote = false;\n    bool in_paren_group_open_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren = false;\n\
    \    bool in_paren_group_closed_inside_quote_inside_paren = false;\n    bool in_quote_group_closed_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_closed_inside_quote_in\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqao78qff.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpqao78qff.d(48): Error: semicolon expected,
    not `unittest`\n/tmp/tmpqao78qff.d(48): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqao78qff.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long index = 0;\n    bool is_open =\
    \ false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n  \
    \  bool is_closing_paren = false;\n    bool is_opening_curly = false;\n    bool\
    \ is_closing_curly = false;\n    bool is_opening_square = false;\n    bool is_closing_square\
    \ = false;\n    bool is_opening_angle = false;\n    bool is_closing_angle = false;\n\
    \    bool is_opening_paren_or_curly = false;\n    bool is_closing_paren_or_curly\
    \ = false;\n    bool is_opening_paren_or_angle = false;\n    bool is_closing_paren_or_angle\
    \ = false;\n    bool is_opening_square_or_angle = false;\n    bool is_closing_square_or_angle\
    \ = false;\n    bool is_opening_curly_or_angle = false;\n    bool is_closing_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly = false;\n    bool is_closing_square_or_curly\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplk0403cf.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmplk0403cf.d(60):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmplk0403cf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool has_left_paren = false;\n    bool has_right_paren\
    \ = false;\n    bool has_left_bracket = false;\n    bool has_right_bracket = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_square = false;\n    bool has_right_square\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_square = false;\n    bool has_right_square = false;\n    bool has_left_curly\
    \ = false;\n    bool has_right_curly = false;\n    bool has_left_brace = false;\n\
    \    bool has_right_brace = false;\n    bool has_left_square = false;\n    bool\
    \ has_right_square = false;\n    bool has_left_curly = false;\n    bool has_right_curly\
    \ = false;\n    bool has_left_brace = false;\n    bool has_right_brace = false;\n\
    \    bool has_left_square = false;\n    bool has_right_square = false;\n    bool\
    \ has_left_curly = false;\n    bool has_right_curly = false;\n    bool has_left_brace\
    \ = false;\n    bool has_right_brace = false;\n    bool has_left_square = false;\n\
    \    bool has_right_square = false;\n    bool has_left_curly = false;\n    bool\
    \ has_right_curly = false;\n    bool has_left_brace = false;\n    bool has_right_brace\
    \ = false;\n    bool has_left_square = false;\n    bool has_right_square = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_square = false;\n    bool has_right_square\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_square = false;\n    bool has_right_square = false;\n    bool has_left_curly\
    \ = false;\n    bool has_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqyf5z3ug.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpqyf5z3ug.d(84): Error: semicolon expected,
    not `unittest`\n/tmp/tmpqyf5z3ug.d(84): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqyf5z3ug.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long pos = 0;\n    long i = 0;\n    while(pos < paren_string.length()) {\n\
    \        char c = paren_string[pos];\n        if(c == '(') {\n            levels[pos]\
    \ = level;\n            level++;\n        } else if(c == ')') {\n            level--;\n\
    \            if(level == 0) {\n                level = levels[pos];\n        \
    \        levels[pos] = level;\n            }\n        } else if(c == ' ') {\n\
    \            levels[pos] = level;\n        }\n        pos++;\n        i++;\n \
    \   }\n    for(i = 0; i < paren_string.length(); i++) {\n        if(levels[i]\
    \ != level) {\n            max_level = max(max_level, levels[i]);\n        }\n\
    \    }\n    return max_level;\n}\n</code>\n<|/ a tags=algorithm,string,c++ |>\n\
    <| c |>\nThis is not an answer. Just a bunch of code. Could you please explain\
    \ how this solves the problem?\n<|/ c |>\n<| c |>\nThis code will give the maximum\
    \ level of nesting of a string with parentheses.\n<|/ c |>\n<| c |>\nThis code\
    \ does not give the maximum level of nesting of a string with parentheses.\n<|/\
    \ c |>\n<| c |>\nThis code gives the maximum level of nesting of a string with\
    \ parentheses.\n<|/ c |>\n<| c |>\nThis code gives the maximum level of nesting\
    \ of a string with parentheses.\n<|/ c |>\n<| a tags=algorithm,string,c++ |>\n\
    <code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3xdbuulb.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp3xdbuulb.d(43): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3xdbuulb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbkym_5jl.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmpbkym_5jl.d(45):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbkym_5jl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.ToCharArray();\n    for(int i = 0; i\
    \ < paren_string.length(); i++)\n    {\n        if(paren_chars[i] == '(')\n  \
    \      {\n            level++;\n        }\n        else if(paren_chars[i] == ')')\n\
    \        {\n            level--;\n        }\n        levels[i] = level;\n    \
    \    if(level > max_level)\n        {\n            max_level = level;\n      \
    \  }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c#,parentheses\
    \ |>\n<| a tags=algorithm,c#,parentheses |>\n<code>\npublic static void Main(string[]\
    \ args)\n{\n    string input = \"(()()) ((())) () ((())()())\";\n    List<int>\
    \ levels = new List<int>();\n    List<int> levelsCount = new List<int>();\n  \
    \  List<int> levelsCount2 = new List<int>();\n    List<int> levelsCount3 = new\
    \ List<int>();\n    List<int> levelsCount4 = new List<int>();\n    List<int> levelsCount5\
    \ = new List<int>();\n    List<int> levelsCount6 = new List<int>();\n    List<int>\
    \ levelsCount7 = new List<int>();\n    List<int> levelsCount8 = new List<int>();\n\
    \    List<int> levelsCount9 = new List<int>();\n    List<int> levelsCount10 =\
    \ new List<int>();\n    List<int> levelsCount11 = new List<int>();\n    List<int>\
    \ levelsCount12 = new List<int>();\n    List<int> levelsCount13 = new List<int>();\n\
    \    List<int> levelsCount14 = new List<int>();\n    List<int> levelsCount15 =\
    \ new List<int>();\n    List<int> levelsCount16 = new List<int>();\n    List<int>\
    \ levelsCount17 = new List<int>();\n    List<int> levelsCount18 = new List<int>();\n\
    \    List<int> levelsCount19 = new List<int>();\n    List<int> levelsCount20 =\
    \ new List<int>();\n    List<int> levelsCount21 = new List<int>();\n    List<int>\
    \ levelsCount22 = new List<int>();\n    List<int> levelsCount23 = new List<int>();\n\
    \    List<int> levelsCount24 = new List<int>();\n    List<int> levelsCount25 =\
    \ new List<int>();\n    List<int> level\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk8yfz6rf.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpk8yfz6rf.d(17): Deprecation: instead of
    C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmpk8yfz6rf.d(36):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(43): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(43): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(44): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(44):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(45): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(45): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(46): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(46):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(47): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(47): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(48): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(48):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(49): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(49): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(50): Error: no identifier for declarator `List`\n/tmp/tmpk8yfz6rf.d(50):
    Error: declaration expected, not `<`\n/tmp/tmpk8yfz6rf.d(51): Error: no identifier
    for declarator `List`\n/tmp/tmpk8yfz6rf.d(51): Error: declaration expected, not
    `<`\n/tmp/tmpk8yfz6rf.d(52): Error: no identifier for declarator `List`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk8yfz6rf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool has_parens = false;\n    bool has_space = false;\n\
    \    bool has_comma = false;\n    bool has_opening_bracket = false;\n    bool\
    \ has_closing_bracket = false;\n    bool has_opening_paren = false;\n    bool\
    \ has_closing_paren = false;\n    bool has_opening_curly = false;\n    bool has_closing_curly\
    \ = false;\n    bool has_opening_square = false;\n    bool has_closing_square\
    \ = false;\n    bool has_opening_angle = false;\n    bool has_closing_angle =\
    \ false;\n    bool has_opening_plus = false;\n    bool has_closing_plus = false;\n\
    \    bool has_opening_minus = false;\n    bool has_closing_minus = false;\n  \
    \  bool has_opening_comma = false;\n    bool has_closing_comma = false;\n    bool\
    \ has_opening_colon = false;\n    bool has_closing_colon = false;\n    bool has_opening_semicolon\
    \ = false;\n    bool has_closing_semicolon = false;\n    bool has_opening_colon2\
    \ = false;\n    bool has_closing_colon2 = false;\n    bool has_opening_semicolon2\
    \ = false;\n    bool has_closing_semicolon2 = false;\n    bool has_opening_colon3\
    \ = false;\n    bool has_closing_colon3 = false;\n    bool has_opening_semicolon3\
    \ = false;\n    bool has_closing_semicolon3 = false;\n    bool has_opening_colon4\
    \ = false;\n    bool has_closing_colon4 = false;\n    bool has_opening_semicolon4\
    \ = false;\n    bool has_closing_semicolon4 = false;\n    bool has_opening_colon5\
    \ = false;\n    bool has_closing_colon5 = false;\n    bool has_opening_semicolon5\
    \ = false;\n    bool has_closing_semicolon5 = false;\n    bool has_opening_colon6\
    \ = false;\n    bool has_closing_colon6 = false;\n    bool has_opening_semicolon6\
    \ = false;\n    bool has_closing_semicolon6 = false;\n    bool has_opening_colon7\
    \ = false;\n    bool has_closing_colon7 = false;\n    bool has_opening_semicolon7\
    \ = false;\n    bool has_closing_semicolon7 = false;\n    bool has_opening_colon8\
    \ = false;\n    bool has_closing_colon8 = false;\n    bool has_opening_semicolon8\
    \ = false;\n    bool has_closing_semicolon8 = false;\n    bool has_opening_colon9\
    \ = false;\n    bool has_closing_colon9 = false;\n    bool has_opening_semicolon9\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq7a3co8p.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpq7a3co8p.d(72): Error: semicolon expected,
    not `unittest`\n/tmp/tmpq7a3co8p.d(72): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7a3co8p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly = false;\n\
    \    bool is_closing_curly = false;\n    bool is_opening_square = false;\n   \
    \ bool is_closing_square = false;\n    bool is_opening_curly_square = false;\n\
    \    bool is_closing_curly_square = false;\n    bool is_opening_paren_square =\
    \ false;\n    bool is_closing_paren_square = false;\n    bool is_opening_curly_curly\
    \ = false;\n    bool is_closing_curly_curly = false;\n    bool is_opening_square_curly\
    \ = false;\n    bool is_closing_square_curly = false;\n    bool is_opening_paren_curly\
    \ = false;\n    bool is_closing_paren_curly = false;\n    bool is_opening_curly_paren\
    \ = false;\n    bool is_closing_curly_paren = false;\n    bool is_opening_square_paren\
    \ = false;\n    bool is_closing_square_paren = false;\n    bool is_opening_paren_paren\
    \ = false;\n    bool is_closing_paren_paren = false;\n    bool is_opening_curly_curly_paren\
    \ = false;\n    bool is_closing_curly_curly_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    bool is_opening_paren_curly_paren\
    \ = false;\n    bool is_closing_paren_curly_paren = false;\n    bool is_opening_curly_square_paren\
    \ = false;\n    bool is_closing_curly_square_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    bool is_opening_paren_curly_square\
    \ = false;\n    bool is_closing_paren_curly_square = false;\n    bool is_opening_square_curly_square\
    \ = false;\n    bool is_closing_square_curly_square = false;\n    bool is_opening_paren_curly_curly\
    \ = false;\n    bool is_closing_paren_curly_curly = false;\n    bool is_opening_square_curly_curly\
    \ = false;\n    bool is_closing_square_curly_curly = false;\n    bool is_opening_paren_curly_paren\
    \ = false;\n    bool is_closing_paren_curly_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwm2owqva.d(64): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwm2owqva.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    string current_level = \"\";\n\
    \    long current_level_size = 0;\n    bool in_paren = false;\n    bool in_group\
    \ = false;\n    bool in_group_open = false;\n    bool in_group_close = false;\n\
    \    bool in_group_comma = false;\n    bool in_group_space = false;\n    bool\
    \ in_group_newline = false;\n    bool in_group_semicolon = false;\n    bool in_group_colon\
    \ = false;\n    bool in_group_equal = false;\n    bool in_group_comma2 = false;\n\
    \    bool in_group_space2 = false;\n    bool in_group_newline2 = false;\n    bool\
    \ in_group_semicolon2 = false;\n    bool in_group_colon2 = false;\n    bool in_group_equal2\
    \ = false;\n    bool in_group_comma3 = false;\n    bool in_group_space3 = false;\n\
    \    bool in_group_newline3 = false;\n    bool in_group_semicolon3 = false;\n\
    \    bool in_group_colon3 = false;\n    bool in_group_equal3 = false;\n    bool\
    \ in_group_comma4 = false;\n    bool in_group_space4 = false;\n    bool in_group_newline4\
    \ = false;\n    bool in_group_semicolon4 = false;\n    bool in_group_colon4 =\
    \ false;\n    bool in_group_equal4 = false;\n    bool in_group_comma5 = false;\n\
    \    bool in_group_space5 = false;\n    bool in_group_newline5 = false;\n    bool\
    \ in_group_semicolon5 = false;\n    bool in_group_colon5 = false;\n    bool in_group_equal5\
    \ = false;\n    bool in_group_comma6 = false;\n    bool in_group_space6 = false;\n\
    \    bool in_group_newline6 = false;\n    bool in_group_semicolon6 = false;\n\
    \    bool in_group_colon6 = false;\n    bool in_group_equal6 = false;\n    bool\
    \ in_group_comma7 = false;\n    bool in_group_space7 = false;\n    bool in_group_newline7\
    \ = false;\n    bool in_group_semicolon7 = false;\n    bool in_group_colon7 =\
    \ false;\n    bool in_group_equal7 = false;\n    bool in_group_comma8 = false;\n\
    \    bool in_group_space8 = false;\n    bool in_group_newline8 = false;\n    bool\
    \ in_group_semicolon8 = false;\n    bool in_group_colon8 = false;\n    bool in_group_equal8\
    \ = false;\n    bool in_group_comma9 = false;\n    bool in_group_space9 = false;\n\
    \    bool in_group_newline9 = false;\n    bool in_group_semicolon9 = false;\n\
    \    bool in_group_colon9 = false;\n    bool in_group_equal9 = false;\n    bool\
    \ in_group_comma10 = false;\n    bool in_group_space10 = false;\n    bool in_group_newline10\
    \ = false;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1bfl17lb.d(79): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1bfl17lb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paran = false;\n    bool in_paran2 =\
    \ false;\n    bool in_paran3 = false;\n    bool in_paran4 = false;\n    bool in_paran5\
    \ = false;\n    bool in_paran6 = false;\n    bool in_paran7 = false;\n    bool\
    \ in_paran8 = false;\n    bool in_paran9 = false;\n    bool in_paran10 = false;\n\
    \    bool in_paran11 = false;\n    bool in_paran12 = false;\n    bool in_paran13\
    \ = false;\n    bool in_paran14 = false;\n    bool in_paran15 = false;\n    bool\
    \ in_paran16 = false;\n    bool in_paran17 = false;\n    bool in_paran18 = false;\n\
    \    bool in_paran19 = false;\n    bool in_paran20 = false;\n    bool in_paran21\
    \ = false;\n    bool in_paran22 = false;\n    bool in_paran23 = false;\n    bool\
    \ in_paran24 = false;\n    bool in_paran25 = false;\n    bool in_paran26 = false;\n\
    \    bool in_paran27 = false;\n    bool in_paran28 = false;\n    bool in_paran29\
    \ = false;\n    bool in_paran30 = false;\n    bool in_paran31 = false;\n    bool\
    \ in_paran32 = false;\n    bool in_paran33 = false;\n    bool in_paran34 = false;\n\
    \    bool in_paran35 = false;\n    bool in_paran36 = false;\n    bool in_paran37\
    \ = false;\n    bool in_paran38 = false;\n    bool in_paran39 = false;\n    bool\
    \ in_paran40 = false;\n    bool in_paran41 = false;\n    bool in_paran42 = false;\n\
    \    bool in_paran43 = false;\n    bool in_paran44 = false;\n    bool in_paran45\
    \ = false;\n    bool in_paran46 = false;\n    bool in_paran47 = false;\n    bool\
    \ in_paran48 = false;\n    bool in_paran49 = false;\n    bool in_paran50 = false;\n\
    \    bool in_paran51 = false;\n    bool in_paran52 = false;\n    bool in_paran53\
    \ = false;\n    bool in_paran54 = false;\n    bool in_paran55 = false;\n    bool\
    \ in_paran56 = false;\n    bool in_paran57 = false;\n    bool in_paran58 = false;\n\
    \    bool in_paran59 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvwsz7r73.d(77): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvwsz7r73.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren = false;\n  \
    \  bool is_closing_paren_or_opening_paren_or_closed_or_open = false;\n    bool\
    \ is_opening_paren_or_closed_or_opening_paren_or_closed = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzap9y_7q.d(45): Error: semicolon expected, not \''unittest\''\n/tmp/tmpzap9y_7q.d(45):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpzap9y_7q.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for your answer. Your code works well for simple parentheses, but fails\
    \ for more complex ones. For example, it fails for \"((()))\" with maximum level\
    \ of nesting \"2\".\n<|/ c |>\n<| c |>\nI updated my answer to include a solution\
    \ for more complex parentheses\n<|/ c |>\n<| c |>\nThanks for your answer. Your\
    \ code works well for simple parentheses, but fails for more complex ones. For\
    \ example, it fails for \"((()))\" with maximum level of nesting \"2\".\n<|/ c\
    \ |>\n<| c |>\nI updated my answer to include a solution for more complex parentheses\n\
    <|/ c |>\n<| c |>\nThanks for your answer. Your code works well for simple parentheses,\
    \ but fails for more complex ones. For example, it fails for \"((()))\" with maximum\
    \ level of nesting \"2\".\n<|/ c |>\n<| a tags=algorithm,parentheses,c++ |>\n\
    <code>\n#include <iostream>\n#include <stack>\n#include <string>\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvoo4wzdf.d(35): Error: Declaration expected, not \''<\''\n/tmp/tmpvoo4wzdf.d(61):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpvoo4wzdf.d(62): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpvoo4wzdf.d(63): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpvoo4wzdf.d(64): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvoo4wzdf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_close =\
    \ false;\n    bool in_group_close_brace_close = false;\n    bool in_group_open_brace_open\
    \ = false;\n    bool in_group_close_brace_open = false;\n    bool in_group_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace\
    \ = false;\n    bool in_group_close_brace_open_brace = false;\n    bool in_group_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close = false;\n    bool in_group_close_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace = false;\n \
    \   bool in_group_open_brace_open_brace_close_brace_close = false;\n    bool in_group_close_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close = false;\n\
    \    bool in_group_open_brace_open_brace_close_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_open_brace_close_brace_close_brace = false;\n   \
    \ bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn7fidaxp.d(50): Error: semicolon expected, not \''unittest\''\n/tmp/tmpn7fidaxp.d(50):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpn7fidaxp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            if(!in_paren)\n        \
    \    {\n                level++;\n                in_paren = true;\n         \
    \   }\n        }\n        else if(paren_string[i] == ')')\n        {\n       \
    \     if(in_paren)\n            {\n                level--;\n                in_paren\
    \ = false;\n            }\n        }\n        else\n        {\n            levels[i]\
    \ = level;\n            in_paren = false;\n        }\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++,parentheses,recursion |>\n<| c |>\n\
    This does not work. Try it with `\"((()))\"`.\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I added the test case to the answer.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it with `\"((()))\"`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I added the test case to the answer.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `\"((()))\"`.\n<|/ c |>\n<| a tags=string,algorithm,c++,parentheses,recursion\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_m8_gvxj.d(43): Error: Declaration expected, not \''<\''\n/tmp/tmp_m8_gvxj.d(52):
    Error: unterminated character constant\n/tmp/tmp_m8_gvxj.d(58): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_m8_gvxj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_close = false;\n    bool in_group_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open = false;\n    bool in_group_close_brace_open\
    \ = false;\n    bool in_group_open_brace_close_brace = false;\n    bool in_group_close_brace_close_brace\
    \ = false;\n    bool in_group_open_brace_open_brace = false;\n    bool in_group_close_brace_open_brace\
    \ = false;\n    bool in_group_open_brace_close_brace_close = false;\n    bool\
    \ in_group_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close = false;\n    bool\
    \ in_group_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close = false;\n\
    \    bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_open_brace_close\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_0h4xc56.d(49): Error: semicolon expected, not \''unittest\''\n/tmp/tmp_0h4xc56.d(49):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_0h4xc56.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool is_open = false;\n    bool is_close = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open = false;\n\
    \    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphodliiyk.d(64): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphodliiyk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    string paren_chars[] = paren_string.ToCharArray();\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        if(paren_chars[i] == '(')\n     \
    \   {\n            levels[level] = level;\n            ++level;\n        }\n \
    \       else if(paren_chars[i] == ')')\n        {\n            level = levels[level];\n\
    \            levels[level] = 0;\n            ++level;\n        }\n        else\n\
    \        {\n            level = levels[level];\n        }\n        if(level >\
    \ max_level)\n        {\n            max_level = level;\n        }\n    }\n  \
    \  return max_level;\n}\n</code>\n<|/ a tags=c#,algorithm,parentheses |>\n<| a\
    \ dscore=0 |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing\
    \ System.Linq;\nusing System.Text;\nusing System.IO;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu0jjdkfr.d(42): Error: Declaration expected, not \''<\''\n/tmp/tmpu0jjdkfr.d(47):
    Error: semicolon expected, not \''.\''\n/tmp/tmpu0jjdkfr.d(47): Error: no identifier
    for declarator .Collections.Generic\n/tmp/tmpu0jjdkfr.d(48): Error: semicolon
    expected, not \''.\''\n/tmp/tmpu0jjdkfr.d(48): Error: no identifier for declarator
    .Linq\n/tmp/tmpu0jjdkfr.d(49): Error: semicolon expected, not \''.\''\n/tmp/tmpu0jjdkfr.d(49):
    Error: no identifier for declarator .Text\n/tmp/tmpu0jjdkfr.d(50): Error: semicolon
    expected, not \''.\''\n/tmp/tmpu0jjdkfr.d(50): Error: no identifier for declarator
    .IO\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu0jjdkfr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    string parens[] = paren_string.split(\" \");\n    for(long i = 0; i < parens.length;\
    \ ++i)\n    {\n        string paren = parens[i];\n        if(paren.length() ==\
    \ 0)\n            continue;\n        level = 0;\n        for(char c : paren)\n\
    \        {\n            if(c == '(')\n                ++level;\n            else\
    \ if(c == ')')\n                --level;\n            levels[level] = max(levels[level],\
    \ level);\n        }\n        max_level = max(max_level, level);\n    }\n    return\
    \ levels;\n}\n</code>\n<|/ a tags=algorithm,string,c++,parsing |>\n<| c |>\nI\
    \ like this solution. One thing I noticed is that it only works with parentheses\
    \ around a single expression. For example, it doesn't work with `((()))` but does\
    \ with `(()())`. Any idea how to fix that?\n<|/ c |>\n<| c |>\nI fixed the issue\
    \ by changing the `if` statement to `if(paren.length() == 0 || paren[0] == '(')`.\
    \ Thanks!\n<|/ c |>\n<| a tags=algorithm,string,c++,parsing |>\nI wrote a parser\
    \ for my own language in C++. My language is similar to Python, but with some\
    \ differences. I used a stack to keep track of nesting levels. I used a recursive\
    \ descent parser to parse the string. \nThe code below is my parser for my language.\
    \ \n<code>\n#include <iostream>\n#include <stack>\n#include <string>\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5k9mp9ck.d(24): Error: semicolon expected, not \'':\''\n/tmp/tmp5k9mp9ck.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmp5k9mp9ck.d(24): Error: found
    \''paren\'' when expecting \'';\'' following for condition\n/tmp/tmp5k9mp9ck.d(36):
    Error: Declaration expected, not \''<\''\n/tmp/tmp5k9mp9ck.d(39): Error: unterminated
    character constant\n/tmp/tmp5k9mp9ck.d(55): Error: Declaration expected, not \''assert\''\n/tmp/tmp5k9mp9ck.d(56):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp5k9mp9ck.d(57): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp5k9mp9ck.d(58): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5k9mp9ck.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       levels[i] = paren_level;\n        if(paren_level > max_level)\n      \
    \  {\n            max_level = paren_level;\n        }\n    }\n    for(long i =\
    \ 0; i < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       if(paren_level > max_level)\n        {\n            max_level = paren_level;\n\
    \        }\n    }\n    for(long i = 0; i < paren_chars.length; ++i)\n    {\n \
    \       string paren_char = paren_chars[i];\n        long paren_level = paren_char.count('(')\
    \ - paren_char.count(')');\n        if(paren_level > max_level)\n        {\n \
    \           max_level = paren_level;\n        }\n    }\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       if(paren_level > max_level)\n        {\n            max_level = paren_level;\n\
    \        }\n    }\n    for(long i = 0; i < paren_chars.length; ++i)\n    {\n \
    \       string paren_char = paren_chars[i];\n        long paren_level = paren_char.count('(')\
    \ - paren_char.count(')');\n        if(paren_level > max_level)\n        {\n \
    \           max_level = paren_level;\n        }\n    }\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       if(paren_level > max_level)\n        {\n            max_level = paren_level;\n\
    \        }\n    }\n    for(long i = 0; i < paren_chars.length; ++i)\n    {\n \
    \       string paren_char = paren_chars[i];\n        long paren_level = paren_char.count('(')\
    \ - paren_char.count(')');\n        if(paren_level > max_level)\n        {\n \
    \           max_level = paren_level;\n        }\n    }\n    for(\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7o78su1p.d(83): Error: found \''unittest\'' instead of statement\n/tmp/tmp7o78su1p.d(88):
    Error: found \'';\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp7o78su1p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_top = new long[paren_string.length()];\n    long[] levels_stack_bottom\
    \ = new long[paren_string.length()];\n    long levels_stack_top_index = 0;\n \
    \   long levels_stack_bottom_index = 0;\n    long levels_stack_index = 0;\n  \
    \  long levels_stack_top_index_next = 0;\n    long levels_stack_bottom_index_next\
    \ = 0;\n    long levels_stack_index_next = 0;\n    long levels_stack_top_index_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next = 0;\n    long levels_stack_index_next_next\
    \ = 0;\n    long levels_stack_top_index_next_next_next = 0;\n    long levels_stack_bottom_index_next_next_next\
    \ = 0;\n    long levels_stack_index_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next = 0;\n    long\
    \ levels_stack_index_next_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next = 0;\n   \
    \ long levels_stack_index_next_next_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_index_next_next_next_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_index_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_top_index_next_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_bottom_index_next_next_next_next_next_next_next_next =\
    \ 0;\n    long levels_stack_index_next_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_top_index_next_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_bottom_index_next_next_next_next_next_next_next_next =\
    \ 0;\n    long levels_stack_index_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_top_index_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_index_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_top_index_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdg14sd9i.d(52): Error: semicolon expected, not \''unittest\''\n/tmp/tmpdg14sd9i.d(52):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdg14sd9i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjggn76p3.d(86): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjggn76p3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    while(i < paren_string.length())\n    {\n\
    \        if(paren_string[i] == '(')\n        {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n        levels[i] = level;\n        i++;\n    }\n    for(i = 0; i\
    \ < levels.length; i++)\n    {\n        if(levels[i] > max_level)\n        {\n\
    \            max_level = levels[i];\n        }\n    }\n    long[] result = new\
    \ long[max_level + 1];\n    for(i = 0; i < levels.length; i++)\n    {\n      \
    \  result[levels[i]] = levels[i];\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis code doesn't work. Try it on \"((()))\". It returns\
    \ [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n<| c |>\nIt works fine for\
    \ me. Try it on \"((()))\". It returns [1L, 1L, 1L, 1L], which is not correct.\n\
    <|/ c |>\n<| c |>\nIt returns [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n\
    <| c |>\nIt returns [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n<| c |>\n\
    It returns [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n<| a tags=algorithm,string,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Text.RegularExpressions;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpph39q8aa.d(46): Error: Declaration expected, not \''<\''\n/tmp/tmpph39q8aa.d(49):
    Error: unterminated character constant\n/tmp/tmpph39q8aa.d(66): Error: semicolon
    expected, not \''.\''\n/tmp/tmpph39q8aa.d(66): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpph39q8aa.d(67): Error: semicolon expected, not \''.\''\n/tmp/tmpph39q8aa.d(67):
    Error: no identifier for declarator .Linq\n/tmp/tmpph39q8aa.d(68): Error: semicolon
    expected, not \''.\''\n/tmp/tmpph39q8aa.d(68): Error: no identifier for declarator
    .Text\n/tmp/tmpph39q8aa.d(69): Error: semicolon expected, not \''.\''\n/tmp/tmpph39q8aa.d(69):
    Error: no identifier for declarator .Text.RegularExpressions\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpph39q8aa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkza_51xr.d(63): Error: no identifier for declarator long\n/tmp/tmpkza_51xr.d(63):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkza_51xr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i] ==\
    \ '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,c#,parentheses\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.IO;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1oo514go.d(30): Error: Declaration expected, not \''<\''\n/tmp/tmp1oo514go.d(35):
    Error: semicolon expected, not \''.\''\n/tmp/tmp1oo514go.d(35): Error: no identifier
    for declarator .Collections.Generic\n/tmp/tmp1oo514go.d(36): Error: semicolon
    expected, not \''.\''\n/tmp/tmp1oo514go.d(36): Error: no identifier for declarator
    .Linq\n/tmp/tmp1oo514go.d(37): Error: semicolon expected, not \''.\''\n/tmp/tmp1oo514go.d(37):
    Error: no identifier for declarator .Text\n/tmp/tmp1oo514go.d(38): Error: semicolon
    expected, not \''.\''\n/tmp/tmp1oo514go.d(38): Error: no identifier for declarator
    .IO\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1oo514go.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1v7avsvg.d(86): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1v7avsvg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_opening = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing = false;\n    bool is_closing_paren_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_paren = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening = false;\n \
    \   bool is_closing_paren_or_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpttc18qaz.d(44): Error: semicolon expected, not \''unittest\''\n/tmp/tmpttc18qaz.d(44):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpttc18qaz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    bool\
    \ is_first = true;\n    bool is_last = true;\n    bool is_last_in_group = false;\n\
    \    bool is_last_in_group_prev = false;\n    bool is_last_in_group_next = false;\n\
    \    bool is_last_in_group_next_prev = false;\n    bool is_last_in_group_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_prev = false;\n    bool is_last_in_group_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_prev = false;\n\
    \    bool is_last_in_group_next_next_next_next_next_next_prev = false;\n    bool\
    \ is_last_in_group_next_next_next_next_next_next_next_prev = false;\n    bool\
    \ is_last_in_group_next_next_next_next_next_next_next_next_prev = false;\n   \
    \ bool is_last_in_group_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsewbbi8y.d(47): Error: semicolon expected, not \''unittest\''\n/tmp/tmpsewbbi8y.d(47):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpsewbbi8y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] current_levels = new long[paren_string.length()];\n\
    \    long[] max_levels = new long[paren_string.length()];\n    long[] current_max_levels\
    \ = new long[paren_string.length()];\n    long[] current_levels_index = new long[paren_string.length()];\n\
    \    long[] current_max_levels_index = new long[paren_string.length()];\n    long[]\
    \ current_levels_index_in_parens = new long[paren_string.length()];\n    long[]\
    \ current_max_levels_index_in_parens = new long[paren_string.length()];\n    long[]\
    \ current_levels_index_in_parens_index = new long[paren_string.length()];\n  \
    \  long[] current_max_levels_index_in_parens_index = new long[paren_string.length()];\n\
    \    long[] current_levels_index_in_parens_index_in_parens = new long[paren_string.length()];\n\
    \    long[] current_max_levels_index_in_parens_index_in_parens = new long[paren_string.length()];\n\
    \    long[] current_levels_index_in_parens_index_in_parens_index = new long[paren_string.length()];\n\
    \    long[] current_max_levels_index_in_parens_index_in_parens_index = new long[paren_string.length()];\n\
    \    long[] current_levels_index_in_parens_index_in_parens_index_in_parens = new\
    \ long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8kxp4x6n.d(38): Error: no identifier for declarator long\n/tmp/tmp8kxp4x6n.d(38):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp8kxp4x6n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n    long paren_levels_index47\
    \ = 0;\n    long paren_levels_index48 = 0;\n    long paren_levels_index49 = 0;\n\
    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu9pcd380.d(67): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9pcd380.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pos = 0;\n    long level_stack_len = MAX_LEVELS;\n    long\
    \ paren_level = 0;\n    long paren_level_stack[MAX_LEVELS];\n    long paren_level_stack_pos\
    \ = 0;\n    long paren_level_stack_len = MAX_LEVELS;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_stack[MAX_LEVELS];\n    long paren_level_count_stack_pos\
    \ = 0;\n    long paren_level_count_stack_len = MAX_LEVELS;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pos\
    \ = 0;\n    long paren_level_count_max_stack_len = MAX_LEVELS;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pos\
    \ = 0;\n    long paren_level_count_min_stack_len = MAX_LEVELS;\n    long paren_level_count_sum\
    \ = 0;\n    long paren_level_count_sum_stack[MAX_LEVELS];\n    long paren_level_count_sum_stack_pos\
    \ = 0;\n    long paren_level_count_sum_stack_len = MAX_LEVELS;\n    long paren_level_count_avg\
    \ = 0;\n    long paren_level_count_avg_stack[MAX_LEVELS];\n    long paren_level_count_avg_stack_pos\
    \ = 0;\n    long paren_level_count_avg_stack_len = MAX_LEVELS;\n    long paren_level_count_sum2\
    \ = 0;\n    long paren_level_count_sum2_stack[MAX_LEVELS];\n    long paren_level_count_sum2_stack_pos\
    \ = 0;\n    long paren_level_count_sum2_stack_len = MAX_LEVELS;\n    long paren_level_count_sum3\
    \ = 0;\n    long paren_level_count_sum3_stack[MAX_LEVELS];\n    long paren_level_count_sum3_stack_pos\
    \ = 0;\n    long paren_level_count_sum3_stack_len = MAX_LEVELS;\n    long paren_level_count_sum4\
    \ = 0;\n    long paren_level_count_sum4_stack[MAX_LEVELS];\n    long paren_level_count_sum4_stack_pos\
    \ = 0;\n    long paren_level_count_sum4_stack_len = MAX_LEVELS;\n    long paren_level_count_sum5\
    \ = 0;\n    long paren_level_count_sum5_stack[MAX_LEVELS];\n    long paren_level_count_sum5_stack_pos\
    \ = 0;\n    long paren_level_count_sum\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0lf9wzl_.d(59): Error: semicolon expected, not \''unittest\''\n/tmp/tmp0lf9wzl_.d(59):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0lf9wzl_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close_brace_close = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5ao_9y8l.d(42): Error: semicolon expected, not \''unittest\''\n/tmp/tmp5ao_9y8l.d(42):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp5ao_9y8l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    stack<int> level_stack = new stack<int>();\n    bool in_paren\
    \ = false;\n    bool in_level_stack = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            paren_stack.push(i);\n            in_paren = true;\n      \
    \  }\n        else if(c == ')')\n        {\n            int paren_index = paren_stack.top();\n\
    \            paren_stack.pop();\n            int level = 0;\n            while(paren_index\
    \ != -1)\n            {\n                level++;\n                paren_index\
    \ = paren_stack.top();\n                paren_stack.pop();\n            }\n  \
    \          levels[levelsIndex++] = level;\n            in_level_stack = false;\n\
    \        }\n        else if(c == '(' || c == '[' || c == '{')\n        {\n   \
    \         int level = 0;\n            while(level_stack.top() != -1)\n       \
    \     {\n                level++;\n                level_stack.pop();\n      \
    \      }\n            level_stack.push(level);\n            in_level_stack = true;\n\
    \        }\n        else if(c == ']' || c == '}' || c == ')' || c == ']' || c\
    \ == '}')\n        {\n            int level = level_stack.top();\n           \
    \ level_stack.pop();\n            int paren_index = paren_stack.top();\n     \
    \       paren_stack.pop();\n            while(levels[levelsIndex--] != level)\n\
    \                levelsIndex--;\n            in_level_stack = false;\n       \
    \ }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c\
    \ |>\nThanks for your answer. Your code works fine for parenthesis containing\
    \ only two levels of nesting. However, it fails for parenthesis containing three\
    \ or more levels of nesting.\n<|/ c |>\n<| c |>\nI tested it on `((())) () ((())()())`\
    \ and it returned `[3, 3, 1, 3]`\n<|/ c |>\n<| c |>\nI tested it on `((())) ()\
    \ ((())()())` and it returned `[3, 3, 1, 3]`\n<|/ c |>\n<| c |>\nI tested it on\
    \ `((())) () ((())()())` and it returned `[3, 3, 1, 3]`\n<|/ c |>\n<| c |>\nI\
    \ tested it on `((())) () ((())()())` and it returned `[3, 3, 1, 3]`\n<|/ c |>\n\
    <| a dscore=0 |>\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpys59jocx.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpys59jocx.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpys59jocx.d(15): Error: found \''(\'' when expecting identifier
    following \''int.\''\n/tmp/tmpys59jocx.d(15): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpys59jocx.d(16): Error: found \''>\'' when
    expecting \''.\'' following int\n/tmp/tmpys59jocx.d(16): Error: found \''>\''
    when expecting \''.\'' following int\n/tmp/tmpys59jocx.d(16): Error: found \''(\''
    when expecting identifier following \''int.\''\n/tmp/tmpys59jocx.d(16): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmpys59jocx.d(65):
    Error: Declaration expected, not \''<\''\n/tmp/tmpys59jocx.d(88): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpys59jocx.d(89): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpys59jocx.d(90): Error: Declaration expected, not \''assert\''\n/tmp/tmpys59jocx.d(91):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpys59jocx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    for(char c : paren_string)\n    {\n        if(c != '('\
    \ && c != ')')\n        {\n            levels[index] = level;\n            index++;\n\
    \        }\n        else if(c != '(')\n        {\n            level++;\n     \
    \   }\n        else\n        {\n            level--;\n        }\n        if(level\
    \ > max_level)\n        {\n            max_level = level;\n        }\n    }\n\
    \    return levels;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c |>\nI like\
    \ your solution. Very elegant and simple. Thanks!\n<|/ c |>\n<| a tags=algorithm,c++\
    \ |>\nI wrote a recursive solution in Python that works well for me:\n<code>\n\
    def paren_count(s):\n    level = 0\n    count = 0\n    for c in s:\n        if\
    \ c == '(':\n            level += 1\n        elif c == ')':\n            level\
    \ -= 1\n        if level == 0:\n            count += 1\n    return count\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxjzmklkr.d(18): Error: semicolon expected, not \'':\''\n/tmp/tmpxjzmklkr.d(18):
    Error: expression expected, not \'':\''\n/tmp/tmpxjzmklkr.d(18): Error: found
    \''paren_string\'' when expecting \'';\'' following for condition\n/tmp/tmpxjzmklkr.d(40):
    Error: Declaration expected, not \''<\''\n/tmp/tmpxjzmklkr.d(63): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpxjzmklkr.d(64): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpxjzmklkr.d(65): Error: Declaration expected, not \''assert\''\n/tmp/tmpxjzmklkr.d(66):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxjzmklkr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren\
    \ = false;\n    bool has_opening_paren_or_closing_paren = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjjdl6k62.d(34): Error: semicolon expected, not \''unittest\''\n/tmp/tmpjjdl6k62.d(34):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjjdl6k62.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_paren\
    \ = false;\n    bool in_paren_group_close_paren = false;\n    bool in_paren_group_open_curly\
    \ = false;\n    bool in_paren_group_close_curly = false;\n    bool in_paren_group_open_angle\
    \ = false;\n    bool in_paren_group_close_angle = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp62hdohpf.d(65): Error: semicolon expected, not \''unittest\''\n/tmp/tmp62hdohpf.d(65):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp62hdohpf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4lrq2s1s.d(46): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4lrq2s1s.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long i = 0;\n    bool inside_group = false;\n    bool inside_paren\
    \ = false;\n    bool inside_paren_group = false;\n    bool inside_paren_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group = false;\n    bool inside_paren_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group =\
    \ false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0zse_kyn.d(40): Error: semicolon expected, not \''unittest\''\n/tmp/tmp0zse_kyn.d(40):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0zse_kyn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(c == ')') {\n            level--;\n            if(level\
    \ == 0) {\n                max_level = max(max_level, levels[level]);\n      \
    \      }\n        }\n    }\n    return max_level;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with `\"(()()) ((())) () ((())()())\"\
    `\n<|/ c |>\n<| c |>\nI tested it and it works. I added the test case to the answer.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `((()))` - it returns `1` instead of `3`.\n\
    <|/ c |>\n<| c |>\nIt works for me. Are you sure you copied the code correctly?\
    \ I tested it with `\"(()()) ((())) () ((())()())\"` and it returns `[2L, 3L,\
    \ 1L, 3L]`.\n<|/ c |>\n<| c |>\nI tested it again and it works. I added the test\
    \ case to the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;\nclass GFG\n{\n    public static void main\
    \ (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new\
    \ Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n\
    \        for(int i=0;i<n;i++)\n        {\n            String s = sc.nextLine();\n\
    \            int l = s.length();\n            int count = 0;\n            for(int\
    \ j=0;j<l;j++)\n            {\n                if(s.charAt(j)=='(')\n        \
    \        {\n                    count++;\n                }\n                if(s.charAt(j)==')')\n\
    \                {\n                    count--;\n                }\n        \
    \    }\n            System.out.println(count);\n        }\n    }\n}\n</code>\n\
    <|/ a tags=java,algorithm |>\n<| c |>\nThis doesn't work. Try it with `\"(()())\
    \ ((())) () ((())()())\"`\n<|/ c |>\n<| c |>\nI tested it and it works. I added\
    \ the test case to the answer.\n<|/ c |>\n<| c |>\nIt doesn't work for `((()))`\
    \ - it returns `1` instead of `\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4w8rvg5s.d(32): Error: Declaration expected, not \''<\''\n/tmp/tmp4w8rvg5s.d(35):
    Error: unterminated character constant\n/tmp/tmp4w8rvg5s.d(41): Error: unterminated
    character constant\n/tmp/tmp4w8rvg5s.d(52): Error: identifier expected following
    package\n/tmp/tmp4w8rvg5s.d(52): Error: \'';\'' expected\n/tmp/tmp4w8rvg5s.d(53):
    Error: identifier expected following package\n/tmp/tmp4w8rvg5s.d(53): Error: \'';\''
    expected\n/tmp/tmp4w8rvg5s.d(56): Error: semicolon expected following function
    declaration\n/tmp/tmp4w8rvg5s.d(56): Error: semicolon expected, not \''.\''\n/tmp/tmp4w8rvg5s.d(57):
    Error: no identifier for declarator .lang.Exception\n/tmp/tmp4w8rvg5s.d(57): Error:
    Declaration expected, not \''{\''\n/tmp/tmp4w8rvg5s.d(60): Error: function declaration
    without return type. (Note that constructors are always named \''this\'')\n/tmp/tmp4w8rvg5s.d(60):
    Error: no identifier for declarator sc.nextLine()\n/tmp/tmp4w8rvg5s.d(61): Error:
    Declaration expected, not \''for\''\n/tmp/tmp4w8rvg5s.d(61): Error: no identifier
    for declarator i\n/tmp/tmp4w8rvg5s.d(61): Error: Declaration expected, not \''<\''\n/tmp/tmp4w8rvg5s.d(61):
    Error: no identifier for declarator i\n/tmp/tmp4w8rvg5s.d(61): Error: Declaration
    expected, not \''++\''\n/tmp/tmp4w8rvg5s.d(66): Error: Declaration expected, not
    \''for\''\n/tmp/tmp4w8rvg5s.d(66): Error: no identifier for declarator j\n/tmp/tmp4w8rvg5s.d(66):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp4w8rvg5s.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_group;\n    long max_level = 0;\n    long[] levels = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        paren_group\
    \ = paren_string.substr(i, paren_string.length() - i);\n        if(paren_group.length()\
    \ > max_level)\n        {\n            max_level = paren_group.length();\n   \
    \     }\n        levels[i] = max_level;\n    }\n    return levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc341kohs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_opener = false;\n    bool in_paren_group_closer\
    \ = false;\n    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_close\
    \ = false;\n    bool in_paren_group_opener_open = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_opener_closed = false;\n    bool in_paren_group_closer_closed\
    \ = false;\n    bool in_paren_group_opener_opener = false;\n    bool in_paren_group_closer_opener\
    \ = false;\n    bool in_paren_group_opener_closer = false;\n    bool in_paren_group_closer_closer\
    \ = false;\n    bool in_paren_group_opener_opener_closed = false;\n    bool in_paren_group_closer_opener_closed\
    \ = false;\n    bool in_paren_group_opener_closer_closed = false;\n    bool in_paren_group_opener_closer_open\
    \ = false;\n    bool in_paren_group_closer_closer_open = false;\n    bool in_paren_group_opener_closer_closer_close\
    \ = false;\n    bool in_paren_group_opener_closer_closer_open = false;\n    bool\
    \ in_paren_group_closer_closer_closer_close = false;\n    bool in_paren_group_opener_closer_closer_closer_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer_close = false;\n\
    \    bool in_paren_group_opener_closer_closer_closer_closer_open = false;\n  \
    \  bool in_paren_group_closer_closer_closer_closer_closer_close = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_closer_closer_open = false;\n\
    \    bool in_paren_group_closer_closer_closer_closer_closer_closer_close = false;\n\
    \    bool in_paren_group_opener_closer_closer_closer_closer_closer_closer_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer_closer_closer_close\
    \ = false;\n    bool in_paren_group_opener_closer_closer_closer_closer_closer_closer_close\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer_closer_closer_closer_close\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2bbd1tzj.d(52): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2bbd1tzj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_eu6dj5c.d(67): Error: semicolon expected, not \''unittest\''\n/tmp/tmp_eu6dj5c.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_eu6dj5c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string opening_paren_chars = \"((\";\n    string\
    \ closing_paren_chars = \")\";\n    string opening_paren_chars_count = paren_chars.size();\n\
    \    string closing_paren_chars_count = paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0h4f6h2n.d(44): Error: semicolon expected, not \''unittest\''\n/tmp/tmp0h4f6h2n.d(44):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0h4f6h2n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    string parens[] = paren_string.split(\" \");\n    for(long i = 0; i < parens.length;\
    \ ++i)\n    {\n        string paren = parens[i];\n        string paren_copy =\
    \ paren;\n        while(paren_copy.size() > 0)\n        {\n            char c\
    \ = paren_copy[0];\n            paren_copy = paren_copy.substr(1);\n         \
    \   if(c == '(')\n            {\n                ++level;\n                levels[level]\
    \ = level;\n            }\n            else if(c == ')')\n            {\n    \
    \            --level;\n                if(level < 0)\n                {\n    \
    \                throw new Exception(\"Unbalanced parenthesis\");\n          \
    \      }\n                levels[level] = level;\n            }\n        }\n \
    \       if(level > max_level)\n        {\n            max_level = level;\n   \
    \     }\n    }\n    long[] result = new long[max_level + 1];\n    for(long i =\
    \ 0; i < max_level; ++i)\n    {\n        result[i] = levels[i];\n    }\n    result[max_level]\
    \ = max_level;\n    return result;\n}\n</code>\n<|/ a tags=algorithm,string,java\
    \ |>\n<| c |>\nThis solution doesn't work for nested parentheses such as \"(()())\"\
    \n<|/ c |>\n<| c |>\nYes, it does. I tested it on \"(()())\" and it returned [2,3,1,1,3]\n\
    <|/ c |>\n<| c |>\nIt doesn't work for \"(()())\" because you only count the outer\
    \ parentheses, not the inner ones.\n<|/ c |>\n<| c |>\nYes, I tested it on \"\
    (()())\" and it returned [2,3,1,1,3]\n<|/ c |>\n<| c |>\nI tested it on \"(()())\"\
    \ and it returned [2,3,1,1,3]\n<|/ c |>\n<| a tags=algorithm,string,java |>\n\
    <code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppx8lzl8k.d(54): Error: Declaration expected, not \''<\''\n/tmp/tmppx8lzl8k.d(57):
    Error: unterminated character constant\n/tmp/tmppx8lzl8k.d(63): Error: unterminated
    character constant\n/tmp/tmppx8lzl8k.d(74): Error: identifier expected following
    package\n/tmp/tmppx8lzl8k.d(74): Error: \'';\'' expected\n/tmp/tmppx8lzl8k.d(75):
    Error: identifier expected following package\n/tmp/tmppx8lzl8k.d(75): Error: \'';\''
    expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppx8lzl8k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool has_open = false;\n    bool\
    \ has_close = false;\n    long level = 0;\n    long levels_sum = 0;\n    long\
    \ levels_max = 0;\n    long levels_max_index = 0;\n    long levels_max_index2\
    \ = 0;\n    long levels_max_index3 = 0;\n    long levels_max_index4 = 0;\n   \
    \ long levels_max_index5 = 0;\n    long levels_max_index6 = 0;\n    long levels_max_index7\
    \ = 0;\n    long levels_max_index8 = 0;\n    long levels_max_index9 = 0;\n   \
    \ long levels_max_index10 = 0;\n    long levels_max_index11 = 0;\n    long levels_max_index12\
    \ = 0;\n    long levels_max_index13 = 0;\n    long levels_max_index14 = 0;\n \
    \   long levels_max_index15 = 0;\n    long levels_max_index16 = 0;\n    long levels_max_index17\
    \ = 0;\n    long levels_max_index18 = 0;\n    long levels_max_index19 = 0;\n \
    \   long levels_max_index20 = 0;\n    long levels_max_index21 = 0;\n    long levels_max_index22\
    \ = 0;\n    long levels_max_index23 = 0;\n    long levels_max_index24 = 0;\n \
    \   long levels_max_index25 = 0;\n    long levels_max_index26 = 0;\n    long levels_max_index27\
    \ = 0;\n    long levels_max_index28 = 0;\n    long levels_max_index29 = 0;\n \
    \   long levels_max_index30 = 0;\n    long levels_max_index31 = 0;\n    long levels_max_index32\
    \ = 0;\n    long levels_max_index33 = 0;\n    long levels_max_index34 = 0;\n \
    \   long levels_max_index35 = 0;\n    long levels_max_index36 = 0;\n    long levels_max_index37\
    \ = 0;\n    long levels_max_index38 = 0;\n    long levels_max_index39 = 0;\n \
    \   long levels_max_index40 = 0;\n    long levels_max_index41 = 0;\n    long levels_max_index42\
    \ = 0;\n    long levels_max_index43 = 0;\n    long levels_max_index44 = 0;\n \
    \   long levels_max_index45 = 0;\n    long levels_max_index46 = 0;\n    long levels_max_index47\
    \ = 0;\n    long levels_max_index48 = 0;\n    long levels_max_index49 = 0;\n \
    \   long levels_max_index50 = 0;\n    long levels_max_index51 = 0;\n    long levels_max_index52\
    \ = 0;\n    long levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9334upf7.d(73): Error: semicolon expected, not \''unittest\''\n/tmp/tmp9334upf7.d(73):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp9334upf7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    bool in_paren = false;\n    bool in_paren_prev\
    \ = false;\n    bool in_paren_next_prev = false;\n    bool in_paren_next_next\
    \ = false;\n    bool in_paren_next_next_prev = false;\n    bool in_paren_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_prev = false;\n  \
    \  bool in_paren_next_next_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1a4eaf2a.d(47): Error: semicolon expected, not \''unittest\''\n/tmp/tmp1a4eaf2a.d(47):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1a4eaf2a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_open_brace_close_brace = false;\n    bool in_paren_group_open_brace_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_open_brace = false;\n\
    \    bool in_paren_group_open_brace_close_brace_close_brace_close = false;\n \
    \   bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close_brace_open = false;\n    bool\
    \ in_paren_group_close_brace_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open_brace_close =\
    \ false;\n    bool in_paren_group_close_bra\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkwq3d47h.d(49): Error: semicolon expected, not \''unittest\''\n/tmp/tmpkwq3d47h.d(49):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkwq3d47h.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_closing_square_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_square_bracket_or_paren_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_closing_square_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_square_bracket_or_paren_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmposkb8qwq.d(51): Error: semicolon expected, not \''unittest\''\n/tmp/tmposkb8qwq.d(51):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmposkb8qwq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2d6vcb8j.d(79): Error: no identifier for declarator long\n/tmp/tmp2d6vcb8j.d(79):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2d6vcb8j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 0;\n    long level_max = 0;\n    long level_max_size = 0;\n    long level_max_max\
    \ = 0;\n    long level_max_max_size = 0;\n    long level_max_max_max = 0;\n  \
    \  long level_max_max_max_size = 0;\n    long level_max_max_max_max = 0;\n   \
    \ long level_max_max_max_max_size = 0;\n    long level_max_max_max_max_max = 0;\n\
    \    long level_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_size = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max = 0;\n    long level_max_max_max_max_max_max_max_max_max_size\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_size = 0;\n   \
    \ long level_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_size\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_size = 0;\n\
    \    long level_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9dm5tr_b.d(55): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9dm5tr_b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long max_level = 0;\n    long\
    \ level = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n    bool\
    \ in_brace = false;\n    bool in_curly = false;\n    bool in_paren_group = false;\n\
    \    bool in_bracket_group = false;\n    bool in_brace_group = false;\n    bool\
    \ in_curly_group = false;\n    bool in_paren_group_open = false;\n    bool in_bracket_group_open\
    \ = false;\n    bool in_brace_group_open = false;\n    bool in_curly_group_open\
    \ = false;\n    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed\
    \ = false;\n    bool in_brace_group_closed = false;\n    bool in_curly_group_closed\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_bracket_group_open_brace\
    \ = false;\n    bool in_brace_group_open_brace = false;\n    bool in_curly_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_curly_group_closed_brace\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_bracket_group_open_bracket\
    \ = false;\n    bool in_brace_group_open_bracket = false;\n    bool in_curly_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_curly_group_closed_bracket\
    \ = false;\n    bool in_paren_group_open_brace_group = false;\n    bool in_bracket_group_open_brace_group\
    \ = false;\n    bool in_brace_group_open_brace_group = false;\n    bool in_curly_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_curly_group_closed_brace_group\
    \ = false;\n    bool in_paren_group_open_brace_group_open = false;\n    bool in_bracket_group_open_brace_group_open\
    \ = false;\n    bool in_brace_group_open_brace_group_open = false;\n    bool in_curly_group_open_brace_group_open\
    \ = false;\n    bool in_paren_group_closed_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt10a56cd.d(62): Error: semicolon expected, not \''unittest\''\n/tmp/tmpt10a56cd.d(62):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpt10a56cd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp37cl6ugl.d(75): Error: semicolon expected, not \''unittest\''\n/tmp/tmp37cl6ugl.d(75):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp37cl6ugl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3m3d92on.d(48): Error: semicolon expected, not \''unittest\''\n/tmp/tmp3m3d92on.d(48):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3m3d92on.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    long paren_stack_pointer = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_stack[MAX_LEVELS];\n    long paren_level_stack_pointer\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_stack[MAX_LEVELS];\n\
    \    long paren_level_count_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_r7j8lba.d(62): Error: semicolon expected, not \''unittest\''\n/tmp/tmp_r7j8lba.d(62):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_r7j8lba.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_char = \"()\";\n    string paren_char2 = \"()\";\n    string paren_char3\
    \ = \"()\";\n    string paren_char4 = \"()\";\n    string paren_char5 = \"()\"\
    ;\n    string paren_char6 = \"()\";\n    string paren_char7 = \"()\";\n    string\
    \ paren_char8 = \"()\";\n    string paren_char9 = \"()\";\n    string paren_char10\
    \ = \"()\";\n    string paren_char11 = \"()\";\n    string paren_char12 = \"()\"\
    ;\n    string paren_char13 = \"()\";\n    string paren_char14 = \"()\";\n    string\
    \ paren_char15 = \"()\";\n    string paren_char16 = \"()\";\n    string paren_char17\
    \ = \"()\";\n    string paren_char18 = \"()\";\n    string paren_char19 = \"()\"\
    ;\n    string paren_char20 = \"()\";\n    string paren_char21 = \"()\";\n    string\
    \ paren_char22 = \"()\";\n    string paren_char23 = \"()\";\n    string paren_char24\
    \ = \"()\";\n    string paren_char25 = \"()\";\n    string paren_char26 = \"()\"\
    ;\n    string paren_char27 = \"()\";\n    string paren_char28 = \"()\";\n    string\
    \ paren_char29 = \"()\";\n    string paren_char30 = \"()\";\n    string paren_char31\
    \ = \"()\";\n    string paren_char32 = \"()\";\n    string paren_char33 = \"()\"\
    ;\n    string paren_char34 = \"()\";\n    string paren_char35 = \"()\";\n    string\
    \ paren_char36 = \"()\";\n    string paren_char37 = \"()\";\n    string paren_char38\
    \ = \"()\";\n    string paren_char39 = \"()\";\n    string paren_char40 = \"()\"\
    ;\n    string paren_char41 = \"()\";\n    string paren_char42 = \"()\";\n    string\
    \ paren_char43 = \"()\";\n    string paren_char44 = \"()\";\n    string paren_char45\
    \ = \"()\";\n    string paren_char46 = \"()\";\n    string paren_char47 = \"()\"\
    ;\n    string paren_char48 = \"()\";\n    string paren_char49 = \"()\";\n    string\
    \ paren_char50 = \"()\";\n    string paren_char51 = \"\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx89pwgua.d(69): Error: expression expected, not \'')\''\n/tmp/tmpx89pwgua.d(69):
    Error: expression expected, not \'')\''\n/tmp/tmpx89pwgua.d(69): Error: expression
    expected, not \'')\''\n/tmp/tmpx89pwgua.d(69): Error: found \''") == [2L, 3L,
    1L, 3L]);\\x0a    assert(candidate("\'' when expecting \'',\''\n/tmp/tmpx89pwgua.d(70):
    Error: expression expected, not \'')\''\n/tmp/tmpx89pwgua.d(70): Error: expression
    expected, not \'')\''\n/tmp/tmpx89pwgua.d(70): Error: expression expected, not
    \'')\''\n/tmp/tmpx89pwgua.d(70): Error: expression expected, not \'')\''\n/tmp/tmpx89pwgua.d(70):
    Error: found \''") == [1L, 2L, 3L, 4L]);\\x0a    assert(candidate("\'' when expecting
    \'',\''\n/tmp/tmpx89pwgua.d(71): Error: unterminated string constant starting
    at /tmp/tmpx89pwgua.d(71)\n/tmp/tmpx89pwgua.d(71): Error: expression expected,
    not \'')\''\n/tmp/tmpx89pwgua.d(71): Error: expression expected, not \'')\''\n/tmp/tmpx89pwgua.d(71):
    Error: expression expected, not \'')\''\n/tmp/tmpx89pwgua.d(71): Error: found
    \''""\'' when expecting \'',\''\n/tmp/tmpx89pwgua.d(73): Error: found \''EOF\''
    when expecting \'')\''\n/tmp/tmpx89pwgua.d(71): Error: found \''EOF\'' when expecting
    \'')\''\n/tmp/tmpx89pwgua.d(71): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmpx89pwgua.d(73):
    Error: found \''EOF\'' when expecting \'',\''\n/tmp/tmpx89pwgua.d(73): Error:
    found \''EOF\'' when expecting \'')\''\n/tmp/tmpx89pwgua.d(73): Error: found \''EOF\''
    when expecting \'',\''\n/tmp/tmpx89pwgua.d(73): Error: found \''EOF\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx89pwgua.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string current_paren_string = paren_string;\n    string next_paren_string;\n\
    \    bool has_next_paren = false;\n    bool has_next_paren_pair = false;\n   \
    \ bool has_next_paren_pair2 = false;\n    bool has_next_paren_pair3 = false;\n\
    \    bool has_next_paren_pair4 = false;\n    bool has_next_paren_pair5 = false;\n\
    \    bool has_next_paren_pair6 = false;\n    bool has_next_paren_pair7 = false;\n\
    \    bool has_next_paren_pair8 = false;\n    bool has_next_paren_pair9 = false;\n\
    \    bool has_next_paren_pair10 = false;\n    bool has_next_paren_pair11 = false;\n\
    \    bool has_next_paren_pair12 = false;\n    bool has_next_paren_pair13 = false;\n\
    \    bool has_next_paren_pair14 = false;\n    bool has_next_paren_pair15 = false;\n\
    \    bool has_next_paren_pair16 = false;\n    bool has_next_paren_pair17 = false;\n\
    \    bool has_next_paren_pair18 = false;\n    bool has_next_paren_pair19 = false;\n\
    \    bool has_next_paren_pair20 = false;\n    bool has_next_paren_pair21 = false;\n\
    \    bool has_next_paren_pair22 = false;\n    bool has_next_paren_pair23 = false;\n\
    \    bool has_next_paren_pair24 = false;\n    bool has_next_paren_pair25 = false;\n\
    \    bool has_next_paren_pair26 = false;\n    bool has_next_paren_pair27 = false;\n\
    \    bool has_next_paren_pair28 = false;\n    bool has_next_paren_pair29 = false;\n\
    \    bool has_next_paren_pair30 = false;\n    bool has_next_paren_pair31 = false;\n\
    \    bool has_next_paren_pair32 = false;\n    bool has_next_paren_pair33 = false;\n\
    \    bool has_next_paren_pair34 = false;\n    bool has_next_paren_pair35 = false;\n\
    \    bool has_next_paren_pair36 = false;\n    bool has_next_paren_pair37 = false;\n\
    \    bool has_next_paren_pair38 = false;\n    bool has_next_paren_pair39 = false;\n\
    \    bool has_next_paren_pair40 = false;\n    bool has_next_paren_pair41 = false;\n\
    \    bool has_next_paren_pair42 = false;\n    bool has_next_paren_pair43 = false;\n\
    \    bool has_next_paren_pair44 = false;\n    bool has_next_paren_pair45 = false;\n\
    \    bool has_next_paren_pair4\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxgwrgc_j.d(66): Error: semicolon expected, not \''unittest\''\n/tmp/tmpxgwrgc_j.d(66):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpxgwrgc_j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            if(!in_paren)\n        \
    \    {\n                level++;\n                levels[level] = level;\n   \
    \         }\n            in_paren = true;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            if(!in_paren)\n            {\n             \
    \   level--;\n                levels[level] = level;\n            }\n        \
    \    in_paren = false;\n        }\n    }\n    return levels;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmcloi8op.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool has_open = false;\n    bool has_close = false;\n    bool has_open_brace\
    \ = false;\n    bool has_close_brace = false;\n    bool has_open_paren = false;\n\
    \    bool has_close_paren = false;\n    bool has_open_curly = false;\n    bool\
    \ has_close_curly = false;\n    bool has_open_paren_or_curly = false;\n    bool\
    \ has_close_paren_or_curly = false;\n    bool has_open_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiay0kb0_.d(49): Error: semicolon expected, not \''unittest\''\n/tmp/tmpiay0kb0_.d(49):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpiay0kb0_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool has_opening_bracket = false;\n\
    \    bool has_closing_bracket = false;\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long current_level = 0;\n    long current_index\
    \ = 0;\n    long current_paren_level = 0;\n    long current_paren_index = 0;\n\
    \    long current_paren_level_index = 0;\n    long current_paren_level_size =\
    \ 0;\n    long current_paren_index = 0;\n    long current_paren_level_size = 0;\n\
    \    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps0kcm74k.d(69): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0kcm74k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close = false;\n    bool in_group_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_or_open = false;\n    bool in_group_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace = false;\n   \
    \ bool in_group_close_brace_or_open_or_close_brace = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open = false;\n\
    \    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open = false;\n\
    \    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close = false;\n\
    \    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace =\
    \ false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy99ue4we.d(43): Error: semicolon expected, not \''unittest\''\n/tmp/tmpy99ue4we.d(43):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy99ue4we.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    long levels_index2 = 0;\n\
    \    long levels_index3 = 0;\n    long levels_index4 = 0;\n    long levels_index5\
    \ = 0;\n    long levels_index6 = 0;\n    long levels_index7 = 0;\n    long levels_index8\
    \ = 0;\n    long levels_index9 = 0;\n    long levels_index10 = 0;\n    long levels_index11\
    \ = 0;\n    long levels_index12 = 0;\n    long levels_index13 = 0;\n    long levels_index14\
    \ = 0;\n    long levels_index15 = 0;\n    long levels_index16 = 0;\n    long levels_index17\
    \ = 0;\n    long levels_index18 = 0;\n    long levels_index19 = 0;\n    long levels_index20\
    \ = 0;\n    long levels_index21 = 0;\n    long levels_index22 = 0;\n    long levels_index23\
    \ = 0;\n    long levels_index24 = 0;\n    long levels_index25 = 0;\n    long levels_index26\
    \ = 0;\n    long levels_index27 = 0;\n    long levels_index28 = 0;\n    long levels_index29\
    \ = 0;\n    long levels_index30 = 0;\n    long levels_index31 = 0;\n    long levels_index32\
    \ = 0;\n    long levels_index33 = 0;\n    long levels_index34 = 0;\n    long levels_index35\
    \ = 0;\n    long levels_index36 = 0;\n    long levels_index37 = 0;\n    long levels_index38\
    \ = 0;\n    long levels_index39 = 0;\n    long levels_index40 = 0;\n    long levels_index41\
    \ = 0;\n    long levels_index42 = 0;\n    long levels_index43 = 0;\n    long levels_index44\
    \ = 0;\n    long levels_index45 = 0;\n    long levels_index46 = 0;\n    long levels_index47\
    \ = 0;\n    long levels_index48 = 0;\n    long levels_index49 = 0;\n    long levels_index50\
    \ = 0;\n    long levels_index51 = 0;\n    long levels_index52 = 0;\n    long levels_index53\
    \ = 0;\n    long levels_index54 = 0;\n    long levels_index55 = 0;\n    long levels_index56\
    \ = 0;\n    long levels_index57 = 0;\n    long levels_index58 = 0;\n    long levels_index59\
    \ = 0;\n    long levels_index60 = 0;\n    long levels_index61\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvib0hin2.d(79): Error: semicolon expected, not \''unittest\''\n/tmp/tmpvib0hin2.d(79):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpvib0hin2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_index = 0;\n    bool paren_found\
    \ = false;\n    bool paren_open = false;\n    bool paren_closed = false;\n   \
    \ bool paren_opening = false;\n    bool paren_closing = false;\n    bool paren_opening_found\
    \ = false;\n    bool paren_closing_found = false;\n    bool paren_opening_paren_found\
    \ = false;\n    bool paren_closing_paren_found = false;\n    bool paren_opening_paren_closing\
    \ = false;\n    bool paren_closing_paren_closing = false;\n    bool paren_opening_paren_closing_found\
    \ = false;\n    bool paren_closing_paren_closing_found = false;\n    bool paren_opening_paren_closing_paren_found\
    \ = false;\n    bool paren_closing_paren_closing_paren_found = false;\n    bool\
    \ paren_opening_paren_closing_paren_closing = false;\n    bool paren_closing_paren_closing_paren_closing\
    \ = false;\n    bool paren_opening_paren_closing_paren_closing_found = false;\n\
    \    bool paren_closing_paren_closing_paren_closing_found = false;\n    bool paren_opening_paren_closing_paren_closing_paren_found\
    \ = false;\n    bool paren_closing_paren_closing_paren_closing_paren_found = false;\n\
    \    bool paren_opening_paren_closing_paren_closing_paren_closing = false;\n \
    \   bool paren_closing_paren_closing_paren_closing_paren_closing = false;\n  \
    \  bool paren_opening_paren_closing_paren_closing_paren_closing_found = false;\n\
    \    bool paren_closing_paren_closing_paren_closing_paren_closing_found = false;\n\
    \    bool paren_opening_paren_closing_paren_closing_paren_closing_paren_found\
    \ = false;\n    bool paren_closing_paren_closing_paren_closing_paren_closing_paren_found\
    \ = false;\n    bool paren_opening_paren_closing_paren_closing_paren_closing_paren_closing\
    \ = false;\n    bool paren_closing_paren_closing_paren_closing_paren_closing_paren_closing\
    \ = false;\n    bool paren_opening_paren_closing_paren_closing_paren_closing_paren_closing_found\
    \ = false;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnevs178w.d(52): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnevs178w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            level++;\n            levels[level]\
    \ = level;\n            in_paren = true;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n            if(level < 0)\n      \
    \      {\n                throw new Exception(\"Invalid parenthesis string\");\n\
    \            }\n            levels[level] = level;\n            in_paren = false;\n\
    \        }\n        else if(in_paren)\n        {\n            levels[level] =\
    \ level;\n        }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=c#,algorithm,parentheses\
    \ |>\n<| c |>\nI like your solution, but I believe it has a bug. For example,\
    \ `parse_nested_parens(\"(()()) ((())) () ((())()())\")` returns `[2, 2, 2, 2,\
    \ 2]` instead of `[3, 3, 3, 3, 3]`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I've fixed the bug and added a test case to show that it works.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgjfv8ykp.d(42): Error: Declaration expected, not \''<\''\n/tmp/tmpgjfv8ykp.d(48):
    Error: unterminated character constant\n/tmp/tmpgjfv8ykp.d(53): Error: semicolon
    expected, not \''.\''\n/tmp/tmpgjfv8ykp.d(53): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpgjfv8ykp.d(54): Error: semicolon expected, not \''.\''\n/tmp/tmpgjfv8ykp.d(54):
    Error: no identifier for declarator .Linq\n/tmp/tmpgjfv8ykp.d(55): Error: semicolon
    expected, not \''.\''\n/tmp/tmpgjfv8ykp.d(55): Error: no identifier for declarator
    .Text\n/tmp/tmpgjfv8ykp.d(56): Error: semicolon expected, not \''.\''\n/tmp/tmpgjfv8ykp.d(56):
    Error: no identifier for declarator .Text.RegularExpressions\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgjfv8ykp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_size = 0;\n    long\
    \ level_size = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long\
    \ max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n \
    \   long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n\
    \    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_u3z_p_7.d(93): Error: expression expected, not \''unittest\''\n/tmp/tmp_u3z_p_7.d(94):
    Error: semicolon expected, not \''{\''\n/tmp/tmp_u3z_p_7.d(101): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_u3z_p_7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 1;\n    bool in_paren = false;\n    bool in_paren_group = false;\n    bool\
    \ in_paren_group_open = false;\n    bool in_paren_group_close = false;\n    bool\
    \ in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace = false;\n\
    \    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnflo8ul5.d(47): Error: semicolon expected, not \''unittest\''\n/tmp/tmpnflo8ul5.d(47):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnflo8ul5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6cvn8flx.d(63): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6cvn8flx.d(63):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6cvn8flx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_copy = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long levels_stack_index = 0;\n    long levels_stack_copy_index = 0;\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma = false;\n    bool in_paren_group_open_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf25jfysv.d(43): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf25jfysv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n    bool\
    \ is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n   \
    \ bool is_opening_paren_or_opening_paren_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4jjaits8.d(42): Error: semicolon expected, not \''unittest\''\n/tmp/tmp4jjaits8.d(42):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4jjaits8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_index46 = 0;\n    long paren_levels_index47 = 0;\n    long\
    \ paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpogv2jv73.d(66): Error: semicolon expected, not \''unittest\''\n/tmp/tmpogv2jv73.d(66):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpogv2jv73.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_quote = false;\n    bool in_backslash = false;\n    bool\
    \ in_backslash2 = false;\n    bool in_backslash3 = false;\n    bool in_backslash4\
    \ = false;\n    bool in_backslash5 = false;\n    bool in_backslash6 = false;\n\
    \    bool in_backslash7 = false;\n    bool in_backslash8 = false;\n    bool in_backslash9\
    \ = false;\n    bool in_backslash10 = false;\n    bool in_backslash11 = false;\n\
    \    bool in_backslash12 = false;\n    bool in_backslash13 = false;\n    bool\
    \ in_backslash14 = false;\n    bool in_backslash15 = false;\n    bool in_backslash16\
    \ = false;\n    bool in_backslash17 = false;\n    bool in_backslash18 = false;\n\
    \    bool in_backslash19 = false;\n    bool in_backslash20 = false;\n    bool\
    \ in_backslash21 = false;\n    bool in_backslash22 = false;\n    bool in_backslash23\
    \ = false;\n    bool in_backslash24 = false;\n    bool in_backslash25 = false;\n\
    \    bool in_backslash26 = false;\n    bool in_backslash27 = false;\n    bool\
    \ in_backslash28 = false;\n    bool in_backslash29 = false;\n    bool in_backslash30\
    \ = false;\n    bool in_backslash31 = false;\n    bool in_backslash32 = false;\n\
    \    bool in_backslash33 = false;\n    bool in_backslash34 = false;\n    bool\
    \ in_backslash35 = false;\n    bool in_backslash36 = false;\n    bool in_backslash37\
    \ = false;\n    bool in_backslash38 = false;\n    bool in_backslash39 = false;\n\
    \    bool in_backslash40 = false;\n    bool in_backslash41 = false;\n    bool\
    \ in_backslash42 = false;\n    bool in_backslash43 = false;\n    bool in_backslash44\
    \ = false;\n    bool in_backslash45 = false;\n    bool in_backslash46 = false;\n\
    \    bool in_backslash47 = false;\n    bool in_backslash48 = false;\n    bool\
    \ in_backslash49 = false;\n    bool in_backslash50 = false;\n    bool in_backslash51\
    \ = false;\n    bool in_backslash52 = false;\n    bool in_backslash53 = false;\n\
    \    bool in_backslash54 = false;\n    bool in_backslash55 = false;\n    bool\
    \ in_backslash56 = false;\n    bool in_backslash57 = false;\n    bool in_backslash58\
    \ = false;\n    bool in_backslash59 = false;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm7t646wo.d(78): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7t646wo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9cyb4fw6.d(38): Error: semicolon expected, not \''unittest\''\n/tmp/tmp9cyb4fw6.d(38):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp9cyb4fw6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long current_level = 0;\n    long current_max_level = 0;\n    long\
    \ current_index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6k4yoqzf.d(72): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6k4yoqzf.d(72):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6k4yoqzf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool has_paren = false;\n    bool has_space = false;\n    bool has_comma\
    \ = false;\n    bool has_open = false;\n    bool has_close = false;\n    bool\
    \ has_open_bracket = false;\n    bool has_close_bracket = false;\n    bool has_open_square\
    \ = false;\n    bool has_close_square = false;\n    bool has_open_curly = false;\n\
    \    bool has_close_curly = false;\n    bool has_open_paren = false;\n    bool\
    \ has_close_paren = false;\n    bool has_open_curly_bracket = false;\n    bool\
    \ has_close_curly_bracket = false;\n    bool has_open_parenthesis = false;\n \
    \   bool has_close_parenthesis = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbjinlzqa.d(67): Error: semicolon expected, not \''unittest\''\n/tmp/tmpbjinlzqa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpbjinlzqa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjggn76p3.d(86): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjggn76p3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        if(paren_char.length() == 0)\n            continue;\n        string open_paren\
    \ = paren_char.substr(0, 1);\n        string close_paren = paren_char.substr(1,\
    \ 1);\n        string open_paren_chars[] = open_paren.split(\"\");\n        string\
    \ close_paren_chars[] = close_paren.split(\"\");\n        for(long j = 0; j <\
    \ open_paren_chars.length; ++j)\n        {\n            string open_paren_char\
    \ = open_paren_chars[j];\n            string close_paren_char = close_paren_chars[j];\n\
    \            if(open_paren_char == close_paren_char)\n            {\n        \
    \        levels[level] = level;\n                level++;\n            }\n   \
    \         else\n            {\n                levels[level] = level;\n      \
    \          levels[level + 1] = level;\n                level++;\n            }\n\
    \        }\n    }\n    for(long i = 0; i < levels.length; ++i)\n    {\n      \
    \  if(levels[i] > max_level)\n            max_level = levels[i];\n    }\n    return\
    \ max_level;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp68amrd9c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(c == ')') {\n            level--;\n            if(level\
    \ == 0) {\n                level = levels[level];\n            }\n        }\n\
    \    }\n    for(int i = 0; i < levels.length; i++) {\n        if(levels[i] > max_level)\
    \ {\n            max_level = levels[i];\n        }\n    }\n    return max_level;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++,parentheses,recursion |>\n<| a tags=string,algorithm,c++,parentheses,recursion\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <stack>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7yam4_qx.d(37): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7yam4_qx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqtqkybhg.d(79): Error: semicolon expected, not \''unittest\''\n/tmp/tmpqtqkybhg.d(79):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqtqkybhg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n \
    \   bool in_brace = false;\n    bool in_paren_group = false;\n    bool in_bracket_group\
    \ = false;\n    bool in_brace_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_bracket_group_open = false;\n    bool in_brace_group_open = false;\n\
    \    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed = false;\n\
    \    bool in_brace_group_closed = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_bracket_group_open_brace = false;\n    bool in_brace_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_paren_group_open_bracket\
    \ = false;\n    bool in_bracket_group_open_bracket = false;\n    bool in_brace_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_paren_group_open_brace_group\
    \ = false;\n    bool in_bracket_group_open_brace_group = false;\n    bool in_brace_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_paren_group_open_brace_group_open\
    \ = false;\n    bool in_bracket_group_open_brace_group_open = false;\n    bool\
    \ in_brace_group_open_brace_group_open = false;\n    bool in_paren_group_closed_brace_group_open\
    \ = false;\n    bool in_bracket_group_closed_brace_group_open = false;\n    bool\
    \ in_brace_group_closed_brace_group_open = false;\n    bool in_paren_group_open_brace_group_closed\
    \ = false;\n    bool in_bracket_group_open_brace_group_closed = false;\n    bool\
    \ in_brace_group_open_brace_group_closed = false;\n    bool in_paren_group_closed_brace_group_closed\
    \ = false;\n    bool in_bracket_group_closed_brace_group_closed = false;\n   \
    \ bool in_brace_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprwl37xuv.d(60): Error: semicolon expected, not \''unittest\''\n/tmp/tmprwl37xuv.d(60):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmprwl37xuv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_current = 0;\n\
    \    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy58afsom.d(67): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy58afsom.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    long paren_count = 0;\n\
    \    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_cur\
    \ = 0;\n    long paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long\
    \ paren_level_max3 = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4\
    \ = 0;\n    long paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long\
    \ paren_level_cur5 = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6\
    \ = 0;\n    long paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long\
    \ paren_level_max8 = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9\
    \ = 0;\n    long paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long\
    \ paren_level_cur10 = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11\
    \ = 0;\n    long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n   \
    \ long paren_level_max13 = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14\
    \ = 0;\n    long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n   \
    \ long paren_level_cur15 = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16\
    \ = 0;\n    long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n   \
    \ long paren_level_max18 = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19\
    \ = 0;\n    long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n   \
    \ long paren_level_cur20 = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21\
    \ = 0;\n    long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n   \
    \ long paren_level_max23 = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24\
    \ = 0;\n    long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n   \
    \ long paren_level_cur25 = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7_vtsq10.d(75): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7_vtsq10.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] max_levels = new long[paren_groups.size()];\n\
    \    long max_level = 0;\n    long level = 0;\n    bool has_paren = false;\n \
    \   bool has_space = false;\n    bool has_comma = false;\n    bool has_opening_bracket\
    \ = false;\n    bool has_closing_bracket = false;\n    bool has_opening_paren\
    \ = false;\n    bool has_closing_paren = false;\n    bool has_opening_curly =\
    \ false;\n    bool has_closing_curly = false;\n    bool has_opening_square = false;\n\
    \    bool has_closing_square = false;\n    bool has_opening_angle = false;\n \
    \   bool has_closing_angle = false;\n    bool has_opening_paren_or_angle = false;\n\
    \    bool has_closing_paren_or_angle = false;\n    bool has_opening_curly_or_angle\
    \ = false;\n    bool has_closing_curly_or_angle = false;\n    bool has_opening_square_or_angle\
    \ = false;\n    bool has_closing_square_or_angle = false;\n    bool has_opening_angle_or_angle\
    \ = false;\n    bool has_closing_angle_or_angle = false;\n    bool has_opening_paren_or_angle_or_angle\
    \ = false;\n    bool has_closing_paren_or_angle_or_angle = false;\n    bool has_opening_curly_or_angle_or_angle\
    \ = false;\n    bool has_closing_curly_or_angle_or_angle = false;\n    bool has_opening_square_or_angle_or_angle\
    \ = false;\n    bool has_closing_square_or_angle_or_angle = false;\n    bool has_opening_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_angle_or_angle_or_angle = false;\n    bool has_opening_paren_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_paren_or_angle_or_angle_or_angle = false;\n \
    \   bool has_opening_curly_or_angle_or_angle_or_angle = false;\n    bool has_closing_curly_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_opening_square_or_angle_or_angle_or_angle = false;\n\
    \    bool has_closing_square_or_angle_or_angle_or_angle = false;\n    bool has_opening_angle_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_angle_or_angle_or_angle_or_angle = false;\n \
    \   bool has_opening_paren_or_angle_or_angle_or_angle_or_angle = false;\n    bool\
    \ has_closing_paren_or_angle_or_angle_or_angle_or_angle = false;\n    bool has_opening_curly_or_angle_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_curly_or_angle_or_angle_or_angle_or_angle\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpumsxa547.d(59): Error: semicolon expected, not \''unittest\''\n/tmp/tmpumsxa547.d(59):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpumsxa547.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n\
    \    bool in_brace = false;\n    bool in_braces = false;\n    bool in_braces_open\
    \ = false;\n    bool in_braces_close = false;\n    bool in_braces_open2 = false;\n\
    \    bool in_braces_close2 = false;\n    bool in_braces_open3 = false;\n    bool\
    \ in_braces_close3 = false;\n    bool in_braces_open4 = false;\n    bool in_braces_close4\
    \ = false;\n    bool in_braces_open5 = false;\n    bool in_braces_close5 = false;\n\
    \    bool in_braces_open6 = false;\n    bool in_braces_close6 = false;\n    bool\
    \ in_braces_open7 = false;\n    bool in_braces_close7 = false;\n    bool in_braces_open8\
    \ = false;\n    bool in_braces_close8 = false;\n    bool in_braces_open9 = false;\n\
    \    bool in_braces_close9 = false;\n    bool in_braces_open10 = false;\n    bool\
    \ in_braces_close10 = false;\n    bool in_braces_open11 = false;\n    bool in_braces_close11\
    \ = false;\n    bool in_braces_open12 = false;\n    bool in_braces_close12 = false;\n\
    \    bool in_braces_open13 = false;\n    bool in_braces_close13 = false;\n   \
    \ bool in_braces_open14 = false;\n    bool in_braces_close14 = false;\n    bool\
    \ in_braces_open15 = false;\n    bool in_braces_close15 = false;\n    bool in_braces_open16\
    \ = false;\n    bool in_braces_close16 = false;\n    bool in_braces_open17 = false;\n\
    \    bool in_braces_close17 = false;\n    bool in_braces_open18 = false;\n   \
    \ bool in_braces_close18 = false;\n    bool in_braces_open19 = false;\n    bool\
    \ in_braces_close19 = false;\n    bool in_braces_open20 = false;\n    bool in_braces_close20\
    \ = false;\n    bool in_braces_open21 = false;\n    bool in_braces_close21 = false;\n\
    \    bool in_braces_open22 = false;\n    bool in_braces_close22 = false;\n   \
    \ bool in_braces_open23 = false;\n    bool in_braces_close23 = false;\n    bool\
    \ in_braces_open24 = false;\n    bool in_braces_close24 = false;\n    bool in_braces_open25\
    \ = false;\n    bool in_braces_close25 = false;\n    bool in_braces_open\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpimr1q6n7.d(73): Error: semicolon expected, not \''unittest\''\n/tmp/tmpimr1q6n7.d(73):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpimr1q6n7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_min\
    \ = 0;\n    long parens_level_diff = 0;\n    long parens_level_diff_max = 0;\n\
    \    long parens_level_diff_min = 0;\n    long parens_level_diff_max2 = 0;\n \
    \   long parens_level_diff_min2 = 0;\n    long parens_level_diff_max3 = 0;\n \
    \   long parens_level_diff_min3 = 0;\n    long parens_level_diff_max4 = 0;\n \
    \   long parens_level_diff_min4 = 0;\n    long parens_level_diff_max5 = 0;\n \
    \   long parens_level_diff_min5 = 0;\n    long parens_level_diff_max6 = 0;\n \
    \   long parens_level_diff_min6 = 0;\n    long parens_level_diff_max7 = 0;\n \
    \   long parens_level_diff_min7 = 0;\n    long parens_level_diff_max8 = 0;\n \
    \   long parens_level_diff_min8 = 0;\n    long parens_level_diff_max9 = 0;\n \
    \   long parens_level_diff_min9 = 0;\n    long parens_level_diff_max10 = 0;\n\
    \    long parens_level_diff_min10 = 0;\n    long parens_level_diff_max11 = 0;\n\
    \    long parens_level_diff_min11 = 0;\n    long parens_level_diff_max12 = 0;\n\
    \    long parens_level_diff_min12 = 0;\n    long parens_level_diff_max13 = 0;\n\
    \    long parens_level_diff_min13 = 0;\n    long parens_level_diff_max14 = 0;\n\
    \    long parens_level_diff_min14 = 0;\n    long parens_level_diff_max15 = 0;\n\
    \    long parens_level_diff_min15 = 0;\n    long parens_level_diff_max16 = 0;\n\
    \    long parens_level_diff_min16 = 0;\n    long parens_level_diff_max17 = 0;\n\
    \    long parens_level_diff_min17 = 0;\n    long parens_level_diff_max18 = 0;\n\
    \    long parens_level_diff_min18 = 0;\n    long parens_level_diff_max19 = 0;\n\
    \    long parens_level_diff_min19 = 0;\n    long parens_level_diff_max20 = 0;\n\
    \    long parens_level_diff_min20 = 0;\n    long parens_level_diff_max21 = 0;\n\
    \    long parens_level_diff_min21 = 0;\n    long parens_level_diff_max22 = 0;\n\
    \    long parens_level_diff_min22 = 0;\n    long parens_level_diff_max23 = 0;\n\
    \    long parens_level_diff_min23 = 0;\n    long parens_level_diff_max\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgh9rt5qj.d(68): Error: semicolon expected, not \''unittest\''\n/tmp/tmpgh9rt5qj.d(68):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpgh9rt5qj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_index46\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_pd72mbo.d(67): Error: semicolon expected, not \''unittest\''\n/tmp/tmp_pd72mbo.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_pd72mbo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_eu6dj5c.d(67): Error: semicolon expected, not \''unittest\''\n/tmp/tmp_eu6dj5c.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_eu6dj5c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            level++;\n        } else if(paren_string[i] == ')') {\n     \
    \       level--;\n        }\n        levels[i] = level;\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=algorithm,string,c++,parentheses |>\n<| c |>\nI like your\
    \ solution, but I believe it can be optimized a little bit more. For example,\
    \ instead of iterating over all characters, you can just iterate over all pairs\
    \ of parentheses and count the level of nesting for each pair. Also, instead of\
    \ iterating over all characters, you can just iterate over all pairs of parentheses\
    \ and count the level of nesting for each pair. Also, instead of iterating over\
    \ all characters, you can just iterate over all pairs of parentheses and count\
    \ the level of nesting for each pair. Also, instead of iterating over all characters,\
    \ you can just iterate over all pairs of parentheses and count the level of nesting\
    \ for each pair. Also, instead of iterating over all characters, you can just\
    \ iterate over all pairs of parentheses and count the level of nesting for each\
    \ pair. Also, instead of iterating over all characters, you can just iterate over\
    \ all pairs of parentheses and count the level of nesting for each pair. Also,\
    \ instead of iterating over all characters, you can just iterate over all pairs\
    \ of parentheses and count the level of nesting for each pair. Also, instead of\
    \ iterating over all characters, you can just iterate over all pairs of parentheses\
    \ and count the level of nesting for each pair. Also, instead of iterating over\
    \ all characters, you can just iterate over all pairs of parentheses and count\
    \ the level of nesting for each pair. Also, instead of iterating over all characters,\
    \ you can just iterate over all pairs of parentheses and count the level of nesting\
    \ for each pair. Also, instead of iterating over all characters, you can just\
    \ iterate over all pairs of parentheses and count the level of nesting for each\
    \ pair. Also, instead of iterating over all characters, you can just iterate over\
    \ all pairs of parentheses and count the level of nesting for each pair. Also,\
    \ instead of iterating over all characters, you can just iterate over all pairs\
    \ of parentheses and count the level of nesting for each pair. Also, instead of\
    \ iterating over all characters, you can just iterate over all pairs of parentheses\
    \ and count the level of nesting for each pair.\n<|/ c |>\n<| c |>\nAlso, I think\
    \ it would be better to iterate over all pairs of parentheses and count the level\
    \ of nesting for each pair. Also, instead of iterating over all characters, you\
    \ can \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf06471d9.d(26): Error: Declaration expected, not \''<\''\n/tmp/tmpf06471d9.d(37):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpf06471d9.d(38): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpf06471d9.d(39): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpf06471d9.d(40): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf06471d9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = paren_string;\n    long[] levels = new long[paren_chars.length()];\n\
    \    long[] max_levels = new long[paren_chars.length()];\n    long[] max_levels_index\
    \ = new long[paren_chars.length()];\n    long[] current_levels = new long[paren_chars.length()];\n\
    \    long[] current_levels_index = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index2 = new long[paren_chars.length()];\n    long[] current_levels_index3\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index4 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index5 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index6 = new long[paren_chars.length()];\n    long[] current_levels_index7\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index8 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index9 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index10 = new long[paren_chars.length()];\n    long[] current_levels_index11\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index12 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index13 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index14 = new long[paren_chars.length()];\n    long[] current_levels_index15\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index16 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index17 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index18 = new long[paren_chars.length()];\n    long[] current_levels_index19\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index20 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index21 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index22 = new long[paren_chars.length()];\n    long[] current_levels_index23\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index24 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index25 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index26 = new long[paren_chars.length()];\n    \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgwe_or4w.d(46): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgwe_or4w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n \
    \       if(paren_string[i] == '(')\n        {\n            paren_stack.push(i);\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            int\
    \ paren_level = paren_stack.top();\n            paren_stack.pop();\n         \
    \   levels[paren_level] = max(levels[paren_level], paren_stack.size());\n    \
    \    }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,parentheses,c++\
    \ |>\n<| c |>\nI believe this solution will fail for input like `((()))` which\
    \ has one level of nesting but is missing a closing parenthesis.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. I missed that case. Thanks for pointing it out.\n\
    <|/ c |>\n<| c |>\nI believe this solution will fail for input like `((()))` which\
    \ has one level of nesting but is missing a closing parenthesis.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. I missed that case. Thanks for pointing it out.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <stack>\nusing namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1r8o4o8p.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmp1r8o4o8p.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmp1r8o4o8p.d(15): Error: found \''(\'' when expecting identifier
    following \''int.\''\n/tmp/tmp1r8o4o8p.d(15): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmp1r8o4o8p.d(31): Error: Declaration expected,
    not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1r8o4o8p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            level++;\n        }\n        else if(paren_string[i] == ')')\
    \ {\n            level--;\n        }\n        levels[i] = level;\n    }\n    return\
    \ levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphr7wn76z.d(27): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphr7wn76z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_bracket =\
    \ false;\n    bool in_group_close_bracket = false;\n    bool in_group_open_square\
    \ = false;\n    bool in_group_close_square = false;\n    bool in_group_open_curly\
    \ = false;\n    bool in_group_close_curly = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren_square\
    \ = false;\n    bool in_group_close_paren_square = false;\n    bool in_group_open_paren_curly\
    \ = false;\n    bool in_group_close_paren_curly = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren_square\
    \ = false;\n    bool in_group_close_paren_square = false;\n    bool in_group_open_paren_curly\
    \ = false;\n    bool in_group_close_paren_curly = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren_square\
    \ = false;\n    bool in_group_close_paren_square = false;\n    bool in_group_open_paren_curly\
    \ = false;\n    bool in_group_close_paren_curly = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5pqxpem3.d(68): Error: semicolon expected, not \''unittest\''\n/tmp/tmp5pqxpem3.d(68):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp5pqxpem3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long max_level = 0;\n    long\
    \ level = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool\
    \ in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_open_brace\
    \ = false;\n    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6thxaosp.d(36): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6thxaosp.d(36):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6thxaosp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool in_paren = false;\n    long\
    \ level = 0;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n    \
    \    if(paren_string[i] == '(')\n        {\n            in_paren = true;\n   \
    \         level++;\n        }\n        else if(paren_string[i] == ')')\n     \
    \   {\n            in_paren = false;\n            level--;\n        }\n      \
    \  else if(in_paren)\n        {\n            levels[level] = levels[level] + 1;\n\
    \        }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,c#,algorithm\
    \ |>\nI wrote a recursive solution in C#:\n<code>\npublic static int GetMaxNestingLevel(string\
    \ input)\n{\n    if (string.IsNullOrEmpty(input))\n        return 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjf64qiv_.d(36): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjf64qiv_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool paren_open = false;\n    bool paren_closed = false;\n\
    \    bool paren_opening_closed = false;\n    bool paren_opening_open = false;\n\
    \    bool paren_opening_closed_open = false;\n    bool paren_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_open = false;\n    bool paren_opening_closed_opening_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed = false;\n  \
    \  bool paren_opening_closed_opening_opening_closed_open = false;\n    bool paren_opening_closed_opening_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxaq1za78.d(43): Error: semicolon expected, not \''unittest\''\n/tmp/tmpxaq1za78.d(43):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpxaq1za78.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_open = false;\n   \
    \ bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_open =\
    \ false;\n    bool in_paren_group_close_brace_close_brace_close_brace_open = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_close_brace_open_brace_close_brace_close = false;\n   \
    \ bool in_paren_group_close_brace_close_brace_close_brace_close = false;\n   \
    \ bool in_paren_group_open_brace_open_bra\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx_g7_f9z.d(49): Error: semicolon expected, not \''unittest\''\n/tmp/tmpx_g7_f9z.d(49):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpx_g7_f9z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next = 0;\n    long paren_level_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6gwunw9o.d(50): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6gwunw9o.d(50):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6gwunw9o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_open2 = false;\n    bool is_closed2\
    \ = false;\n    bool is_open3 = false;\n    bool is_closed3 = false;\n    bool\
    \ is_open4 = false;\n    bool is_closed4 = false;\n    bool is_open5 = false;\n\
    \    bool is_closed5 = false;\n    bool is_open6 = false;\n    bool is_closed6\
    \ = false;\n    bool is_open7 = false;\n    bool is_closed7 = false;\n    bool\
    \ is_open8 = false;\n    bool is_closed8 = false;\n    bool is_open9 = false;\n\
    \    bool is_closed9 = false;\n    bool is_open10 = false;\n    bool is_closed10\
    \ = false;\n    bool is_open11 = false;\n    bool is_closed11 = false;\n    bool\
    \ is_open12 = false;\n    bool is_closed12 = false;\n    bool is_open13 = false;\n\
    \    bool is_closed13 = false;\n    bool is_open14 = false;\n    bool is_closed14\
    \ = false;\n    bool is_open15 = false;\n    bool is_closed15 = false;\n    bool\
    \ is_open16 = false;\n    bool is_closed16 = false;\n    bool is_open17 = false;\n\
    \    bool is_closed17 = false;\n    bool is_open18 = false;\n    bool is_closed18\
    \ = false;\n    bool is_open19 = false;\n    bool is_closed19 = false;\n    bool\
    \ is_open20 = false;\n    bool is_closed20 = false;\n    bool is_open21 = false;\n\
    \    bool is_closed21 = false;\n    bool is_open22 = false;\n    bool is_closed22\
    \ = false;\n    bool is_open23 = false;\n    bool is_closed23 = false;\n    bool\
    \ is_open24 = false;\n    bool is_closed24 = false;\n    bool is_open25 = false;\n\
    \    bool is_closed25 = false;\n    bool is_open26 = false;\n    bool is_closed26\
    \ = false;\n    bool is_open27 = false;\n    bool is_closed27 = false;\n    bool\
    \ is_open28 = false;\n    bool is_closed28 = false;\n    bool is_open29 = false;\n\
    \    bool is_closed29 = false;\n    bool is_open30 = false;\n    bool is_closed30\
    \ = false;\n    bool is_open31 = false;\n    bool is_closed31 = false;\n    bool\
    \ is_open32 = false;\n    bool is_closed32 = false;\n    bool is_open33 = false;\n\
    \    bool is_closed33 = false;\n    bool is_open34 = false;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu_lvnvyy.d(87): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_lvnvyy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_chars_set = paren_chars.toLower();\n\
    \    string paren_chars_set_size = paren_chars_set.size();\n    string paren_chars_set_chars\
    \ = paren_chars.toCharArray();\n    string paren_chars_set_chars_size = paren_chars_set_chars.size();\n\
    \    string paren_chars_set_chars_chars = paren_chars_set_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_size = paren_chars_set_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars = paren_chars_set_chars_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_chars_size = paren_chars_set_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars = paren_chars_set_chars_chars_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars = paren_chars_set_chars_chars_chars_chars_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_size\
    \ = paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_chars_chars_chars_size\
    \ = paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_char\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5jhplf_q.d(31): Error: found \''paren_char\'' when expecting
    \'';\'' following statement\n/tmp/tmp5jhplf_q.d(32): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jhplf_q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    string current_paren = \"\";\n    string next_paren\
    \ = \"\";\n    string current_string = \"\";\n    string next_string = \"\";\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(current_paren == \"\")\n            {\n \
    \               current_paren = paren_string[i];\n            }\n            else\n\
    \            {\n                current_string += paren_string[i];\n         \
    \   }\n        }\n        else if(paren_string[i] == ')')\n        {\n       \
    \     if(current_paren != \"\")\n            {\n                levels[level_counter]\
    \ = level;\n                level_counter++;\n                level = level_counter;\n\
    \                current_paren = \"\";\n                current_string = \"\"\
    ;\n            }\n        }\n        else if(current_paren != \"\")\n        {\n\
    \            current_string += paren_string[i];\n        }\n    }\n    levels[level_counter]\
    \ = level;\n    level_counter++;\n    level = level_counter;\n    for(int i =\
    \ 0; i < level_counter; i++)\n    {\n        if(levels[i] > max_level)\n     \
    \   {\n            max_level = levels[i];\n        }\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,parentheses |>\n<| c |>\nThis solution doesn't\
    \ work for nested parentheses such as \"(()())\".\n<|/ c |>\n<| c |>\nYes, it\
    \ does. I tested it before posting it. The OP asked for the deepest level of nesting,\
    \ not the number of levels. I used the word \"level\" instead of \"depth\" because\
    \ I thought it would be more intuitive to someone who reads the code. Anyway,\
    \ I edited my answer to make it clear that this function returns the deepest level\
    \ of nesting.\n<|/ c |>\n<| c |>\nI see. Thanks for the clarification.\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl3er465.d(63): Error: Declaration expected, not \''<\''\n/tmp/tmpkl3er465.d(66):
    Error: unterminated character constant\n/tmp/tmpkl3er465.d(77): Error: semicolon
    expected, not \''.\''\n/tmp/tmpkl3er465.d(77): Error: no identifier for declarator
    .Collections.Generic\n/tmp/tmpkl3er465.d(78): Error: semicolon expected, not \''.\''\n/tmp/tmpkl3er465.d(78):
    Error: no identifier for declarator .Linq\n/tmp/tmpkl3er465.d(79): Error: semicolon
    expected, not \''.\''\n/tmp/tmpkl3er465.d(79): Error: no identifier for declarator
    .Text\n/tmp/tmpkl3er465.d(80): Error: semicolon expected, not \''.\''\n/tmp/tmpkl3er465.d(80):
    Error: no identifier for declarator .Text.RegularExpressions\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpkl3er465.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n   \
    \ long paren_level_index = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_index2 = 0;\n    long paren_level_max_index3\
    \ = 0;\n    long paren_level_max_index4 = 0;\n    long paren_level_max_index5\
    \ = 0;\n    long paren_level_max_index6 = 0;\n    long paren_level_max_index7\
    \ = 0;\n    long paren_level_max_index8 = 0;\n    long paren_level_max_index9\
    \ = 0;\n    long paren_level_max_index10 = 0;\n    long paren_level_max_index11\
    \ = 0;\n    long paren_level_max_index12 = 0;\n    long paren_level_max_index13\
    \ = 0;\n    long paren_level_max_index14 = 0;\n    long paren_level_max_index15\
    \ = 0;\n    long paren_level_max_index16 = 0;\n    long paren_level_max_index17\
    \ = 0;\n    long paren_level_max_index18 = 0;\n    long paren_level_max_index19\
    \ = 0;\n    long paren_level_max_index20 = 0;\n    long paren_level_max_index21\
    \ = 0;\n    long paren_level_max_index22 = 0;\n    long paren_level_max_index23\
    \ = 0;\n    long paren_level_max_index24 = 0;\n    long paren_level_max_index25\
    \ = 0;\n    long paren_level_max_index26 = 0;\n    long paren_level_max_index27\
    \ = 0;\n    long paren_level_max_index28 = 0;\n    long paren_level_max_index29\
    \ = 0;\n    long paren_level_max_index30 = 0;\n    long paren_level_max_index31\
    \ = 0;\n    long paren_level_max_index32 = 0;\n    long paren_level_max_index33\
    \ = 0;\n    long paren_level_max_index34 = 0;\n    long paren_level_max_index35\
    \ = 0;\n    long paren_level_max_index36 = 0;\n    long paren_level_max_index37\
    \ = 0;\n    long paren_level_max_index38 = 0;\n    long paren_level_max_index39\
    \ = 0;\n    long paren_level_max_index40 = 0;\n    long paren_level_max_index41\
    \ = 0;\n    long paren_level_max_index42 = 0;\n    long paren_level_max_index43\
    \ = 0;\n    long paren_level_max_index44 = 0;\n    long paren_level_max_index45\
    \ = 0;\n    long paren_level_max_index46 = 0;\n    long \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzh57on5b.d(69): Error: no identifier for declarator long\n/tmp/tmpzh57on5b.d(69):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpzh57on5b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_ptr = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long level_ptr = 0;\n    long level_ptr_prev = 0;\n    long level_ptr_next\
    \ = 0;\n    long level_ptr_next_prev = 0;\n    long level_ptr_next_next = 0;\n\
    \    long level_ptr_next_next_prev = 0;\n    long level_ptr_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ level_ptr_next_next_next_next_next_next_next_next = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ level_ptr_next_next_next_next_next_next_next_next_next = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n \
    \   long level_ptr_next_next_next_next_next_next_next_next_next_next = 0;\n  \
    \  long level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n   \
    \ long level_ptr_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next_prev =\
    \ 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n \
    \   long level_ptr_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptr84p_45.d(52): Error: semicolon expected, not \''unittest\''\n/tmp/tmptr84p_45.d(52):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmptr84p_45.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer = new\
    \ long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpohc0kj6p.d(34): Error: semicolon expected, not \''unittest\''\n/tmp/tmpohc0kj6p.d(34):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpohc0kj6p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long index = 0;\n    bool has_open\
    \ = false;\n    bool has_close = false;\n    bool has_open_brace = false;\n  \
    \  bool has_close_brace = false;\n    bool has_open_paren = false;\n    bool has_close_paren\
    \ = false;\n    bool has_open_curly = false;\n    bool has_close_curly = false;\n\
    \    bool has_open_angle = false;\n    bool has_close_angle = false;\n    bool\
    \ has_open_paren_curly = false;\n    bool has_close_paren_curly = false;\n   \
    \ bool has_open_curly_curly = false;\n    bool has_close_curly_curly = false;\n\
    \    bool has_open_angle_brace = false;\n    bool has_close_angle_brace = false;\n\
    \    bool has_open_paren_angle = false;\n    bool has_close_paren_angle = false;\n\
    \    bool has_open_curly_angle = false;\n    bool has_close_curly_angle = false;\n\
    \    bool has_open_angle_brace_curly = false;\n    bool has_close_angle_brace_curly\
    \ = false;\n    bool has_open_paren_curly_angle = false;\n    bool has_close_paren_curly_angle\
    \ = false;\n    bool has_open_curly_curly_angle = false;\n    bool has_close_curly_curly_angle\
    \ = false;\n    bool has_open_angle_brace_curly_angle = false;\n    bool has_close_angle_brace_curly_angle\
    \ = false;\n    bool has_open_paren_curly_curly_angle = false;\n    bool has_close_paren_curly_curly_angle\
    \ = false;\n    bool has_open_curly_curly_curly_angle = false;\n    bool has_close_curly_curly_curly_angle\
    \ = false;\n    bool has_open_angle_brace_curly_curly_angle = false;\n    bool\
    \ has_close_angle_brace_curly_curly_angle = false;\n    bool has_open_paren_curly_curly_curly_angle\
    \ = false;\n    bool has_close_paren_curly_curly_curly_angle = false;\n    bool\
    \ has_open_curly_curly_curly_curly_angle = false;\n    bool has_close_curly_curly_curly_curly_angle\
    \ = false;\n    bool has_open_angle_brace_curly_curly_curly_angle = false;\n \
    \   bool has_close_angle_brace_curly_curly_curly_angle = false;\n    bool has_open_paren_curly_curly_curly_curly_angle\
    \ = false;\n    bool has_close_paren_curly_curly_curly_curly_angle = false;\n\
    \    bool has_open_cur\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpogujof54.d(62): Error: semicolon expected, not \''unittest\''\n/tmp/tmpogujof54.d(62):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpogujof54.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_opener = false;\n    bool in_paren_group_closer = false;\n\
    \    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_closer_close = false;\n    bool in_paren_group_opener_close_open\
    \ = false;\n    bool in_paren_group_closer_close_open = false;\n    bool in_paren_group_opener_close_close\
    \ = false;\n    bool in_paren_group_closer_close_close = false;\n    bool in_paren_group_opener_close_opener\
    \ = false;\n    bool in_paren_group_closer_close_opener = false;\n    bool in_paren_group_opener_close_closer\
    \ = false;\n    bool in_paren_group_closer_close_closer = false;\n    bool in_paren_group_opener_close_opener_close\
    \ = false;\n    bool in_paren_group_closer_close_opener_close = false;\n    bool\
    \ in_paren_group_opener_close_closer_close = false;\n    bool in_paren_group_closer_close_closer_close\
    \ = false;\n    bool in_paren_group_opener_close_opener_close_close = false;\n\
    \    bool in_paren_group_closer_close_opener_close_close = false;\n    bool in_paren_group_opener_close_closer_close_close\
    \ = false;\n    bool in_paren_group_closer_close_closer_close_close = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close_open = false;\n    bool\
    \ in_paren_group_closer_close_opener_close_close_open = false;\n    bool in_paren_group_opener_close_closer_close_close_open\
    \ = false;\n    bool in_paren_group_closer_close_closer_close_close_open = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close_close = false;\n    bool\
    \ in_paren_group_closer_close_opener_close_close_close = false;\n    bool in_paren_group_opener_close_closer_close_close_close\
    \ = false;\n    bool in_paren_group_closer_close_closer_close_close_close = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close_close_open = false;\n\
    \    bool in_paren_group_closer_close_opener_close_close_close_open = false;\n\
    \    bool in_paren_group_opener_close_closer_close_close_close_close = false;\n\
    \    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2mc_pqzl.d(55): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2mc_pqzl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_or_closing\
    \ = false;\n    bool is_opening_or_closed = false;\n    bool is_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_closing = false;\n    bool is_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening = false;\n    bool is_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_closed = false;\n   \
    \ bool is_opening_or_opening_or_opening_or_opening = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_closed = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening = false;\n  \
    \  bool is_opening_or_opening_or_opening_or_opening_or_opening_or_closing = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_closed = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening =\
    \ false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9hs40tpw.d(46): Error: semicolon expected, not \''unittest\''\n/tmp/tmp9hs40tpw.d(46):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp9hs40tpw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_size = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening = false;\n\
    \    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0o0z5_az.d(38): Error: semicolon expected, not \''unittest\''\n/tmp/tmp0o0z5_az.d(38):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0o0z5_az.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_comma\
    \ = false;\n    bool in_group_semicolon = false;\n    bool in_group_newline =\
    \ false;\n    bool in_group_end = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_angle = false;\n\
    \    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace =\
    \ false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_curly_square\
    \ = false;\n    bool in_group_close_curly_square = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace\
    \ = false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_curly_square\
    \ = false;\n    bool in_group_close_curly_square = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace\
    \ = false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_curly_square\
    \ = false;\n    bool in_group_close_curly_square = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace\
    \ = false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_cur\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6unh_4_v.d(73): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6unh_4_v.d(73):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6unh_4_v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_comma = false;\n    bool in_paren_group_close_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_comma_brace = false;\n    bool in_paren_group_open_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma = false;\n \
    \   bool in_paren_group_open_brace_comma_brace_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_comma_brace_comma_brace = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_b\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnfccqx1j.d(44): Error: semicolon expected, not \''unittest\''\n/tmp/tmpnfccqx1j.d(44):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnfccqx1j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_index = 0;\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close = false;\n\
    \    bool in_paren_group_open_brace_or_close_brace_or_close_paren = false;\n \
    \   bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close = false;\n\
    \    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsikgzd15.d(41): Error: semicolon expected, not \''unittest\''\n/tmp/tmpsikgzd15.d(41):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpsikgzd15.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    bool in_paren = false;\n    bool in_paren_prev\
    \ = false;\n    bool in_paren_next = false;\n    bool in_paren_next_prev = false;\n\
    \    bool in_paren_next_next = false;\n    bool in_paren_next_next_prev = false;\n\
    \    bool in_paren_next_next_next = false;\n    bool in_paren_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next = false;\n    bool in_paren_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next = false;\n    bool in_paren_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next = false;\n    bool\
    \ in_paren_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_prev = false;\n  \
    \  bool in_paren_next_next_next_next_next_next_next = false;\n    bool in_paren_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_prev = false;\n   \
    \ bool in_paren_next_next_next_next_next_next_next_next_next = false;\n    bool\
    \ in_paren_next_next_next_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpats03ded.d(52): Error: semicolon expected, not \''unittest\''\n/tmp/tmpats03ded.d(52):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpats03ded.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_open = false;\n    bool in_paren_group_open_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_open = false;\n    bool in_paren_group_open_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_open = false;\n   \
    \ bool in_paren_group_open_close_close_close_close = false;\n    bool in_paren_group_open_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close = false;\n\
    \    bool in_paren_group_open_close_close_close_close_close_open = false;\n  \
    \  bool in_paren_group_open_close_close_close_close_close_close = false;\n   \
    \ bool in_paren_group_open_close_close_close_close_close_open = false;\n    bool\
    \ in_paren_group_open_close_close_close_close_close_close_close = false;\n   \
    \ bool in_paren_group_open_close_close_close_close_close_close_open = false;\n\
    \    bool in_paren_group_open_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmparpsybxj.d(50): Error: semicolon expected, not \''unittest\''\n/tmp/tmparpsybxj.d(50):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmparpsybxj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_clo\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6zylz8ym.d(43): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6zylz8ym.d(43):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6zylz8ym.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsrh0t_zr.d(52): Error: semicolon expected, not \''unittest\''\n/tmp/tmpsrh0t_zr.d(52):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpsrh0t_zr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_square = false;\n    bool in_paren_group_close_square\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_paren = false;\n    bool in_paren_group_close_paren\
    \ = false;\n    bool in_paren_group_open_angle_bracket = false;\n    bool in_paren_group_close_angle_bracket\
    \ = false;\n    bool in_paren_group_open_angle_brace = false;\n    bool in_paren_group_close_angle_brace\
    \ = false;\n    bool in_paren_group_open_curly_bracket = false;\n    bool in_paren_group_close_curly_bracket\
    \ = false;\n    bool in_paren_group_open_curly_brace = false;\n    bool in_paren_group_close_curly_brace\
    \ = false;\n    bool in_paren_group_open_curly_square = false;\n    bool in_paren_group_close_curly_square\
    \ = false;\n    bool in_paren_group_open_paren_bracket = false;\n    bool in_paren_group_close_paren_bracket\
    \ = false;\n    bool in_paren_group_open_paren_brace = false;\n    bool in_paren_group_close_paren_brace\
    \ = false;\n    bool in_paren_group_open_angle_bracket = false;\n    bool in_paren_group_close_angle_bracket\
    \ = false;\n    bool in_paren_group_open_angle_brace = false;\n    bool in_paren_group_close_angle_brace\
    \ = false;\n    bool in_paren_group_open_curly_bracket = false;\n    bool in_paren_group_close_curly_bracket\
    \ = false;\n    bool in_paren_group_open_curly_brace = false;\n    bool in_paren_group_close_curly_brace\
    \ = false;\n    bool in_paren_group_open_curly_square = false;\n    bool in_paren_group_close_curly_square\
    \ = false;\n    bool in_paren_group_open_paren_bracket = false;\n    bool in_paren_group_close_paren_bracket\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpudbfgs16.d(61): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpudbfgs16.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1_pb47nd.d(36): Error: semicolon expected, not \''unittest\''\n/tmp/tmp1_pb47nd.d(36):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1_pb47nd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2d6vcb8j.d(79): Error: no identifier for declarator long\n/tmp/tmp2d6vcb8j.d(79):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2d6vcb8j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n   \
    \ long paren_level_index = 0;\n    long paren_level_size = 0;\n    long paren_level_size_index\
    \ = 0;\n    long paren_level_size_size = 0;\n    long paren_level_size_size_index\
    \ = 0;\n    long paren_level_size_size_level = 0;\n    long paren_level_size_size_level_index\
    \ = 0;\n    long paren_level_size_size_level_size = 0;\n    long paren_level_size_size_level_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size = 0;\n    long paren_level_size_size_level_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size = 0;\n    long paren_level_size_size_level_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_level_size_size_size_index = 0;\n    long paren_level_size_size_level_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_level_size_size_size_size_index = 0;\n    long paren_level_size_size_level_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_level_size_size_size_size_size_index = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_index =\
    \ 0;\n    long paren_level_size_size_level_size_size_size_size_size_size = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_size = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_size = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size_size\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_a4lye41.d(54): Error: semicolon expected, not \''unittest\''\n/tmp/tmp_a4lye41.d(54):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_a4lye41.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_comma\
    \ = false;\n    bool in_group_semicolon = false;\n    bool in_group_newline =\
    \ false;\n    bool in_group_end = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7ed0iwvs.d(75): Error: semicolon expected, not \''unittest\''\n/tmp/tmp7ed0iwvs.d(75):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp7ed0iwvs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqtqkybhg.d(79): Error: semicolon expected, not \''unittest\''\n/tmp/tmpqtqkybhg.d(79):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqtqkybhg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool in_paren = false;\n    long\
    \ level = 0;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n    \
    \    if(paren_string[i] == '(')\n        {\n            if(!in_paren)\n      \
    \      {\n                level++;\n                in_paren = true;\n       \
    \     }\n        }\n        else if(paren_string[i] == ')')\n        {\n     \
    \       if(!in_paren)\n            {\n                level--;\n             \
    \   in_paren = true;\n            }\n        }\n        else\n        {\n    \
    \        in_paren = false;\n        }\n        levels[i] = level;\n    }\n   \
    \ return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_y6kdch4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at = 0;\n    long level_at\
    \ = 0;\n    long level_at_prev = 0;\n    long level_at_prev2 = 0;\n    long level_at_prev3\
    \ = 0;\n    long level_at_prev4 = 0;\n    long level_at_prev5 = 0;\n    long level_at_prev6\
    \ = 0;\n    long level_at_prev7 = 0;\n    long level_at_prev8 = 0;\n    long level_at_prev9\
    \ = 0;\n    long level_at_prev10 = 0;\n    long level_at_prev11 = 0;\n    long\
    \ level_at_prev12 = 0;\n    long level_at_prev13 = 0;\n    long level_at_prev14\
    \ = 0;\n    long level_at_prev15 = 0;\n    long level_at_prev16 = 0;\n    long\
    \ level_at_prev17 = 0;\n    long level_at_prev18 = 0;\n    long level_at_prev19\
    \ = 0;\n    long level_at_prev20 = 0;\n    long level_at_prev21 = 0;\n    long\
    \ level_at_prev22 = 0;\n    long level_at_prev23 = 0;\n    long level_at_prev24\
    \ = 0;\n    long level_at_prev25 = 0;\n    long level_at_prev26 = 0;\n    long\
    \ level_at_prev27 = 0;\n    long level_at_prev28 = 0;\n    long level_at_prev29\
    \ = 0;\n    long level_at_prev30 = 0;\n    long level_at_prev31 = 0;\n    long\
    \ level_at_prev32 = 0;\n    long level_at_prev33 = 0;\n    long level_at_prev34\
    \ = 0;\n    long level_at_prev35 = 0;\n    long level_at_prev36 = 0;\n    long\
    \ level_at_prev37 = 0;\n    long level_at_prev38 = 0;\n    long level_at_prev39\
    \ = 0;\n    long level_at_prev40 = 0;\n    long level_at_prev41 = 0;\n    long\
    \ level_at_prev42 = 0;\n    long level_at_prev43 = 0;\n    long level_at_prev44\
    \ = 0;\n    long level_at_prev45 = 0;\n    long level_at_prev46 = 0;\n    long\
    \ level_at_prev47 = 0;\n    long level_at_prev48 = 0;\n    long level_at_prev49\
    \ = 0;\n    long level_at_prev50 = 0;\n    long level_at_prev51 = 0;\n    long\
    \ level_at_prev52 = 0;\n    long level_at_prev53 = 0;\n    long level_at_prev54\
    \ = 0;\n    long level_at_prev55 = 0;\n    long level_at_prev56 = 0;\n    long\
    \ level_at_prev57 = 0;\n    long level_at_prev58 = 0;\n    long level_at_prev59\
    \ = 0;\n    long level_at_prev60 = 0;\n    long level_at_prev61 = 0;\n    long\
    \ level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmf50f7vy.d(80): Error: semicolon expected, not \''unittest\''\n/tmp/tmpmf50f7vy.d(80):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpmf50f7vy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long[] current_levels_of_nesting = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_with_parens = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens_without_spaces = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens_with_spaces = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplr55z0ao.d(33): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplr55z0ao.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack;\n   \
    \ bool in_paren = false;\n    bool in_group = false;\n    long level = 0;\n  \
    \  long max_level = 0;\n    for(int i = 0; i < paren_string.length(); i++) {\n\
    \        char c = paren_string[i];\n        if(c == '(') {\n            if(!in_group)\
    \ {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == ')')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == ' ') {\n   \
    \         if(!in_group) {\n                level++;\n            }\n        }\n\
    \        else if(c == '(' || c == ')') {\n            if(!in_group) {\n      \
    \          level--;\n            }\n        }\n        else if(c == '[') {\n \
    \           if(!in_group) {\n                in_group = true;\n              \
    \  paren_stack.push(i);\n                level++;\n            }\n        }\n\
    \        else if(c == ']') {\n            if(!in_group) {\n                in_group\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == '[' || c == ']') {\n            if(!in_group) {\n                level--;\n\
    \            }\n        }\n        else if(c == '{') {\n            if(!in_group)\
    \ {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '}')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '{') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '}')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '<') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '>')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '<') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '>')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '!') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv5_7ivfg.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpv5_7ivfg.d(120): Error: found \''unittest\'' instead of
    statement\n/tmp/tmpv5_7ivfg.d(128): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmpv5_7ivfg.d(128): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\n/tmp/tmpv5_7ivfg.d(128):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv5_7ivfg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_char;\n    long max_level = 0;\n    long level = 0;\n    long levels[]\
    \ = new long[MAX_LEVELS];\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8ao9dpxd.d(85): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ao9dpxd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp37cl6ugl.d(75): Error: semicolon expected, not \''unittest\''\n/tmp/tmp37cl6ugl.d(75):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp37cl6ugl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnllkmm4m.d(42): Error: semicolon expected, not \''unittest\''\n/tmp/tmpnllkmm4m.d(42):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnllkmm4m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack = new long[paren_groups.length()];\n\
    \    long[] max_levels_stack_pos = new long[paren_groups.length()];\n    long[]\
    \ max_levels_stack_pos_stack = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1jnm33ol.d(37): Error: semicolon expected, not \''unittest\''\n/tmp/tmp1jnm33ol.d(37):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1jnm33ol.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb4m2zvsz.d(48): Error: semicolon expected, not \''unittest\''\n/tmp/tmpb4m2zvsz.d(48):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpb4m2zvsz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long\
    \ paren_level_next = 0;\n    long paren_level_next_max = 0;\n    long paren_level_next_cur\
    \ = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_max\
    \ = 0;\n    long paren_level_next_next_cur = 0;\n    long paren_level_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_max = 0;\n    long paren_level_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_cur = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_cur = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_cur = 0;\n   \
    \ long paren_level_next_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_cur = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_max = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsx3dw7x1.d(55): Error: semicolon expected, not \''unittest\''\n/tmp/tmpsx3dw7x1.d(55):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpsx3dw7x1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_chars_set = paren_chars.toLower();\n\
    \    string paren_chars_set_size = paren_chars_set.size();\n    string paren_chars_set_reversed\
    \ = paren_chars_set.reverse();\n    string paren_chars_set_reversed_size = paren_chars_set_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed = paren_chars_set_reversed.reverse();\n\
    \    string paren_chars_set_reversed_reversed_size = paren_chars_set_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_size = paren_chars_set_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_size = paren_chars_set_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed.size();\n   \
    \ string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reverse\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe145ae7i.d(30): Error: semicolon expected, not \''unittest\''\n/tmp/tmpe145ae7i.d(30):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpe145ae7i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_paren_or_closed = false;\n    bool is_closing_paren_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_open = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_closing_paren_or_opening_paren_or_closed_or_open = false;\n    bool\
    \ is_opening_paren_or_closed_or_opening_paren = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb6m1xazm.d(46): Error: semicolon expected, not \''unittest\''\n/tmp/tmpb6m1xazm.d(46):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpb6m1xazm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_group\
    \ = false;\n    bool in_quote_group = false;\n    bool in_paren_group_close =\
    \ false;\n    bool in_quote_group_close = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_quote_group_open = false;\n    bool in_paren_group_open2\
    \ = false;\n    bool in_quote_group_open2 = false;\n    bool in_paren_group_open3\
    \ = false;\n    bool in_quote_group_open3 = false;\n    bool in_paren_group_open4\
    \ = false;\n    bool in_quote_group_open4 = false;\n    bool in_paren_group_open5\
    \ = false;\n    bool in_quote_group_open5 = false;\n    bool in_paren_group_open6\
    \ = false;\n    bool in_quote_group_open6 = false;\n    bool in_paren_group_open7\
    \ = false;\n    bool in_quote_group_open7 = false;\n    bool in_paren_group_open8\
    \ = false;\n    bool in_quote_group_open8 = false;\n    bool in_paren_group_open9\
    \ = false;\n    bool in_quote_group_open9 = false;\n    bool in_paren_group_open10\
    \ = false;\n    bool in_quote_group_open10 = false;\n    bool in_paren_group_open11\
    \ = false;\n    bool in_quote_group_open11 = false;\n    bool in_paren_group_open12\
    \ = false;\n    bool in_quote_group_open12 = false;\n    bool in_paren_group_open13\
    \ = false;\n    bool in_quote_group_open13 = false;\n    bool in_paren_group_open14\
    \ = false;\n    bool in_quote_group_open14 = false;\n    bool in_paren_group_open15\
    \ = false;\n    bool in_quote_group_open15 = false;\n    bool in_paren_group_open16\
    \ = false;\n    bool in_quote_group_open16 = false;\n    bool in_paren_group_open17\
    \ = false;\n    bool in_quote_group_open17 = false;\n    bool in_paren_group_open18\
    \ = false;\n    bool in_quote_group_open18 = false;\n    bool in_paren_group_open19\
    \ = false;\n    bool in_quote_group_open19 = false;\n    bool in_paren_group_open20\
    \ = false;\n    bool in_quote_group_open20 = false;\n    bool in_paren_group_open21\
    \ = false;\n    bool in_quote_group_open21 = false;\n    bool in_paren_group_open22\
    \ = false;\n    bool in_quote_group_open22 = false;\n    bool in_paren_group_open23\
    \ = false;\n    bool in_quote_group_open23 = false;\n    bool in_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeots79yx.d(70): Error: semicolon expected, not \''unittest\''\n/tmp/tmpeots79yx.d(70):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpeots79yx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c++,string\
    \ |>\n<| c |>\nThis doesn't work. Try it with the string \"(()())\".\n<|/ c |>\n\
    <| c |>\nIt works. I tested it with the string \"(()())\"\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with the string \"(()())\".\n<|/ c |>\n<| c |>\nIt works.\
    \ I tested it with the string \"(()())\"\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try it with the string \"(()())\".\n<|/ c |>\n<| a dscore=2 |>\nI believe this\
    \ can be solved using dynamic programming. \nThe idea is to build a table of size\
    \ n+1 where n is the number of parentheses in the string. \nThe first row of the\
    \ table will contain the number of parentheses in the string and the number of\
    \ parentheses contained in the string itself. \nThe next row will contain the\
    \ number of parentheses in the string and the number of parentheses contained\
    \ in the string after the first parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first two parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first three parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first four parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first five parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first six parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first seven parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first eight parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first nine parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8mj3zkd.d(35): Error: Declaration expected, not \''<\''\n/tmp/tmpg8mj3zkd.d(38):
    Error: unterminated character constant\n/tmp/tmpg8mj3zkd.d(44): Error: unterminated
    character constant\n/tmp/tmpg8mj3zkd.d(50): Error: unterminated character constant\n/tmp/tmpg8mj3zkd.d(70):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpg8mj3zkd.d(71): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpg8mj3zkd.d(72): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpg8mj3zkd.d(73): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8mj3zkd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_current\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp30zlli2.d(72): Error: semicolon expected, not \''unittest\''\n/tmp/tmpp30zlli2.d(72):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp30zlli2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n \
    \       if(paren_string[i] == '(')\n        {\n            paren_stack.push(i);\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            int\
    \ paren_level = paren_stack.top();\n            paren_stack.pop();\n         \
    \   levels[paren_level] = max(levels[paren_level], paren_stack.size());\n    \
    \    }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,string,c++\
    \ |>\nI wrote a recursive solution in Python:\n<code>\ndef paren_levels(s):\n\
    \    levels = []\n    level = 0\n    stack = []\n    for c in s:\n        if c\
    \ == '(':\n            stack.append(level)\n        elif c == ')':\n         \
    \   level = stack.pop()\n        else:\n            levels.append(level)\n   \
    \         level = 0\n    return levels\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n#include <iostream>\n#include <stack>\n#include <string>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe3y0q6qs.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpe3y0q6qs.d(15): Error: found \''>\'' when expecting \''.\''
    following int\n/tmp/tmpe3y0q6qs.d(15): Error: found \''(\'' when expecting identifier
    following \''int.\''\n/tmp/tmpe3y0q6qs.d(15): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpe3y0q6qs.d(31): Error: Declaration expected,
    not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3y0q6qs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpde21_k55.d(86): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde21_k55.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_quote = false;\n    bool in_escape = false;\n    bool\
    \ in_escaped = false;\n    bool in_string = false;\n    bool in_comment = false;\n\
    \    bool in_comment = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc6d5tvza.d(99): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc6d5tvza.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    long index = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space = false;\n    bool is_closing_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space_or_space = false;\n    bool is_closing_paren_or_space_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space_or_space = false;\n\
    \    bool is_closing_curly_bracket_or_paren_or_space_or_space = false;\n    bool\
    \ is_opening_square_bracket_or_paren_or_space_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space_or_space\
    \ = false;\n    bool is_opening_paren_or_space_or_space_or_space = false;\n  \
    \  bool is_closing_paren_or_space_or_space_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_opening_paren_or_space_or_space_or_space_or_space = false;\n\
    \    bool is_closing_paren_or_space_or_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppj418cwo.d(51): Error: semicolon expected, not \''unittest\''\n/tmp/tmppj418cwo.d(51):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmppj418cwo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long max_level = 0;\n    long current_level\
    \ = 0;\n    long current_level_of_nesting = 0;\n    long current_level_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting = 0;\n    long\
    \ current_level_of_nesting_of_nesting_of_nesting_of_nesting = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdb5y3za9.d(34): Error: semicolon expected, not \''unittest\''\n/tmp/tmpdb5y3za9.d(34):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdb5y3za9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_bracket\
    \ = false;\n    bool in_paren_group_close_bracket = false;\n    bool in_paren_group_open_square\
    \ = false;\n    bool in_paren_group_close_square = false;\n    bool in_paren_group_open_curly\
    \ = false;\n    bool in_paren_group_close_curly = false;\n    bool in_paren_group_open_angle\
    \ = false;\n    bool in_paren_group_close_angle = false;\n    bool in_paren_group_open_paren\
    \ = false;\n    bool in_paren_group_close_paren = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0g1r074h.d(65): Error: semicolon expected, not \''unittest\''\n/tmp/tmp0g1r074h.d(65):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0g1r074h.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2 =\
    \ false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5\
    \ = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n    bool\
    \ in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n\
    \    bool in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13\
    \ = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n    bool\
    \ in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n\
    \    bool in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21\
    \ = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n    bool\
    \ in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n\
    \    bool in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29\
    \ = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n    bool\
    \ in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n\
    \    bool in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37\
    \ = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n    bool\
    \ in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n\
    \    bool in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45\
    \ = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n    bool\
    \ in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n\
    \    bool in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53\
    \ = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n    bool\
    \ in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n\
    \    bool in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61\
    \ = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n    bool\
    \ in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n\
    \    bool in_group67 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwafldhpc.d(85): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwafldhpc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_levels[] =\
    \ new long[paren_string.length()];\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_square = false;\n    bool in_paren_group_close_square\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_plus = false;\n    bool in_paren_group_close_plus\
    \ = false;\n    bool in_paren_group_open_minus = false;\n    bool in_paren_group_close_minus\
    \ = false;\n    bool in_paren_group_open_star = false;\n    bool in_paren_group_close_star\
    \ = false;\n    bool in_paren_group_open_comma = false;\n    bool in_paren_group_close_comma\
    \ = false;\n    bool in_paren_group_open_colon = false;\n    bool in_paren_group_close_colon\
    \ = false;\n    bool in_paren_group_open_semicolon = false;\n    bool in_paren_group_close_semicolon\
    \ = false;\n    bool in_paren_group_open_hash = false;\n    bool in_paren_group_close_hash\
    \ = false;\n    bool in_paren_group_open_open_paren = false;\n    bool in_paren_group_close_open_paren\
    \ = false;\n    bool in_paren_group_open_close_paren = false;\n    bool in_paren_group_open_open_curly\
    \ = false;\n    bool in_paren_group_close_open_curly = false;\n    bool in_paren_group_open_close_curly\
    \ = false;\n    bool in_paren_group_open_open_angle = false;\n    bool in_paren_group_close_open_angle\
    \ = false;\n    bool in_paren_group_open_open_plus = false;\n    bool in_paren_group_close_open_plus\
    \ = false;\n    bool in_paren_group_open_close_minus = false;\n    bool in_paren_group_open_close_star\
    \ = false;\n    bool in_paren_group_open_close_comma = false;\n    bool in_paren_group_open_close_colon\
    \ = false;\n    bool in_paren_group_open_close_semicolon = false;\n    bool in_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwfhcq7f3.d(64): Error: semicolon expected, not \''unittest\''\n/tmp/tmpwfhcq7f3.d(64):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpwfhcq7f3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] levels = new long[paren_groups.length()];\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpll3h5dla.d(63): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpll3h5dla.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma = false;\n    bool in_paren_group_open_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_comma_brace_comma = false;\n    bool in_paren_group_close_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_close_brace_comma_brace_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_comma_brace_comma_brace_comma = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_bra\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaktb6udf.d(43): Error: semicolon expected, not \''unittest\''\n/tmp/tmpaktb6udf.d(43):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpaktb6udf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_sum = 0;\n  \
    \  long paren_level_count_sum_max = 0;\n    long paren_level_count_sum_min = 0;\n\
    \    long paren_level_count_sum_avg = 0;\n    long paren_level_count_sum_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_min = 0;\n    long paren_level_count_sum_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7x4njra2.d(60): Error: semicolon expected, not \''unittest\''\n/tmp/tmp7x4njra2.d(60):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp7x4njra2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close = false;\n  \
    \  bool in_group_open_brace_or_close_brace_or_open_brace = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8lzbu48m.d(42): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8lzbu48m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_GROUPS];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppia62uvi.d(79): Error: semicolon expected, not \''unittest\''\n/tmp/tmppia62uvi.d(79):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmppia62uvi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_levels[] =\
    \ new long[paren_string.length()];\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening = false;\n    bool is_closing = false;\n    bool\
    \ is_opening_open = false;\n    bool is_opening_closed = false;\n    bool is_closing_open\
    \ = false;\n    bool is_closing_closed = false;\n    bool is_opening_opening =\
    \ false;\n    bool is_opening_closing = false;\n    bool is_closing_opening =\
    \ false;\n    bool is_closing_closing = false;\n    bool is_opening_opening_open\
    \ = false;\n    bool is_opening_opening_closed = false;\n    bool is_opening_closing_open\
    \ = false;\n    bool is_opening_closing_closed = false;\n    bool is_closing_opening_open\
    \ = false;\n    bool is_closing_opening_closed = false;\n    bool is_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closed = false;\n    bool is_opening_opening_opening\
    \ = false;\n    bool is_opening_opening_closing = false;\n    bool is_opening_closing_opening\
    \ = false;\n    bool is_opening_closing_closing = false;\n    bool is_closing_opening_opening\
    \ = false;\n    bool is_closing_opening_closing = false;\n    bool is_closing_closing_opening\
    \ = false;\n    bool is_closing_closing_closing = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_opening_open\
    \ = false;\n    bool is_closing_closing_opening_closed = false;\n    bool is_closing_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqfig7jcw.d(66): Error: no identifier for declarator bool\n/tmp/tmpqfig7jcw.d(66):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqfig7jcw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbb4ozv2n.d(86): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbb4ozv2n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_cur = 0;\n    long paren_level_next_prev = 0;\n    long paren_level_next_cur\
    \ = 0;\n    long paren_level_next_next_prev = 0;\n    long paren_level_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_prev = 0;\n    long paren_level_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_cur = 0;\n   \
    \ long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4yeyvqum.d(51): Error: semicolon expected, not \''unittest\''\n/tmp/tmp4yeyvqum.d(51):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4yeyvqum.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    bool is_open = false;\n    bool is_close = false;\n  \
    \  bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_level\
    \ = false;\n    bool is_closing_paren_level = false;\n    bool is_opening_paren_level_open\
    \ = false;\n    bool is_closing_paren_level_open = false;\n    bool is_opening_paren_level_close\
    \ = false;\n    bool is_closing_paren_level_close = false;\n    bool is_opening_paren_level_opening\
    \ = false;\n    bool is_closing_paren_level_opening = false;\n    bool is_opening_paren_level_closing\
    \ = false;\n    bool is_closing_paren_level_closing = false;\n    bool is_opening_paren_level_opening_paren\
    \ = false;\n    bool is_closing_paren_level_opening_paren = false;\n    bool is_opening_paren_level_closing_paren\
    \ = false;\n    bool is_closing_paren_level_closing_paren = false;\n    bool is_opening_paren_level_opening_paren_level\
    \ = false;\n    bool is_closing_paren_level_opening_paren_level = false;\n   \
    \ bool is_opening_paren_level_closing_paren_level = false;\n    bool is_closing_paren_level_closing_paren_level\
    \ = false;\n    bool is_opening_paren_level_opening_paren_level_open = false;\n\
    \    bool is_closing_paren_level_opening_paren_level_open = false;\n    bool is_opening_paren_level_closing_paren_level_open\
    \ = false;\n    bool is_closing_paren_level_closing_paren_level_open = false;\n\
    \    bool is_opening_paren_level_opening_paren_level_close = false;\n    bool\
    \ is_closing_paren_level_opening_paren_level_close = false;\n    bool is_opening_paren_level_closing_paren_level_close\
    \ = false;\n    bool is_closing_paren_level_closing_paren_level_close = false;\n\
    \    bool is_opening_paren_level_opening_paren_level_opening = false;\n    bool\
    \ is_closing_paren_level_opening_paren_level_opening = false;\n    bool is_opening_paren_level_closing_paren_level_opening\
    \ = false;\n    bool is_closing_paren_level_closing_paren_level_opening = false;\n\
    \    bool is_opening_paren_level_opening_paren_level_closing = false;\n    bool\
    \ is_closing_paren_level_opening_paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy1fsuqzj.d(56): Error: semicolon expected, not \''unittest\''\n/tmp/tmpy1fsuqzj.d(56):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy1fsuqzj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing = false;\n    bool\
    \ is_opening_paren_or_closing_or_opening_or_closing = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe5pogbu0.d(41): Error: semicolon expected, not \''unittest\''\n/tmp/tmpe5pogbu0.d(41):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpe5pogbu0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool has_open = false;\n    bool\
    \ has_close = false;\n    bool has_open_brace = false;\n    bool has_close_brace\
    \ = false;\n    bool has_open_paren = false;\n    bool has_close_paren = false;\n\
    \    bool has_open_curly = false;\n    bool has_close_curly = false;\n    bool\
    \ has_open_paren_or_curly = false;\n    bool has_close_paren_or_curly = false;\n\
    \    bool has_open_curly_or_curly = false;\n    bool has_close_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly = false;\n    bool has_close_paren_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_paren_or_curly_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu4elm0fu.d(47): Error: semicolon expected, not \''unittest\''\n/tmp/tmpu4elm0fu.d(47):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpu4elm0fu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i] ==\
    \ '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6pj_0n83.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n    bool\
    \ is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n   \
    \ bool is_opening_paren_or_opening_paren_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4jjaits8.d(42): Error: semicolon expected, not \''unittest\''\n/tmp/tmp4jjaits8.d(42):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4jjaits8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_group = 0;\n    long\
    \ current_group = 0;\n    long current_level = 0;\n    long current_level_group\
    \ = 0;\n    bool has_opening_paren = false;\n    bool has_opening_curly_brace\
    \ = false;\n    bool has_opening_curly_brace_group = false;\n    bool has_opening_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace = false;\n\
    \    bool has_opening_curly_brace_group_with_curly_brace_group = false;\n    bool\
    \ has_opening_curly_brace_group_with_curly_brace_group_with_paren = false;\n \
    \   bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp44c3pik7.d(39): Error: semicolon expected, not \''unittest\''\n/tmp/tmp44c3pik7.d(39):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp44c3pik7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_max_index\
    \ = 0;\n    long parens_level_max_index2 = 0;\n    long parens_level_max_index3\
    \ = 0;\n    long parens_level_max_index4 = 0;\n    long parens_level_max_index5\
    \ = 0;\n    long parens_level_max_index6 = 0;\n    long parens_level_max_index7\
    \ = 0;\n    long parens_level_max_index8 = 0;\n    long parens_level_max_index9\
    \ = 0;\n    long parens_level_max_index10 = 0;\n    long parens_level_max_index11\
    \ = 0;\n    long parens_level_max_index12 = 0;\n    long parens_level_max_index13\
    \ = 0;\n    long parens_level_max_index14 = 0;\n    long parens_level_max_index15\
    \ = 0;\n    long parens_level_max_index16 = 0;\n    long parens_level_max_index17\
    \ = 0;\n    long parens_level_max_index18 = 0;\n    long parens_level_max_index19\
    \ = 0;\n    long parens_level_max_index20 = 0;\n    long parens_level_max_index21\
    \ = 0;\n    long parens_level_max_index22 = 0;\n    long parens_level_max_index23\
    \ = 0;\n    long parens_level_max_index24 = 0;\n    long parens_level_max_index25\
    \ = 0;\n    long parens_level_max_index26 = 0;\n    long parens_level_max_index27\
    \ = 0;\n    long parens_level_max_index28 = 0;\n    long parens_level_max_index29\
    \ = 0;\n    long parens_level_max_index30 = 0;\n    long parens_level_max_index31\
    \ = 0;\n    long parens_level_max_index32 = 0;\n    long parens_level_max_index33\
    \ = 0;\n    long parens_level_max_index34 = 0;\n    long parens_level_max_index35\
    \ = 0;\n    long parens_level_max_index36 = 0;\n    long parens_level_max_index37\
    \ = 0;\n    long parens_level_max_index38 = 0;\n    long parens_level_max_index39\
    \ = 0;\n    long parens_level_max_index40 = 0;\n    long parens_level_max_index41\
    \ = 0;\n    long parens_level_max_index42 = 0;\n    long parens_level_max_index43\
    \ = 0;\n    long parens_level_max_index44 = 0;\n    long parens_level_max_index45\
    \ = 0;\n    long parens_level_max_index46 = 0;\n    long parens_level_max_index47\
    \ = 0;\n    long parens_level_max_index48\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp7sdn6h8.d(67): Error: semicolon expected, not \''unittest\''\n/tmp/tmpp7sdn6h8.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp7sdn6h8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 1;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly = false;\n\
    \    bool is_closing_curly = false;\n    bool is_opening_square = false;\n   \
    \ bool is_closing_square = false;\n    bool is_opening_angle = false;\n    bool\
    \ is_closing_angle = false;\n    bool is_opening_comma = false;\n    bool is_closing_comma\
    \ = false;\n    bool is_opening_colon = false;\n    bool is_closing_colon = false;\n\
    \    bool is_opening_semicolon = false;\n    bool is_closing_semicolon = false;\n\
    \    bool is_opening_colon2 = false;\n    bool is_closing_colon2 = false;\n  \
    \  bool is_opening_semicolon2 = false;\n    bool is_closing_semicolon2 = false;\n\
    \    bool is_opening_colon3 = false;\n    bool is_closing_colon3 = false;\n  \
    \  bool is_opening_semicolon3 = false;\n    bool is_closing_semicolon3 = false;\n\
    \    bool is_opening_colon4 = false;\n    bool is_closing_colon4 = false;\n  \
    \  bool is_opening_semicolon4 = false;\n    bool is_closing_semicolon4 = false;\n\
    \    bool is_opening_colon5 = false;\n    bool is_closing_colon5 = false;\n  \
    \  bool is_opening_semicolon5 = false;\n    bool is_closing_semicolon5 = false;\n\
    \    bool is_opening_colon6 = false;\n    bool is_closing_colon6 = false;\n  \
    \  bool is_opening_semicolon6 = false;\n    bool is_closing_semicolon6 = false;\n\
    \    bool is_opening_colon7 = false;\n    bool is_closing_colon7 = false;\n  \
    \  bool is_opening_semicolon7 = false;\n    bool is_closing_semicolon7 = false;\n\
    \    bool is_opening_colon8 = false;\n    bool is_closing_colon8 = false;\n  \
    \  bool is_opening_semicolon8 = false;\n    bool is_closing_semicolon8 = false;\n\
    \    bool is_opening_colon9 = false;\n    bool is_closing_colon9 = false;\n  \
    \  bool is_opening_semicolon9 = false;\n    bool is_closing_semicolon9 = false;\n\
    \    bool is_opening_colon10 = false;\n    bool is_closing_colon10 = false;\n\
    \    bool is_opening_semicolon10 = false;\n    bool is_closing_semicolon10 = false;\n\
    \    bool is_opening_colon11 = false;\n    bool is_closing_colon11 = false;\n\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaej5qzx6.d(72): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaej5qzx6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkza_51xr.d(63): Error: no identifier for declarator long\n/tmp/tmpkza_51xr.d(63):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkza_51xr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_max_min = 0;\n\
    \    long paren_level_count_max_min_index = 0;\n    long paren_level_count_max_min_index2\
    \ = 0;\n    long paren_level_count_max_min_index3 = 0;\n    long paren_level_count_max_min_index4\
    \ = 0;\n    long paren_level_count_max_min_index5 = 0;\n    long paren_level_count_max_min_index6\
    \ = 0;\n    long paren_level_count_max_min_index7 = 0;\n    long paren_level_count_max_min_index8\
    \ = 0;\n    long paren_level_count_max_min_index9 = 0;\n    long paren_level_count_max_min_index10\
    \ = 0;\n    long paren_level_count_max_min_index11 = 0;\n    long paren_level_count_max_min_index12\
    \ = 0;\n    long paren_level_count_max_min_index13 = 0;\n    long paren_level_count_max_min_index14\
    \ = 0;\n    long paren_level_count_max_min_index15 = 0;\n    long paren_level_count_max_min_index16\
    \ = 0;\n    long paren_level_count_max_min_index17 = 0;\n    long paren_level_count_max_min_index18\
    \ = 0;\n    long paren_level_count_max_min_index19 = 0;\n    long paren_level_count_max_min_index20\
    \ = 0;\n    long paren_level_count_max_min_index21 = 0;\n    long paren_level_count_max_min_index22\
    \ = 0;\n    long paren_level_count_max_min_index23 = 0;\n    long paren_level_count_max_min_index24\
    \ = 0;\n    long paren_level_count_max_min_index25 = 0;\n    long paren_level_count_max_min_index26\
    \ = 0;\n    long paren_level_count_max_min_index27 = 0;\n    long paren_level_count_max_min_index28\
    \ = 0;\n    long paren_level_count_max_min_index29 = 0;\n    long paren_level_count_max_min_index30\
    \ = 0;\n    long paren_level_count_max_min_index31 = 0;\n    long paren_level_count_max_min_index32\
    \ = 0;\n    long paren_level_count_max_min_index33 = 0;\n    long paren_level_count_max_min_index34\
    \ = 0;\n    long paren_level_count_max_min_index35 = 0;\n    long paren_level_count_max_min_index36\
    \ = 0;\n    long paren_level_count_max_min_index37 = 0;\n    long paren_level_count_max_min_index38\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8yb1t0hf.d(59): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8yb1t0hf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_dolt_s.d(95): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_dolt_s.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long levels_index = 0;\n    bool is_open\
    \ = false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_paren_or_closed = false;\n\
    \    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren = false;\n  \
    \  bool is_closing_paren_or_opening_paren_or_closed_or_open = false;\n    bool\
    \ is_opening_paren_or_closed_or_opening_paren_or_closed = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv8thvcn.d(47): Error: semicolon expected, not \''unittest\''\n/tmp/tmpxv8thvcn.d(47):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpxv8thvcn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplreifsoo.d(67): Error: semicolon expected, not \''unittest\''\n/tmp/tmplreifsoo.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplreifsoo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjggn76p3.d(86): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjggn76p3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_levels[]\
    \ = new long[paren_string.length()];\n    string paren_strings[] = paren_string.split(\"\
    \ \");\n    for(long i = 0; i < paren_strings.length; i++)\n    {\n        paren_levels[i]\
    \ = 0;\n        string paren_string = paren_strings[i];\n        for(long j =\
    \ 0; j < paren_string.length(); j++)\n        {\n            if(paren_string[j]\
    \ == '(')\n            {\n                paren_levels[i]++;\n            }\n\
    \            else if(paren_string[j] == ')')\n            {\n                paren_levels[i]--;\n\
    \                if(paren_levels[i] < 0)\n                {\n                \
    \    paren_levels[i] = 0;\n                }\n            }\n        }\n     \
    \   if(paren_levels[i] > max_level)\n        {\n            max_level = paren_levels[i];\n\
    \            level = i;\n        }\n    }\n    long[] result = new long[max_level\
    \ + 1];\n    result[level] = paren_string.length();\n    for(long i = 0; i < paren_strings.length;\
    \ i++)\n    {\n        string paren_string = paren_strings[i];\n        for(long\
    \ j = 0; j < paren_string.length(); j++)\n        {\n            if(paren_string[j]\
    \ == '(')\n            {\n                result[level]++;\n            }\n  \
    \          else if(paren_string[j] == ')')\n            {\n                result[level]--;\n\
    \                if(result[level] <= 0)\n                {\n                 \
    \   result[level] = 0;\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25r4s0nv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at_index = 0;\n    long\
    \ level_at_index = 0;\n    long level_at_paren_index = 0;\n    long level_at_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_index = 0;\n    long level_at_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_index = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_index = 0;\n\
    \    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_index = 0;\n\
    \    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl5kx1iuk.d(37): Error: semicolon expected, not \''unittest\''\n/tmp/tmpl5kx1iuk.d(37):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpl5kx1iuk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string current_paren = paren_string;\n    string next_paren = \"\";\n   \
    \ bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppztt4o5z.d(68): Error: no identifier for declarator bool\n/tmp/tmppztt4o5z.d(68):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmppztt4o5z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_open2 = false;\n    bool is_close2 =\
    \ false;\n    bool is_open3 = false;\n    bool is_close3 = false;\n    bool is_open4\
    \ = false;\n    bool is_close4 = false;\n    bool is_open5 = false;\n    bool\
    \ is_close5 = false;\n    bool is_open6 = false;\n    bool is_close6 = false;\n\
    \    bool is_open7 = false;\n    bool is_close7 = false;\n    bool is_open8 =\
    \ false;\n    bool is_close8 = false;\n    bool is_open9 = false;\n    bool is_close9\
    \ = false;\n    bool is_open10 = false;\n    bool is_close10 = false;\n    bool\
    \ is_open11 = false;\n    bool is_close11 = false;\n    bool is_open12 = false;\n\
    \    bool is_close12 = false;\n    bool is_open13 = false;\n    bool is_close13\
    \ = false;\n    bool is_open14 = false;\n    bool is_close14 = false;\n    bool\
    \ is_open15 = false;\n    bool is_close15 = false;\n    bool is_open16 = false;\n\
    \    bool is_close16 = false;\n    bool is_open17 = false;\n    bool is_close17\
    \ = false;\n    bool is_open18 = false;\n    bool is_close18 = false;\n    bool\
    \ is_open19 = false;\n    bool is_close19 = false;\n    bool is_open20 = false;\n\
    \    bool is_close20 = false;\n    bool is_open21 = false;\n    bool is_close21\
    \ = false;\n    bool is_open22 = false;\n    bool is_close22 = false;\n    bool\
    \ is_open23 = false;\n    bool is_close23 = false;\n    bool is_open24 = false;\n\
    \    bool is_close24 = false;\n    bool is_open25 = false;\n    bool is_close25\
    \ = false;\n    bool is_open26 = false;\n    bool is_close26 = false;\n    bool\
    \ is_open27 = false;\n    bool is_close27 = false;\n    bool is_open28 = false;\n\
    \    bool is_close28 = false;\n    bool is_open29 = false;\n    bool is_close29\
    \ = false;\n    bool is_open30 = false;\n    bool is_close30 = false;\n    bool\
    \ is_open31 = false;\n    bool is_close31 = false;\n    bool is_open32 = false;\n\
    \    bool is_close32 = false;\n    bool is_open33 = false;\n    bool is_close33\
    \ = false;\n    bool is_open34 = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkk9dil_v.d(87): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkk9dil_v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool\
    \ in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n\
    \    bool in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8\
    \ = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n    bool\
    \ in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n\
    \    bool in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16\
    \ = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n    bool\
    \ in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n\
    \    bool in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24\
    \ = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n    bool\
    \ in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n\
    \    bool in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32\
    \ = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n    bool\
    \ in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n\
    \    bool in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40\
    \ = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n    bool\
    \ in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n\
    \    bool in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48\
    \ = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n    bool\
    \ in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n\
    \    bool in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56\
    \ = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n    bool\
    \ in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n\
    \    bool in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64\
    \ = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n    bool\
    \ in_group67 = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr00k77yf.d(85): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr00k77yf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    bool has_paren = false;\n    bool has_paren2 = false;\n    bool has_paren3\
    \ = false;\n    bool has_paren4 = false;\n    bool has_paren5 = false;\n    bool\
    \ has_paren6 = false;\n    bool has_paren7 = false;\n    bool has_paren8 = false;\n\
    \    bool has_paren9 = false;\n    bool has_paren10 = false;\n    bool has_paren11\
    \ = false;\n    bool has_paren12 = false;\n    bool has_paren13 = false;\n   \
    \ bool has_paren14 = false;\n    bool has_paren15 = false;\n    bool has_paren16\
    \ = false;\n    bool has_paren17 = false;\n    bool has_paren18 = false;\n   \
    \ bool has_paren19 = false;\n    bool has_paren20 = false;\n    bool has_paren21\
    \ = false;\n    bool has_paren22 = false;\n    bool has_paren23 = false;\n   \
    \ bool has_paren24 = false;\n    bool has_paren25 = false;\n    bool has_paren26\
    \ = false;\n    bool has_paren27 = false;\n    bool has_paren28 = false;\n   \
    \ bool has_paren29 = false;\n    bool has_paren30 = false;\n    bool has_paren31\
    \ = false;\n    bool has_paren32 = false;\n    bool has_paren33 = false;\n   \
    \ bool has_paren34 = false;\n    bool has_paren35 = false;\n    bool has_paren36\
    \ = false;\n    bool has_paren37 = false;\n    bool has_paren38 = false;\n   \
    \ bool has_paren39 = false;\n    bool has_paren40 = false;\n    bool has_paren41\
    \ = false;\n    bool has_paren42 = false;\n    bool has_paren43 = false;\n   \
    \ bool has_paren44 = false;\n    bool has_paren45 = false;\n    bool has_paren46\
    \ = false;\n    bool has_paren47 = false;\n    bool has_paren48 = false;\n   \
    \ bool has_paren49 = false;\n    bool has_paren50 = false;\n    bool has_paren51\
    \ = false;\n    bool has_paren52 = false;\n    bool has_paren53 = false;\n   \
    \ bool has_paren54 = false;\n    bool has_paren55 = false;\n    bool has_paren56\
    \ = false;\n    bool has_paren57 = false;\n    bool has_paren58 = false;\n   \
    \ bool has_paren59 = false;\n    bool has_paren60 = false;\n    bool has_paren61\
    \ = false;\n    bool has_paren62 = false;\n    bool has_paren63 = false;\n   \
    \ bool has_paren64 = false;\n    bool has_paren65 = false;\n    bool has_paren66\
    \ = false;\n    bool has_paren67 = false;\n    bool has_paren68 = false;\n\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm3tui_xc.d(87): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3tui_xc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n6353yt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6n6353yt.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmp6n6353yt.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n6353yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_square = false;\n    bool in_paren_group_close_square\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_comma = false;\n    bool in_paren_group_close_comma\
    \ = false;\n    bool in_paren_group_open_colon = false;\n    bool in_paren_group_close_colon\
    \ = false;\n    bool in_paren_group_open_semicolon = false;\n    bool in_paren_group_close_semicolon\
    \ = false;\n    bool in_paren_group_open_colon2 = false;\n    bool in_paren_group_close_colon2\
    \ = false;\n    bool in_paren_group_open_semicolon2 = false;\n    bool in_paren_group_close_semicolon2\
    \ = false;\n    bool in_paren_group_open_colon3 = false;\n    bool in_paren_group_close_colon3\
    \ = false;\n    bool in_paren_group_open_semicolon3 = false;\n    bool in_paren_group_close_semicolon3\
    \ = false;\n    bool in_paren_group_open_colon4 = false;\n    bool in_paren_group_close_colon4\
    \ = false;\n    bool in_paren_group_open_semicolon4 = false;\n    bool in_paren_group_close_semicolon4\
    \ = false;\n    bool in_paren_group_open_colon5 = false;\n    bool in_paren_group_close_colon5\
    \ = false;\n    bool in_paren_group_open_semicolon5 = false;\n    bool in_paren_group_close_semicolon5\
    \ = false;\n    bool in_paren_group_open_colon6 = false;\n    bool in_paren_group_close_colon6\
    \ = false;\n    bool in_paren_group_open_semicolon6 = false;\n    bool in_paren_group_close_semicolon6\
    \ = false;\n    bool in_paren_group_open_colon7 = false;\n    bool in_paren_group_close_colon7\
    \ = false;\n    bool in_paren_group_open_semicolon7 = false;\n    bool in_paren_group_close_semicolon7\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyrpeu9w1.d(63): Error: no identifier for declarator bool\n/tmp/tmpyrpeu9w1.d(63):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpyrpeu9w1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    bool has_opening_paren = false;\n \
    \   bool has_closing_paren = false;\n    bool has_opening_paren_after_closing_paren\
    \ = false;\n    bool has_closing_paren_after_opening_paren = false;\n    bool\
    \ has_opening_paren_after_closing_paren_after_opening_paren = false;\n    bool\
    \ has_closing_paren_after_closing_paren_after_opening_paren = false;\n    bool\
    \ has_closing_paren_after_closing_paren_after_closing_paren = false;\n    bool\
    \ has_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp32164aqf.d(34): Error: semicolon expected, not \''unittest\''\n/tmp/tmp32164aqf.d(34):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp32164aqf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at_depth = 0;\n    long\
    \ level_at_depth = 0;\n    long paren_level = 0;\n    long paren_level_at_depth\
    \ = 0;\n    long paren_max_level_at_depth = 0;\n    long paren_level_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth = 0;\n    long paren_level_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth = 0;\n  \
    \  long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth = 0;\n    long\
    \ paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth = 0;\n    long\
    \ paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth = 0;\n   \
    \ long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth =\
    \ 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp00s2zrko.d(40): Error: semicolon expected, not \''unittest\''\n/tmp/tmp00s2zrko.d(40):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp00s2zrko.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_opener = false;\n    bool in_paren_group_closer = false;\n\
    \    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_closer_close = false;\n    bool in_paren_group_opener_close_open\
    \ = false;\n    bool in_paren_group_opener_close_close = false;\n    bool in_paren_group_closer_close_open\
    \ = false;\n    bool in_paren_group_closer_close_close = false;\n    bool in_paren_group_opener_close_opener\
    \ = false;\n    bool in_paren_group_opener_close_closer = false;\n    bool in_paren_group_closer_opener\
    \ = false;\n    bool in_paren_group_closer_closer = false;\n    bool in_paren_group_opener_close_opener_close\
    \ = false;\n    bool in_paren_group_opener_close_closer_open = false;\n    bool\
    \ in_paren_group_opener_close_closer_close = false;\n    bool in_paren_group_closer_opener_close\
    \ = false;\n    bool in_paren_group_closer_closer_open = false;\n    bool in_paren_group_closer_closer_close\
    \ = false;\n    bool in_paren_group_opener_close_opener_close_open = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close = false;\n    bool in_paren_group_opener_close_closer_opener_close\
    \ = false;\n    bool in_paren_group_opener_close_closer_closer_open = false;\n\
    \    bool in_paren_group_opener_close_closer_closer_close = false;\n    bool in_paren_group_closer_opener_close_opener_close\
    \ = false;\n    bool in_paren_group_closer_opener_close_closer_open = false;\n\
    \    bool in_paren_group_closer_opener_close_closer_close = false;\n    bool in_paren_group_closer_closer_opener_close\
    \ = false;\n    bool in_paren_group_closer_closer_closer_open = false;\n    bool\
    \ in_paren_group_closer_closer_closer_close = false;\n    bool in_paren_group_opener_close_opener_close_opener_close_open\
    \ = false;\n    bool in_paren_group_opener_close_opener_close_opener_close_close\
    \ = false;\n    bool in_paren_group_opener_close_clo\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcm4zfciy.d(55): Error: semicolon expected, not \''unittest\''\n/tmp/tmpcm4zfciy.d(55):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpcm4zfciy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            if(!in_paren)\n            {\n                in_paren = true;\n\
    \                level++;\n            }\n        }\n        else if(c == ')')\n\
    \        {\n            if(!in_paren)\n            {\n                in_paren\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == ' ' && in_paren)\n        {\n            levels[level] = levels[level] +\
    \ 1;\n        }\n        else if(c == ' ' && in_group)\n        {\n          \
    \  levels[level] = levels[level] + 1;\n        }\n        else if(c == '(')\n\
    \        {\n            in_group = true;\n        }\n        else if(c == ')')\n\
    \        {\n            in_group = false;\n        }\n    }\n    return levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3nbc1o2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2 =\
    \ false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5\
    \ = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n    bool\
    \ in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n\
    \    bool in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13\
    \ = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n    bool\
    \ in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n\
    \    bool in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21\
    \ = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n    bool\
    \ in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n\
    \    bool in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29\
    \ = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n    bool\
    \ in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n\
    \    bool in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37\
    \ = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n    bool\
    \ in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n\
    \    bool in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45\
    \ = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n    bool\
    \ in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n\
    \    bool in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53\
    \ = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n    bool\
    \ in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n\
    \    bool in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61\
    \ = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n    bool\
    \ in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n\
    \    bool in_group67 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwafldhpc.d(85): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwafldhpc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_cur\
    \ = 0;\n    long paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long\
    \ paren_level_max3 = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4\
    \ = 0;\n    long paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long\
    \ paren_level_cur5 = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6\
    \ = 0;\n    long paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long\
    \ paren_level_max8 = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9\
    \ = 0;\n    long paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long\
    \ paren_level_cur10 = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11\
    \ = 0;\n    long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n   \
    \ long paren_level_max13 = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14\
    \ = 0;\n    long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n   \
    \ long paren_level_cur15 = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16\
    \ = 0;\n    long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n   \
    \ long paren_level_max18 = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19\
    \ = 0;\n    long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n   \
    \ long paren_level_cur20 = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21\
    \ = 0;\n    long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n   \
    \ long paren_level_max23 = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24\
    \ = 0;\n    long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n   \
    \ long paren_level_cur25 = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26\
    \ = 0;\n    long paren_level_max27 = 0;\n    long paren_level_cur27 = 0;\n   \
    \ long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1aeytx1r.d(73): Error: semicolon expected, not \''unittest\''\n/tmp/tmp1aeytx1r.d(73):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1aeytx1r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long last_index = 0;\n    long last_level = 0;\n   \
    \ long paren_level = 0;\n    long paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3yjlunkf.d(68): Error: no identifier for declarator long\n/tmp/tmp3yjlunkf.d(68):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3yjlunkf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp37cl6ugl.d(75): Error: semicolon expected, not \''unittest\''\n/tmp/tmp37cl6ugl.d(75):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp37cl6ugl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797829
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma = false;\n    bool in_paren_group_open_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2wwctuk2.d(42): Error: semicolon expected, not \''unittest\''\n/tmp/tmp2wwctuk2.d(42):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2wwctuk2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797830
