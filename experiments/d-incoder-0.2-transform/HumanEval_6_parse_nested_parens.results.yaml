language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long max_level = 0;\n    long level = 0;\n\
    \    long levels_of_nesting = 0;\n    long current_level = 0;\n    long current_level_of_nesting\
    \ = 0;\n    long current_level_of_nesting_count = 0;\n    bool is_first_group\
    \ = true;\n    bool is_last_group = true;\n    bool is_first_group_of_current_level\
    \ = true;\n    bool is_last_group_of_current_level = true;\n    bool is_first_group_of_current_level_of_nesting\
    \ = true;\n    bool is_last_group_of_current_level_of_nesting = true;\n    bool\
    \ is_first_group_of_current_level_of_nesting_count = true;\n    bool is_last_group_of_current_level_of_nesting_count\
    \ = true;\n    bool is_first_group_of_current_level_of_nesting_count_plus_one\
    \ = true;\n    bool is_last_group_of_current_level_of_nesting_count_plus_one =\
    \ true;\n    bool is_first_group_of_current_level_of_nesting_count_plus_two =\
    \ true;\n    bool is_last_group_of_current_level_of_nesting_count_plus_two = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_three = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_three = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_four = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_four = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_five = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_five = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_six = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_six = true;\n \
    \   bool is_first_group_of_current_level_of_nesting_count_plus_seven = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_seven = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_eight = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_eight = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_nine = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_nine = true;\n\
    \    bool is_first_group_of_current_level_of_nesting_count_plus_ten = true;\n\
    \    bool is_last_group_of_current_level_of_nesting_count_plus_ten = true;\n \
    \   bool is_first_group_of_current_level_of_nesting_count_plus_eleven = true;\n\
    \    bool is_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe37y70gd.d(52): Error: semicolon expected, not `unittest`

    /tmp/tmpe37y70gd.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe37y70gd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_or_closing = false;\n\
    \    bool is_opening_or_closing_or_opening = false;\n    bool is_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening =\
    \ false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgpii1q_c.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpgpii1q_c.d(33): Error: semicolon expected, not `unittest`

    /tmp/tmpgpii1q_c.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgpii1q_c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_index = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_closing_curly_brace\
    \ = false;\n    bool has_opening_square_brace = false;\n    bool has_closing_square_brace\
    \ = false;\n    bool has_opening_curly_bracket = false;\n    bool has_closing_curly_bracket\
    \ = false;\n    bool has_opening_square_bracket = false;\n    bool has_closing_square_bracket\
    \ = false;\n    bool has_opening_curly_brace = false;\n    bool has_clo\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe53677wu.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] level_stack`

    /tmp/tmpe53677wu.d(66): Error: semicolon expected, not `unittest`

    /tmp/tmpe53677wu.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe53677wu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   long paren_levels[] = new long[paren_string.length()];\n    long paren_level_index\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index = 0;\n \
    \   long paren_level_max_index2 = 0;\n    long paren_level_max_index3 = 0;\n \
    \   long paren_level_max_index4 = 0;\n    long paren_level_max_index5 = 0;\n \
    \   long paren_level_max_index6 = 0;\n    long paren_level_max_index7 = 0;\n \
    \   long paren_level_max_index8 = 0;\n    long paren_level_max_index9 = 0;\n \
    \   long paren_level_max_index10 = 0;\n    long paren_level_max_index11 = 0;\n\
    \    long paren_level_max_index12 = 0;\n    long paren_level_max_index13 = 0;\n\
    \    long paren_level_max_index14 = 0;\n    long paren_level_max_index15 = 0;\n\
    \    long paren_level_max_index16 = 0;\n    long paren_level_max_index17 = 0;\n\
    \    long paren_level_max_index18 = 0;\n    long paren_level_max_index19 = 0;\n\
    \    long paren_level_max_index20 = 0;\n    long paren_level_max_index21 = 0;\n\
    \    long paren_level_max_index22 = 0;\n    long paren_level_max_index23 = 0;\n\
    \    long paren_level_max_index24 = 0;\n    long paren_level_max_index25 = 0;\n\
    \    long paren_level_max_index26 = 0;\n    long paren_level_max_index27 = 0;\n\
    \    long paren_level_max_index28 = 0;\n    long paren_level_max_index29 = 0;\n\
    \    long paren_level_max_index30 = 0;\n    long paren_level_max_index31 = 0;\n\
    \    long paren_level_max_index32 = 0;\n    long paren_level_max_index33 = 0;\n\
    \    long paren_level_max_index34 = 0;\n    long paren_level_max_index35 = 0;\n\
    \    long paren_level_max_index36 = 0;\n    long paren_level_max_index37 = 0;\n\
    \    long paren_level_max_index38 = 0;\n    long paren_level_max_index39 = 0;\n\
    \    long paren_level_max_index40 = 0;\n    long paren_level_max_index41 = 0;\n\
    \    long paren_level_max_index42 = 0;\n    long paren_level_max_index43 = 0;\n\
    \    long paren_level_max_index44 = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp14vqf8iv.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp14vqf8iv.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] paren_levels`

    /tmp/tmp14vqf8iv.d(68): Error: no identifier for declarator `long`

    /tmp/tmp14vqf8iv.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp14vqf8iv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren = false;\n    bool in_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren = false;\n \
    \   bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote = false;\n    bool\
    \ in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren = false;\n  \
    \  bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren\
    \ = false;\n    bool in_paren_or_quote_or_paren_or_quote_or_paren_or_quote_or_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplfd4yssl.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmplfd4yssl.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmplfd4yssl.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplfd4yssl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; i++) \n    {\n        if(paren_chars[i] == \"(\") \n \
    \       {\n            level++;\n        }\n        else if(paren_chars[i] ==\
    \ \")\") \n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level) \n        {\n            max_level = level;\n \
    \       }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ikk4xki.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp2ikk4xki.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_chars`

    /tmp/tmp2ikk4xki.d(16): Error: no property `length` for type `string`

    /tmp/tmp2ikk4xki.d(17): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ikk4xki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    paren_stack = paren_string;\n    paren_levels[paren_level] = 0;\n    long\
    \ paren_levels_index = 0;\n    bool paren_stack_empty = true;\n    long paren_levels_index2\
    \ = 0;\n    bool paren_levels_index2_empty = true;\n    long paren_levels_index3\
    \ = 0;\n    bool paren_levels_index3_empty = true;\n    long paren_levels_index4\
    \ = 0;\n    bool paren_levels_index4_empty = true;\n    long paren_levels_index5\
    \ = 0;\n    bool paren_levels_index5_empty = true;\n    long paren_levels_index6\
    \ = 0;\n    bool paren_levels_index6_empty = true;\n    long paren_levels_index7\
    \ = 0;\n    bool paren_levels_index7_empty = true;\n    long paren_levels_index8\
    \ = 0;\n    bool paren_levels_index8_empty = true;\n    long paren_levels_index9\
    \ = 0;\n    bool paren_levels_index9_empty = true;\n    long paren_levels_index10\
    \ = 0;\n    bool paren_levels_index10_empty = true;\n    long paren_levels_index11\
    \ = 0;\n    bool paren_levels_index11_empty = true;\n    long paren_levels_index12\
    \ = 0;\n    bool paren_levels_index12_empty = true;\n    long paren_levels_index13\
    \ = 0;\n    bool paren_levels_index13_empty = true;\n    long paren_levels_index14\
    \ = 0;\n    bool paren_levels_index14_empty = true;\n    long paren_levels_index15\
    \ = 0;\n    bool paren_levels_index15_empty = true;\n    long paren_levels_index16\
    \ = 0;\n    bool paren_levels_index16_empty = true;\n    long paren_levels_index17\
    \ = 0;\n    bool paren_levels_index17_empty = true;\n    long paren_levels_index18\
    \ = 0;\n    bool paren_levels_index18_empty = true;\n    long paren_levels_index19\
    \ = 0;\n    bool paren_levels_index19_empty = true;\n    long paren_levels_index20\
    \ = 0;\n    bool paren_levels_index20_empty = true;\n    long paren_levels_index21\
    \ = 0;\n    bool paren_levels_index21_empty = true;\n    long paren_levels_index22\
    \ = 0;\n    bool paren_levels_index22_empty = true;\n    long paren_levels_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptud7rzeq.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] paren_levels`

    /tmp/tmptud7rzeq.d(64): Error: semicolon expected, not `unittest`

    /tmp/tmptud7rzeq.d(64): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptud7rzeq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_opener\
    \ = false;\n    bool in_group_closer = false;\n    bool in_group_opener_close\
    \ = false;\n    bool in_group_closer_close = false;\n    bool in_group_opener_open\
    \ = false;\n    bool in_group_closer_open = false;\n    bool in_group_opener_opener\
    \ = false;\n    bool in_group_closer_opener = false;\n    bool in_group_opener_closer\
    \ = false;\n    bool in_group_closer_closer = false;\n    bool in_group_opener_opener\
    \ = false;\n    bool in_group_closer_opener = false;\n    bool in_group_closer_closer\
    \ = false;\n    bool in_group_opener_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_opener_closer_closer_open\
    \ = false;\n    bool in_group_closer_closer_open = false;\n    bool in_group_closer_closer_open\
    \ = false;\n    bool in_group_opener_closer_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8zmvnmua.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp8zmvnmua.d(64): Error: semicolon expected, not `unittest`

    /tmp/tmp8zmvnmua.d(64): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zmvnmua.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_b\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplbfaj2c5.d(48): Error: semicolon expected, not `unittest`

    /tmp/tmplbfaj2c5.d(48): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplbfaj2c5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxih3nl78.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpxih3nl78.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmpxih3nl78.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxih3nl78.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    long level_size = 0;\n    long level_pointer\
    \ = 0;\n    long level_pointer_pointer = 0;\n    long level_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer = 0;\n    long level_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer = 0;\n\
    \    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer = 0;\n\
    \    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = 0;\n    long level_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0sp1ti4.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] level_stack`

    /tmp/tmpd0sp1ti4.d(39): Error: semicolon expected, not `unittest`

    /tmp/tmpd0sp1ti4.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0sp1ti4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_group\
    \ = false;\n    bool in_quote_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_quote_group_open = false;\n    bool in_paren_group_closed = false;\n\
    \    bool in_quote_group_closed = false;\n    bool in_paren_group_open_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote = false;\n    bool in_paren_group_closed_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote = false;\n    bool in_paren_group_open_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren = false;\n\
    \    bool in_paren_group_closed_inside_quote_inside_paren = false;\n    bool in_quote_group_closed_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_closed_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_quote_group_closed_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote\
    \ = false;\n    bool in_paren_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_quote_group_open_inside_quote_inside_paren_inside_quote_inside_paren_inside_quote_inside_paren\
    \ = false;\n    bool in_paren_group_closed_inside_quote_in\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6zfs8clv.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp6zfs8clv.d(48): Error: semicolon expected, not `unittest`

    /tmp/tmp6zfs8clv.d(48): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zfs8clv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long index = 0;\n    bool is_open =\
    \ false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n  \
    \  bool is_closing_paren = false;\n    bool is_opening_curly = false;\n    bool\
    \ is_closing_curly = false;\n    bool is_opening_square = false;\n    bool is_closing_square\
    \ = false;\n    bool is_opening_angle = false;\n    bool is_closing_angle = false;\n\
    \    bool is_opening_paren_or_curly = false;\n    bool is_closing_paren_or_curly\
    \ = false;\n    bool is_opening_paren_or_angle = false;\n    bool is_closing_paren_or_angle\
    \ = false;\n    bool is_opening_square_or_angle = false;\n    bool is_closing_square_or_angle\
    \ = false;\n    bool is_opening_curly_or_angle = false;\n    bool is_closing_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly = false;\n    bool is_closing_square_or_curly\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_or_angle = false;\n    bool is_closing_square_or_curly_or_angle\
    \ = false;\n    bool is_opening_paren_or_curly_or_angle = false;\n    bool is_closing_paren_or_curly_or_angle\
    \ = false;\n    bool is_opening_square_or_curly_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgsjyc95e.d(60): Error: semicolon expected, not `unittest`

    /tmp/tmpgsjyc95e.d(60): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsjyc95e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool has_left_paren = false;\n    bool has_right_paren\
    \ = false;\n    bool has_left_bracket = false;\n    bool has_right_bracket = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_square = false;\n    bool has_right_square\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_square = false;\n    bool has_right_square = false;\n    bool has_left_curly\
    \ = false;\n    bool has_right_curly = false;\n    bool has_left_brace = false;\n\
    \    bool has_right_brace = false;\n    bool has_left_square = false;\n    bool\
    \ has_right_square = false;\n    bool has_left_curly = false;\n    bool has_right_curly\
    \ = false;\n    bool has_left_brace = false;\n    bool has_right_brace = false;\n\
    \    bool has_left_square = false;\n    bool has_right_square = false;\n    bool\
    \ has_left_curly = false;\n    bool has_right_curly = false;\n    bool has_left_brace\
    \ = false;\n    bool has_right_brace = false;\n    bool has_left_square = false;\n\
    \    bool has_right_square = false;\n    bool has_left_curly = false;\n    bool\
    \ has_right_curly = false;\n    bool has_left_brace = false;\n    bool has_right_brace\
    \ = false;\n    bool has_left_square = false;\n    bool has_right_square = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_square = false;\n    bool has_right_square\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_square = false;\n    bool has_right_square = false;\n    bool has_left_curly\
    \ = false;\n    bool has_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr3ljemwo.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpr3ljemwo.d(84): Error: semicolon expected, not `unittest`

    /tmp/tmpr3ljemwo.d(84): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr3ljemwo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long pos = 0;\n    long i = 0;\n    while(pos < paren_string.length()) {\n\
    \        char c = paren_string[pos];\n        if(c == '(') {\n            levels[pos]\
    \ = level;\n            level++;\n        } else if(c == ')') {\n            level--;\n\
    \            if(level == 0) {\n                level = levels[pos];\n        \
    \        levels[pos] = level;\n            }\n        } else if(c == ' ') {\n\
    \            levels[pos] = level;\n        }\n        pos++;\n        i++;\n \
    \   }\n    for(i = 0; i < paren_string.length(); i++) {\n        if(levels[i]\
    \ != level) {\n            max_level = max(max_level, levels[i]);\n        }\n\
    \    }\n    return max_level;\n}\n</code>\n<|/ a tags=algorithm,string,c++ |>\n\
    <| c |>\nThis is not an answer. Just a bunch of code. Could you please explain\
    \ how this solves the problem?\n<|/ c |>\n<| c |>\nThis code will give the maximum\
    \ level of nesting of a string with parentheses.\n<|/ c |>\n<| c |>\nThis code\
    \ does not give the maximum level of nesting of a string with parentheses.\n<|/\
    \ c |>\n<| c |>\nThis code gives the maximum level of nesting of a string with\
    \ parentheses.\n<|/ c |>\n<| c |>\nThis code gives the maximum level of nesting\
    \ of a string with parentheses.\n<|/ c |>\n<| a tags=algorithm,string,c++ |>\n\
    <code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl8j4gg4l.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpl8j4gg4l.d(43): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8j4gg4l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsupsm_z5.d(45): Error: semicolon expected, not `unittest`

    /tmp/tmpsupsm_z5.d(45): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsupsm_z5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.ToCharArray();\n    for(int i = 0; i\
    \ < paren_string.length(); i++)\n    {\n        if(paren_chars[i] == '(')\n  \
    \      {\n            level++;\n        }\n        else if(paren_chars[i] == ')')\n\
    \        {\n            level--;\n        }\n        levels[i] = level;\n    \
    \    if(level > max_level)\n        {\n            max_level = level;\n      \
    \  }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c#,parentheses\
    \ |>\n<| a tags=algorithm,c#,parentheses |>\n<code>\npublic static void Main(string[]\
    \ args)\n{\n    string input = \"(()()) ((())) () ((())()())\";\n    List<int>\
    \ levels = new List<int>();\n    List<int> levelsCount = new List<int>();\n  \
    \  List<int> levelsCount2 = new List<int>();\n    List<int> levelsCount3 = new\
    \ List<int>();\n    List<int> levelsCount4 = new List<int>();\n    List<int> levelsCount5\
    \ = new List<int>();\n    List<int> levelsCount6 = new List<int>();\n    List<int>\
    \ levelsCount7 = new List<int>();\n    List<int> levelsCount8 = new List<int>();\n\
    \    List<int> levelsCount9 = new List<int>();\n    List<int> levelsCount10 =\
    \ new List<int>();\n    List<int> levelsCount11 = new List<int>();\n    List<int>\
    \ levelsCount12 = new List<int>();\n    List<int> levelsCount13 = new List<int>();\n\
    \    List<int> levelsCount14 = new List<int>();\n    List<int> levelsCount15 =\
    \ new List<int>();\n    List<int> levelsCount16 = new List<int>();\n    List<int>\
    \ levelsCount17 = new List<int>();\n    List<int> levelsCount18 = new List<int>();\n\
    \    List<int> levelsCount19 = new List<int>();\n    List<int> levelsCount20 =\
    \ new List<int>();\n    List<int> levelsCount21 = new List<int>();\n    List<int>\
    \ levelsCount22 = new List<int>();\n    List<int> levelsCount23 = new List<int>();\n\
    \    List<int> levelsCount24 = new List<int>();\n    List<int> levelsCount25 =\
    \ new List<int>();\n    List<int> level\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7arn3qq0.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp7arn3qq0.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_chars`

    /tmp/tmp7arn3qq0.d(36): Error: declaration expected, not `<`

    /tmp/tmp7arn3qq0.d(43): Error: no identifier for declarator `List`

    /tmp/tmp7arn3qq0.d(43): Error: declaration expected, not `<`

    /tmp/tmp7arn3qq0.d(44): Error: no identifier for declarator `List`

    /tmp/tmp7arn3qq0.d(44): Error: declaration expected, not `<`

    /tmp/tmp7arn3qq0.d(45): Error: no identifier for declarator `List`

    /tmp/tmp7arn3qq0.d(45): Error: declaration expected, not `<`

    /tmp/tmp7arn3qq0.d(46): Error: no identifier for declarator `List`

    /tmp/tmp7arn3qq0.d(46): Error: declaration expected, not `<`

    /tmp/tmp7arn3qq0.d(47): Error: no identifier for declarator `List`

    /tmp/tmp7arn3qq0.d(47): Error: declaration expected, not `<`

    /tmp/tmp7arn3qq0.d(48): Error: no identifier for declarator `List`

    /tmp/tmp7arn3qq0.d(48): Error: declaration expected'
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool has_parens = false;\n    bool has_space = false;\n\
    \    bool has_comma = false;\n    bool has_opening_bracket = false;\n    bool\
    \ has_closing_bracket = false;\n    bool has_opening_paren = false;\n    bool\
    \ has_closing_paren = false;\n    bool has_opening_curly = false;\n    bool has_closing_curly\
    \ = false;\n    bool has_opening_square = false;\n    bool has_closing_square\
    \ = false;\n    bool has_opening_angle = false;\n    bool has_closing_angle =\
    \ false;\n    bool has_opening_plus = false;\n    bool has_closing_plus = false;\n\
    \    bool has_opening_minus = false;\n    bool has_closing_minus = false;\n  \
    \  bool has_opening_comma = false;\n    bool has_closing_comma = false;\n    bool\
    \ has_opening_colon = false;\n    bool has_closing_colon = false;\n    bool has_opening_semicolon\
    \ = false;\n    bool has_closing_semicolon = false;\n    bool has_opening_colon2\
    \ = false;\n    bool has_closing_colon2 = false;\n    bool has_opening_semicolon2\
    \ = false;\n    bool has_closing_semicolon2 = false;\n    bool has_opening_colon3\
    \ = false;\n    bool has_closing_colon3 = false;\n    bool has_opening_semicolon3\
    \ = false;\n    bool has_closing_semicolon3 = false;\n    bool has_opening_colon4\
    \ = false;\n    bool has_closing_colon4 = false;\n    bool has_opening_semicolon4\
    \ = false;\n    bool has_closing_semicolon4 = false;\n    bool has_opening_colon5\
    \ = false;\n    bool has_closing_colon5 = false;\n    bool has_opening_semicolon5\
    \ = false;\n    bool has_closing_semicolon5 = false;\n    bool has_opening_colon6\
    \ = false;\n    bool has_closing_colon6 = false;\n    bool has_opening_semicolon6\
    \ = false;\n    bool has_closing_semicolon6 = false;\n    bool has_opening_colon7\
    \ = false;\n    bool has_closing_colon7 = false;\n    bool has_opening_semicolon7\
    \ = false;\n    bool has_closing_semicolon7 = false;\n    bool has_opening_colon8\
    \ = false;\n    bool has_closing_colon8 = false;\n    bool has_opening_semicolon8\
    \ = false;\n    bool has_closing_semicolon8 = false;\n    bool has_opening_colon9\
    \ = false;\n    bool has_closing_colon9 = false;\n    bool has_opening_semicolon9\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgu8a9qao.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpgu8a9qao.d(72): Error: semicolon expected, not `unittest`

    /tmp/tmpgu8a9qao.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgu8a9qao.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly = false;\n\
    \    bool is_closing_curly = false;\n    bool is_opening_square = false;\n   \
    \ bool is_closing_square = false;\n    bool is_opening_curly_square = false;\n\
    \    bool is_closing_curly_square = false;\n    bool is_opening_paren_square =\
    \ false;\n    bool is_closing_paren_square = false;\n    bool is_opening_curly_curly\
    \ = false;\n    bool is_closing_curly_curly = false;\n    bool is_opening_square_curly\
    \ = false;\n    bool is_closing_square_curly = false;\n    bool is_opening_paren_curly\
    \ = false;\n    bool is_closing_paren_curly = false;\n    bool is_opening_curly_paren\
    \ = false;\n    bool is_closing_curly_paren = false;\n    bool is_opening_square_paren\
    \ = false;\n    bool is_closing_square_paren = false;\n    bool is_opening_paren_paren\
    \ = false;\n    bool is_closing_paren_paren = false;\n    bool is_opening_curly_curly_paren\
    \ = false;\n    bool is_closing_curly_curly_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    bool is_opening_paren_curly_paren\
    \ = false;\n    bool is_closing_paren_curly_paren = false;\n    bool is_opening_curly_square_paren\
    \ = false;\n    bool is_closing_curly_square_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    bool is_opening_paren_curly_square\
    \ = false;\n    bool is_closing_paren_curly_square = false;\n    bool is_opening_square_curly_square\
    \ = false;\n    bool is_closing_square_curly_square = false;\n    bool is_opening_paren_curly_curly\
    \ = false;\n    bool is_closing_paren_curly_curly = false;\n    bool is_opening_square_curly_curly\
    \ = false;\n    bool is_closing_square_curly_curly = false;\n    bool is_opening_paren_curly_paren\
    \ = false;\n    bool is_closing_paren_curly_paren = false;\n    bool is_opening_square_curly_paren\
    \ = false;\n    bool is_closing_square_curly_paren = false;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpih9avzko.d(64): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpih9avzko.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    string current_level = \"\";\n\
    \    long current_level_size = 0;\n    bool in_paren = false;\n    bool in_group\
    \ = false;\n    bool in_group_open = false;\n    bool in_group_close = false;\n\
    \    bool in_group_comma = false;\n    bool in_group_space = false;\n    bool\
    \ in_group_newline = false;\n    bool in_group_semicolon = false;\n    bool in_group_colon\
    \ = false;\n    bool in_group_equal = false;\n    bool in_group_comma2 = false;\n\
    \    bool in_group_space2 = false;\n    bool in_group_newline2 = false;\n    bool\
    \ in_group_semicolon2 = false;\n    bool in_group_colon2 = false;\n    bool in_group_equal2\
    \ = false;\n    bool in_group_comma3 = false;\n    bool in_group_space3 = false;\n\
    \    bool in_group_newline3 = false;\n    bool in_group_semicolon3 = false;\n\
    \    bool in_group_colon3 = false;\n    bool in_group_equal3 = false;\n    bool\
    \ in_group_comma4 = false;\n    bool in_group_space4 = false;\n    bool in_group_newline4\
    \ = false;\n    bool in_group_semicolon4 = false;\n    bool in_group_colon4 =\
    \ false;\n    bool in_group_equal4 = false;\n    bool in_group_comma5 = false;\n\
    \    bool in_group_space5 = false;\n    bool in_group_newline5 = false;\n    bool\
    \ in_group_semicolon5 = false;\n    bool in_group_colon5 = false;\n    bool in_group_equal5\
    \ = false;\n    bool in_group_comma6 = false;\n    bool in_group_space6 = false;\n\
    \    bool in_group_newline6 = false;\n    bool in_group_semicolon6 = false;\n\
    \    bool in_group_colon6 = false;\n    bool in_group_equal6 = false;\n    bool\
    \ in_group_comma7 = false;\n    bool in_group_space7 = false;\n    bool in_group_newline7\
    \ = false;\n    bool in_group_semicolon7 = false;\n    bool in_group_colon7 =\
    \ false;\n    bool in_group_equal7 = false;\n    bool in_group_comma8 = false;\n\
    \    bool in_group_space8 = false;\n    bool in_group_newline8 = false;\n    bool\
    \ in_group_semicolon8 = false;\n    bool in_group_colon8 = false;\n    bool in_group_equal8\
    \ = false;\n    bool in_group_comma9 = false;\n    bool in_group_space9 = false;\n\
    \    bool in_group_newline9 = false;\n    bool in_group_semicolon9 = false;\n\
    \    bool in_group_colon9 = false;\n    bool in_group_equal9 = false;\n    bool\
    \ in_group_comma10 = false;\n    bool in_group_space10 = false;\n    bool in_group_newline10\
    \ = false;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt86xbthn.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt86xbthn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paran = false;\n    bool in_paran2 =\
    \ false;\n    bool in_paran3 = false;\n    bool in_paran4 = false;\n    bool in_paran5\
    \ = false;\n    bool in_paran6 = false;\n    bool in_paran7 = false;\n    bool\
    \ in_paran8 = false;\n    bool in_paran9 = false;\n    bool in_paran10 = false;\n\
    \    bool in_paran11 = false;\n    bool in_paran12 = false;\n    bool in_paran13\
    \ = false;\n    bool in_paran14 = false;\n    bool in_paran15 = false;\n    bool\
    \ in_paran16 = false;\n    bool in_paran17 = false;\n    bool in_paran18 = false;\n\
    \    bool in_paran19 = false;\n    bool in_paran20 = false;\n    bool in_paran21\
    \ = false;\n    bool in_paran22 = false;\n    bool in_paran23 = false;\n    bool\
    \ in_paran24 = false;\n    bool in_paran25 = false;\n    bool in_paran26 = false;\n\
    \    bool in_paran27 = false;\n    bool in_paran28 = false;\n    bool in_paran29\
    \ = false;\n    bool in_paran30 = false;\n    bool in_paran31 = false;\n    bool\
    \ in_paran32 = false;\n    bool in_paran33 = false;\n    bool in_paran34 = false;\n\
    \    bool in_paran35 = false;\n    bool in_paran36 = false;\n    bool in_paran37\
    \ = false;\n    bool in_paran38 = false;\n    bool in_paran39 = false;\n    bool\
    \ in_paran40 = false;\n    bool in_paran41 = false;\n    bool in_paran42 = false;\n\
    \    bool in_paran43 = false;\n    bool in_paran44 = false;\n    bool in_paran45\
    \ = false;\n    bool in_paran46 = false;\n    bool in_paran47 = false;\n    bool\
    \ in_paran48 = false;\n    bool in_paran49 = false;\n    bool in_paran50 = false;\n\
    \    bool in_paran51 = false;\n    bool in_paran52 = false;\n    bool in_paran53\
    \ = false;\n    bool in_paran54 = false;\n    bool in_paran55 = false;\n    bool\
    \ in_paran56 = false;\n    bool in_paran57 = false;\n    bool in_paran58 = false;\n\
    \    bool in_paran59 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4c7x433l.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp4c7x433l.d(77): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4c7x433l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren = false;\n  \
    \  bool is_closing_paren_or_opening_paren_or_closed_or_open = false;\n    bool\
    \ is_opening_paren_or_closed_or_opening_paren_or_closed = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpag33rvih.d(45): Error: semicolon expected, not `unittest`

    /tmp/tmpag33rvih.d(45): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpag33rvih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for your answer. Your code works well for simple parentheses, but fails\
    \ for more complex ones. For example, it fails for \"((()))\" with maximum level\
    \ of nesting \"2\".\n<|/ c |>\n<| c |>\nI updated my answer to include a solution\
    \ for more complex parentheses\n<|/ c |>\n<| c |>\nThanks for your answer. Your\
    \ code works well for simple parentheses, but fails for more complex ones. For\
    \ example, it fails for \"((()))\" with maximum level of nesting \"2\".\n<|/ c\
    \ |>\n<| c |>\nI updated my answer to include a solution for more complex parentheses\n\
    <|/ c |>\n<| c |>\nThanks for your answer. Your code works well for simple parentheses,\
    \ but fails for more complex ones. For example, it fails for \"((()))\" with maximum\
    \ level of nesting \"2\".\n<|/ c |>\n<| a tags=algorithm,parentheses,c++ |>\n\
    <code>\n#include <iostream>\n#include <stack>\n#include <string>\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpky5p08pf.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpky5p08pf.d(35): Error: declaration expected, not `<`

    /tmp/tmpky5p08pf.d(61): Error: declaration expected, not `assert`

    /tmp/tmpky5p08pf.d(62): Error: declaration expected, not `assert`

    /tmp/tmpky5p08pf.d(63): Error: declaration expected, not `assert`

    /tmp/tmpky5p08pf.d(64): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpky5p08pf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_close =\
    \ false;\n    bool in_group_close_brace_close = false;\n    bool in_group_open_brace_open\
    \ = false;\n    bool in_group_close_brace_open = false;\n    bool in_group_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace\
    \ = false;\n    bool in_group_close_brace_open_brace = false;\n    bool in_group_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close = false;\n    bool in_group_close_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace = false;\n \
    \   bool in_group_open_brace_open_brace_close_brace_close = false;\n    bool in_group_close_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close = false;\n\
    \    bool in_group_open_brace_open_brace_close_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_open_brace_close_brace_close_brace = false;\n   \
    \ bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsn6jnvw1.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpsn6jnvw1.d(50): Error: semicolon expected, not `unittest`

    /tmp/tmpsn6jnvw1.d(50): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn6jnvw1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            if(!in_paren)\n        \
    \    {\n                level++;\n                in_paren = true;\n         \
    \   }\n        }\n        else if(paren_string[i] == ')')\n        {\n       \
    \     if(in_paren)\n            {\n                level--;\n                in_paren\
    \ = false;\n            }\n        }\n        else\n        {\n            levels[i]\
    \ = level;\n            in_paren = false;\n        }\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++,parentheses,recursion |>\n<| c |>\n\
    This does not work. Try it with `\"((()))\"`.\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I added the test case to the answer.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it with `\"((()))\"`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I added the test case to the answer.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `\"((()))\"`.\n<|/ c |>\n<| a tags=string,algorithm,c++,parentheses,recursion\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt3tae3ya.d(43): Error: declaration expected, not `<`

    /tmp/tmpt3tae3ya.d(52): Error: unterminated character constant

    /tmp/tmpt3tae3ya.d(58): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt3tae3ya.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_close = false;\n    bool in_group_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open = false;\n    bool in_group_close_brace_open\
    \ = false;\n    bool in_group_open_brace_close_brace = false;\n    bool in_group_close_brace_close_brace\
    \ = false;\n    bool in_group_open_brace_open_brace = false;\n    bool in_group_close_brace_open_brace\
    \ = false;\n    bool in_group_open_brace_close_brace_close = false;\n    bool\
    \ in_group_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close = false;\n    bool\
    \ in_group_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close = false;\n\
    \    bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_open_brace_close\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6putn31z.d(49): Error: semicolon expected, not `unittest`

    /tmp/tmp6putn31z.d(49): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6putn31z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool is_open = false;\n    bool is_close = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open = false;\n\
    \    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_close = false;\n\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo9tuoh8v.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpo9tuoh8v.d(64): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo9tuoh8v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    string paren_chars[] = paren_string.ToCharArray();\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        if(paren_chars[i] == '(')\n     \
    \   {\n            levels[level] = level;\n            ++level;\n        }\n \
    \       else if(paren_chars[i] == ')')\n        {\n            level = levels[level];\n\
    \            levels[level] = 0;\n            ++level;\n        }\n        else\n\
    \        {\n            level = levels[level];\n        }\n        if(level >\
    \ max_level)\n        {\n            max_level = level;\n        }\n    }\n  \
    \  return max_level;\n}\n</code>\n<|/ a tags=c#,algorithm,parentheses |>\n<| a\
    \ dscore=0 |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing\
    \ System.Linq;\nusing System.Text;\nusing System.IO;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuuc2yu85.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpuuc2yu85.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_chars`

    /tmp/tmpuuc2yu85.d(42): Error: declaration expected, not `<`

    /tmp/tmpuuc2yu85.d(47): Error: semicolon expected, not `.`

    /tmp/tmpuuc2yu85.d(47): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmpuuc2yu85.d(48): Error: semicolon expected, not `.`

    /tmp/tmpuuc2yu85.d(48): Error: no identifier for declarator `.Linq`

    /tmp/tmpuuc2yu85.d(49): Error: semicolon expected, not `.`

    /tmp/tmpuuc2yu85.d(49): Error: no identifier for declarator `.Text`

    /tmp/tmpuuc2yu85.d(50): Error: semicolon expected, not `.`

    /tmp/tmpuuc2yu85.d(50): Error: no identifier for declarator `.IO`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuuc2yu85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    string parens[] = paren_string.split(\" \");\n    for(long i = 0; i < parens.length;\
    \ ++i)\n    {\n        string paren = parens[i];\n        if(paren.length() ==\
    \ 0)\n            continue;\n        level = 0;\n        for(char c : paren)\n\
    \        {\n            if(c == '(')\n                ++level;\n            else\
    \ if(c == ')')\n                --level;\n            levels[level] = max(levels[level],\
    \ level);\n        }\n        max_level = max(max_level, level);\n    }\n    return\
    \ levels;\n}\n</code>\n<|/ a tags=algorithm,string,c++,parsing |>\n<| c |>\nI\
    \ like this solution. One thing I noticed is that it only works with parentheses\
    \ around a single expression. For example, it doesn't work with `((()))` but does\
    \ with `(()())`. Any idea how to fix that?\n<|/ c |>\n<| c |>\nI fixed the issue\
    \ by changing the `if` statement to `if(paren.length() == 0 || paren[0] == '(')`.\
    \ Thanks!\n<|/ c |>\n<| a tags=algorithm,string,c++,parsing |>\nI wrote a parser\
    \ for my own language in C++. My language is similar to Python, but with some\
    \ differences. I used a stack to keep track of nesting levels. I used a recursive\
    \ descent parser to parse the string. \nThe code below is my parser for my language.\
    \ \n<code>\n#include <iostream>\n#include <stack>\n#include <string>\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptsqk8p3h.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmptsqk8p3h.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] parens`

    /tmp/tmptsqk8p3h.d(24): Error: semicolon expected, not `:`

    /tmp/tmptsqk8p3h.d(24): Error: expression expected, not `:`

    /tmp/tmptsqk8p3h.d(24): Error: found `paren` when expecting `;` following `for`
    condition

    /tmp/tmptsqk8p3h.d(36): Error: declaration expected, not `<`

    /tmp/tmptsqk8p3h.d(39): Error: unterminated character constant

    /tmp/tmptsqk8p3h.d(55): Error: declaration expected, not `assert`

    /tmp/tmptsqk8p3h.d(56): Error: declaration expected, not `assert`

    /tmp/tmptsqk8p3h.d(57): Error: declaration expected, not `assert`

    /tmp/tmptsqk8p3h.d(58): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsqk8p3h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       levels[i] = paren_level;\n        if(paren_level > max_level)\n      \
    \  {\n            max_level = paren_level;\n        }\n    }\n    for(long i =\
    \ 0; i < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       if(paren_level > max_level)\n        {\n            max_level = paren_level;\n\
    \        }\n    }\n    for(long i = 0; i < paren_chars.length; ++i)\n    {\n \
    \       string paren_char = paren_chars[i];\n        long paren_level = paren_char.count('(')\
    \ - paren_char.count(')');\n        if(paren_level > max_level)\n        {\n \
    \           max_level = paren_level;\n        }\n    }\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       if(paren_level > max_level)\n        {\n            max_level = paren_level;\n\
    \        }\n    }\n    for(long i = 0; i < paren_chars.length; ++i)\n    {\n \
    \       string paren_char = paren_chars[i];\n        long paren_level = paren_char.count('(')\
    \ - paren_char.count(')');\n        if(paren_level > max_level)\n        {\n \
    \           max_level = paren_level;\n        }\n    }\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        long paren_level = paren_char.count('(') - paren_char.count(')');\n \
    \       if(paren_level > max_level)\n        {\n            max_level = paren_level;\n\
    \        }\n    }\n    for(long i = 0; i < paren_chars.length; ++i)\n    {\n \
    \       string paren_char = paren_chars[i];\n        long paren_level = paren_char.count('(')\
    \ - paren_char.count(')');\n        if(paren_level > max_level)\n        {\n \
    \           max_level = paren_level;\n        }\n    }\n    for(\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw6p5ry0o.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpw6p5ry0o.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_chars`

    /tmp/tmpw6p5ry0o.d(83): Error: found `unittest` instead of statement

    /tmp/tmpw6p5ry0o.d(88): Error: found `;` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw6p5ry0o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_top = new long[paren_string.length()];\n    long[] levels_stack_bottom\
    \ = new long[paren_string.length()];\n    long levels_stack_top_index = 0;\n \
    \   long levels_stack_bottom_index = 0;\n    long levels_stack_index = 0;\n  \
    \  long levels_stack_top_index_next = 0;\n    long levels_stack_bottom_index_next\
    \ = 0;\n    long levels_stack_index_next = 0;\n    long levels_stack_top_index_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next = 0;\n    long levels_stack_index_next_next\
    \ = 0;\n    long levels_stack_top_index_next_next_next = 0;\n    long levels_stack_bottom_index_next_next_next\
    \ = 0;\n    long levels_stack_index_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next = 0;\n    long\
    \ levels_stack_index_next_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next = 0;\n   \
    \ long levels_stack_index_next_next_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_index_next_next_next_next_next_next = 0;\n    long levels_stack_top_index_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_index_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_top_index_next_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_bottom_index_next_next_next_next_next_next_next_next =\
    \ 0;\n    long levels_stack_index_next_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_top_index_next_next_next_next_next_next_next_next = 0;\n\
    \    long levels_stack_bottom_index_next_next_next_next_next_next_next_next =\
    \ 0;\n    long levels_stack_index_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_top_index_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_bottom_index_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_index_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long levels_stack_top_index_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvy1omk5f.d(52): Error: semicolon expected, not `unittest`

    /tmp/tmpvy1omk5f.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvy1omk5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4y3tauey.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp4y3tauey.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4y3tauey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    while(i < paren_string.length())\n    {\n\
    \        if(paren_string[i] == '(')\n        {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n        levels[i] = level;\n        i++;\n    }\n    for(i = 0; i\
    \ < levels.length; i++)\n    {\n        if(levels[i] > max_level)\n        {\n\
    \            max_level = levels[i];\n        }\n    }\n    long[] result = new\
    \ long[max_level + 1];\n    for(i = 0; i < levels.length; i++)\n    {\n      \
    \  result[levels[i]] = levels[i];\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis code doesn't work. Try it on \"((()))\". It returns\
    \ [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n<| c |>\nIt works fine for\
    \ me. Try it on \"((()))\". It returns [1L, 1L, 1L, 1L], which is not correct.\n\
    <|/ c |>\n<| c |>\nIt returns [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n\
    <| c |>\nIt returns [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n<| c |>\n\
    It returns [1L, 1L, 1L, 1L], which is not correct.\n<|/ c |>\n<| a tags=algorithm,string,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Text.RegularExpressions;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6d63nj1f.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp6d63nj1f.d(46): Error: declaration expected, not `<`

    /tmp/tmp6d63nj1f.d(49): Error: unterminated character constant

    /tmp/tmp6d63nj1f.d(66): Error: semicolon expected, not `.`

    /tmp/tmp6d63nj1f.d(66): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmp6d63nj1f.d(67): Error: semicolon expected, not `.`

    /tmp/tmp6d63nj1f.d(67): Error: no identifier for declarator `.Linq`

    /tmp/tmp6d63nj1f.d(68): Error: semicolon expected, not `.`

    /tmp/tmp6d63nj1f.d(68): Error: no identifier for declarator `.Text`

    /tmp/tmp6d63nj1f.d(69): Error: semicolon expected, not `.`

    /tmp/tmp6d63nj1f.d(69): Error: no identifier for declarator `.Text.RegularExpressions`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6d63nj1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmparqqmqic.d(63): Error: no identifier for declarator `long`

    /tmp/tmparqqmqic.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmparqqmqic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i] ==\
    \ '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,c#,parentheses\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.IO;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvcc07x46.d(30): Error: declaration expected, not `<`

    /tmp/tmpvcc07x46.d(35): Error: semicolon expected, not `.`

    /tmp/tmpvcc07x46.d(35): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmpvcc07x46.d(36): Error: semicolon expected, not `.`

    /tmp/tmpvcc07x46.d(36): Error: no identifier for declarator `.Linq`

    /tmp/tmpvcc07x46.d(37): Error: semicolon expected, not `.`

    /tmp/tmpvcc07x46.d(37): Error: no identifier for declarator `.Text`

    /tmp/tmpvcc07x46.d(38): Error: semicolon expected, not `.`

    /tmp/tmpvcc07x46.d(38): Error: no identifier for declarator `.IO`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvcc07x46.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq4rsj4j5.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4rsj4j5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_opening = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing = false;\n    bool is_closing_paren_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_paren = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening = false;\n \
    \   bool is_closing_paren_or_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa9wo82u3.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpa9wo82u3.d(44): Error: semicolon expected, not `unittest`

    /tmp/tmpa9wo82u3.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9wo82u3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    bool\
    \ is_first = true;\n    bool is_last = true;\n    bool is_last_in_group = false;\n\
    \    bool is_last_in_group_prev = false;\n    bool is_last_in_group_next = false;\n\
    \    bool is_last_in_group_next_prev = false;\n    bool is_last_in_group_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_prev = false;\n    bool is_last_in_group_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_prev = false;\n\
    \    bool is_last_in_group_next_next_next_next_next_next_prev = false;\n    bool\
    \ is_last_in_group_next_next_next_next_next_next_next_prev = false;\n    bool\
    \ is_last_in_group_next_next_next_next_next_next_next_next_prev = false;\n   \
    \ bool is_last_in_group_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool is_last_in_group_next_next_next_next_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphakwgffq.d(47): Error: semicolon expected, not `unittest`

    /tmp/tmphakwgffq.d(47): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphakwgffq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] current_levels = new long[paren_string.length()];\n\
    \    long[] max_levels = new long[paren_string.length()];\n    long[] current_max_levels\
    \ = new long[paren_string.length()];\n    long[] current_levels_index = new long[paren_string.length()];\n\
    \    long[] current_max_levels_index = new long[paren_string.length()];\n    long[]\
    \ current_levels_index_in_parens = new long[paren_string.length()];\n    long[]\
    \ current_max_levels_index_in_parens = new long[paren_string.length()];\n    long[]\
    \ current_levels_index_in_parens_index = new long[paren_string.length()];\n  \
    \  long[] current_max_levels_index_in_parens_index = new long[paren_string.length()];\n\
    \    long[] current_levels_index_in_parens_index_in_parens = new long[paren_string.length()];\n\
    \    long[] current_max_levels_index_in_parens_index_in_parens = new long[paren_string.length()];\n\
    \    long[] current_levels_index_in_parens_index_in_parens_index = new long[paren_string.length()];\n\
    \    long[] current_max_levels_index_in_parens_index_in_parens_index = new long[paren_string.length()];\n\
    \    long[] current_levels_index_in_parens_index_in_parens_index_in_parens = new\
    \ long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_string.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_string.length()];\n    long\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp56gbi7o6.d(38): Error: no identifier for declarator `long`

    /tmp/tmp56gbi7o6.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp56gbi7o6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n    long paren_levels_index47\
    \ = 0;\n    long paren_levels_index48 = 0;\n    long paren_levels_index49 = 0;\n\
    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp46mtpwt6.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] paren_levels`

    /tmp/tmp46mtpwt6.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp46mtpwt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pos = 0;\n    long level_stack_len = MAX_LEVELS;\n    long\
    \ paren_level = 0;\n    long paren_level_stack[MAX_LEVELS];\n    long paren_level_stack_pos\
    \ = 0;\n    long paren_level_stack_len = MAX_LEVELS;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_stack[MAX_LEVELS];\n    long paren_level_count_stack_pos\
    \ = 0;\n    long paren_level_count_stack_len = MAX_LEVELS;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pos\
    \ = 0;\n    long paren_level_count_max_stack_len = MAX_LEVELS;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pos\
    \ = 0;\n    long paren_level_count_min_stack_len = MAX_LEVELS;\n    long paren_level_count_sum\
    \ = 0;\n    long paren_level_count_sum_stack[MAX_LEVELS];\n    long paren_level_count_sum_stack_pos\
    \ = 0;\n    long paren_level_count_sum_stack_len = MAX_LEVELS;\n    long paren_level_count_avg\
    \ = 0;\n    long paren_level_count_avg_stack[MAX_LEVELS];\n    long paren_level_count_avg_stack_pos\
    \ = 0;\n    long paren_level_count_avg_stack_len = MAX_LEVELS;\n    long paren_level_count_sum2\
    \ = 0;\n    long paren_level_count_sum2_stack[MAX_LEVELS];\n    long paren_level_count_sum2_stack_pos\
    \ = 0;\n    long paren_level_count_sum2_stack_len = MAX_LEVELS;\n    long paren_level_count_sum3\
    \ = 0;\n    long paren_level_count_sum3_stack[MAX_LEVELS];\n    long paren_level_count_sum3_stack_pos\
    \ = 0;\n    long paren_level_count_sum3_stack_len = MAX_LEVELS;\n    long paren_level_count_sum4\
    \ = 0;\n    long paren_level_count_sum4_stack[MAX_LEVELS];\n    long paren_level_count_sum4_stack_pos\
    \ = 0;\n    long paren_level_count_sum4_stack_len = MAX_LEVELS;\n    long paren_level_count_sum5\
    \ = 0;\n    long paren_level_count_sum5_stack[MAX_LEVELS];\n    long paren_level_count_sum5_stack_pos\
    \ = 0;\n    long paren_level_count_sum\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: '/tmp/tmpebpd3y0t.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] level_stack`

    /tmp/tmpebpd3y0t.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_stack`

    /tmp/tmpebpd3y0t.d(24): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_stack`

    /tmp/tmpebpd3y0t.d(28): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_max_stack`

    /tmp/tmpebpd3y0t.d(32): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_min_stack`

    /tmp/tmpebpd3y0t.d(36): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_sum_stack`

    /tmp/tmpebpd3y0t.d(40): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_avg_stack`

    /tmp/tmpebpd3y0t.d(44): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_sum2_stack`

    /tmp/tmpebpd3'
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close_brace_close = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close_brace_\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxc1gj3aw.d(42): Error: semicolon expected, not `unittest`

    /tmp/tmpxc1gj3aw.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxc1gj3aw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    stack<int> level_stack = new stack<int>();\n    bool in_paren\
    \ = false;\n    bool in_level_stack = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            paren_stack.push(i);\n            in_paren = true;\n      \
    \  }\n        else if(c == ')')\n        {\n            int paren_index = paren_stack.top();\n\
    \            paren_stack.pop();\n            int level = 0;\n            while(paren_index\
    \ != -1)\n            {\n                level++;\n                paren_index\
    \ = paren_stack.top();\n                paren_stack.pop();\n            }\n  \
    \          levels[levelsIndex++] = level;\n            in_level_stack = false;\n\
    \        }\n        else if(c == '(' || c == '[' || c == '{')\n        {\n   \
    \         int level = 0;\n            while(level_stack.top() != -1)\n       \
    \     {\n                level++;\n                level_stack.pop();\n      \
    \      }\n            level_stack.push(level);\n            in_level_stack = true;\n\
    \        }\n        else if(c == ']' || c == '}' || c == ')' || c == ']' || c\
    \ == '}')\n        {\n            int level = level_stack.top();\n           \
    \ level_stack.pop();\n            int paren_index = paren_stack.top();\n     \
    \       paren_stack.pop();\n            while(levels[levelsIndex--] != level)\n\
    \                levelsIndex--;\n            in_level_stack = false;\n       \
    \ }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c\
    \ |>\nThanks for your answer. Your code works fine for parenthesis containing\
    \ only two levels of nesting. However, it fails for parenthesis containing three\
    \ or more levels of nesting.\n<|/ c |>\n<| c |>\nI tested it on `((())) () ((())()())`\
    \ and it returned `[3, 3, 1, 3]`\n<|/ c |>\n<| c |>\nI tested it on `((())) ()\
    \ ((())()())` and it returned `[3, 3, 1, 3]`\n<|/ c |>\n<| c |>\nI tested it on\
    \ `((())) () ((())()())` and it returned `[3, 3, 1, 3]`\n<|/ c |>\n<| c |>\nI\
    \ tested it on `((())) () ((())()())` and it returned `[3, 3, 1, 3]`\n<|/ c |>\n\
    <| a dscore=0 |>\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb29uy9tf.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpb29uy9tf.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpb29uy9tf.d(15): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpb29uy9tf.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmpb29uy9tf.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpb29uy9tf.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmpb29uy9tf.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmpb29uy9tf.d(16): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpb29uy9tf.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmpb29uy9tf.d(16): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpb29uy9tf.d(65): Error: declaration expected, not `<`

    /tmp/tmpb29uy9tf.d(88): Error: declaration expected, not `assert`

    /tmp/tmpb29uy9tf.d(89): Error: declaration expected, not `assert`

    /tmp/tmpb29uy9tf.d(90): Error: declaration expect'
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    for(char c : paren_string)\n    {\n        if(c != '('\
    \ && c != ')')\n        {\n            levels[index] = level;\n            index++;\n\
    \        }\n        else if(c != '(')\n        {\n            level++;\n     \
    \   }\n        else\n        {\n            level--;\n        }\n        if(level\
    \ > max_level)\n        {\n            max_level = level;\n        }\n    }\n\
    \    return levels;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c |>\nI like\
    \ your solution. Very elegant and simple. Thanks!\n<|/ c |>\n<| a tags=algorithm,c++\
    \ |>\nI wrote a recursive solution in Python that works well for me:\n<code>\n\
    def paren_count(s):\n    level = 0\n    count = 0\n    for c in s:\n        if\
    \ c == '(':\n            level += 1\n        elif c == ')':\n            level\
    \ -= 1\n        if level == 0:\n            count += 1\n    return count\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpss8wcu_9.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpss8wcu_9.d(18): Error: semicolon expected, not `:`

    /tmp/tmpss8wcu_9.d(18): Error: expression expected, not `:`

    /tmp/tmpss8wcu_9.d(18): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmpss8wcu_9.d(40): Error: declaration expected, not `<`

    /tmp/tmpss8wcu_9.d(63): Error: declaration expected, not `assert`

    /tmp/tmpss8wcu_9.d(64): Error: declaration expected, not `assert`

    /tmp/tmpss8wcu_9.d(65): Error: declaration expected, not `assert`

    /tmp/tmpss8wcu_9.d(66): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpss8wcu_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren\
    \ = false;\n    bool has_opening_paren_or_closing_paren = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2229sarr.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmp2229sarr.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2229sarr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_paren\
    \ = false;\n    bool in_paren_group_close_paren = false;\n    bool in_paren_group_open_curly\
    \ = false;\n    bool in_paren_group_close_curly = false;\n    bool in_paren_group_open_angle\
    \ = false;\n    bool in_paren_group_close_angle = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8v2qbo2l.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp8v2qbo2l.d(65): Error: semicolon expected, not `unittest`

    /tmp/tmp8v2qbo2l.d(65): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8v2qbo2l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9z3svmmy.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp9z3svmmy.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9z3svmmy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long i = 0;\n    bool inside_group = false;\n    bool inside_paren\
    \ = false;\n    bool inside_paren_group = false;\n    bool inside_paren_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group = false;\n    bool inside_paren_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group =\
    \ false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group\
    \ = false;\n    bool inside_paren_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_or_group_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp19vf1v06.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmp19vf1v06.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19vf1v06.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(c == ')') {\n            level--;\n            if(level\
    \ == 0) {\n                max_level = max(max_level, levels[level]);\n      \
    \      }\n        }\n    }\n    return max_level;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with `\"(()()) ((())) () ((())()())\"\
    `\n<|/ c |>\n<| c |>\nI tested it and it works. I added the test case to the answer.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `((()))` - it returns `1` instead of `3`.\n\
    <|/ c |>\n<| c |>\nIt works for me. Are you sure you copied the code correctly?\
    \ I tested it with `\"(()()) ((())) () ((())()())\"` and it returns `[2L, 3L,\
    \ 1L, 3L]`.\n<|/ c |>\n<| c |>\nI tested it again and it works. I added the test\
    \ case to the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;\nclass GFG\n{\n    public static void main\
    \ (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new\
    \ Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n\
    \        for(int i=0;i<n;i++)\n        {\n            String s = sc.nextLine();\n\
    \            int l = s.length();\n            int count = 0;\n            for(int\
    \ j=0;j<l;j++)\n            {\n                if(s.charAt(j)=='(')\n        \
    \        {\n                    count++;\n                }\n                if(s.charAt(j)==')')\n\
    \                {\n                    count--;\n                }\n        \
    \    }\n            System.out.println(count);\n        }\n    }\n}\n</code>\n\
    <|/ a tags=java,algorithm |>\n<| c |>\nThis doesn't work. Try it with `\"(()())\
    \ ((())) () ((())()())\"`\n<|/ c |>\n<| c |>\nI tested it and it works. I added\
    \ the test case to the answer.\n<|/ c |>\n<| c |>\nIt doesn't work for `((()))`\
    \ - it returns `1` instead of `\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0uad1dr0.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp0uad1dr0.d(32): Error: declaration expected, not `<`

    /tmp/tmp0uad1dr0.d(35): Error: unterminated character constant

    /tmp/tmp0uad1dr0.d(41): Error: unterminated character constant

    /tmp/tmp0uad1dr0.d(52): Error: identifier expected following `package`

    /tmp/tmp0uad1dr0.d(52): Error: `;` expected

    /tmp/tmp0uad1dr0.d(53): Error: identifier expected following `package`

    /tmp/tmp0uad1dr0.d(53): Error: `;` expected

    /tmp/tmp0uad1dr0.d(56): Error: semicolon expected following function declaration

    /tmp/tmp0uad1dr0.d(56): Error: semicolon expected, not `.`

    /tmp/tmp0uad1dr0.d(57): Error: no identifier for declarator `.lang.Exception`

    /tmp/tmp0uad1dr0.d(57): Error: declaration expected, not `{`

    /tmp/tmp0uad1dr0.d(60): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp0uad1dr0.d(60): Error: no identifier for declarator `sc.nextLine()`

    /tmp/tmp0uad1dr0.d(61): Error: '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_group;\n    long max_level = 0;\n    long[] levels = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        paren_group\
    \ = paren_string.substr(i, paren_string.length() - i);\n        if(paren_group.length()\
    \ > max_level)\n        {\n            max_level = paren_group.length();\n   \
    \     }\n        levels[i] = max_level;\n    }\n    return levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpalo2h9ub.d(16): Error: no property `length` for type `string`

    /tmp/tmpalo2h9ub.d(17): Error: no property `length` for type `string`

    /tmp/tmpalo2h9ub.d(19): Error: no property `substr` for type `string`

    /tmp/tmpalo2h9ub.d(20): Error: no property `length` for type `string`

    /tmp/tmpalo2h9ub.d(22): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpalo2h9ub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_opener = false;\n    bool in_paren_group_closer\
    \ = false;\n    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_close\
    \ = false;\n    bool in_paren_group_opener_open = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_opener_closed = false;\n    bool in_paren_group_closer_closed\
    \ = false;\n    bool in_paren_group_opener_opener = false;\n    bool in_paren_group_closer_opener\
    \ = false;\n    bool in_paren_group_opener_closer = false;\n    bool in_paren_group_closer_closer\
    \ = false;\n    bool in_paren_group_opener_opener_closed = false;\n    bool in_paren_group_closer_opener_closed\
    \ = false;\n    bool in_paren_group_opener_closer_closed = false;\n    bool in_paren_group_opener_closer_open\
    \ = false;\n    bool in_paren_group_closer_closer_open = false;\n    bool in_paren_group_opener_closer_closer_close\
    \ = false;\n    bool in_paren_group_opener_closer_closer_open = false;\n    bool\
    \ in_paren_group_closer_closer_closer_close = false;\n    bool in_paren_group_opener_closer_closer_closer_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer_close = false;\n\
    \    bool in_paren_group_opener_closer_closer_closer_closer_open = false;\n  \
    \  bool in_paren_group_closer_closer_closer_closer_closer_close = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_closer_closer_open = false;\n\
    \    bool in_paren_group_closer_closer_closer_closer_closer_closer_close = false;\n\
    \    bool in_paren_group_opener_closer_closer_closer_closer_closer_closer_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer_closer_closer_close\
    \ = false;\n    bool in_paren_group_opener_closer_closer_closer_closer_closer_closer_close\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer_closer_closer_closer_close\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaqmiuwre.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpaqmiuwre.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqmiuwre.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptot5kul5.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmptot5kul5.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] paren_levels`

    /tmp/tmptot5kul5.d(67): Error: semicolon expected, not `unittest`

    /tmp/tmptot5kul5.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptot5kul5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string opening_paren_chars = \"((\";\n    string\
    \ closing_paren_chars = \")\";\n    string opening_paren_chars_count = paren_chars.size();\n\
    \    string closing_paren_chars_count = paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size();\n    string closing_paren_chars_count_str = closing_paren_chars.size();\n\
    \    string opening_paren_chars_count_str = opening_paren_chars.size();\n    string\
    \ closing_paren_chars_count_str = closing_paren_chars.size();\n    string opening_paren_chars_count_str\
    \ = opening_paren_chars.size\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwnxttwm2.d(44): Error: semicolon expected, not `unittest`

    /tmp/tmpwnxttwm2.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwnxttwm2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    string parens[] = paren_string.split(\" \");\n    for(long i = 0; i < parens.length;\
    \ ++i)\n    {\n        string paren = parens[i];\n        string paren_copy =\
    \ paren;\n        while(paren_copy.size() > 0)\n        {\n            char c\
    \ = paren_copy[0];\n            paren_copy = paren_copy.substr(1);\n         \
    \   if(c == '(')\n            {\n                ++level;\n                levels[level]\
    \ = level;\n            }\n            else if(c == ')')\n            {\n    \
    \            --level;\n                if(level < 0)\n                {\n    \
    \                throw new Exception(\"Unbalanced parenthesis\");\n          \
    \      }\n                levels[level] = level;\n            }\n        }\n \
    \       if(level > max_level)\n        {\n            max_level = level;\n   \
    \     }\n    }\n    long[] result = new long[max_level + 1];\n    for(long i =\
    \ 0; i < max_level; ++i)\n    {\n        result[i] = levels[i];\n    }\n    result[max_level]\
    \ = max_level;\n    return result;\n}\n</code>\n<|/ a tags=algorithm,string,java\
    \ |>\n<| c |>\nThis solution doesn't work for nested parentheses such as \"(()())\"\
    \n<|/ c |>\n<| c |>\nYes, it does. I tested it on \"(()())\" and it returned [2,3,1,1,3]\n\
    <|/ c |>\n<| c |>\nIt doesn't work for \"(()())\" because you only count the outer\
    \ parentheses, not the inner ones.\n<|/ c |>\n<| c |>\nYes, I tested it on \"\
    (()())\" and it returned [2,3,1,1,3]\n<|/ c |>\n<| c |>\nI tested it on \"(()())\"\
    \ and it returned [2,3,1,1,3]\n<|/ c |>\n<| a tags=algorithm,string,java |>\n\
    <code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiqc8c7dz.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpiqc8c7dz.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] parens`

    /tmp/tmpiqc8c7dz.d(54): Error: declaration expected, not `<`

    /tmp/tmpiqc8c7dz.d(57): Error: unterminated character constant

    /tmp/tmpiqc8c7dz.d(63): Error: unterminated character constant

    /tmp/tmpiqc8c7dz.d(74): Error: identifier expected following `package`

    /tmp/tmpiqc8c7dz.d(74): Error: `;` expected

    /tmp/tmpiqc8c7dz.d(75): Error: identifier expected following `package`

    /tmp/tmpiqc8c7dz.d(75): Error: `;` expected

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiqc8c7dz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool has_open = false;\n    bool\
    \ has_close = false;\n    long level = 0;\n    long levels_sum = 0;\n    long\
    \ levels_max = 0;\n    long levels_max_index = 0;\n    long levels_max_index2\
    \ = 0;\n    long levels_max_index3 = 0;\n    long levels_max_index4 = 0;\n   \
    \ long levels_max_index5 = 0;\n    long levels_max_index6 = 0;\n    long levels_max_index7\
    \ = 0;\n    long levels_max_index8 = 0;\n    long levels_max_index9 = 0;\n   \
    \ long levels_max_index10 = 0;\n    long levels_max_index11 = 0;\n    long levels_max_index12\
    \ = 0;\n    long levels_max_index13 = 0;\n    long levels_max_index14 = 0;\n \
    \   long levels_max_index15 = 0;\n    long levels_max_index16 = 0;\n    long levels_max_index17\
    \ = 0;\n    long levels_max_index18 = 0;\n    long levels_max_index19 = 0;\n \
    \   long levels_max_index20 = 0;\n    long levels_max_index21 = 0;\n    long levels_max_index22\
    \ = 0;\n    long levels_max_index23 = 0;\n    long levels_max_index24 = 0;\n \
    \   long levels_max_index25 = 0;\n    long levels_max_index26 = 0;\n    long levels_max_index27\
    \ = 0;\n    long levels_max_index28 = 0;\n    long levels_max_index29 = 0;\n \
    \   long levels_max_index30 = 0;\n    long levels_max_index31 = 0;\n    long levels_max_index32\
    \ = 0;\n    long levels_max_index33 = 0;\n    long levels_max_index34 = 0;\n \
    \   long levels_max_index35 = 0;\n    long levels_max_index36 = 0;\n    long levels_max_index37\
    \ = 0;\n    long levels_max_index38 = 0;\n    long levels_max_index39 = 0;\n \
    \   long levels_max_index40 = 0;\n    long levels_max_index41 = 0;\n    long levels_max_index42\
    \ = 0;\n    long levels_max_index43 = 0;\n    long levels_max_index44 = 0;\n \
    \   long levels_max_index45 = 0;\n    long levels_max_index46 = 0;\n    long levels_max_index47\
    \ = 0;\n    long levels_max_index48 = 0;\n    long levels_max_index49 = 0;\n \
    \   long levels_max_index50 = 0;\n    long levels_max_index51 = 0;\n    long levels_max_index52\
    \ = 0;\n    long levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_648w45l.d(73): Error: semicolon expected, not `unittest`

    /tmp/tmp_648w45l.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_648w45l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    bool in_paren = false;\n    bool in_paren_prev\
    \ = false;\n    bool in_paren_next_prev = false;\n    bool in_paren_next_next\
    \ = false;\n    bool in_paren_next_next_prev = false;\n    bool in_paren_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_prev = false;\n  \
    \  bool in_paren_next_next_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp54cyyhei.d(47): Error: semicolon expected, not `unittest`

    /tmp/tmp54cyyhei.d(47): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp54cyyhei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_open_brace_close_brace = false;\n    bool in_paren_group_open_brace_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_open_brace = false;\n\
    \    bool in_paren_group_open_brace_close_brace_close_brace_close = false;\n \
    \   bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close_brace_open = false;\n    bool\
    \ in_paren_group_close_brace_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open_brace_close =\
    \ false;\n    bool in_paren_group_close_bra\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplktiynr_.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmplktiynr_.d(49): Error: semicolon expected, not `unittest`

    /tmp/tmplktiynr_.d(49): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplktiynr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_closing_square_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_square_bracket_or_paren_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_closing_square_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_square_bracket_or_paren_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppg6mh9uo.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] level_stack`

    /tmp/tmppg6mh9uo.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmppg6mh9uo.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppg6mh9uo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl429m1rw.d(79): Error: no identifier for declarator `long`

    /tmp/tmpl429m1rw.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl429m1rw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 0;\n    long level_max = 0;\n    long level_max_size = 0;\n    long level_max_max\
    \ = 0;\n    long level_max_max_size = 0;\n    long level_max_max_max = 0;\n  \
    \  long level_max_max_max_size = 0;\n    long level_max_max_max_max = 0;\n   \
    \ long level_max_max_max_max_size = 0;\n    long level_max_max_max_max_max = 0;\n\
    \    long level_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_size = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max = 0;\n    long level_max_max_max_max_max_max_max_max_max_size\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_size = 0;\n   \
    \ long level_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_size\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_size = 0;\n\
    \    long level_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_max_size = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzg88m112.d(55): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzg88m112.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long max_level = 0;\n    long\
    \ level = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n    bool\
    \ in_brace = false;\n    bool in_curly = false;\n    bool in_paren_group = false;\n\
    \    bool in_bracket_group = false;\n    bool in_brace_group = false;\n    bool\
    \ in_curly_group = false;\n    bool in_paren_group_open = false;\n    bool in_bracket_group_open\
    \ = false;\n    bool in_brace_group_open = false;\n    bool in_curly_group_open\
    \ = false;\n    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed\
    \ = false;\n    bool in_brace_group_closed = false;\n    bool in_curly_group_closed\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_bracket_group_open_brace\
    \ = false;\n    bool in_brace_group_open_brace = false;\n    bool in_curly_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_curly_group_closed_brace\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_bracket_group_open_bracket\
    \ = false;\n    bool in_brace_group_open_bracket = false;\n    bool in_curly_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_curly_group_closed_bracket\
    \ = false;\n    bool in_paren_group_open_brace_group = false;\n    bool in_bracket_group_open_brace_group\
    \ = false;\n    bool in_brace_group_open_brace_group = false;\n    bool in_curly_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_curly_group_closed_brace_group\
    \ = false;\n    bool in_paren_group_open_brace_group_open = false;\n    bool in_bracket_group_open_brace_group_open\
    \ = false;\n    bool in_brace_group_open_brace_group_open = false;\n    bool in_curly_group_open_brace_group_open\
    \ = false;\n    bool in_paren_group_closed_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp987u3tc.d(62): Error: semicolon expected, not `unittest`

    /tmp/tmpp987u3tc.d(62): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp987u3tc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26f0nl78.d(75): Error: semicolon expected, not `unittest`

    /tmp/tmp26f0nl78.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26f0nl78.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp781q2n34.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp781q2n34.d(48): Error: semicolon expected, not `unittest`

    /tmp/tmp781q2n34.d(48): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp781q2n34.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    long paren_stack_pointer = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_stack[MAX_LEVELS];\n    long paren_level_stack_pointer\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_stack[MAX_LEVELS];\n\
    \    long paren_level_count_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: '/tmp/tmpzih16exe.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_LEVELS] level_stack`

    /tmp/tmpzih16exe.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_stack`

    /tmp/tmpzih16exe.d(23): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_stack`

    /tmp/tmpzih16exe.d(26): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_max_stack`

    /tmp/tmpzih16exe.d(29): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_min_stack`

    /tmp/tmpzih16exe.d(32): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_max_stack`

    /tmp/tmpzih16exe.d(35): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_min_stack`

    /tmp/tmpzih16exe.d(38): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_LEVELS] paren_level_count_max_stack`

    /tmp/tmpzih16e'
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_char = \"()\";\n    string paren_char2 = \"()\";\n    string paren_char3\
    \ = \"()\";\n    string paren_char4 = \"()\";\n    string paren_char5 = \"()\"\
    ;\n    string paren_char6 = \"()\";\n    string paren_char7 = \"()\";\n    string\
    \ paren_char8 = \"()\";\n    string paren_char9 = \"()\";\n    string paren_char10\
    \ = \"()\";\n    string paren_char11 = \"()\";\n    string paren_char12 = \"()\"\
    ;\n    string paren_char13 = \"()\";\n    string paren_char14 = \"()\";\n    string\
    \ paren_char15 = \"()\";\n    string paren_char16 = \"()\";\n    string paren_char17\
    \ = \"()\";\n    string paren_char18 = \"()\";\n    string paren_char19 = \"()\"\
    ;\n    string paren_char20 = \"()\";\n    string paren_char21 = \"()\";\n    string\
    \ paren_char22 = \"()\";\n    string paren_char23 = \"()\";\n    string paren_char24\
    \ = \"()\";\n    string paren_char25 = \"()\";\n    string paren_char26 = \"()\"\
    ;\n    string paren_char27 = \"()\";\n    string paren_char28 = \"()\";\n    string\
    \ paren_char29 = \"()\";\n    string paren_char30 = \"()\";\n    string paren_char31\
    \ = \"()\";\n    string paren_char32 = \"()\";\n    string paren_char33 = \"()\"\
    ;\n    string paren_char34 = \"()\";\n    string paren_char35 = \"()\";\n    string\
    \ paren_char36 = \"()\";\n    string paren_char37 = \"()\";\n    string paren_char38\
    \ = \"()\";\n    string paren_char39 = \"()\";\n    string paren_char40 = \"()\"\
    ;\n    string paren_char41 = \"()\";\n    string paren_char42 = \"()\";\n    string\
    \ paren_char43 = \"()\";\n    string paren_char44 = \"()\";\n    string paren_char45\
    \ = \"()\";\n    string paren_char46 = \"()\";\n    string paren_char47 = \"()\"\
    ;\n    string paren_char48 = \"()\";\n    string paren_char49 = \"()\";\n    string\
    \ paren_char50 = \"()\";\n    string paren_char51 = \"\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbxi5ftyv.d(69): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(69): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(69): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(69): Error: found `") == [2L, 3L, 1L, 3L]);\x0a    assert(candidate("`
    when expecting `,`

    /tmp/tmpbxi5ftyv.d(70): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(70): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(70): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(70): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(70): Error: found `") == [1L, 2L, 3L, 4L]);\x0a    assert(candidate("`
    when expecting `,`

    /tmp/tmpbxi5ftyv.d(71): Error: unterminated string constant starting at /tmp/tmpbxi5ftyv.d(71)

    /tmp/tmpbxi5ftyv.d(71): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(71): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(71): Error: expression expected, not `)`

    /tmp/tmpbxi5ftyv.d(71): Error: found `""` when expecting `,`

    /tmp/tmpbxi5ftyv.d(73): Error: found `End of File`'
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string current_paren_string = paren_string;\n    string next_paren_string;\n\
    \    bool has_next_paren = false;\n    bool has_next_paren_pair = false;\n   \
    \ bool has_next_paren_pair2 = false;\n    bool has_next_paren_pair3 = false;\n\
    \    bool has_next_paren_pair4 = false;\n    bool has_next_paren_pair5 = false;\n\
    \    bool has_next_paren_pair6 = false;\n    bool has_next_paren_pair7 = false;\n\
    \    bool has_next_paren_pair8 = false;\n    bool has_next_paren_pair9 = false;\n\
    \    bool has_next_paren_pair10 = false;\n    bool has_next_paren_pair11 = false;\n\
    \    bool has_next_paren_pair12 = false;\n    bool has_next_paren_pair13 = false;\n\
    \    bool has_next_paren_pair14 = false;\n    bool has_next_paren_pair15 = false;\n\
    \    bool has_next_paren_pair16 = false;\n    bool has_next_paren_pair17 = false;\n\
    \    bool has_next_paren_pair18 = false;\n    bool has_next_paren_pair19 = false;\n\
    \    bool has_next_paren_pair20 = false;\n    bool has_next_paren_pair21 = false;\n\
    \    bool has_next_paren_pair22 = false;\n    bool has_next_paren_pair23 = false;\n\
    \    bool has_next_paren_pair24 = false;\n    bool has_next_paren_pair25 = false;\n\
    \    bool has_next_paren_pair26 = false;\n    bool has_next_paren_pair27 = false;\n\
    \    bool has_next_paren_pair28 = false;\n    bool has_next_paren_pair29 = false;\n\
    \    bool has_next_paren_pair30 = false;\n    bool has_next_paren_pair31 = false;\n\
    \    bool has_next_paren_pair32 = false;\n    bool has_next_paren_pair33 = false;\n\
    \    bool has_next_paren_pair34 = false;\n    bool has_next_paren_pair35 = false;\n\
    \    bool has_next_paren_pair36 = false;\n    bool has_next_paren_pair37 = false;\n\
    \    bool has_next_paren_pair38 = false;\n    bool has_next_paren_pair39 = false;\n\
    \    bool has_next_paren_pair40 = false;\n    bool has_next_paren_pair41 = false;\n\
    \    bool has_next_paren_pair42 = false;\n    bool has_next_paren_pair43 = false;\n\
    \    bool has_next_paren_pair44 = false;\n    bool has_next_paren_pair45 = false;\n\
    \    bool has_next_paren_pair4\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9adc8ita.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp9adc8ita.d(66): Error: semicolon expected, not `unittest`

    /tmp/tmp9adc8ita.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9adc8ita.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            if(!in_paren)\n        \
    \    {\n                level++;\n                levels[level] = level;\n   \
    \         }\n            in_paren = true;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            if(!in_paren)\n            {\n             \
    \   level--;\n                levels[level] = level;\n            }\n        \
    \    in_paren = false;\n        }\n    }\n    return levels;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpul5uxin1.d(14): Error: no property `length` for type `string`

    /tmp/tmpul5uxin1.d(17): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpul5uxin1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool has_open = false;\n    bool has_close = false;\n    bool has_open_brace\
    \ = false;\n    bool has_close_brace = false;\n    bool has_open_paren = false;\n\
    \    bool has_close_paren = false;\n    bool has_open_curly = false;\n    bool\
    \ has_close_curly = false;\n    bool has_open_paren_or_curly = false;\n    bool\
    \ has_close_paren_or_curly = false;\n    bool has_open_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp33vw0_oq.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp33vw0_oq.d(49): Error: semicolon expected, not `unittest`

    /tmp/tmp33vw0_oq.d(49): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp33vw0_oq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool has_opening_bracket = false;\n\
    \    bool has_closing_bracket = false;\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long current_level = 0;\n    long current_index\
    \ = 0;\n    long current_paren_level = 0;\n    long current_paren_index = 0;\n\
    \    long current_paren_level_index = 0;\n    long current_paren_level_size =\
    \ 0;\n    long current_paren_index = 0;\n    long current_paren_level_size = 0;\n\
    \    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n    long current_paren_level_size_index = 0;\n    long current_paren_level_size_index\
    \ = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpopvlix_u.d(69): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopvlix_u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close = false;\n    bool in_group_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_or_open = false;\n    bool in_group_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace = false;\n   \
    \ bool in_group_close_brace_or_open_or_close_brace = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open = false;\n\
    \    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open = false;\n\
    \    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close = false;\n\
    \    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace =\
    \ false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_or_close_brace_or_open_or_close_brace_or_open_or_close\
    \ = false;\n    bool in_group_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxcbmvjfa.d(43): Error: semicolon expected, not `unittest`

    /tmp/tmpxcbmvjfa.d(43): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxcbmvjfa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    long levels_index2 = 0;\n\
    \    long levels_index3 = 0;\n    long levels_index4 = 0;\n    long levels_index5\
    \ = 0;\n    long levels_index6 = 0;\n    long levels_index7 = 0;\n    long levels_index8\
    \ = 0;\n    long levels_index9 = 0;\n    long levels_index10 = 0;\n    long levels_index11\
    \ = 0;\n    long levels_index12 = 0;\n    long levels_index13 = 0;\n    long levels_index14\
    \ = 0;\n    long levels_index15 = 0;\n    long levels_index16 = 0;\n    long levels_index17\
    \ = 0;\n    long levels_index18 = 0;\n    long levels_index19 = 0;\n    long levels_index20\
    \ = 0;\n    long levels_index21 = 0;\n    long levels_index22 = 0;\n    long levels_index23\
    \ = 0;\n    long levels_index24 = 0;\n    long levels_index25 = 0;\n    long levels_index26\
    \ = 0;\n    long levels_index27 = 0;\n    long levels_index28 = 0;\n    long levels_index29\
    \ = 0;\n    long levels_index30 = 0;\n    long levels_index31 = 0;\n    long levels_index32\
    \ = 0;\n    long levels_index33 = 0;\n    long levels_index34 = 0;\n    long levels_index35\
    \ = 0;\n    long levels_index36 = 0;\n    long levels_index37 = 0;\n    long levels_index38\
    \ = 0;\n    long levels_index39 = 0;\n    long levels_index40 = 0;\n    long levels_index41\
    \ = 0;\n    long levels_index42 = 0;\n    long levels_index43 = 0;\n    long levels_index44\
    \ = 0;\n    long levels_index45 = 0;\n    long levels_index46 = 0;\n    long levels_index47\
    \ = 0;\n    long levels_index48 = 0;\n    long levels_index49 = 0;\n    long levels_index50\
    \ = 0;\n    long levels_index51 = 0;\n    long levels_index52 = 0;\n    long levels_index53\
    \ = 0;\n    long levels_index54 = 0;\n    long levels_index55 = 0;\n    long levels_index56\
    \ = 0;\n    long levels_index57 = 0;\n    long levels_index58 = 0;\n    long levels_index59\
    \ = 0;\n    long levels_index60 = 0;\n    long levels_index61\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmwd6qadx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpmwd6qadx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpmwd6qadx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwd6qadx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_index = 0;\n    bool paren_found\
    \ = false;\n    bool paren_open = false;\n    bool paren_closed = false;\n   \
    \ bool paren_opening = false;\n    bool paren_closing = false;\n    bool paren_opening_found\
    \ = false;\n    bool paren_closing_found = false;\n    bool paren_opening_paren_found\
    \ = false;\n    bool paren_closing_paren_found = false;\n    bool paren_opening_paren_closing\
    \ = false;\n    bool paren_closing_paren_closing = false;\n    bool paren_opening_paren_closing_found\
    \ = false;\n    bool paren_closing_paren_closing_found = false;\n    bool paren_opening_paren_closing_paren_found\
    \ = false;\n    bool paren_closing_paren_closing_paren_found = false;\n    bool\
    \ paren_opening_paren_closing_paren_closing = false;\n    bool paren_closing_paren_closing_paren_closing\
    \ = false;\n    bool paren_opening_paren_closing_paren_closing_found = false;\n\
    \    bool paren_closing_paren_closing_paren_closing_found = false;\n    bool paren_opening_paren_closing_paren_closing_paren_found\
    \ = false;\n    bool paren_closing_paren_closing_paren_closing_paren_found = false;\n\
    \    bool paren_opening_paren_closing_paren_closing_paren_closing = false;\n \
    \   bool paren_closing_paren_closing_paren_closing_paren_closing = false;\n  \
    \  bool paren_opening_paren_closing_paren_closing_paren_closing_found = false;\n\
    \    bool paren_closing_paren_closing_paren_closing_paren_closing_found = false;\n\
    \    bool paren_opening_paren_closing_paren_closing_paren_closing_paren_found\
    \ = false;\n    bool paren_closing_paren_closing_paren_closing_paren_closing_paren_found\
    \ = false;\n    bool paren_opening_paren_closing_paren_closing_paren_closing_paren_closing\
    \ = false;\n    bool paren_closing_paren_closing_paren_closing_paren_closing_paren_closing\
    \ = false;\n    bool paren_opening_paren_closing_paren_closing_paren_closing_paren_closing_found\
    \ = false;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpszy8k39l.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpszy8k39l.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] paren_levels`

    /tmp/tmpszy8k39l.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpszy8k39l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            level++;\n            levels[level]\
    \ = level;\n            in_paren = true;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n            if(level < 0)\n      \
    \      {\n                throw new Exception(\"Invalid parenthesis string\");\n\
    \            }\n            levels[level] = level;\n            in_paren = false;\n\
    \        }\n        else if(in_paren)\n        {\n            levels[level] =\
    \ level;\n        }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=c#,algorithm,parentheses\
    \ |>\n<| c |>\nI like your solution, but I believe it has a bug. For example,\
    \ `parse_nested_parens(\"(()()) ((())) () ((())()())\")` returns `[2, 2, 2, 2,\
    \ 2]` instead of `[3, 3, 3, 3, 3]`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I've fixed the bug and added a test case to show that it works.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa35gjc19.d(42): Error: declaration expected, not `<`

    /tmp/tmpa35gjc19.d(48): Error: unterminated character constant

    /tmp/tmpa35gjc19.d(53): Error: semicolon expected, not `.`

    /tmp/tmpa35gjc19.d(53): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmpa35gjc19.d(54): Error: semicolon expected, not `.`

    /tmp/tmpa35gjc19.d(54): Error: no identifier for declarator `.Linq`

    /tmp/tmpa35gjc19.d(55): Error: semicolon expected, not `.`

    /tmp/tmpa35gjc19.d(55): Error: no identifier for declarator `.Text`

    /tmp/tmpa35gjc19.d(56): Error: semicolon expected, not `.`

    /tmp/tmpa35gjc19.d(56): Error: no identifier for declarator `.Text.RegularExpressions`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa35gjc19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_size = 0;\n    long\
    \ level_size = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long\
    \ max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n \
    \   long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n\
    \    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = 0;\n    long level_pos = 0;\n    long max_level_pos\
    \ = 0;\n    long level_pos = 0;\n    long max_level_pos = 0;\n    long level_pos\
    \ = 0;\n    long max_level_pos = \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqzr14v4x.d(93): Error: expression expected, not `unittest`

    /tmp/tmpqzr14v4x.d(94): Error: semicolon expected, not `{`

    /tmp/tmpqzr14v4x.d(101): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqzr14v4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 1;\n    bool in_paren = false;\n    bool in_paren_group = false;\n    bool\
    \ in_paren_group_open = false;\n    bool in_paren_group_close = false;\n    bool\
    \ in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace = false;\n\
    \    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoo_6kr58.d(47): Error: semicolon expected, not `unittest`

    /tmp/tmpoo_6kr58.d(47): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoo_6kr58.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpavrut5yg.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpavrut5yg.d(63): Error: semicolon expected, not `unittest`

    /tmp/tmpavrut5yg.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpavrut5yg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_copy = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long levels_stack_index = 0;\n    long levels_stack_copy_index = 0;\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma = false;\n    bool in_paren_group_open_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdl689wbk.d(43): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdl689wbk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n    bool\
    \ is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n   \
    \ bool is_opening_paren_or_opening_paren_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcv00h65d.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpcv00h65d.d(42): Error: semicolon expected, not `unittest`

    /tmp/tmpcv00h65d.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv00h65d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_index46 = 0;\n    long paren_levels_index47 = 0;\n    long\
    \ paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz3azw2wk.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] paren_levels`

    /tmp/tmpz3azw2wk.d(66): Error: semicolon expected, not `unittest`

    /tmp/tmpz3azw2wk.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz3azw2wk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_quote = false;\n    bool in_backslash = false;\n    bool\
    \ in_backslash2 = false;\n    bool in_backslash3 = false;\n    bool in_backslash4\
    \ = false;\n    bool in_backslash5 = false;\n    bool in_backslash6 = false;\n\
    \    bool in_backslash7 = false;\n    bool in_backslash8 = false;\n    bool in_backslash9\
    \ = false;\n    bool in_backslash10 = false;\n    bool in_backslash11 = false;\n\
    \    bool in_backslash12 = false;\n    bool in_backslash13 = false;\n    bool\
    \ in_backslash14 = false;\n    bool in_backslash15 = false;\n    bool in_backslash16\
    \ = false;\n    bool in_backslash17 = false;\n    bool in_backslash18 = false;\n\
    \    bool in_backslash19 = false;\n    bool in_backslash20 = false;\n    bool\
    \ in_backslash21 = false;\n    bool in_backslash22 = false;\n    bool in_backslash23\
    \ = false;\n    bool in_backslash24 = false;\n    bool in_backslash25 = false;\n\
    \    bool in_backslash26 = false;\n    bool in_backslash27 = false;\n    bool\
    \ in_backslash28 = false;\n    bool in_backslash29 = false;\n    bool in_backslash30\
    \ = false;\n    bool in_backslash31 = false;\n    bool in_backslash32 = false;\n\
    \    bool in_backslash33 = false;\n    bool in_backslash34 = false;\n    bool\
    \ in_backslash35 = false;\n    bool in_backslash36 = false;\n    bool in_backslash37\
    \ = false;\n    bool in_backslash38 = false;\n    bool in_backslash39 = false;\n\
    \    bool in_backslash40 = false;\n    bool in_backslash41 = false;\n    bool\
    \ in_backslash42 = false;\n    bool in_backslash43 = false;\n    bool in_backslash44\
    \ = false;\n    bool in_backslash45 = false;\n    bool in_backslash46 = false;\n\
    \    bool in_backslash47 = false;\n    bool in_backslash48 = false;\n    bool\
    \ in_backslash49 = false;\n    bool in_backslash50 = false;\n    bool in_backslash51\
    \ = false;\n    bool in_backslash52 = false;\n    bool in_backslash53 = false;\n\
    \    bool in_backslash54 = false;\n    bool in_backslash55 = false;\n    bool\
    \ in_backslash56 = false;\n    bool in_backslash57 = false;\n    bool in_backslash58\
    \ = false;\n    bool in_backslash59 = false;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc96gfnxp.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc96gfnxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqfwd8r4p.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpqfwd8r4p.d(38): Error: semicolon expected, not `unittest`

    /tmp/tmpqfwd8r4p.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqfwd8r4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long current_level = 0;\n    long current_max_level = 0;\n    long\
    \ current_index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_brace\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwr55n58c.d(72): Error: semicolon expected, not `unittest`

    /tmp/tmpwr55n58c.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwr55n58c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool has_paren = false;\n    bool has_space = false;\n    bool has_comma\
    \ = false;\n    bool has_open = false;\n    bool has_close = false;\n    bool\
    \ has_open_bracket = false;\n    bool has_close_bracket = false;\n    bool has_open_square\
    \ = false;\n    bool has_close_square = false;\n    bool has_open_curly = false;\n\
    \    bool has_close_curly = false;\n    bool has_open_paren = false;\n    bool\
    \ has_close_paren = false;\n    bool has_open_curly_bracket = false;\n    bool\
    \ has_close_curly_bracket = false;\n    bool has_open_parenthesis = false;\n \
    \   bool has_close_parenthesis = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_bracket_bracket\
    \ = false;\n    bool has_close_curly_bracket_bracket = false;\n    bool has_open_parenthesis_bracket\
    \ = false;\n    bool has_close_parenthesis_bracket = false;\n    bool has_open_curly_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4y3tauey.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp4y3tauey.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4y3tauey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        if(paren_char.length() == 0)\n            continue;\n        string open_paren\
    \ = paren_char.substr(0, 1);\n        string close_paren = paren_char.substr(1,\
    \ 1);\n        string open_paren_chars[] = open_paren.split(\"\");\n        string\
    \ close_paren_chars[] = close_paren.split(\"\");\n        for(long j = 0; j <\
    \ open_paren_chars.length; ++j)\n        {\n            string open_paren_char\
    \ = open_paren_chars[j];\n            string close_paren_char = close_paren_chars[j];\n\
    \            if(open_paren_char == close_paren_char)\n            {\n        \
    \        levels[level] = level;\n                level++;\n            }\n   \
    \         else\n            {\n                levels[level] = level;\n      \
    \          levels[level + 1] = level;\n                level++;\n            }\n\
    \        }\n    }\n    for(long i = 0; i < levels.length; ++i)\n    {\n      \
    \  if(levels[i] > max_level)\n            max_level = levels[i];\n    }\n    return\
    \ max_level;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptpnx7fv3.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmptpnx7fv3.d(17): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_chars`

    /tmp/tmptpnx7fv3.d(25): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] open_paren_chars`

    /tmp/tmptpnx7fv3.d(26): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] close_paren_chars`

    /tmp/tmptpnx7fv3.d(16): Error: no property `length` for type `string`

    /tmp/tmptpnx7fv3.d(17): Error: no property `split` for type `string`

    /tmp/tmptpnx7fv3.d(21): Error: no property `length` for type `string`

    /tmp/tmptpnx7fv3.d(23): Error: no property `substr` for type `string`

    /tmp/tmptpnx7fv3.d(24): Error: no property `substr` for type `string`

    /tmp/tmptpnx7fv3.d(25): Error: no property `split` for type `string`

    /tmp/tmptpnx7fv3.d(26): Error: no property `split` for type `string`

    /tmp/tmptpnx7fv3.d(49): Error: cannot implicitly convert expression `max_level`
    of type `long` to `long[]`

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(c == ')') {\n            level--;\n            if(level\
    \ == 0) {\n                level = levels[level];\n            }\n        }\n\
    \    }\n    for(int i = 0; i < levels.length; i++) {\n        if(levels[i] > max_level)\
    \ {\n            max_level = levels[i];\n        }\n    }\n    return max_level;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++,parentheses,recursion |>\n<| a tags=string,algorithm,c++,parentheses,recursion\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <stack>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_gx2jow6.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp_gx2jow6.d(37): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_gx2jow6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6y775nt_.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp6y775nt_.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmp6y775nt_.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6y775nt_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n \
    \   bool in_brace = false;\n    bool in_paren_group = false;\n    bool in_bracket_group\
    \ = false;\n    bool in_brace_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_bracket_group_open = false;\n    bool in_brace_group_open = false;\n\
    \    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed = false;\n\
    \    bool in_brace_group_closed = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_bracket_group_open_brace = false;\n    bool in_brace_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_paren_group_open_bracket\
    \ = false;\n    bool in_bracket_group_open_bracket = false;\n    bool in_brace_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_paren_group_open_brace_group\
    \ = false;\n    bool in_bracket_group_open_brace_group = false;\n    bool in_brace_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_paren_group_open_brace_group_open\
    \ = false;\n    bool in_bracket_group_open_brace_group_open = false;\n    bool\
    \ in_brace_group_open_brace_group_open = false;\n    bool in_paren_group_closed_brace_group_open\
    \ = false;\n    bool in_bracket_group_closed_brace_group_open = false;\n    bool\
    \ in_brace_group_closed_brace_group_open = false;\n    bool in_paren_group_open_brace_group_closed\
    \ = false;\n    bool in_bracket_group_open_brace_group_closed = false;\n    bool\
    \ in_brace_group_open_brace_group_closed = false;\n    bool in_paren_group_closed_brace_group_closed\
    \ = false;\n    bool in_bracket_group_closed_brace_group_closed = false;\n   \
    \ bool in_brace_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8rhb4kgw.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp8rhb4kgw.d(60): Error: semicolon expected, not `unittest`

    /tmp/tmp8rhb4kgw.d(60): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8rhb4kgw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_current = 0;\n\
    \    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd3h80thm.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd3h80thm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    long paren_count = 0;\n\
    \    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_cur\
    \ = 0;\n    long paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long\
    \ paren_level_max3 = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4\
    \ = 0;\n    long paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long\
    \ paren_level_cur5 = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6\
    \ = 0;\n    long paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long\
    \ paren_level_max8 = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9\
    \ = 0;\n    long paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long\
    \ paren_level_cur10 = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11\
    \ = 0;\n    long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n   \
    \ long paren_level_max13 = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14\
    \ = 0;\n    long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n   \
    \ long paren_level_cur15 = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16\
    \ = 0;\n    long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n   \
    \ long paren_level_max18 = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19\
    \ = 0;\n    long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n   \
    \ long paren_level_cur20 = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21\
    \ = 0;\n    long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n   \
    \ long paren_level_max23 = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24\
    \ = 0;\n    long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n   \
    \ long paren_level_cur25 = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7fxkjro.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpz7fxkjro.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7fxkjro.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] max_levels = new long[paren_groups.size()];\n\
    \    long max_level = 0;\n    long level = 0;\n    bool has_paren = false;\n \
    \   bool has_space = false;\n    bool has_comma = false;\n    bool has_opening_bracket\
    \ = false;\n    bool has_closing_bracket = false;\n    bool has_opening_paren\
    \ = false;\n    bool has_closing_paren = false;\n    bool has_opening_curly =\
    \ false;\n    bool has_closing_curly = false;\n    bool has_opening_square = false;\n\
    \    bool has_closing_square = false;\n    bool has_opening_angle = false;\n \
    \   bool has_closing_angle = false;\n    bool has_opening_paren_or_angle = false;\n\
    \    bool has_closing_paren_or_angle = false;\n    bool has_opening_curly_or_angle\
    \ = false;\n    bool has_closing_curly_or_angle = false;\n    bool has_opening_square_or_angle\
    \ = false;\n    bool has_closing_square_or_angle = false;\n    bool has_opening_angle_or_angle\
    \ = false;\n    bool has_closing_angle_or_angle = false;\n    bool has_opening_paren_or_angle_or_angle\
    \ = false;\n    bool has_closing_paren_or_angle_or_angle = false;\n    bool has_opening_curly_or_angle_or_angle\
    \ = false;\n    bool has_closing_curly_or_angle_or_angle = false;\n    bool has_opening_square_or_angle_or_angle\
    \ = false;\n    bool has_closing_square_or_angle_or_angle = false;\n    bool has_opening_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_angle_or_angle_or_angle = false;\n    bool has_opening_paren_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_paren_or_angle_or_angle_or_angle = false;\n \
    \   bool has_opening_curly_or_angle_or_angle_or_angle = false;\n    bool has_closing_curly_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_opening_square_or_angle_or_angle_or_angle = false;\n\
    \    bool has_closing_square_or_angle_or_angle_or_angle = false;\n    bool has_opening_angle_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_angle_or_angle_or_angle_or_angle = false;\n \
    \   bool has_opening_paren_or_angle_or_angle_or_angle_or_angle = false;\n    bool\
    \ has_closing_paren_or_angle_or_angle_or_angle_or_angle = false;\n    bool has_opening_curly_or_angle_or_angle_or_angle_or_angle\
    \ = false;\n    bool has_closing_curly_or_angle_or_angle_or_angle_or_angle\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpos4w3qz7.d(59): Error: semicolon expected, not `unittest`

    /tmp/tmpos4w3qz7.d(59): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpos4w3qz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n\
    \    bool in_brace = false;\n    bool in_braces = false;\n    bool in_braces_open\
    \ = false;\n    bool in_braces_close = false;\n    bool in_braces_open2 = false;\n\
    \    bool in_braces_close2 = false;\n    bool in_braces_open3 = false;\n    bool\
    \ in_braces_close3 = false;\n    bool in_braces_open4 = false;\n    bool in_braces_close4\
    \ = false;\n    bool in_braces_open5 = false;\n    bool in_braces_close5 = false;\n\
    \    bool in_braces_open6 = false;\n    bool in_braces_close6 = false;\n    bool\
    \ in_braces_open7 = false;\n    bool in_braces_close7 = false;\n    bool in_braces_open8\
    \ = false;\n    bool in_braces_close8 = false;\n    bool in_braces_open9 = false;\n\
    \    bool in_braces_close9 = false;\n    bool in_braces_open10 = false;\n    bool\
    \ in_braces_close10 = false;\n    bool in_braces_open11 = false;\n    bool in_braces_close11\
    \ = false;\n    bool in_braces_open12 = false;\n    bool in_braces_close12 = false;\n\
    \    bool in_braces_open13 = false;\n    bool in_braces_close13 = false;\n   \
    \ bool in_braces_open14 = false;\n    bool in_braces_close14 = false;\n    bool\
    \ in_braces_open15 = false;\n    bool in_braces_close15 = false;\n    bool in_braces_open16\
    \ = false;\n    bool in_braces_close16 = false;\n    bool in_braces_open17 = false;\n\
    \    bool in_braces_close17 = false;\n    bool in_braces_open18 = false;\n   \
    \ bool in_braces_close18 = false;\n    bool in_braces_open19 = false;\n    bool\
    \ in_braces_close19 = false;\n    bool in_braces_open20 = false;\n    bool in_braces_close20\
    \ = false;\n    bool in_braces_open21 = false;\n    bool in_braces_close21 = false;\n\
    \    bool in_braces_open22 = false;\n    bool in_braces_close22 = false;\n   \
    \ bool in_braces_open23 = false;\n    bool in_braces_close23 = false;\n    bool\
    \ in_braces_open24 = false;\n    bool in_braces_close24 = false;\n    bool in_braces_open25\
    \ = false;\n    bool in_braces_close25 = false;\n    bool in_braces_open\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgz4v527_.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpgz4v527_.d(73): Error: semicolon expected, not `unittest`

    /tmp/tmpgz4v527_.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz4v527_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_min\
    \ = 0;\n    long parens_level_diff = 0;\n    long parens_level_diff_max = 0;\n\
    \    long parens_level_diff_min = 0;\n    long parens_level_diff_max2 = 0;\n \
    \   long parens_level_diff_min2 = 0;\n    long parens_level_diff_max3 = 0;\n \
    \   long parens_level_diff_min3 = 0;\n    long parens_level_diff_max4 = 0;\n \
    \   long parens_level_diff_min4 = 0;\n    long parens_level_diff_max5 = 0;\n \
    \   long parens_level_diff_min5 = 0;\n    long parens_level_diff_max6 = 0;\n \
    \   long parens_level_diff_min6 = 0;\n    long parens_level_diff_max7 = 0;\n \
    \   long parens_level_diff_min7 = 0;\n    long parens_level_diff_max8 = 0;\n \
    \   long parens_level_diff_min8 = 0;\n    long parens_level_diff_max9 = 0;\n \
    \   long parens_level_diff_min9 = 0;\n    long parens_level_diff_max10 = 0;\n\
    \    long parens_level_diff_min10 = 0;\n    long parens_level_diff_max11 = 0;\n\
    \    long parens_level_diff_min11 = 0;\n    long parens_level_diff_max12 = 0;\n\
    \    long parens_level_diff_min12 = 0;\n    long parens_level_diff_max13 = 0;\n\
    \    long parens_level_diff_min13 = 0;\n    long parens_level_diff_max14 = 0;\n\
    \    long parens_level_diff_min14 = 0;\n    long parens_level_diff_max15 = 0;\n\
    \    long parens_level_diff_min15 = 0;\n    long parens_level_diff_max16 = 0;\n\
    \    long parens_level_diff_min16 = 0;\n    long parens_level_diff_max17 = 0;\n\
    \    long parens_level_diff_min17 = 0;\n    long parens_level_diff_max18 = 0;\n\
    \    long parens_level_diff_min18 = 0;\n    long parens_level_diff_max19 = 0;\n\
    \    long parens_level_diff_min19 = 0;\n    long parens_level_diff_max20 = 0;\n\
    \    long parens_level_diff_min20 = 0;\n    long parens_level_diff_max21 = 0;\n\
    \    long parens_level_diff_min21 = 0;\n    long parens_level_diff_max22 = 0;\n\
    \    long parens_level_diff_min22 = 0;\n    long parens_level_diff_max23 = 0;\n\
    \    long parens_level_diff_min23 = 0;\n    long parens_level_diff_max\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplt2bljzl.d(68): Error: semicolon expected, not `unittest`

    /tmp/tmplt2bljzl.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplt2bljzl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_index46\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfd47f90g.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpfd47f90g.d(20): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] paren_levels`

    /tmp/tmpfd47f90g.d(67): Error: semicolon expected, not `unittest`

    /tmp/tmpfd47f90g.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfd47f90g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptot5kul5.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmptot5kul5.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] paren_levels`

    /tmp/tmptot5kul5.d(67): Error: semicolon expected, not `unittest`

    /tmp/tmptot5kul5.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptot5kul5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            level++;\n        } else if(paren_string[i] == ')') {\n     \
    \       level--;\n        }\n        levels[i] = level;\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=algorithm,string,c++,parentheses |>\n<| c |>\nI like your\
    \ solution, but I believe it can be optimized a little bit more. For example,\
    \ instead of iterating over all characters, you can just iterate over all pairs\
    \ of parentheses and count the level of nesting for each pair. Also, instead of\
    \ iterating over all characters, you can just iterate over all pairs of parentheses\
    \ and count the level of nesting for each pair. Also, instead of iterating over\
    \ all characters, you can just iterate over all pairs of parentheses and count\
    \ the level of nesting for each pair. Also, instead of iterating over all characters,\
    \ you can just iterate over all pairs of parentheses and count the level of nesting\
    \ for each pair. Also, instead of iterating over all characters, you can just\
    \ iterate over all pairs of parentheses and count the level of nesting for each\
    \ pair. Also, instead of iterating over all characters, you can just iterate over\
    \ all pairs of parentheses and count the level of nesting for each pair. Also,\
    \ instead of iterating over all characters, you can just iterate over all pairs\
    \ of parentheses and count the level of nesting for each pair. Also, instead of\
    \ iterating over all characters, you can just iterate over all pairs of parentheses\
    \ and count the level of nesting for each pair. Also, instead of iterating over\
    \ all characters, you can just iterate over all pairs of parentheses and count\
    \ the level of nesting for each pair. Also, instead of iterating over all characters,\
    \ you can just iterate over all pairs of parentheses and count the level of nesting\
    \ for each pair. Also, instead of iterating over all characters, you can just\
    \ iterate over all pairs of parentheses and count the level of nesting for each\
    \ pair. Also, instead of iterating over all characters, you can just iterate over\
    \ all pairs of parentheses and count the level of nesting for each pair. Also,\
    \ instead of iterating over all characters, you can just iterate over all pairs\
    \ of parentheses and count the level of nesting for each pair. Also, instead of\
    \ iterating over all characters, you can just iterate over all pairs of parentheses\
    \ and count the level of nesting for each pair.\n<|/ c |>\n<| c |>\nAlso, I think\
    \ it would be better to iterate over all pairs of parentheses and count the level\
    \ of nesting for each pair. Also, instead of iterating over all characters, you\
    \ can \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvxtapaz5.d(26): Error: declaration expected, not `<`

    /tmp/tmpvxtapaz5.d(37): Error: declaration expected, not `assert`

    /tmp/tmpvxtapaz5.d(38): Error: declaration expected, not `assert`

    /tmp/tmpvxtapaz5.d(39): Error: declaration expected, not `assert`

    /tmp/tmpvxtapaz5.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvxtapaz5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = paren_string;\n    long[] levels = new long[paren_chars.length()];\n\
    \    long[] max_levels = new long[paren_chars.length()];\n    long[] max_levels_index\
    \ = new long[paren_chars.length()];\n    long[] current_levels = new long[paren_chars.length()];\n\
    \    long[] current_levels_index = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index2 = new long[paren_chars.length()];\n    long[] current_levels_index3\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index4 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index5 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index6 = new long[paren_chars.length()];\n    long[] current_levels_index7\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index8 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index9 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index10 = new long[paren_chars.length()];\n    long[] current_levels_index11\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index12 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index13 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index14 = new long[paren_chars.length()];\n    long[] current_levels_index15\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index16 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index17 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index18 = new long[paren_chars.length()];\n    long[] current_levels_index19\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index20 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index21 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index22 = new long[paren_chars.length()];\n    long[] current_levels_index23\
    \ = new long[paren_chars.length()];\n    long[] current_levels_index24 = new long[paren_chars.length()];\n\
    \    long[] current_levels_index25 = new long[paren_chars.length()];\n    long[]\
    \ current_levels_index26 = new long[paren_chars.length()];\n    \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5ym73ets.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ym73ets.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n \
    \       if(paren_string[i] == '(')\n        {\n            paren_stack.push(i);\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            int\
    \ paren_level = paren_stack.top();\n            paren_stack.pop();\n         \
    \   levels[paren_level] = max(levels[paren_level], paren_stack.size());\n    \
    \    }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,parentheses,c++\
    \ |>\n<| c |>\nI believe this solution will fail for input like `((()))` which\
    \ has one level of nesting but is missing a closing parenthesis.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. I missed that case. Thanks for pointing it out.\n\
    <|/ c |>\n<| c |>\nI believe this solution will fail for input like `((()))` which\
    \ has one level of nesting but is missing a closing parenthesis.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. I missed that case. Thanks for pointing it out.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <stack>\nusing namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy026leep.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpy026leep.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpy026leep.d(15): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpy026leep.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmpy026leep.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpy026leep.d(31): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy026leep.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            level++;\n        }\n        else if(paren_string[i] == ')')\
    \ {\n            level--;\n        }\n        levels[i] = level;\n    }\n    return\
    \ levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxjccwwdf.d(27): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxjccwwdf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_bracket =\
    \ false;\n    bool in_group_close_bracket = false;\n    bool in_group_open_square\
    \ = false;\n    bool in_group_close_square = false;\n    bool in_group_open_curly\
    \ = false;\n    bool in_group_close_curly = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren_square\
    \ = false;\n    bool in_group_close_paren_square = false;\n    bool in_group_open_paren_curly\
    \ = false;\n    bool in_group_close_paren_curly = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren_square\
    \ = false;\n    bool in_group_close_paren_square = false;\n    bool in_group_open_paren_curly\
    \ = false;\n    bool in_group_close_paren_curly = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren_square\
    \ = false;\n    bool in_group_close_paren_square = false;\n    bool in_group_open_paren_curly\
    \ = false;\n    bool in_group_close_paren_curly = false;\n    bool in_group_open_angle_bracket\
    \ = false;\n    bool in_group_close_angle_bracket = false;\n    bool in_group_open_angle_square\
    \ = false;\n    bool in_group_close_angle_square = false;\n    bool in_group_open_paren_bracket\
    \ = false;\n    bool in_group_close_paren_bracket = false;\n    bool in_group_open_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5t1vufhc.d(68): Error: semicolon expected, not `unittest`

    /tmp/tmp5t1vufhc.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5t1vufhc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long max_level = 0;\n    long\
    \ level = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool\
    \ in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_open_brace\
    \ = false;\n    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeswkev9v.d(36): Error: semicolon expected, not `unittest`

    /tmp/tmpeswkev9v.d(36): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeswkev9v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool in_paren = false;\n    long\
    \ level = 0;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n    \
    \    if(paren_string[i] == '(')\n        {\n            in_paren = true;\n   \
    \         level++;\n        }\n        else if(paren_string[i] == ')')\n     \
    \   {\n            in_paren = false;\n            level--;\n        }\n      \
    \  else if(in_paren)\n        {\n            levels[level] = levels[level] + 1;\n\
    \        }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,c#,algorithm\
    \ |>\nI wrote a recursive solution in C#:\n<code>\npublic static int GetMaxNestingLevel(string\
    \ input)\n{\n    if (string.IsNullOrEmpty(input))\n        return 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvrgr4t80.d(36): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrgr4t80.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool paren_open = false;\n    bool paren_closed = false;\n\
    \    bool paren_opening_closed = false;\n    bool paren_opening_open = false;\n\
    \    bool paren_opening_closed_open = false;\n    bool paren_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_open = false;\n    bool paren_opening_closed_opening_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed = false;\n  \
    \  bool paren_opening_closed_opening_opening_closed_open = false;\n    bool paren_opening_closed_opening_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_opening_open\
    \ = false;\n    bool paren_opening_closed_opening_opening_closed_opening_closed_opening_closed_opening_closed_opening_closed_closed\
    \ = false;\n    bool paren_opening_closed_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv2m96rd1.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpv2m96rd1.d(43): Error: semicolon expected, not `unittest`

    /tmp/tmpv2m96rd1.d(43): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv2m96rd1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_open = false;\n   \
    \ bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_open =\
    \ false;\n    bool in_paren_group_close_brace_close_brace_close_brace_open = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_close_brace_open_brace_close_brace_close = false;\n   \
    \ bool in_paren_group_close_brace_close_brace_close_brace_close = false;\n   \
    \ bool in_paren_group_open_brace_open_bra\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyywk8w67.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpyywk8w67.d(49): Error: semicolon expected, not `unittest`

    /tmp/tmpyywk8w67.d(49): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyywk8w67.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next = 0;\n    long paren_level_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi_e4jg25.d(50): Error: semicolon expected, not `unittest`

    /tmp/tmpi_e4jg25.d(50): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_e4jg25.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_open2 = false;\n    bool is_closed2\
    \ = false;\n    bool is_open3 = false;\n    bool is_closed3 = false;\n    bool\
    \ is_open4 = false;\n    bool is_closed4 = false;\n    bool is_open5 = false;\n\
    \    bool is_closed5 = false;\n    bool is_open6 = false;\n    bool is_closed6\
    \ = false;\n    bool is_open7 = false;\n    bool is_closed7 = false;\n    bool\
    \ is_open8 = false;\n    bool is_closed8 = false;\n    bool is_open9 = false;\n\
    \    bool is_closed9 = false;\n    bool is_open10 = false;\n    bool is_closed10\
    \ = false;\n    bool is_open11 = false;\n    bool is_closed11 = false;\n    bool\
    \ is_open12 = false;\n    bool is_closed12 = false;\n    bool is_open13 = false;\n\
    \    bool is_closed13 = false;\n    bool is_open14 = false;\n    bool is_closed14\
    \ = false;\n    bool is_open15 = false;\n    bool is_closed15 = false;\n    bool\
    \ is_open16 = false;\n    bool is_closed16 = false;\n    bool is_open17 = false;\n\
    \    bool is_closed17 = false;\n    bool is_open18 = false;\n    bool is_closed18\
    \ = false;\n    bool is_open19 = false;\n    bool is_closed19 = false;\n    bool\
    \ is_open20 = false;\n    bool is_closed20 = false;\n    bool is_open21 = false;\n\
    \    bool is_closed21 = false;\n    bool is_open22 = false;\n    bool is_closed22\
    \ = false;\n    bool is_open23 = false;\n    bool is_closed23 = false;\n    bool\
    \ is_open24 = false;\n    bool is_closed24 = false;\n    bool is_open25 = false;\n\
    \    bool is_closed25 = false;\n    bool is_open26 = false;\n    bool is_closed26\
    \ = false;\n    bool is_open27 = false;\n    bool is_closed27 = false;\n    bool\
    \ is_open28 = false;\n    bool is_closed28 = false;\n    bool is_open29 = false;\n\
    \    bool is_closed29 = false;\n    bool is_open30 = false;\n    bool is_closed30\
    \ = false;\n    bool is_open31 = false;\n    bool is_closed31 = false;\n    bool\
    \ is_open32 = false;\n    bool is_closed32 = false;\n    bool is_open33 = false;\n\
    \    bool is_closed33 = false;\n    bool is_open34 = false;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoh9lqkjk.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpoh9lqkjk.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoh9lqkjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_chars_set = paren_chars.toLower();\n\
    \    string paren_chars_set_size = paren_chars_set.size();\n    string paren_chars_set_chars\
    \ = paren_chars.toCharArray();\n    string paren_chars_set_chars_size = paren_chars_set_chars.size();\n\
    \    string paren_chars_set_chars_chars = paren_chars_set_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_size = paren_chars_set_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars = paren_chars_set_chars_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_chars_size = paren_chars_set_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars = paren_chars_set_chars_chars_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars = paren_chars_set_chars_chars_chars_chars_chars.toCharArray();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_chars_size = paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_size\
    \ = paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_chars_chars_chars_size\
    \ = paren_chars_set_chars_chars_chars_chars_chars_chars_chars_chars_chars_chars.size();\n\
    \    string paren_char\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk2j13sew.d(31): Error: found `paren_char` when expecting `;` following
    statement

    /tmp/tmpk2j13sew.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk2j13sew.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    string current_paren = \"\";\n    string next_paren\
    \ = \"\";\n    string current_string = \"\";\n    string next_string = \"\";\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(current_paren == \"\")\n            {\n \
    \               current_paren = paren_string[i];\n            }\n            else\n\
    \            {\n                current_string += paren_string[i];\n         \
    \   }\n        }\n        else if(paren_string[i] == ')')\n        {\n       \
    \     if(current_paren != \"\")\n            {\n                levels[level_counter]\
    \ = level;\n                level_counter++;\n                level = level_counter;\n\
    \                current_paren = \"\";\n                current_string = \"\"\
    ;\n            }\n        }\n        else if(current_paren != \"\")\n        {\n\
    \            current_string += paren_string[i];\n        }\n    }\n    levels[level_counter]\
    \ = level;\n    level_counter++;\n    level = level_counter;\n    for(int i =\
    \ 0; i < level_counter; i++)\n    {\n        if(levels[i] > max_level)\n     \
    \   {\n            max_level = levels[i];\n        }\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,parentheses |>\n<| c |>\nThis solution doesn't\
    \ work for nested parentheses such as \"(()())\".\n<|/ c |>\n<| c |>\nYes, it\
    \ does. I tested it before posting it. The OP asked for the deepest level of nesting,\
    \ not the number of levels. I used the word \"level\" instead of \"depth\" because\
    \ I thought it would be more intuitive to someone who reads the code. Anyway,\
    \ I edited my answer to make it clear that this function returns the deepest level\
    \ of nesting.\n<|/ c |>\n<| c |>\nI see. Thanks for the clarification.\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp33aig8bm.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp33aig8bm.d(63): Error: declaration expected, not `<`

    /tmp/tmp33aig8bm.d(66): Error: unterminated character constant

    /tmp/tmp33aig8bm.d(77): Error: semicolon expected, not `.`

    /tmp/tmp33aig8bm.d(77): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmp33aig8bm.d(78): Error: semicolon expected, not `.`

    /tmp/tmp33aig8bm.d(78): Error: no identifier for declarator `.Linq`

    /tmp/tmp33aig8bm.d(79): Error: semicolon expected, not `.`

    /tmp/tmp33aig8bm.d(79): Error: no identifier for declarator `.Text`

    /tmp/tmp33aig8bm.d(80): Error: semicolon expected, not `.`

    /tmp/tmp33aig8bm.d(80): Error: no identifier for declarator `.Text.RegularExpressions`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp33aig8bm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n   \
    \ long paren_level_index = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_index2 = 0;\n    long paren_level_max_index3\
    \ = 0;\n    long paren_level_max_index4 = 0;\n    long paren_level_max_index5\
    \ = 0;\n    long paren_level_max_index6 = 0;\n    long paren_level_max_index7\
    \ = 0;\n    long paren_level_max_index8 = 0;\n    long paren_level_max_index9\
    \ = 0;\n    long paren_level_max_index10 = 0;\n    long paren_level_max_index11\
    \ = 0;\n    long paren_level_max_index12 = 0;\n    long paren_level_max_index13\
    \ = 0;\n    long paren_level_max_index14 = 0;\n    long paren_level_max_index15\
    \ = 0;\n    long paren_level_max_index16 = 0;\n    long paren_level_max_index17\
    \ = 0;\n    long paren_level_max_index18 = 0;\n    long paren_level_max_index19\
    \ = 0;\n    long paren_level_max_index20 = 0;\n    long paren_level_max_index21\
    \ = 0;\n    long paren_level_max_index22 = 0;\n    long paren_level_max_index23\
    \ = 0;\n    long paren_level_max_index24 = 0;\n    long paren_level_max_index25\
    \ = 0;\n    long paren_level_max_index26 = 0;\n    long paren_level_max_index27\
    \ = 0;\n    long paren_level_max_index28 = 0;\n    long paren_level_max_index29\
    \ = 0;\n    long paren_level_max_index30 = 0;\n    long paren_level_max_index31\
    \ = 0;\n    long paren_level_max_index32 = 0;\n    long paren_level_max_index33\
    \ = 0;\n    long paren_level_max_index34 = 0;\n    long paren_level_max_index35\
    \ = 0;\n    long paren_level_max_index36 = 0;\n    long paren_level_max_index37\
    \ = 0;\n    long paren_level_max_index38 = 0;\n    long paren_level_max_index39\
    \ = 0;\n    long paren_level_max_index40 = 0;\n    long paren_level_max_index41\
    \ = 0;\n    long paren_level_max_index42 = 0;\n    long paren_level_max_index43\
    \ = 0;\n    long paren_level_max_index44 = 0;\n    long paren_level_max_index45\
    \ = 0;\n    long paren_level_max_index46 = 0;\n    long \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn85ekk8u.d(69): Error: no identifier for declarator `long`

    /tmp/tmpn85ekk8u.d(69): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn85ekk8u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_ptr = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long level_ptr = 0;\n    long level_ptr_prev = 0;\n    long level_ptr_next\
    \ = 0;\n    long level_ptr_next_prev = 0;\n    long level_ptr_next_next = 0;\n\
    \    long level_ptr_next_next_prev = 0;\n    long level_ptr_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ level_ptr_next_next_next_next_next_next_next_next = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ level_ptr_next_next_next_next_next_next_next_next_next = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n \
    \   long level_ptr_next_next_next_next_next_next_next_next_next_next = 0;\n  \
    \  long level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n   \
    \ long level_ptr_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next_prev =\
    \ 0;\n    long level_ptr_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_next_next_next_next_next_next_next_prev = 0;\n \
    \   long level_ptr_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long level_ptr_next_next_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tkgcj1g.d(52): Error: semicolon expected, not `unittest`

    /tmp/tmp_tkgcj1g.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tkgcj1g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer = new\
    \ long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpilioydv1.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmpilioydv1.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilioydv1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    long index = 0;\n    bool has_open\
    \ = false;\n    bool has_close = false;\n    bool has_open_brace = false;\n  \
    \  bool has_close_brace = false;\n    bool has_open_paren = false;\n    bool has_close_paren\
    \ = false;\n    bool has_open_curly = false;\n    bool has_close_curly = false;\n\
    \    bool has_open_angle = false;\n    bool has_close_angle = false;\n    bool\
    \ has_open_paren_curly = false;\n    bool has_close_paren_curly = false;\n   \
    \ bool has_open_curly_curly = false;\n    bool has_close_curly_curly = false;\n\
    \    bool has_open_angle_brace = false;\n    bool has_close_angle_brace = false;\n\
    \    bool has_open_paren_angle = false;\n    bool has_close_paren_angle = false;\n\
    \    bool has_open_curly_angle = false;\n    bool has_close_curly_angle = false;\n\
    \    bool has_open_angle_brace_curly = false;\n    bool has_close_angle_brace_curly\
    \ = false;\n    bool has_open_paren_curly_angle = false;\n    bool has_close_paren_curly_angle\
    \ = false;\n    bool has_open_curly_curly_angle = false;\n    bool has_close_curly_curly_angle\
    \ = false;\n    bool has_open_angle_brace_curly_angle = false;\n    bool has_close_angle_brace_curly_angle\
    \ = false;\n    bool has_open_paren_curly_curly_angle = false;\n    bool has_close_paren_curly_curly_angle\
    \ = false;\n    bool has_open_curly_curly_curly_angle = false;\n    bool has_close_curly_curly_curly_angle\
    \ = false;\n    bool has_open_angle_brace_curly_curly_angle = false;\n    bool\
    \ has_close_angle_brace_curly_curly_angle = false;\n    bool has_open_paren_curly_curly_curly_angle\
    \ = false;\n    bool has_close_paren_curly_curly_curly_angle = false;\n    bool\
    \ has_open_curly_curly_curly_curly_angle = false;\n    bool has_close_curly_curly_curly_curly_angle\
    \ = false;\n    bool has_open_angle_brace_curly_curly_curly_angle = false;\n \
    \   bool has_close_angle_brace_curly_curly_curly_angle = false;\n    bool has_open_paren_curly_curly_curly_curly_angle\
    \ = false;\n    bool has_close_paren_curly_curly_curly_curly_angle = false;\n\
    \    bool has_open_cur\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppzridn1v.d(62): Error: semicolon expected, not `unittest`

    /tmp/tmppzridn1v.d(62): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppzridn1v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_opener = false;\n    bool in_paren_group_closer = false;\n\
    \    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_closer_close = false;\n    bool in_paren_group_opener_close_open\
    \ = false;\n    bool in_paren_group_closer_close_open = false;\n    bool in_paren_group_opener_close_close\
    \ = false;\n    bool in_paren_group_closer_close_close = false;\n    bool in_paren_group_opener_close_opener\
    \ = false;\n    bool in_paren_group_closer_close_opener = false;\n    bool in_paren_group_opener_close_closer\
    \ = false;\n    bool in_paren_group_closer_close_closer = false;\n    bool in_paren_group_opener_close_opener_close\
    \ = false;\n    bool in_paren_group_closer_close_opener_close = false;\n    bool\
    \ in_paren_group_opener_close_closer_close = false;\n    bool in_paren_group_closer_close_closer_close\
    \ = false;\n    bool in_paren_group_opener_close_opener_close_close = false;\n\
    \    bool in_paren_group_closer_close_opener_close_close = false;\n    bool in_paren_group_opener_close_closer_close_close\
    \ = false;\n    bool in_paren_group_closer_close_closer_close_close = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close_open = false;\n    bool\
    \ in_paren_group_closer_close_opener_close_close_open = false;\n    bool in_paren_group_opener_close_closer_close_close_open\
    \ = false;\n    bool in_paren_group_closer_close_closer_close_close_open = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close_close = false;\n    bool\
    \ in_paren_group_closer_close_opener_close_close_close = false;\n    bool in_paren_group_opener_close_closer_close_close_close\
    \ = false;\n    bool in_paren_group_closer_close_closer_close_close_close = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close_close_open = false;\n\
    \    bool in_paren_group_closer_close_opener_close_close_close_open = false;\n\
    \    bool in_paren_group_opener_close_closer_close_close_close_close = false;\n\
    \    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_8gopl_.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpz_8gopl_.d(55): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_8gopl_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_or_closing\
    \ = false;\n    bool is_opening_or_closed = false;\n    bool is_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_closing = false;\n    bool is_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening = false;\n    bool is_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_closed = false;\n   \
    \ bool is_opening_or_opening_or_opening_or_opening = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_closed = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening = false;\n  \
    \  bool is_opening_or_opening_or_opening_or_opening_or_opening_or_closing = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_closed = false;\n\
    \    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening =\
    \ false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_opening_or_closed\
    \ = false;\n    bool is_opening_or_opening_or_opening_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuz63ifux.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpuz63ifux.d(46): Error: semicolon expected, not `unittest`

    /tmp/tmpuz63ifux.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuz63ifux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_size = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening = false;\n\
    \    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa84x73u4.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpa84x73u4.d(38): Error: semicolon expected, not `unittest`

    /tmp/tmpa84x73u4.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa84x73u4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_comma\
    \ = false;\n    bool in_group_semicolon = false;\n    bool in_group_newline =\
    \ false;\n    bool in_group_end = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_angle = false;\n\
    \    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace =\
    \ false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_curly_square\
    \ = false;\n    bool in_group_close_curly_square = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace\
    \ = false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_curly_square\
    \ = false;\n    bool in_group_close_curly_square = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace\
    \ = false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_curly_square\
    \ = false;\n    bool in_group_close_curly_square = false;\n    bool in_group_open_paren\
    \ = false;\n    bool in_group_close_paren = false;\n    bool in_group_open_angle\
    \ = false;\n    bool in_group_close_angle = false;\n    bool in_group_open_curly_brace\
    \ = false;\n    bool in_group_close_curly_brace = false;\n    bool in_group_open_curly_bracket\
    \ = false;\n    bool in_group_close_curly_bracket = false;\n    bool in_group_open_cur\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gydb74j.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp7gydb74j.d(73): Error: semicolon expected, not `unittest`

    /tmp/tmp7gydb74j.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gydb74j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_comma = false;\n    bool in_paren_group_close_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_comma_brace = false;\n    bool in_paren_group_open_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma = false;\n \
    \   bool in_paren_group_open_brace_comma_brace_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_comma_brace_comma_brace = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_b\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp96loj9xe.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp96loj9xe.d(44): Error: semicolon expected, not `unittest`

    /tmp/tmp96loj9xe.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp96loj9xe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_index = 0;\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close = false;\n\
    \    bool in_paren_group_open_brace_or_close_brace_or_close_paren = false;\n \
    \   bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close = false;\n\
    \    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_close_paren_or_close_paren_or_close_paren_or_close_paren_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpifpmdb1x.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpifpmdb1x.d(41): Error: semicolon expected, not `unittest`

    /tmp/tmpifpmdb1x.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpifpmdb1x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    bool in_paren = false;\n    bool in_paren_prev\
    \ = false;\n    bool in_paren_next = false;\n    bool in_paren_next_prev = false;\n\
    \    bool in_paren_next_next = false;\n    bool in_paren_next_next_prev = false;\n\
    \    bool in_paren_next_next_next = false;\n    bool in_paren_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next = false;\n    bool in_paren_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next = false;\n    bool in_paren_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next = false;\n    bool\
    \ in_paren_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_prev = false;\n  \
    \  bool in_paren_next_next_next_next_next_next_next = false;\n    bool in_paren_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_prev = false;\n   \
    \ bool in_paren_next_next_next_next_next_next_next_next_next = false;\n    bool\
    \ in_paren_next_next_next_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp05d2lxi4.d(52): Error: semicolon expected, not `unittest`

    /tmp/tmp05d2lxi4.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp05d2lxi4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_open = false;\n    bool in_paren_group_open_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_open = false;\n    bool in_paren_group_open_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_open = false;\n   \
    \ bool in_paren_group_open_close_close_close_close = false;\n    bool in_paren_group_open_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close = false;\n\
    \    bool in_paren_group_open_close_close_close_close_close_open = false;\n  \
    \  bool in_paren_group_open_close_close_close_close_close_close = false;\n   \
    \ bool in_paren_group_open_close_close_close_close_close_open = false;\n    bool\
    \ in_paren_group_open_close_close_close_close_close_close_close = false;\n   \
    \ bool in_paren_group_open_close_close_close_close_close_close_open = false;\n\
    \    bool in_paren_group_open_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_close_close_close_close_close_close_close_close_close_close_open\
    \ = false;\n    bool in_paren_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz10pjv5.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpyz10pjv5.d(50): Error: semicolon expected, not `unittest`

    /tmp/tmpyz10pjv5.d(50): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz10pjv5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_clo\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpesk6ktcb.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpesk6ktcb.d(43): Error: semicolon expected, not `unittest`

    /tmp/tmpesk6ktcb.d(43): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpesk6ktcb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_open = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_open = false;\n   \
    \ bool in_paren_group_close_brace_open_brace_close = false;\n    bool in_paren_group_open_brace_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj1t5yu3f.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpj1t5yu3f.d(52): Error: semicolon expected, not `unittest`

    /tmp/tmpj1t5yu3f.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1t5yu3f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_square = false;\n    bool in_paren_group_close_square\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_paren = false;\n    bool in_paren_group_close_paren\
    \ = false;\n    bool in_paren_group_open_angle_bracket = false;\n    bool in_paren_group_close_angle_bracket\
    \ = false;\n    bool in_paren_group_open_angle_brace = false;\n    bool in_paren_group_close_angle_brace\
    \ = false;\n    bool in_paren_group_open_curly_bracket = false;\n    bool in_paren_group_close_curly_bracket\
    \ = false;\n    bool in_paren_group_open_curly_brace = false;\n    bool in_paren_group_close_curly_brace\
    \ = false;\n    bool in_paren_group_open_curly_square = false;\n    bool in_paren_group_close_curly_square\
    \ = false;\n    bool in_paren_group_open_paren_bracket = false;\n    bool in_paren_group_close_paren_bracket\
    \ = false;\n    bool in_paren_group_open_paren_brace = false;\n    bool in_paren_group_close_paren_brace\
    \ = false;\n    bool in_paren_group_open_angle_bracket = false;\n    bool in_paren_group_close_angle_bracket\
    \ = false;\n    bool in_paren_group_open_angle_brace = false;\n    bool in_paren_group_close_angle_brace\
    \ = false;\n    bool in_paren_group_open_curly_bracket = false;\n    bool in_paren_group_close_curly_bracket\
    \ = false;\n    bool in_paren_group_open_curly_brace = false;\n    bool in_paren_group_close_curly_brace\
    \ = false;\n    bool in_paren_group_open_curly_square = false;\n    bool in_paren_group_close_curly_square\
    \ = false;\n    bool in_paren_group_open_paren_bracket = false;\n    bool in_paren_group_close_paren_bracket\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph9fco4lt.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmph9fco4lt.d(61): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9fco4lt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace = false;\n\
    \    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphynibwwp.d(36): Error: semicolon expected, not `unittest`

    /tmp/tmphynibwwp.d(36): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphynibwwp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl429m1rw.d(79): Error: no identifier for declarator `long`

    /tmp/tmpl429m1rw.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl429m1rw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n   \
    \ long paren_level_index = 0;\n    long paren_level_size = 0;\n    long paren_level_size_index\
    \ = 0;\n    long paren_level_size_size = 0;\n    long paren_level_size_size_index\
    \ = 0;\n    long paren_level_size_size_level = 0;\n    long paren_level_size_size_level_index\
    \ = 0;\n    long paren_level_size_size_level_size = 0;\n    long paren_level_size_size_level_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size = 0;\n    long paren_level_size_size_level_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size = 0;\n    long paren_level_size_size_level_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_level_size_size_size_index = 0;\n    long paren_level_size_size_level_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_level_size_size_size_size_index = 0;\n    long paren_level_size_size_level_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_level_size_size_size_size_size_index = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_index =\
    \ 0;\n    long paren_level_size_size_level_size_size_size_size_size_size = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_size = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_size = 0;\n\
    \    long paren_level_size_size_level_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_level_size_size_size_size_size_size_size\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq7hqfxh7.d(54): Error: semicolon expected, not `unittest`

    /tmp/tmpq7hqfxh7.d(54): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq7hqfxh7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_comma\
    \ = false;\n    bool in_group_semicolon = false;\n    bool in_group_newline =\
    \ false;\n    bool in_group_end = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_bracket = false;\n\
    \    bool in_group_close_bracket = false;\n    bool in_group_open_square = false;\n\
    \    bool in_group_close_square = false;\n    bool in_group_open_curly = false;\n\
    \    bool in_group_close_curly = false;\n    bool in_group_open_paren = false;\n\
    \    bool in_group_close_paren = false;\n    bool in_group_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1513fb5q.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp1513fb5q.d(75): Error: semicolon expected, not `unittest`

    /tmp/tmp1513fb5q.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1513fb5q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6y775nt_.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp6y775nt_.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmp6y775nt_.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6y775nt_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool in_paren = false;\n    long\
    \ level = 0;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n    \
    \    if(paren_string[i] == '(')\n        {\n            if(!in_paren)\n      \
    \      {\n                level++;\n                in_paren = true;\n       \
    \     }\n        }\n        else if(paren_string[i] == ')')\n        {\n     \
    \       if(!in_paren)\n            {\n                level--;\n             \
    \   in_paren = true;\n            }\n        }\n        else\n        {\n    \
    \        in_paren = false;\n        }\n        levels[i] = level;\n    }\n   \
    \ return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0eutytlv.d(14): Error: no property `length` for type `string`

    /tmp/tmp0eutytlv.d(17): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0eutytlv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at = 0;\n    long level_at\
    \ = 0;\n    long level_at_prev = 0;\n    long level_at_prev2 = 0;\n    long level_at_prev3\
    \ = 0;\n    long level_at_prev4 = 0;\n    long level_at_prev5 = 0;\n    long level_at_prev6\
    \ = 0;\n    long level_at_prev7 = 0;\n    long level_at_prev8 = 0;\n    long level_at_prev9\
    \ = 0;\n    long level_at_prev10 = 0;\n    long level_at_prev11 = 0;\n    long\
    \ level_at_prev12 = 0;\n    long level_at_prev13 = 0;\n    long level_at_prev14\
    \ = 0;\n    long level_at_prev15 = 0;\n    long level_at_prev16 = 0;\n    long\
    \ level_at_prev17 = 0;\n    long level_at_prev18 = 0;\n    long level_at_prev19\
    \ = 0;\n    long level_at_prev20 = 0;\n    long level_at_prev21 = 0;\n    long\
    \ level_at_prev22 = 0;\n    long level_at_prev23 = 0;\n    long level_at_prev24\
    \ = 0;\n    long level_at_prev25 = 0;\n    long level_at_prev26 = 0;\n    long\
    \ level_at_prev27 = 0;\n    long level_at_prev28 = 0;\n    long level_at_prev29\
    \ = 0;\n    long level_at_prev30 = 0;\n    long level_at_prev31 = 0;\n    long\
    \ level_at_prev32 = 0;\n    long level_at_prev33 = 0;\n    long level_at_prev34\
    \ = 0;\n    long level_at_prev35 = 0;\n    long level_at_prev36 = 0;\n    long\
    \ level_at_prev37 = 0;\n    long level_at_prev38 = 0;\n    long level_at_prev39\
    \ = 0;\n    long level_at_prev40 = 0;\n    long level_at_prev41 = 0;\n    long\
    \ level_at_prev42 = 0;\n    long level_at_prev43 = 0;\n    long level_at_prev44\
    \ = 0;\n    long level_at_prev45 = 0;\n    long level_at_prev46 = 0;\n    long\
    \ level_at_prev47 = 0;\n    long level_at_prev48 = 0;\n    long level_at_prev49\
    \ = 0;\n    long level_at_prev50 = 0;\n    long level_at_prev51 = 0;\n    long\
    \ level_at_prev52 = 0;\n    long level_at_prev53 = 0;\n    long level_at_prev54\
    \ = 0;\n    long level_at_prev55 = 0;\n    long level_at_prev56 = 0;\n    long\
    \ level_at_prev57 = 0;\n    long level_at_prev58 = 0;\n    long level_at_prev59\
    \ = 0;\n    long level_at_prev60 = 0;\n    long level_at_prev61 = 0;\n    long\
    \ level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3_n705y9.d(80): Error: semicolon expected, not `unittest`

    /tmp/tmp3_n705y9.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_n705y9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long[] current_levels_of_nesting = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_with_parens = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens_without_spaces = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens_with_spaces = new long[paren_groups.length()];\n\
    \    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\n    long[] current_levels_of_nesting_without_parens_with_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces_without_spaces\
    \ = new long[paren_groups.length()];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbklavujv.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbklavujv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack;\n   \
    \ bool in_paren = false;\n    bool in_group = false;\n    long level = 0;\n  \
    \  long max_level = 0;\n    for(int i = 0; i < paren_string.length(); i++) {\n\
    \        char c = paren_string[i];\n        if(c == '(') {\n            if(!in_group)\
    \ {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == ')')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == ' ') {\n   \
    \         if(!in_group) {\n                level++;\n            }\n        }\n\
    \        else if(c == '(' || c == ')') {\n            if(!in_group) {\n      \
    \          level--;\n            }\n        }\n        else if(c == '[') {\n \
    \           if(!in_group) {\n                in_group = true;\n              \
    \  paren_stack.push(i);\n                level++;\n            }\n        }\n\
    \        else if(c == ']') {\n            if(!in_group) {\n                in_group\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == '[' || c == ']') {\n            if(!in_group) {\n                level--;\n\
    \            }\n        }\n        else if(c == '{') {\n            if(!in_group)\
    \ {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '}')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '{') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '}')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '<') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '>')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '<') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\n            }\n        }\n        else if(c == '>')\
    \ {\n            if(!in_group) {\n                in_group = false;\n        \
    \        level--;\n            }\n        }\n        else if(c == '!') {\n   \
    \         if(!in_group) {\n                in_group = true;\n                paren_stack.push(i);\n\
    \                level++;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1mao6rt7.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmp1mao6rt7.d(120): Error: found `unittest` instead of statement

    /tmp/tmp1mao6rt7.d(128): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp1mao6rt7.d(128): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp1mao6rt7.d(128): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1mao6rt7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_char;\n    long max_level = 0;\n    long level = 0;\n    long levels[]\
    \ = new long[MAX_LEVELS];\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztv_5p2e.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpztv_5p2e.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztv_5p2e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26f0nl78.d(75): Error: semicolon expected, not `unittest`

    /tmp/tmp26f0nl78.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26f0nl78.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5wsrfsyh.d(42): Error: semicolon expected, not `unittest`

    /tmp/tmp5wsrfsyh.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5wsrfsyh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack = new long[paren_groups.length()];\n\
    \    long[] max_levels_stack_pos = new long[paren_groups.length()];\n    long[]\
    \ max_levels_stack_pos_stack = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvbjdagc.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmpjvbjdagc.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvbjdagc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0mn7zwav.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp0mn7zwav.d(48): Error: semicolon expected, not `unittest`

    /tmp/tmp0mn7zwav.d(48): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mn7zwav.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long\
    \ paren_level_next = 0;\n    long paren_level_next_max = 0;\n    long paren_level_next_cur\
    \ = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_max\
    \ = 0;\n    long paren_level_next_next_cur = 0;\n    long paren_level_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_max = 0;\n    long paren_level_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_cur = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_cur = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_cur = 0;\n   \
    \ long paren_level_next_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_cur = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_max = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpujgajslp.d(55): Error: semicolon expected, not `unittest`

    /tmp/tmpujgajslp.d(55): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpujgajslp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_chars_set = paren_chars.toLower();\n\
    \    string paren_chars_set_size = paren_chars_set.size();\n    string paren_chars_set_reversed\
    \ = paren_chars_set.reverse();\n    string paren_chars_set_reversed_size = paren_chars_set_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed = paren_chars_set_reversed.reverse();\n\
    \    string paren_chars_set_reversed_reversed_size = paren_chars_set_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_size = paren_chars_set_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_size = paren_chars_set_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed.size();\n   \
    \ string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size();\n\
    \    string paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_size\
    \ = paren_chars_set_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reverse\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgemt8x5l.d(30): Error: semicolon expected, not `unittest`

    /tmp/tmpgemt8x5l.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgemt8x5l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_paren_or_closed = false;\n    bool is_closing_paren_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_open = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_closing_paren_or_opening_paren_or_closed_or_open = false;\n    bool\
    \ is_opening_paren_or_closed_or_opening_paren = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzkkm1gb8.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpzkkm1gb8.d(46): Error: semicolon expected, not `unittest`

    /tmp/tmpzkkm1gb8.d(46): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzkkm1gb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_paren_group\
    \ = false;\n    bool in_quote_group = false;\n    bool in_paren_group_close =\
    \ false;\n    bool in_quote_group_close = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_quote_group_open = false;\n    bool in_paren_group_open2\
    \ = false;\n    bool in_quote_group_open2 = false;\n    bool in_paren_group_open3\
    \ = false;\n    bool in_quote_group_open3 = false;\n    bool in_paren_group_open4\
    \ = false;\n    bool in_quote_group_open4 = false;\n    bool in_paren_group_open5\
    \ = false;\n    bool in_quote_group_open5 = false;\n    bool in_paren_group_open6\
    \ = false;\n    bool in_quote_group_open6 = false;\n    bool in_paren_group_open7\
    \ = false;\n    bool in_quote_group_open7 = false;\n    bool in_paren_group_open8\
    \ = false;\n    bool in_quote_group_open8 = false;\n    bool in_paren_group_open9\
    \ = false;\n    bool in_quote_group_open9 = false;\n    bool in_paren_group_open10\
    \ = false;\n    bool in_quote_group_open10 = false;\n    bool in_paren_group_open11\
    \ = false;\n    bool in_quote_group_open11 = false;\n    bool in_paren_group_open12\
    \ = false;\n    bool in_quote_group_open12 = false;\n    bool in_paren_group_open13\
    \ = false;\n    bool in_quote_group_open13 = false;\n    bool in_paren_group_open14\
    \ = false;\n    bool in_quote_group_open14 = false;\n    bool in_paren_group_open15\
    \ = false;\n    bool in_quote_group_open15 = false;\n    bool in_paren_group_open16\
    \ = false;\n    bool in_quote_group_open16 = false;\n    bool in_paren_group_open17\
    \ = false;\n    bool in_quote_group_open17 = false;\n    bool in_paren_group_open18\
    \ = false;\n    bool in_quote_group_open18 = false;\n    bool in_paren_group_open19\
    \ = false;\n    bool in_quote_group_open19 = false;\n    bool in_paren_group_open20\
    \ = false;\n    bool in_quote_group_open20 = false;\n    bool in_paren_group_open21\
    \ = false;\n    bool in_quote_group_open21 = false;\n    bool in_paren_group_open22\
    \ = false;\n    bool in_quote_group_open22 = false;\n    bool in_paren_group_open23\
    \ = false;\n    bool in_quote_group_open23 = false;\n    bool in_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvkhjj7lz.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvkhjj7lz.d(70): Error: semicolon expected, not `unittest`

    /tmp/tmpvkhjj7lz.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvkhjj7lz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c++,string\
    \ |>\n<| c |>\nThis doesn't work. Try it with the string \"(()())\".\n<|/ c |>\n\
    <| c |>\nIt works. I tested it with the string \"(()())\"\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with the string \"(()())\".\n<|/ c |>\n<| c |>\nIt works.\
    \ I tested it with the string \"(()())\"\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try it with the string \"(()())\".\n<|/ c |>\n<| a dscore=2 |>\nI believe this\
    \ can be solved using dynamic programming. \nThe idea is to build a table of size\
    \ n+1 where n is the number of parentheses in the string. \nThe first row of the\
    \ table will contain the number of parentheses in the string and the number of\
    \ parentheses contained in the string itself. \nThe next row will contain the\
    \ number of parentheses in the string and the number of parentheses contained\
    \ in the string after the first parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first two parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first three parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first four parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first five parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first six parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first seven parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first eight parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first nine parentheses.\nThe next row will contain the number\
    \ of parentheses in the string and the number of parentheses contained in the\
    \ string after the first t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxzekp1dj.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpxzekp1dj.d(35): Error: declaration expected, not `<`

    /tmp/tmpxzekp1dj.d(38): Error: unterminated character constant

    /tmp/tmpxzekp1dj.d(44): Error: unterminated character constant

    /tmp/tmpxzekp1dj.d(50): Error: unterminated character constant

    /tmp/tmpxzekp1dj.d(70): Error: declaration expected, not `assert`

    /tmp/tmpxzekp1dj.d(71): Error: declaration expected, not `assert`

    /tmp/tmpxzekp1dj.d(72): Error: declaration expected, not `assert`

    /tmp/tmpxzekp1dj.d(73): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxzekp1dj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_current\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_min\
    \ = 0;\n    long parens_level_current_max = 0;\n    long parens_level_current_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdg9apib0.d(72): Error: semicolon expected, not `unittest`

    /tmp/tmpdg9apib0.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdg9apib0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n \
    \       if(paren_string[i] == '(')\n        {\n            paren_stack.push(i);\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            int\
    \ paren_level = paren_stack.top();\n            paren_stack.pop();\n         \
    \   levels[paren_level] = max(levels[paren_level], paren_stack.size());\n    \
    \    }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,string,c++\
    \ |>\nI wrote a recursive solution in Python:\n<code>\ndef paren_levels(s):\n\
    \    levels = []\n    level = 0\n    stack = []\n    for c in s:\n        if c\
    \ == '(':\n            stack.append(level)\n        elif c == ')':\n         \
    \   level = stack.pop()\n        else:\n            levels.append(level)\n   \
    \         level = 0\n    return levels\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n#include <iostream>\n#include <stack>\n#include <string>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2r2g90xe.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmp2r2g90xe.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmp2r2g90xe.d(15): Error: found `(` when expecting identifier following `int`.

    /tmp/tmp2r2g90xe.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmp2r2g90xe.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp2r2g90xe.d(31): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2r2g90xe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0w13o126.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0w13o126.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_quote = false;\n    bool in_escape = false;\n    bool\
    \ in_escaped = false;\n    bool in_string = false;\n    bool in_comment = false;\n\
    \    bool in_comment = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    bool in_string = false;\n    bool\
    \ in_string = false;\n    bool in_string = false;\n    bool in_string = false;\n\
    \    bool in_string = false;\n    bool in_string = false;\n    bool in_string\
    \ = false;\n    bool in_string = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprw9tusy7.d(99): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprw9tusy7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    long index = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space = false;\n    bool is_closing_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space_or_space = false;\n    bool is_closing_paren_or_space_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space_or_space = false;\n\
    \    bool is_closing_curly_bracket_or_paren_or_space_or_space = false;\n    bool\
    \ is_opening_square_bracket_or_paren_or_space_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space_or_space\
    \ = false;\n    bool is_opening_paren_or_space_or_space_or_space = false;\n  \
    \  bool is_closing_paren_or_space_or_space_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_opening_square_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space_or_space_or_space\
    \ = false;\n    bool is_opening_paren_or_space_or_space_or_space_or_space = false;\n\
    \    bool is_closing_paren_or_space_or_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqz5wjcjg.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpqz5wjcjg.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmpqz5wjcjg.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqz5wjcjg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long max_level = 0;\n    long current_level\
    \ = 0;\n    long current_level_of_nesting = 0;\n    long current_level_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting = 0;\n    long\
    \ current_level_of_nesting_of_nesting_of_nesting_of_nesting = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting\
    \ = 0;\n    long current_level_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_of_nesting_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp916bp3z0.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmp916bp3z0.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp916bp3z0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_bracket\
    \ = false;\n    bool in_paren_group_close_bracket = false;\n    bool in_paren_group_open_square\
    \ = false;\n    bool in_paren_group_close_square = false;\n    bool in_paren_group_open_curly\
    \ = false;\n    bool in_paren_group_close_curly = false;\n    bool in_paren_group_open_angle\
    \ = false;\n    bool in_paren_group_close_angle = false;\n    bool in_paren_group_open_paren\
    \ = false;\n    bool in_paren_group_close_paren = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_group_close_semicolon = false;\n    bool in_paren_group_open_colon\
    \ = false;\n    bool in_paren_group_close_colon = false;\n    bool in_paren_group_open_comma\
    \ = false;\n    bool in_paren_group_close_comma = false;\n    bool in_paren_group_open_semicolon\
    \ = false;\n    bool in_paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21b5512b.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp21b5512b.d(65): Error: semicolon expected, not `unittest`

    /tmp/tmp21b5512b.d(65): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21b5512b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2 =\
    \ false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5\
    \ = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n    bool\
    \ in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n\
    \    bool in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13\
    \ = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n    bool\
    \ in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n\
    \    bool in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21\
    \ = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n    bool\
    \ in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n\
    \    bool in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29\
    \ = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n    bool\
    \ in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n\
    \    bool in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37\
    \ = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n    bool\
    \ in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n\
    \    bool in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45\
    \ = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n    bool\
    \ in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n\
    \    bool in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53\
    \ = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n    bool\
    \ in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n\
    \    bool in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61\
    \ = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n    bool\
    \ in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n\
    \    bool in_group67 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0g03zkd7.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp0g03zkd7.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0g03zkd7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_levels[] =\
    \ new long[paren_string.length()];\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_square = false;\n    bool in_paren_group_close_square\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_plus = false;\n    bool in_paren_group_close_plus\
    \ = false;\n    bool in_paren_group_open_minus = false;\n    bool in_paren_group_close_minus\
    \ = false;\n    bool in_paren_group_open_star = false;\n    bool in_paren_group_close_star\
    \ = false;\n    bool in_paren_group_open_comma = false;\n    bool in_paren_group_close_comma\
    \ = false;\n    bool in_paren_group_open_colon = false;\n    bool in_paren_group_close_colon\
    \ = false;\n    bool in_paren_group_open_semicolon = false;\n    bool in_paren_group_close_semicolon\
    \ = false;\n    bool in_paren_group_open_hash = false;\n    bool in_paren_group_close_hash\
    \ = false;\n    bool in_paren_group_open_open_paren = false;\n    bool in_paren_group_close_open_paren\
    \ = false;\n    bool in_paren_group_open_close_paren = false;\n    bool in_paren_group_open_open_curly\
    \ = false;\n    bool in_paren_group_close_open_curly = false;\n    bool in_paren_group_open_close_curly\
    \ = false;\n    bool in_paren_group_open_open_angle = false;\n    bool in_paren_group_close_open_angle\
    \ = false;\n    bool in_paren_group_open_open_plus = false;\n    bool in_paren_group_close_open_plus\
    \ = false;\n    bool in_paren_group_open_close_minus = false;\n    bool in_paren_group_open_close_star\
    \ = false;\n    bool in_paren_group_open_close_comma = false;\n    bool in_paren_group_open_close_colon\
    \ = false;\n    bool in_paren_group_open_close_semicolon = false;\n    bool in_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfylltbr.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpbfylltbr.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] current_levels`

    /tmp/tmpbfylltbr.d(64): Error: semicolon expected, not `unittest`

    /tmp/tmpbfylltbr.d(64): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfylltbr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] levels = new long[paren_groups.length()];\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2sqslad6.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2sqslad6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma = false;\n    bool in_paren_group_open_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_comma_brace_comma = false;\n    bool in_paren_group_close_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_close_brace_comma_brace_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_comma_brace_comma_brace_comma = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_bra\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6eysdo4m.d(43): Error: semicolon expected, not `unittest`

    /tmp/tmp6eysdo4m.d(43): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6eysdo4m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_sum = 0;\n  \
    \  long paren_level_count_sum_max = 0;\n    long paren_level_count_sum_min = 0;\n\
    \    long paren_level_count_sum_avg = 0;\n    long paren_level_count_sum_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_min = 0;\n    long paren_level_count_sum_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_avg_min = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_s6i57sq.d(60): Error: semicolon expected, not `unittest`

    /tmp/tmp_s6i57sq.d(60): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_s6i57sq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close = false;\n  \
    \  bool in_group_open_brace_or_close_brace_or_open_brace = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpibpa4zuo.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpibpa4zuo.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibpa4zuo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[MAX_GROUPS];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzw8y4i6p.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpzw8y4i6p.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpzw8y4i6p.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzw8y4i6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_levels[] =\
    \ new long[paren_string.length()];\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening = false;\n    bool is_closing = false;\n    bool\
    \ is_opening_open = false;\n    bool is_opening_closed = false;\n    bool is_closing_open\
    \ = false;\n    bool is_closing_closed = false;\n    bool is_opening_opening =\
    \ false;\n    bool is_opening_closing = false;\n    bool is_closing_opening =\
    \ false;\n    bool is_closing_closing = false;\n    bool is_opening_opening_open\
    \ = false;\n    bool is_opening_opening_closed = false;\n    bool is_opening_closing_open\
    \ = false;\n    bool is_opening_closing_closed = false;\n    bool is_closing_opening_open\
    \ = false;\n    bool is_closing_opening_closed = false;\n    bool is_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closed = false;\n    bool is_opening_opening_opening\
    \ = false;\n    bool is_opening_opening_closing = false;\n    bool is_opening_closing_opening\
    \ = false;\n    bool is_opening_closing_closing = false;\n    bool is_closing_opening_opening\
    \ = false;\n    bool is_closing_opening_closing = false;\n    bool is_closing_closing_opening\
    \ = false;\n    bool is_closing_closing_closing = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_opening_open\
    \ = false;\n    bool is_closing_closing_opening_closed = false;\n    bool is_closing_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5zdeg7mi.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp5zdeg7mi.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] current_levels`

    /tmp/tmp5zdeg7mi.d(66): Error: no identifier for declarator `bool`

    /tmp/tmp5zdeg7mi.d(66): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5zdeg7mi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeb5_fcqv.d(86): Error: found `unittest` instead of statement

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_cur = 0;\n    long paren_level_next_prev = 0;\n    long paren_level_next_cur\
    \ = 0;\n    long paren_level_next_next_prev = 0;\n    long paren_level_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_prev = 0;\n    long paren_level_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_cur = 0;\n   \
    \ long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_cur = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_cur\
    \ = 0;\n    long paren_level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfk2but_c.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmpfk2but_c.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfk2but_c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    bool is_open = false;\n    bool is_close = false;\n  \
    \  bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_level\
    \ = false;\n    bool is_closing_paren_level = false;\n    bool is_opening_paren_level_open\
    \ = false;\n    bool is_closing_paren_level_open = false;\n    bool is_opening_paren_level_close\
    \ = false;\n    bool is_closing_paren_level_close = false;\n    bool is_opening_paren_level_opening\
    \ = false;\n    bool is_closing_paren_level_opening = false;\n    bool is_opening_paren_level_closing\
    \ = false;\n    bool is_closing_paren_level_closing = false;\n    bool is_opening_paren_level_opening_paren\
    \ = false;\n    bool is_closing_paren_level_opening_paren = false;\n    bool is_opening_paren_level_closing_paren\
    \ = false;\n    bool is_closing_paren_level_closing_paren = false;\n    bool is_opening_paren_level_opening_paren_level\
    \ = false;\n    bool is_closing_paren_level_opening_paren_level = false;\n   \
    \ bool is_opening_paren_level_closing_paren_level = false;\n    bool is_closing_paren_level_closing_paren_level\
    \ = false;\n    bool is_opening_paren_level_opening_paren_level_open = false;\n\
    \    bool is_closing_paren_level_opening_paren_level_open = false;\n    bool is_opening_paren_level_closing_paren_level_open\
    \ = false;\n    bool is_closing_paren_level_closing_paren_level_open = false;\n\
    \    bool is_opening_paren_level_opening_paren_level_close = false;\n    bool\
    \ is_closing_paren_level_opening_paren_level_close = false;\n    bool is_opening_paren_level_closing_paren_level_close\
    \ = false;\n    bool is_closing_paren_level_closing_paren_level_close = false;\n\
    \    bool is_opening_paren_level_opening_paren_level_opening = false;\n    bool\
    \ is_closing_paren_level_opening_paren_level_opening = false;\n    bool is_opening_paren_level_closing_paren_level_opening\
    \ = false;\n    bool is_closing_paren_level_closing_paren_level_opening = false;\n\
    \    bool is_opening_paren_level_opening_paren_level_closing = false;\n    bool\
    \ is_closing_paren_level_opening_paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp48vo58wr.d(56): Error: semicolon expected, not `unittest`

    /tmp/tmp48vo58wr.d(56): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp48vo58wr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing = false;\n    bool\
    \ is_opening_paren_or_closing_or_opening_or_closing = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgfv1kv1n.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpgfv1kv1n.d(41): Error: semicolon expected, not `unittest`

    /tmp/tmpgfv1kv1n.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgfv1kv1n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool has_open = false;\n    bool\
    \ has_close = false;\n    bool has_open_brace = false;\n    bool has_close_brace\
    \ = false;\n    bool has_open_paren = false;\n    bool has_close_paren = false;\n\
    \    bool has_open_curly = false;\n    bool has_close_curly = false;\n    bool\
    \ has_open_paren_or_curly = false;\n    bool has_close_paren_or_curly = false;\n\
    \    bool has_open_curly_or_curly = false;\n    bool has_close_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly = false;\n    bool has_close_paren_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_paren_or_curly_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuepxanx8.d(47): Error: semicolon expected, not `unittest`

    /tmp/tmpuepxanx8.d(47): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuepxanx8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i] ==\
    \ '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph6kq8vxb.d(14): Error: no property `length` for type `string`

    /tmp/tmph6kq8vxb.d(16): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6kq8vxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n    bool\
    \ is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n   \
    \ bool is_opening_paren_or_opening_paren_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcv00h65d.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpcv00h65d.d(42): Error: semicolon expected, not `unittest`

    /tmp/tmpcv00h65d.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv00h65d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_group = 0;\n    long\
    \ current_group = 0;\n    long current_level = 0;\n    long current_level_group\
    \ = 0;\n    bool has_opening_paren = false;\n    bool has_opening_curly_brace\
    \ = false;\n    bool has_opening_curly_brace_group = false;\n    bool has_opening_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace = false;\n\
    \    bool has_opening_curly_brace_group_with_curly_brace_group = false;\n    bool\
    \ has_opening_curly_brace_group_with_curly_brace_group_with_paren = false;\n \
    \   bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_curly_brace_group_with_paren\
    \ = false;\n    bool has_opening_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7_39byw9.d(39): Error: semicolon expected, not `unittest`

    /tmp/tmp7_39byw9.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7_39byw9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_max_index\
    \ = 0;\n    long parens_level_max_index2 = 0;\n    long parens_level_max_index3\
    \ = 0;\n    long parens_level_max_index4 = 0;\n    long parens_level_max_index5\
    \ = 0;\n    long parens_level_max_index6 = 0;\n    long parens_level_max_index7\
    \ = 0;\n    long parens_level_max_index8 = 0;\n    long parens_level_max_index9\
    \ = 0;\n    long parens_level_max_index10 = 0;\n    long parens_level_max_index11\
    \ = 0;\n    long parens_level_max_index12 = 0;\n    long parens_level_max_index13\
    \ = 0;\n    long parens_level_max_index14 = 0;\n    long parens_level_max_index15\
    \ = 0;\n    long parens_level_max_index16 = 0;\n    long parens_level_max_index17\
    \ = 0;\n    long parens_level_max_index18 = 0;\n    long parens_level_max_index19\
    \ = 0;\n    long parens_level_max_index20 = 0;\n    long parens_level_max_index21\
    \ = 0;\n    long parens_level_max_index22 = 0;\n    long parens_level_max_index23\
    \ = 0;\n    long parens_level_max_index24 = 0;\n    long parens_level_max_index25\
    \ = 0;\n    long parens_level_max_index26 = 0;\n    long parens_level_max_index27\
    \ = 0;\n    long parens_level_max_index28 = 0;\n    long parens_level_max_index29\
    \ = 0;\n    long parens_level_max_index30 = 0;\n    long parens_level_max_index31\
    \ = 0;\n    long parens_level_max_index32 = 0;\n    long parens_level_max_index33\
    \ = 0;\n    long parens_level_max_index34 = 0;\n    long parens_level_max_index35\
    \ = 0;\n    long parens_level_max_index36 = 0;\n    long parens_level_max_index37\
    \ = 0;\n    long parens_level_max_index38 = 0;\n    long parens_level_max_index39\
    \ = 0;\n    long parens_level_max_index40 = 0;\n    long parens_level_max_index41\
    \ = 0;\n    long parens_level_max_index42 = 0;\n    long parens_level_max_index43\
    \ = 0;\n    long parens_level_max_index44 = 0;\n    long parens_level_max_index45\
    \ = 0;\n    long parens_level_max_index46 = 0;\n    long parens_level_max_index47\
    \ = 0;\n    long parens_level_max_index48\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgqd1h9zi.d(67): Error: semicolon expected, not `unittest`

    /tmp/tmpgqd1h9zi.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgqd1h9zi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 1;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly = false;\n\
    \    bool is_closing_curly = false;\n    bool is_opening_square = false;\n   \
    \ bool is_closing_square = false;\n    bool is_opening_angle = false;\n    bool\
    \ is_closing_angle = false;\n    bool is_opening_comma = false;\n    bool is_closing_comma\
    \ = false;\n    bool is_opening_colon = false;\n    bool is_closing_colon = false;\n\
    \    bool is_opening_semicolon = false;\n    bool is_closing_semicolon = false;\n\
    \    bool is_opening_colon2 = false;\n    bool is_closing_colon2 = false;\n  \
    \  bool is_opening_semicolon2 = false;\n    bool is_closing_semicolon2 = false;\n\
    \    bool is_opening_colon3 = false;\n    bool is_closing_colon3 = false;\n  \
    \  bool is_opening_semicolon3 = false;\n    bool is_closing_semicolon3 = false;\n\
    \    bool is_opening_colon4 = false;\n    bool is_closing_colon4 = false;\n  \
    \  bool is_opening_semicolon4 = false;\n    bool is_closing_semicolon4 = false;\n\
    \    bool is_opening_colon5 = false;\n    bool is_closing_colon5 = false;\n  \
    \  bool is_opening_semicolon5 = false;\n    bool is_closing_semicolon5 = false;\n\
    \    bool is_opening_colon6 = false;\n    bool is_closing_colon6 = false;\n  \
    \  bool is_opening_semicolon6 = false;\n    bool is_closing_semicolon6 = false;\n\
    \    bool is_opening_colon7 = false;\n    bool is_closing_colon7 = false;\n  \
    \  bool is_opening_semicolon7 = false;\n    bool is_closing_semicolon7 = false;\n\
    \    bool is_opening_colon8 = false;\n    bool is_closing_colon8 = false;\n  \
    \  bool is_opening_semicolon8 = false;\n    bool is_closing_semicolon8 = false;\n\
    \    bool is_opening_colon9 = false;\n    bool is_closing_colon9 = false;\n  \
    \  bool is_opening_semicolon9 = false;\n    bool is_closing_semicolon9 = false;\n\
    \    bool is_opening_colon10 = false;\n    bool is_closing_colon10 = false;\n\
    \    bool is_opening_semicolon10 = false;\n    bool is_closing_semicolon10 = false;\n\
    \    bool is_opening_colon11 = false;\n    bool is_closing_colon11 = false;\n\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnxmgs3l1.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnxmgs3l1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmparqqmqic.d(63): Error: no identifier for declarator `long`

    /tmp/tmparqqmqic.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmparqqmqic.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_max_min = 0;\n\
    \    long paren_level_count_max_min_index = 0;\n    long paren_level_count_max_min_index2\
    \ = 0;\n    long paren_level_count_max_min_index3 = 0;\n    long paren_level_count_max_min_index4\
    \ = 0;\n    long paren_level_count_max_min_index5 = 0;\n    long paren_level_count_max_min_index6\
    \ = 0;\n    long paren_level_count_max_min_index7 = 0;\n    long paren_level_count_max_min_index8\
    \ = 0;\n    long paren_level_count_max_min_index9 = 0;\n    long paren_level_count_max_min_index10\
    \ = 0;\n    long paren_level_count_max_min_index11 = 0;\n    long paren_level_count_max_min_index12\
    \ = 0;\n    long paren_level_count_max_min_index13 = 0;\n    long paren_level_count_max_min_index14\
    \ = 0;\n    long paren_level_count_max_min_index15 = 0;\n    long paren_level_count_max_min_index16\
    \ = 0;\n    long paren_level_count_max_min_index17 = 0;\n    long paren_level_count_max_min_index18\
    \ = 0;\n    long paren_level_count_max_min_index19 = 0;\n    long paren_level_count_max_min_index20\
    \ = 0;\n    long paren_level_count_max_min_index21 = 0;\n    long paren_level_count_max_min_index22\
    \ = 0;\n    long paren_level_count_max_min_index23 = 0;\n    long paren_level_count_max_min_index24\
    \ = 0;\n    long paren_level_count_max_min_index25 = 0;\n    long paren_level_count_max_min_index26\
    \ = 0;\n    long paren_level_count_max_min_index27 = 0;\n    long paren_level_count_max_min_index28\
    \ = 0;\n    long paren_level_count_max_min_index29 = 0;\n    long paren_level_count_max_min_index30\
    \ = 0;\n    long paren_level_count_max_min_index31 = 0;\n    long paren_level_count_max_min_index32\
    \ = 0;\n    long paren_level_count_max_min_index33 = 0;\n    long paren_level_count_max_min_index34\
    \ = 0;\n    long paren_level_count_max_min_index35 = 0;\n    long paren_level_count_max_min_index36\
    \ = 0;\n    long paren_level_count_max_min_index37 = 0;\n    long paren_level_count_max_min_index38\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpze22jm1t.d(59): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpze22jm1t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpst4wvbo9.d(95): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpst4wvbo9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long levels_index = 0;\n    bool is_open\
    \ = false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_paren_or_closed = false;\n\
    \    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren = false;\n  \
    \  bool is_closing_paren_or_opening_paren_or_closed_or_open = false;\n    bool\
    \ is_opening_paren_or_closed_or_opening_paren_or_closed = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo1yq9y03.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpo1yq9y03.d(47): Error: semicolon expected, not `unittest`

    /tmp/tmpo1yq9y03.d(47): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo1yq9y03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp44784eda.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp44784eda.d(67): Error: semicolon expected, not `unittest`

    /tmp/tmp44784eda.d(67): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp44784eda.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4y3tauey.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp4y3tauey.d(86): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4y3tauey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_levels[]\
    \ = new long[paren_string.length()];\n    string paren_strings[] = paren_string.split(\"\
    \ \");\n    for(long i = 0; i < paren_strings.length; i++)\n    {\n        paren_levels[i]\
    \ = 0;\n        string paren_string = paren_strings[i];\n        for(long j =\
    \ 0; j < paren_string.length(); j++)\n        {\n            if(paren_string[j]\
    \ == '(')\n            {\n                paren_levels[i]++;\n            }\n\
    \            else if(paren_string[j] == ')')\n            {\n                paren_levels[i]--;\n\
    \                if(paren_levels[i] < 0)\n                {\n                \
    \    paren_levels[i] = 0;\n                }\n            }\n        }\n     \
    \   if(paren_levels[i] > max_level)\n        {\n            max_level = paren_levels[i];\n\
    \            level = i;\n        }\n    }\n    long[] result = new long[max_level\
    \ + 1];\n    result[level] = paren_string.length();\n    for(long i = 0; i < paren_strings.length;\
    \ i++)\n    {\n        string paren_string = paren_strings[i];\n        for(long\
    \ j = 0; j < paren_string.length(); j++)\n        {\n            if(paren_string[j]\
    \ == '(')\n            {\n                result[level]++;\n            }\n  \
    \          else if(paren_string[j] == ')')\n            {\n                result[level]--;\n\
    \                if(result[level] <= 0)\n                {\n                 \
    \   result[level] = 0;\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx35ks28.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] paren_levels`

    /tmp/tmpkx35ks28.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_strings`

    /tmp/tmpkx35ks28.d(17): Error: no property `length` for type `string`

    /tmp/tmpkx35ks28.d(18): Error: no property `split` for type `string`

    /tmp/tmpkx35ks28.d(22): Error: variable `paren_string` is shadowing variable `tmpkx35ks28.parse_nested_parens.paren_string`

    /tmp/tmpkx35ks28.d(23): Error: no property `length` for type `string`

    /tmp/tmpkx35ks28.d(45): Error: no property `length` for type `string`

    /tmp/tmpkx35ks28.d(48): Error: variable `paren_string` is shadowing variable `tmpkx35ks28.parse_nested_parens.paren_string`

    /tmp/tmpkx35ks28.d(49): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx35ks28.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at_index = 0;\n    long\
    \ level_at_index = 0;\n    long level_at_paren_index = 0;\n    long level_at_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_index = 0;\n    long level_at_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_index = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_index = 0;\n\
    \    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_index = 0;\n\
    \    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\
    \ = 0;\n    long level_at_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8314_kfh.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmp8314_kfh.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8314_kfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string current_paren = paren_string;\n    string next_paren = \"\";\n   \
    \ bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq5byodab.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpq5byodab.d(68): Error: no identifier for declarator `bool`

    /tmp/tmpq5byodab.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq5byodab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_open2 = false;\n    bool is_close2 =\
    \ false;\n    bool is_open3 = false;\n    bool is_close3 = false;\n    bool is_open4\
    \ = false;\n    bool is_close4 = false;\n    bool is_open5 = false;\n    bool\
    \ is_close5 = false;\n    bool is_open6 = false;\n    bool is_close6 = false;\n\
    \    bool is_open7 = false;\n    bool is_close7 = false;\n    bool is_open8 =\
    \ false;\n    bool is_close8 = false;\n    bool is_open9 = false;\n    bool is_close9\
    \ = false;\n    bool is_open10 = false;\n    bool is_close10 = false;\n    bool\
    \ is_open11 = false;\n    bool is_close11 = false;\n    bool is_open12 = false;\n\
    \    bool is_close12 = false;\n    bool is_open13 = false;\n    bool is_close13\
    \ = false;\n    bool is_open14 = false;\n    bool is_close14 = false;\n    bool\
    \ is_open15 = false;\n    bool is_close15 = false;\n    bool is_open16 = false;\n\
    \    bool is_close16 = false;\n    bool is_open17 = false;\n    bool is_close17\
    \ = false;\n    bool is_open18 = false;\n    bool is_close18 = false;\n    bool\
    \ is_open19 = false;\n    bool is_close19 = false;\n    bool is_open20 = false;\n\
    \    bool is_close20 = false;\n    bool is_open21 = false;\n    bool is_close21\
    \ = false;\n    bool is_open22 = false;\n    bool is_close22 = false;\n    bool\
    \ is_open23 = false;\n    bool is_close23 = false;\n    bool is_open24 = false;\n\
    \    bool is_close24 = false;\n    bool is_open25 = false;\n    bool is_close25\
    \ = false;\n    bool is_open26 = false;\n    bool is_close26 = false;\n    bool\
    \ is_open27 = false;\n    bool is_close27 = false;\n    bool is_open28 = false;\n\
    \    bool is_close28 = false;\n    bool is_open29 = false;\n    bool is_close29\
    \ = false;\n    bool is_open30 = false;\n    bool is_close30 = false;\n    bool\
    \ is_open31 = false;\n    bool is_close31 = false;\n    bool is_open32 = false;\n\
    \    bool is_close32 = false;\n    bool is_open33 = false;\n    bool is_close33\
    \ = false;\n    bool is_open34 = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwlt4mek6.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpwlt4mek6.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwlt4mek6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool\
    \ in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n\
    \    bool in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8\
    \ = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n    bool\
    \ in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n\
    \    bool in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16\
    \ = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n    bool\
    \ in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n\
    \    bool in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24\
    \ = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n    bool\
    \ in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n\
    \    bool in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32\
    \ = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n    bool\
    \ in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n\
    \    bool in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40\
    \ = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n    bool\
    \ in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n\
    \    bool in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48\
    \ = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n    bool\
    \ in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n\
    \    bool in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56\
    \ = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n    bool\
    \ in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n\
    \    bool in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64\
    \ = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n    bool\
    \ in_group67 = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp92qbsygd.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92qbsygd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    bool has_paren = false;\n    bool has_paren2 = false;\n    bool has_paren3\
    \ = false;\n    bool has_paren4 = false;\n    bool has_paren5 = false;\n    bool\
    \ has_paren6 = false;\n    bool has_paren7 = false;\n    bool has_paren8 = false;\n\
    \    bool has_paren9 = false;\n    bool has_paren10 = false;\n    bool has_paren11\
    \ = false;\n    bool has_paren12 = false;\n    bool has_paren13 = false;\n   \
    \ bool has_paren14 = false;\n    bool has_paren15 = false;\n    bool has_paren16\
    \ = false;\n    bool has_paren17 = false;\n    bool has_paren18 = false;\n   \
    \ bool has_paren19 = false;\n    bool has_paren20 = false;\n    bool has_paren21\
    \ = false;\n    bool has_paren22 = false;\n    bool has_paren23 = false;\n   \
    \ bool has_paren24 = false;\n    bool has_paren25 = false;\n    bool has_paren26\
    \ = false;\n    bool has_paren27 = false;\n    bool has_paren28 = false;\n   \
    \ bool has_paren29 = false;\n    bool has_paren30 = false;\n    bool has_paren31\
    \ = false;\n    bool has_paren32 = false;\n    bool has_paren33 = false;\n   \
    \ bool has_paren34 = false;\n    bool has_paren35 = false;\n    bool has_paren36\
    \ = false;\n    bool has_paren37 = false;\n    bool has_paren38 = false;\n   \
    \ bool has_paren39 = false;\n    bool has_paren40 = false;\n    bool has_paren41\
    \ = false;\n    bool has_paren42 = false;\n    bool has_paren43 = false;\n   \
    \ bool has_paren44 = false;\n    bool has_paren45 = false;\n    bool has_paren46\
    \ = false;\n    bool has_paren47 = false;\n    bool has_paren48 = false;\n   \
    \ bool has_paren49 = false;\n    bool has_paren50 = false;\n    bool has_paren51\
    \ = false;\n    bool has_paren52 = false;\n    bool has_paren53 = false;\n   \
    \ bool has_paren54 = false;\n    bool has_paren55 = false;\n    bool has_paren56\
    \ = false;\n    bool has_paren57 = false;\n    bool has_paren58 = false;\n   \
    \ bool has_paren59 = false;\n    bool has_paren60 = false;\n    bool has_paren61\
    \ = false;\n    bool has_paren62 = false;\n    bool has_paren63 = false;\n   \
    \ bool has_paren64 = false;\n    bool has_paren65 = false;\n    bool has_paren66\
    \ = false;\n    bool has_paren67 = false;\n    bool has_paren68 = false;\n\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp60ppf93z.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60ppf93z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvm0d7ucx.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpvm0d7ucx.d(79): Error: semicolon expected, not `unittest`

    /tmp/tmpvm0d7ucx.d(79): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm0d7ucx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_square = false;\n    bool in_paren_group_close_square\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_comma = false;\n    bool in_paren_group_close_comma\
    \ = false;\n    bool in_paren_group_open_colon = false;\n    bool in_paren_group_close_colon\
    \ = false;\n    bool in_paren_group_open_semicolon = false;\n    bool in_paren_group_close_semicolon\
    \ = false;\n    bool in_paren_group_open_colon2 = false;\n    bool in_paren_group_close_colon2\
    \ = false;\n    bool in_paren_group_open_semicolon2 = false;\n    bool in_paren_group_close_semicolon2\
    \ = false;\n    bool in_paren_group_open_colon3 = false;\n    bool in_paren_group_close_colon3\
    \ = false;\n    bool in_paren_group_open_semicolon3 = false;\n    bool in_paren_group_close_semicolon3\
    \ = false;\n    bool in_paren_group_open_colon4 = false;\n    bool in_paren_group_close_colon4\
    \ = false;\n    bool in_paren_group_open_semicolon4 = false;\n    bool in_paren_group_close_semicolon4\
    \ = false;\n    bool in_paren_group_open_colon5 = false;\n    bool in_paren_group_close_colon5\
    \ = false;\n    bool in_paren_group_open_semicolon5 = false;\n    bool in_paren_group_close_semicolon5\
    \ = false;\n    bool in_paren_group_open_colon6 = false;\n    bool in_paren_group_close_colon6\
    \ = false;\n    bool in_paren_group_open_semicolon6 = false;\n    bool in_paren_group_close_semicolon6\
    \ = false;\n    bool in_paren_group_open_colon7 = false;\n    bool in_paren_group_close_colon7\
    \ = false;\n    bool in_paren_group_open_semicolon7 = false;\n    bool in_paren_group_close_semicolon7\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr5y4foom.d(63): Error: no identifier for declarator `bool`

    /tmp/tmpr5y4foom.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5y4foom.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    bool has_opening_paren = false;\n \
    \   bool has_closing_paren = false;\n    bool has_opening_paren_after_closing_paren\
    \ = false;\n    bool has_closing_paren_after_opening_paren = false;\n    bool\
    \ has_opening_paren_after_closing_paren_after_opening_paren = false;\n    bool\
    \ has_closing_paren_after_closing_paren_after_opening_paren = false;\n    bool\
    \ has_closing_paren_after_closing_paren_after_closing_paren = false;\n    bool\
    \ has_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_paren\
    \ = false;\n    bool has_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_closing_paren_after_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7xlj5d1.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmpy7xlj5d1.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7xlj5d1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at_depth = 0;\n    long\
    \ level_at_depth = 0;\n    long paren_level = 0;\n    long paren_level_at_depth\
    \ = 0;\n    long paren_max_level_at_depth = 0;\n    long paren_level_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth = 0;\n    long paren_level_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth = 0;\n  \
    \  long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth = 0;\n    long\
    \ paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth = 0;\n    long\
    \ paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth = 0;\n   \
    \ long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth =\
    \ 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_max_level_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth_at_depth\
    \ = 0;\n    long paren_level_at_depth_at_depth_at_depth_at_depth_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqg8i13xp.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmpqg8i13xp.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqg8i13xp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_opener = false;\n    bool in_paren_group_closer = false;\n\
    \    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_closer_close = false;\n    bool in_paren_group_opener_close_open\
    \ = false;\n    bool in_paren_group_opener_close_close = false;\n    bool in_paren_group_closer_close_open\
    \ = false;\n    bool in_paren_group_closer_close_close = false;\n    bool in_paren_group_opener_close_opener\
    \ = false;\n    bool in_paren_group_opener_close_closer = false;\n    bool in_paren_group_closer_opener\
    \ = false;\n    bool in_paren_group_closer_closer = false;\n    bool in_paren_group_opener_close_opener_close\
    \ = false;\n    bool in_paren_group_opener_close_closer_open = false;\n    bool\
    \ in_paren_group_opener_close_closer_close = false;\n    bool in_paren_group_closer_opener_close\
    \ = false;\n    bool in_paren_group_closer_closer_open = false;\n    bool in_paren_group_closer_closer_close\
    \ = false;\n    bool in_paren_group_opener_close_opener_close_open = false;\n\
    \    bool in_paren_group_opener_close_opener_close_close = false;\n    bool in_paren_group_opener_close_closer_opener_close\
    \ = false;\n    bool in_paren_group_opener_close_closer_closer_open = false;\n\
    \    bool in_paren_group_opener_close_closer_closer_close = false;\n    bool in_paren_group_closer_opener_close_opener_close\
    \ = false;\n    bool in_paren_group_closer_opener_close_closer_open = false;\n\
    \    bool in_paren_group_closer_opener_close_closer_close = false;\n    bool in_paren_group_closer_closer_opener_close\
    \ = false;\n    bool in_paren_group_closer_closer_closer_open = false;\n    bool\
    \ in_paren_group_closer_closer_closer_close = false;\n    bool in_paren_group_opener_close_opener_close_opener_close_open\
    \ = false;\n    bool in_paren_group_opener_close_opener_close_opener_close_close\
    \ = false;\n    bool in_paren_group_opener_close_clo\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyw8o3wdz.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpyw8o3wdz.d(55): Error: semicolon expected, not `unittest`

    /tmp/tmpyw8o3wdz.d(55): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyw8o3wdz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            if(!in_paren)\n            {\n                in_paren = true;\n\
    \                level++;\n            }\n        }\n        else if(c == ')')\n\
    \        {\n            if(!in_paren)\n            {\n                in_paren\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == ' ' && in_paren)\n        {\n            levels[level] = levels[level] +\
    \ 1;\n        }\n        else if(c == ' ' && in_group)\n        {\n          \
    \  levels[level] = levels[level] + 1;\n        }\n        else if(c == '(')\n\
    \        {\n            in_group = true;\n        }\n        else if(c == ')')\n\
    \        {\n            in_group = false;\n        }\n    }\n    return levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpygb2ppue.d(14): Error: no property `length` for type `string`

    /tmp/tmpygb2ppue.d(18): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpygb2ppue.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2 =\
    \ false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5\
    \ = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n    bool\
    \ in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n\
    \    bool in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13\
    \ = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n    bool\
    \ in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n\
    \    bool in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21\
    \ = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n    bool\
    \ in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n\
    \    bool in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29\
    \ = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n    bool\
    \ in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n\
    \    bool in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37\
    \ = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n    bool\
    \ in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n\
    \    bool in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45\
    \ = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n    bool\
    \ in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n\
    \    bool in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53\
    \ = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n    bool\
    \ in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n\
    \    bool in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61\
    \ = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n    bool\
    \ in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n\
    \    bool in_group67 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0g03zkd7.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp0g03zkd7.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0g03zkd7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_cur\
    \ = 0;\n    long paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long\
    \ paren_level_max3 = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4\
    \ = 0;\n    long paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long\
    \ paren_level_cur5 = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6\
    \ = 0;\n    long paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long\
    \ paren_level_max8 = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9\
    \ = 0;\n    long paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long\
    \ paren_level_cur10 = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11\
    \ = 0;\n    long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n   \
    \ long paren_level_max13 = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14\
    \ = 0;\n    long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n   \
    \ long paren_level_cur15 = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16\
    \ = 0;\n    long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n   \
    \ long paren_level_max18 = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19\
    \ = 0;\n    long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n   \
    \ long paren_level_cur20 = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21\
    \ = 0;\n    long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n   \
    \ long paren_level_max23 = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24\
    \ = 0;\n    long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n   \
    \ long paren_level_cur25 = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26\
    \ = 0;\n    long paren_level_max27 = 0;\n    long paren_level_cur27 = 0;\n   \
    \ long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppeo1gegh.d(73): Error: semicolon expected, not `unittest`

    /tmp/tmppeo1gegh.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppeo1gegh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long last_index = 0;\n    long last_level = 0;\n   \
    \ long paren_level = 0;\n    long paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6fmy6kbh.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmp6fmy6kbh.d(21): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] paren_levels`

    /tmp/tmp6fmy6kbh.d(68): Error: no identifier for declarator `long`

    /tmp/tmp6fmy6kbh.d(68): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6fmy6kbh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26f0nl78.d(75): Error: semicolon expected, not `unittest`

    /tmp/tmp26f0nl78.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26f0nl78.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164143
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma = false;\n    bool in_paren_group_open_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpry_tgmc0.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpry_tgmc0.d(42): Error: semicolon expected, not `unittest`

    /tmp/tmpry_tgmc0.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpry_tgmc0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164144
