language: d
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for(int i = 0; i < words.length; ++i)\n\
    \        m[words[i]] = 1;\n    for(int i = 0; i < words.length; ++i)\n    {\n\
    \        int max = 0;\n        for(int j = 0; j < words.length; ++j)\n       \
    \     if(m[j] > 0 && words[j] == words[i])\n                ++m[words[j]];\n \
    \           else\n                max = max(max, m[j]);\n        if(max > 0)\n\
    \            return words[i];\n    }\n    return words[0];\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nI believe this solution is O(n^2) because of the nested\
    \ loops.\n<|/ c |>\n<| c |>\nYes, but this is only a problem if there are many\
    \ words in the list. Otherwise the complexity is O(n).\n<|/ c |>\n<| c |>\nI believe\
    \ this solution is O(n^2) because of the nested loops.\n<|/ c |>\n<| c |>\nYes,\
    \ but this is only a problem if there are many words in the list. Otherwise the\
    \ complexity is O(n).\n<|/ c |>\n<| c |>\nI believe this solution is O(n^2) because\
    \ of the nested loops.\n<|/ c |>\n<| a tags=algorithm,string,c++ |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\
    using namespace std;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoypz4ovj.d(19): Error: found `>` when expecting `.` following
    int\n/tmp/tmpoypz4ovj.d(35): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpoypz4ovj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach (string\
    \ word in words)\n    {\n        int uniqueChars = count(word);\n        if (uniqueChars\
    \ > max)\n        {\n            max = uniqueChars;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,c#,string\
    \ |>\n<code>\nstring find_max(string[] words) \n{\n    int max = 0;\n    string\
    \ maxWord = \"\";\n    foreach (string word in words)\n    {\n        int uniqueChars\
    \ = count(word);\n        if (uniqueChars > max)\n        {\n            max =\
    \ uniqueChars;\n            maxWord = word;\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach (string\
    \ word in words)\n    {\n        int uniqueChars = count(word);\n        if (uniqueChars\
    \ > max)\n        {\n            max = uniqueChars;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=algorithm,c#,string\
    \ |>\n<| a |>\n<code>\nstring find_max(string[] words) \n{\n    int max = 0;\n\
    \    string maxWord = \"\";\n    foreach (string word in words)\n    {\n     \
    \   int uniqueChars = count(word);\n        if (uniqueChars > max)\n        {\n\
    \            max = uniqueChars;\n            maxWord = word;\n        }\n    }\n\
    \    return maxWord;\n}\n</code>\n<|/ a tags=algorithm,c#,string dscore=1 |>\n\
    <| a tags=algorithm,c#,string |>\n<code>\nstring find_max(string[] words) \n{\n\
    \    int max = 0;\n    string maxWord = \"\";\n    foreach (string word in words)\n\
    \    {\n        int uniqueChars = count(word);\n        if (uniqueChars > max)\n\
    \        {\n            max = uniqueChars;\n            maxWord = word;\n    \
    \    }\n    }\n    return maxWord;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nstring find_max(string[] words) \n{\n    int max = 0;\n    string\
    \ maxWord = \"\";\n    foreach (string word in words)\n    {\n        int uniqueChars\
    \ = count(word);\n        if (uniqueChars > max)\n        {\n            max =\
    \ uniqueChars;\n            maxWord = word;\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt8pw_lvf.d(21): Error: found `in` when expecting `;`\n/tmp/tmpt8pw_lvf.d(32):
    Error: declaration expected, not `<`\n/tmp/tmpt8pw_lvf.d(40): Error: declaration
    expected, not `foreach`\n/tmp/tmpt8pw_lvf.d(43): Error: declaration expected,
    not `if`\n/tmp/tmpt8pw_lvf.d(46): Error: no identifier for declarator `maxWord`\n/tmp/tmpt8pw_lvf.d(46):
    Error: declaration expected, not `=`\n/tmp/tmpt8pw_lvf.d(47): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt8pw_lvf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    map<string, int>::iterator it;\n  \
    \  int max = 0;\n    string maxWord = \"\";\n    \n    for(int i = 0; i < words.length;\
    \ i++)\n    {\n        it = m.find(words[i]);\n        if(it != m.end())\n   \
    \     {\n            if(it->second > max)\n            {\n                max\
    \ = it->second;\n                maxWord = words[i];\n            }\n        }\n\
    \        else\n        {\n            m[words[i]] = 1;\n        }\n    }\n   \
    \ return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpttt8sffm.d(19): Error: found `>` when expecting `.` following
    int\n/tmp/tmpttt8sffm.d(20): Error: found `>` when expecting `.` following int\n/tmp/tmpttt8sffm.d(20):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpttt8sffm.d(20):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpttt8sffm.d(29):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpttt8sffm.d(31): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttt8sffm.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    for(int i = 0;\
    \ i < words.length; i++)\n    {\n        int count = 0;\n        for(int j = 0;\
    \ j < words[i].length(); j++)\n        {\n            count += std.count[words[i][j]];\n\
    \        }\n        if(count > max)\n        {\n            max = count;\n   \
    \         maxWord = words[i];\n        }\n    }\n    return maxWord;\n}\n</code>\n\
    <|/ a tags=c++,string,algorithm |>\n<| c |>\nThis doesn't work if there are two\
    \ words with the same number of unique characters. For example, `find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c\
    \ |>\n<| c |>\nYes, I forgot to add that case. Thanks for pointing out.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if there are two words with the same number of\
    \ unique characters. For example, `find_max([\"aaaaaaa\", \"bb\", \"cc\"])` returns\
    \ `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c |>\nI added a solution for\
    \ that case too.\n<|/ c |>\n<| c |>\nThis doesn't work if there are two words\
    \ with the same number of unique characters. For example, `find_max([\"aaaaaaa\"\
    , \"bb\", \"cc\"])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| a\
    \ dscore=1 |>\n<code>\n#include <iostream>\n#include <string>\n#include <vector>\n\
    #include <algorithm>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbphh6s93.d(36): Error: declaration expected, not `<`\n/tmp/tmpbphh6s93.d(39):
    Error: unterminated character constant\n/tmp/tmpbphh6s93.d(45): Error: unterminated
    character constant\n/tmp/tmpbphh6s93.d(51): Error: unterminated character constant\n/tmp/tmpbphh6s93.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpbphh6s93.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpbphh6s93.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpbphh6s93.d(66): Error: declaration expected, not `assert`\n/tmp/tmpbphh6s93.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpbphh6s93.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpbphh6s93.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmpbphh6s93.d(70): Error: declaration expected, not `assert`\n/tmp/tmpbphh6s93.d(71):
    Error: declaration expected, not `assert`\n/tmp/tmpbphh6s93.d(72): Error: declaration
    expected, not `assert`\n/tmp/tmpbphh6s93.d(73): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbphh6s93.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for(int i = 0; i < words.length; ++i)\n\
    \        m[words[i]] = 1;\n    for(int i = 0; i < words.length; ++i)\n    {\n\
    \        for(int j = i+1; j < words.length; ++j)\n        {\n            if(m[words[i]]\
    \ > m[words[j]])\n            {\n                m[words[i]] = m[words[j]];\n\
    \                m[words[j]] = words[i];\n            }\n        }\n    }\n  \
    \  string result = \"\";\n    for(auto it = m.begin(); it != m.end(); ++it)\n\
    \    {\n        if(it->second > 1)\n        {\n            result = it->second;\n\
    \            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8sg3xryj.d(19): Error: found `>` when expecting `.` following
    int\n/tmp/tmp8sg3xryj.d(36): Error: use `.` for member lookup, not `->`\n/tmp/tmp8sg3xryj.d(38):
    Error: use `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8sg3xryj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach (string\
    \ word in words) {\n        int count = std.collections.count(word);\n       \
    \ if (count > max) {\n            max = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=string,c#,algorithm\
    \ |>\n<| a tags=string,c#,algorithm |>\n<code>\npublic static string FindMax(string\
    \ input)\n{\n    char[] chars = input.ToCharArray();\n    Array.Sort(chars);\n\
    \    return chars.Aggregate((a, b) => a + b);\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if you have duplicate characters in the string\n<|/\
    \ c |>\n<| c |>\n: It does work if you have duplicate characters in the string.\
    \ `Aggregate` will return the character with the highest ASCII value when there\
    \ are multiple characters with the same ASCII value.\n<|/ c |>\n<| c |>\n: It\
    \ does work if you have duplicate characters in the string. `Aggregate` will return\
    \ the character with the highest ASCII value when there are multiple characters\
    \ with the same ASCII value.\n<|/ c |>\n<| c |>\n: It does work if you have duplicate\
    \ characters in the string. `Aggregate` will return the character with the highest\
    \ ASCII value when there are multiple characters with the same ASCII value.\n\
    <|/ c |>\n<| c |>\n: It does work if you have duplicate characters in the string.\
    \ `Aggregate` will return the character with the highest ASCII value when there\
    \ are multiple characters with the same ASCII value.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nstring FindMax(string input)\n{\n    char[] chars = input.ToCharArray();\n\
    \    Array.Sort(chars);\n    return chars.Aggregate((a, b) => a + b);\n}\n</code>\n\
    <|/ a tags=string,c#,algorithm |>\n<| a tags=string,c#,algorithm |>\n<code>\n\
    string FindMax(string input)\n{\n    char[] chars = input.ToCharArray();\n   \
    \ Array.Sort(chars);\n    return chars.Aggregate((a, b) => a + b);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=string,c#,algorithm |>\n<code>\nstring FindMax(string\
    \ input)\n{\n    char[] chars = input.ToCharArray();\n    Array.Sort(chars);\n\
    \    return chars.Aggregate((a, b) => a + b);\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw7doeukt.d(21): Error: found `in` when expecting `;`\n/tmp/tmpw7doeukt.d(30):
    Error: declaration expected, not `<`\n/tmp/tmpw7doeukt.d(37): Error: function
    declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpw7doeukt.d(37):
    Error: no identifier for declarator `Array.Sort(chars)`\n/tmp/tmpw7doeukt.d(38):
    Error: declaration expected, not `return`\n/tmp/tmpw7doeukt.d(39): Error: unrecognized
    declaration\n/tmp/tmpw7doeukt.d(43): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7doeukt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach (string\
    \ word in words) {\n        int unique = count(word);\n        if (unique > max)\
    \ {\n            max = unique;\n            maxWord = word;\n        }\n    }\n\
    \    return maxWord;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThe question\
    \ was tagged C++, so why not use STL?\n<|/ c |>\n<| c |>\nBecause I didn't know\
    \ about STL. I'm still learning C++.\n<|/ c |>\n<| c |>\nI guess you mean `std::sort`\
    \ instead of `std::sort`\n<|/ c |>\n<| c |>\nYes, I meant std::sort. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| c |>\nI guess you meant `std::sort` instead of\
    \ `std::sort`. Thanks for pointing it out.\n<|/ c |>\n<| a |>\n<code>\n#include\
    \ <iostream>\n#include <vector>\n#include <algorithm>\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk1j8br0u.d(21): Error: found `in` when expecting `;`\n/tmp/tmpk1j8br0u.d(30):
    Error: declaration expected, not `<`\n/tmp/tmpk1j8br0u.d(36): Error: unterminated
    character constant\n/tmp/tmpk1j8br0u.d(36): Error: unterminated character constant\n/tmp/tmpk1j8br0u.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpk1j8br0u.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpk1j8br0u.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpk1j8br0u.d(59): Error: declaration expected, not `assert`\n/tmp/tmpk1j8br0u.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpk1j8br0u.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpk1j8br0u.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpk1j8br0u.d(63): Error: declaration expected, not `assert`\n/tmp/tmpk1j8br0u.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpk1j8br0u.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpk1j8br0u.d(66): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk1j8br0u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int index = 0;\n    for(int i = 0; i < words.length;\
    \ i++){\n        int count = 0;\n        for(int j = 0; j < words[i].length();\
    \ j++){\n            if(words[i][j] == words[i][j]){\n                count++;\n\
    \            }\n        }\n        if(count > max){\n            max = count;\n\
    \            index = i;\n        }\n    }\n    return words[index];\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\nusing namespace std;\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_g3lqcfp.d(35): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_g3lqcfp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    for(int i = 0;\
    \ i < words.length; i++)\n    {\n        int count = 0;\n        for(int j = 0;\
    \ j < words[i].length(); j++)\n        {\n            count += std.string.length(words[i].charAt(j));\n\
    \        }\n        if(count > max)\n        {\n            max = count;\n   \
    \         maxWord = words[i];\n        }\n    }\n    return maxWord;\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if the words are\
    \ in reverse order.\n<|/ c |>\n<| c |>\nIt does work. Try it out with these inputs:\n\
    `find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"\
    string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\"\
    , \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"\
    ])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n\
    `find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"\
    string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\"\
    , \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"\
    ])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n\
    `find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"\
    string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\"\
    , \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"\
    ])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n\
    `find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"\
    string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\"\
    , \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"\
    ])`\n`find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n\
    `find_max([\"string\", \"name\"])`\n`find_max([\"string\", \"name\"])`\n`find_\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg_f7kv6d.d(36): Error: declaration expected, not `<`\n/tmp/tmpg_f7kv6d.d(39):
    Error: unterminated character constant\n/tmp/tmpg_f7kv6d.d(81): Error: unterminated
    string constant starting at /tmp/tmpg_f7kv6d.d(81)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpg_f7kv6d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    for(int i = 0;\
    \ i < words.length; i++){\n        int count = 0;\n        for(int j = 0; j <\
    \ words[i].length(); j++){\n            count += std.string.length(words[i].charAt(j));\n\
    \        }\n        if(count > max){\n            max = count;\n            maxWord\
    \ = words[i];\n        }\n    }\n    return maxWord;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9zym8495.d(23): Error: no property `length` for type `string`\n/tmp/tmp9zym8495.d(24):
    Error: undefined identifier `string` in package `std`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp9zym8495.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for(int i = 0; i < words.length; i++)\
    \ \n    {\n        m[words[i]] = 1;\n    }\n    for(int i = 0; i < words.length;\
    \ i++) \n    {\n        for(int j = 0; j < words.length; j++) \n        {\n  \
    \          if(words[i] == words[j]) \n            {\n                m[words[i]]++;\n\
    \            }\n        }\n    }\n    string max = \"\";\n    int maxCount = 0;\n\
    \    for(auto it: m) \n    {\n        if(it.second > maxCount) \n        {\n \
    \           max = it.first;\n            maxCount = it.second;\n        }\n  \
    \  }\n    return max;\n}\n</code>\n<|/ a tags=c++,algorithm,string |>\n<| c |>\n\
    This doesn't work. Try it with `find_max([\"aaaaaaa\", \"bb\", \"cc\"])`.\n<|/\
    \ c |>\n<| c |>\nI didn't test the code. Just wrote it on the fly. Thanks for\
    \ pointing out my mistake.\n<|/ c |>\n<| c |>\nThis code does not work. Try it\
    \ with `find_max([\"aaaaaaa\", \"bb\", \"cc\"])`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. I've tested it before posting the answer. I've also added a test case\
    \ to the answer.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])`.\n<|/ c |>\n<| a tags=c++,algorithm,string |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb4o89opl.d(19): Error: found `>` when expecting `.` following
    int\n/tmp/tmpb4o89opl.d(36): Error: no identifier for declarator `it`\n/tmp/tmpb4o89opl.d(36):
    Error: expression expected, not `:`\n/tmp/tmpb4o89opl.d(36): Error: found `m`
    when expecting `;` following `for` condition\n/tmp/tmpb4o89opl.d(46): Error: declaration
    expected, not `<`\n/tmp/tmpb4o89opl.d(49): Error: unterminated character constant\n/tmp/tmpb4o89opl.d(52):
    Error: unterminated character constant\n/tmp/tmpb4o89opl.d(58): Error: unterminated
    character constant\n/tmp/tmpb4o89opl.d(58): Error: unterminated character constant\n/tmp/tmpb4o89opl.d(61):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpb4o89opl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach(string\
    \ word in words) {\n        int count = std.collections.count(word);\n       \
    \ if(count > max) {\n            max = count;\n            maxWord = word;\n \
    \       }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=string,c#,sorting\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using LINQ?\n<|/ c |>\n<| c |>\nI added a solution without LINQ\n<|/ c |>\n\
    <| c |>\nI added a solution without LINQ\n<|/ c |>\n<| a tags=string,c#,sorting\
    \ |>\n<code>\nstring FindMax(string [] words)\n{\n    string maxWord = \"\";\n\
    \    foreach(string word in words)\n    {\n        int count = words.Count(x =>\
    \ x == word);\n        if(count > maxWord.Length)\n        {\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using LINQ?\n<|/ c |>\n<| c |>\nI added a solution without LINQ\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nstring FindMax(string [] words)\n{\n    string maxWord\
    \ = \"\";\n    foreach(string word in words)\n    {\n        int count = words.Count(x\
    \ => x == word);\n        if(count > maxWord.Length)\n        {\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=string,c#,sorting\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using LINQ?\n<|/ c |>\n<| c |>\nI added a solution without LINQ\n<|/ c |>\n\
    <| a tags=string,c#,sorting |>\n<code>\nstring FindMax(string [] words)\n{\n \
    \   string maxWord = \"\";\n    foreach(string word in words)\n    {\n       \
    \ int count = words.Count(x => x == word);\n        if(count > maxWord.Length)\n\
    \        {\n            maxWord = word;\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,c#,sorting |>\n<code>\nstring\
    \ FindMax(string [] words)\n{\n    string maxWord = \"\";\n\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_zwp6gi2.d(21): Error: found `in` when expecting `;`\n/tmp/tmp_zwp6gi2.d(30):
    Error: declaration expected, not `<`\n/tmp/tmp_zwp6gi2.d(46): Error: declaration
    expected, not `foreach`\n/tmp/tmp_zwp6gi2.d(49): Error: declaration expected,
    not `if`\n/tmp/tmp_zwp6gi2.d(52): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_zwp6gi2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach (string\
    \ word in words) {\n        int count = count(word);\n        if (count > max)\
    \ {\n            max = count;\n            maxWord = word;\n        }\n    }\n\
    \    return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkjrx12oz.d(21): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjrx12oz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach(string\
    \ word in words)\n    {\n        int count = count(word);\n        if(count >\
    \ max)\n        {\n            max = count;\n            maxWord = word;\n   \
    \     }\n    }\n    return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkiu3na14.d(21): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkiu3na14.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    for(int i = 0;\
    \ i < words.length; i++){\n        int count = 0;\n        for(int j = 0; j <\
    \ words[i].length(); j++){\n            count += std.string.length(words[i][j]);\n\
    \        }\n        if(count > max){\n            max = count;\n            maxWord\
    \ = words[i];\n        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpamqxk055.d(33): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpamqxk055.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for(int i = 0; i < words.length; ++i)\n\
    \        m[words[i]] = 1;\n    for(int i = 0; i < words.length; ++i)\n    {\n\
    \        int c = words[i].length();\n        for(int j = 0; j < words.length;\
    \ ++j)\n        {\n            int d = words[j].length();\n            if(c <\
    \ d)\n            {\n                string tmp = words[i];\n                words[i]\
    \ = words[j];\n                words[j] = tmp;\n            }\n        }\n   \
    \ }\n    map<string, int>::iterator it;\n    string max;\n    for(it = m.begin();\
    \ it != m.end(); ++it)\n    {\n        if(it->second > 1)\n        {\n       \
    \     max = it->first;\n            break;\n        }\n    }\n    return max;\n\
    }\n</code>\n<|/ a tags=algorithm,string,c++ |>\n<| c |>\nThis doesn't work. Try\
    \ it with `find_max([\"aaaaaaa\", \"bb\", \"cc\"])`.\n<|/ c |>\n<| c |>\n: I see\
    \ what you mean. Fixed.\n<|/ c |>\n<| c |>\n: I added a version that works with\
    \ your test cases. I tested it on ideone.\n<|/ c |>\n<| c |>\n: I added a version\
    \ that works with your test cases. I tested it on ideone.\n<|/ c |>\n<| c |>\n\
    : I added a version that works with your test cases. I tested it on ideone.\n\
    <|/ c |>\n<| a tags=algorithm,string,c++ |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpik9dozpy.d(19): Error: found `>` when expecting `.` following
    int\n/tmp/tmpik9dozpy.d(36): Error: found `>` when expecting `.` following int\n/tmp/tmpik9dozpy.d(36):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpik9dozpy.d(36):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpik9dozpy.d(40):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpik9dozpy.d(42): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpik9dozpy.d(48): Error: declaration expected,
    not `<`\n/tmp/tmpik9dozpy.d(51): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpik9dozpy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    foreach (string\
    \ word in words) {\n        int count = std.collections.count(word);\n       \
    \ if (count > max) {\n            max = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=string,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work if there are multiple strings with the same number\
    \ of unique characters. For example, `find_max([\"aaaaaaa\", \"bb\", \"cc\"])`\
    \ returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c |>\nYes, you are\
    \ right. I've updated the answer with another solution.\n<|/ c |>\n<| a tags=string,c#,algorithm\
    \ |>\n<code>\nstring FindMax(string s)\n{\n    Dictionary<char, int> charCount\
    \ = new Dictionary<char, int>();\n    foreach (char c in s)\n    {\n        if\
    \ (!charCount.ContainsKey(c))\n        {\n            charCount.Add(c, 1);\n \
    \       }\n        else\n        {\n            charCount[c]++;\n        }\n \
    \   }\n    string maxChar = charCount.OrderByDescending(x => x.Value).First().Key;\n\
    \    foreach (char c in maxChar)\n    {\n        if (!charCount.ContainsKey(c))\n\
    \        {\n            charCount.Add(c, 1);\n        }\n        else\n      \
    \  {\n            charCount[c]++;\n        }\n    }\n    string maxChar2 = charCount.OrderByDescending(x\
    \ => x.Value).First().Key;\n    if (maxChar == maxChar2)\n    {\n        return\
    \ maxChar;\n    }\n    else\n    {\n        return maxChar2;\n    }\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>\nstring FindMax(string s)\n{\n    Dictionary<char,\
    \ int> charCount = new Dictionary<char, int>();\n    foreach (char c in s)\n \
    \   {\n        if (!charCount.ContainsKey(c))\n        {\n            charCount.Add(c,\
    \ 1);\n        }\n        else\n        {\n            charCount[c]++;\n     \
    \   }\n    }\n    string maxChar = charCount.OrderByDescending(x => x.Value).First().Key;\n\
    \    foreach (char c in maxChar)\n    {\n        if (!charCount.ContainsKey(c))\n\
    \        {\n            charCount.Add(c, 1);\n        }\n        else\n      \
    \  {\n            charCount[c]++;\n        }\n    }\n    string maxChar2 = charCount.OrderByDescending(\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9il30_i4.d(21): Error: found `in` when expecting `;`\n/tmp/tmp9il30_i4.d(30):
    Error: declaration expected, not `<`\n/tmp/tmp9il30_i4.d(33): Error: unterminated
    character constant\n/tmp/tmp9il30_i4.d(36): Error: unterminated character constant\n/tmp/tmp9il30_i4.d(43):
    Error: declaration expected, not `foreach`\n/tmp/tmp9il30_i4.d(48): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9il30_i4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = \"\";\n    for(int i = 0;\
    \ i < words.length; i++)\n    {\n        for(int j = 0; j < words[i].length();\
    \ j++)\n        {\n            if(words[i].length() > max)\n            {\n  \
    \              max = words[i].length();\n                maxWord = words[i];\n\
    \            }\n        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=string,c++,arrays\
    \ |>\n<| c |>\nThis code does not compile. `string` does not have a member function\
    \ `length()`.\n<|/ c |>\n<| c |>\nIt compiles fine for me. I'm using Visual Studio\
    \ 2015.\n<|/ c |>\n<| c |>\nIt compiles fine for me too. I'm using Visual Studio\
    \ 2015.\n<|/ c |>\n<| c |>\nIt compiles fine for me too. I'm using Visual Studio\
    \ 2015.\n<|/ c |>\n<| c |>\nIt compiles fine for me too. I'm using Visual Studio\
    \ 2015.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <vector>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n \
    \   alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc_l_9abz.d(34): Error: declaration expected, not `<`\n/tmp/tmpc_l_9abz.d(40):
    Error: unterminated character constant\n/tmp/tmpc_l_9abz.d(43): Error: unterminated
    character constant\n/tmp/tmpc_l_9abz.d(46): Error: unterminated character constant\n/tmp/tmpc_l_9abz.d(49):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpc_l_9abz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for(int i = 0; i < words.length; ++i)\n\
    \        m[words[i]] = 1;\n    for(int i = 0; i < words.length; ++i)\n    {\n\
    \        for(int j = i+1; j < words.length; ++j)\n        {\n            if(m[words[i]]\
    \ > m[words[j]])\n            {\n                m[words[i]] = m[words[j]];\n\
    \                m[words[j]] = words[i];\n            }\n        }\n    }\n  \
    \  string max = \"\";\n    for(auto it = m.begin(); it != m.end(); ++it)\n   \
    \ {\n        if(it->second > 0)\n            max = it->second;\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c |>\nI like your solution,\
    \ although it can be optimized a little bit more. Instead of sorting the map by\
    \ value, you can sort it by key (alphabetically) and then iterate over the map\
    \ and find the max value. This will save you a lot of time when there are many\
    \ words with the same number of unique characters.\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. I was thinking about this solution too, but I didn't want to change\
    \ the code too much. Thanks for your suggestion.\n<|/ c |>\n<| c |>\nI added an\
    \ optimized solution to the answer. Thanks for your suggestion.\n<|/ c |>\n<|\
    \ a tags=algorithm,c++ |>\nThe simplest solution is to use std::map and std::max_element:\n\
    <code>\n#include <map>\n#include <algorithm>\n#include <iostream>\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp30sv9b1y.d(19): Error: found `>` when expecting `.` following
    int\n/tmp/tmp30sv9b1y.d(36): Error: use `.` for member lookup, not `->`\n/tmp/tmp30sv9b1y.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp30sv9b1y.d(41): Error: declaration
    expected, not `<`\n/tmp/tmp30sv9b1y.d(47): Error: unterminated character constant\n/tmp/tmp30sv9b1y.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmp30sv9b1y.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmp30sv9b1y.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmp30sv9b1y.d(65): Error: declaration expected, not `assert`\n/tmp/tmp30sv9b1y.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmp30sv9b1y.d(67): Error: declaration
    expected, not `assert`\n/tmp/tmp30sv9b1y.d(68): Error: declaration expected, not
    `assert`\n/tmp/tmp30sv9b1y.d(69): Error: declaration expected, not `assert`\n/tmp/tmp30sv9b1y.d(70):
    Error: declaration expected, not `assert`\n/tmp/tmp30sv9b1y.d(71): Error: declaration
    expected, not `assert`\n/tmp/tmp30sv9b1y.d(72): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp30sv9b1y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nWrite a function that accepts\
    \ a list of strings.\n    The list contains different words. Return the word with\
    \ maximum number\n    of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int index = 0;\n    for(int i = 0; i < words.length;\
    \ i++){\n        for(int j = 0; j < words[i].length(); j++){\n            if(words[i].length()\
    \ > max){\n                max = words[i].length();\n                index = i;\n\
    \            }\n        }\n    }\n    return words[index];\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6bg9kelw.d(31): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6bg9kelw.d", "-I/tmp"]\n'''
  stdout: b''
