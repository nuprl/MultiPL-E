name: HumanEval_87_get_row
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
  \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
  \    each row may contain a different number of columns.\n    Given lst, and integer\
  \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
  \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
  \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
  \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L,\
  \ 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
  \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
  \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
  \ lst, long x) \n"
tests: "unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
  \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
  \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
  \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L,\
  \ 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L,\
  \ 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L),\
  \ tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]],\
  \ 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L,\
  \ 2L)]);\n}\nvoid main(){}"
completions: ["{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length]\
    \ = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n    \n   \
    \ return res;\n}", "{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ sort(res);\n    \n    return res;\n}", "{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = j;\n                res[i + 1]\
    \ = i;\n                return Tuple!(long, long)[](res);\n            }\n   \
    \     }\n    }\n    return Tuple!(long, long)[](res);\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    \n    foreach(i -> foreach(j -> {\n        if (lst[i][j]\
    \ == x) {\n            result ~= Tuple!(i, j);\n        }\n    }), range(0, size(lst)));\n\
    \    \n    sort(result, (a, b) => a.first > b.first ? 1 : a.first < b.first ?\
    \ -1 : 0);\n    sort(result, (a, b) => a.second > b.second ? 1 : a.second < b.second\
    \ ? -1 : 0);\n    \n    return result;\n}", "{\n    Tuple!(long, long)[] result\
    \ = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i].length == x)\n        {\n            for(int j = 0;\
    \ j < lst[i].length; j++)\n            {\n                if(lst[i][j] == x)\n\
    \                {\n                    result.add(Tuple!(i, j));\n          \
    \      }\n            }\n        }\n    }\n    \n    result.sort(function(a, b){return\
    \ a.first > b.first;});\n    result.sort(function(a, b){return a.second > b.second;});\n\
    \    \n    return result;\n}", "{\n    Tuple!(long, long)[] res;\n    \n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n\
    \                break;\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, descending);\n    \n    return res;\n}", "{\n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if\
    \ (lst[i][j] == x) \n            res[res.length] = Tuple!(i, j);\n    }), 0 ..\
    \ lst.length - 1);\n    sort(res);\n    sort(res, (a, b) -> -cmp(a.i, b.i));\n\
    \    return res;\n}", "{\n    Tuple!(long, long)[] res = null;\n    foreach(i\
    \ : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n       \
    \ {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long,\
    \ long)[](Tuple!(0, i), Tuple!(0, j));\n                break;\n            }\n\
    \        }\n        if(res != null)\n            break;\n    }\n    return res;\n\
    }", "{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(row:\
    \ lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x)\
    \ \n            {\n                res.push(Tuple!(long, long)((row, col)));\n\
    \            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) =>\
    \ a.first > b.first);\n    \n    return res;\n}", "{\n    Tuple!(long, long)[]\
    \ res = null;\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row, col);\n                break;\n            }\n        }\n     \
    \   if(res != null)\n            break;\n    }\n    \n    return res;\n}", "{\n\
    \    Tuple!(long, long)[] res;\n    for(int i = 0; i < lst.length; i++){\n   \
    \     if(lst[i][0] == x){\n            Tuple!(long, long)[] temp = new Tuple!(long,\
    \ long)[];\n            for(int j = 0; j < lst[i].length; j++){\n            \
    \    if(lst[i][j] == x){\n                    temp.add(new Tuple!(j, i));\n  \
    \              }\n            }\n            res = temp;\n        }\n    }\n \
    \   return res;\n}", "{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst)\
    \ \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    \n    return res;\n}",
  "{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    \n    return res;\n}", "{\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j\
    \ = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n  \
    \          {\n                res.push(Tuple!(i, j));\n            }\n       \
    \ }\n    }\n    return res;\n}", "{\n    Tuple!(long, long)[] result = new Tuple!(long,\
    \ long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n\
    \        {\n            if(col == x) \n            {\n                result.add(Tuple!(long,\
    \ long)(0, col));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) \n    {\n        return a.1 < b.1;\n    });\n    \n    result.sort(function(a,\
    \ b) \n    {\n        return a.2 < b.2;\n    });\n    \n    return result;\n}",
  "{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, i: 0) {\n      \
    \  foreach(col: row, j: 0) {\n            if(col == x) {\n                res\
    \ = Tuple!(long, long)[i, j];\n            }\n        }\n    }\n    \n    return\
    \ res;\n}", "{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {Tuple!(i +\
    \ 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][j])\n\
    \                {\n                    Tuple!(long, long)[] tuple2 = new Tuple!(long,\
    \ long)[] {Tuple!(i, k)};\n                    foreach(l -> {\n              \
    \          if(lst[k][l] > lst[i][j])\n                        {\n            \
    \                tuple2.push(Tuple!(l, k));\n                        }\n     \
    \               });\n                    tuple.push(tuple2);\n               \
    \ }\n            });\n            result.push(tuple);\n        }\n    }), range(0,\
    \ lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] ==\
    \ x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[]\
    \ {Tuple!(i + 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k]\
    \ > lst[i][j])\n                {\n                    Tuple!(long, long)[] tuple2\
    \ = new Tuple!(long, long)[] {Tuple!(i, k)};\n                    foreach(l ->\
    \ {\n                        if(lst[k][l] > lst[i][j])\n                     \
    \   {\n                            tuple2.push(Tuple!(l, k));\n              \
    \          }\n                    });\n                    tuple.push(tuple2);\n\
    \                }\n            });\n            result.push(tuple);\n       \
    \ }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n \
    \       if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple\
    \ = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k ->\
    \ {\n                if(lst[i][k] > lst[i][j])\n                {\n          \
    \          Tuple!(long, long)[] tuple2 = new Tuple!(long, long)[] {Tuple!(i, k)};\n\
    \                    foreach(l -> {\n                        if(lst[k][l] > lst[i][j])\n\
    \                        {\n                            tuple2.push(Tuple!(l,\
    \ k));\n                        }\n                    });\n                 \
    \   tuple.push(tuple2);\n                }\n            });\n            result.push(tuple);\n\
    \        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j ->\
    \ {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple\
    \ = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k ->\
    \ {\n                if(lst[i][k] > lst[i][j])\n                {\n          \
    \          Tuple!(long, long)[] tuple2 = new Tuple!(long, ", "{\n    Tuple!(long,\
    \ long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j\
    \ : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n         \
    \   {\n                Tuple!(long, long)[] coord = Tuple!(i, j);\n          \
    \      \n                if(coord.x < 0)\n                    coord.x += lst[i].length;\n\
    \                if(coord.y < 0)\n                    coord.y += lst[0].length;\n\
    \                \n                res.push(coord);\n            }\n        }\n\
    \    }\n    \n    return res;\n}", "{\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[];\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i\
    \ == 0)\n            {\n                foreach(k -> \n                {\n   \
    \                 if(lst[i][j] == x)\n                    {\n                \
    \        res.add((i, j));\n                    }\n                });\n      \
    \      }\n            else\n            {\n                foreach(k -> \n   \
    \             {\n                    if(lst[i][j] == x)\n                    {\n\
    \                        res.add((i, j));\n                    }\n           \
    \     });\n            }\n        }), range(0, lst.length));\n    \n    sort(res);\n\
    \    \n    return res;\n}", "{\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[];\n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n\
    \            if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    sort(res,fun(x1,x2)\
    \ -> x1.1 > x2.1);\n    sort(res,fun(x1,x2) -> x1.2 > x2.2);\n    return res;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
