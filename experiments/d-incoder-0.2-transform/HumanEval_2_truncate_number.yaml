name: HumanEval_2_truncate_number
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating point\
  \ number, it can be decomposed into\n    and integer part (largest integer smaller\
  \ than given number) and decimals\n    (leftover part always smaller than 1).\n\n\
  \    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n\
  \    \n*/\nfloat truncate_number(float number) \n"
tests: "unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
  \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) ==\
  \ 0.0);\n}\nvoid main(){}"
completions: ["{\n    float remainder;\n    int integer_part;\n    float decimal_part;",
  "{\n    float remainder;\n    float quotient;\n    float decimals;\n    float result;",
  "{\n    float remainder;\n    int integerPart;\n    \n    integerPart = int(number);\n\
    \    remainder = number - integerPart;\n    \n    return remainder;\n}", "{\n\
    \    long long int int_part;\n    long long int decimal_part;\n    \n    int_part\
    \ = trunc(number);\n    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }", "{\n    float remainder;\n    int integerPart;\n    \n    integerPart = int(number);\n\
    \    remainder = number - integerPart;\n    \n    return remainder;\n}\n/*\n Given\
    \ a positive floating point number, it can be decomposed into\n    and integer\
    \ part (largest integer smaller than given number) and decimals\n    (leftover\
    \ part always smaller than 1).", "{\n    int int_part;\n    float frac_part =\
    \ number - truncate_number(number);\n    \n    int_part = int(frac_part);\n  \
    \  \n    return frac_part - int_part;\n}", "{\n    float decimals = 0.0;\n   \
    \ float int_part = 0.0;\n    float remainder = 0.0;\n    \n    int_part = floor(number);\n\
    \    \n    if (number - int_part > 0.5) {\n        float temp = number - int_part;\n\
    \        \n        while(temp > 0.5) {\n            temp -= 1.0;\n           \
    \ decimals += 1.0;\n        }\n        \n        remainder = temp;\n    }\n  \
    \  \n    return int_part + decimals;\n}", "{\n    float remainder;\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    if (decimal_part == 0.0) \n    {\n     \
    \   return integer_part;\n    }\n    \n    remainder = number - integer_part;\n\
    \    \n    return remainder + decimal_part;\n}", "{\n    int int_part;\n    float\
    \ frac_part = number - truncate_number(number);\n    int_part = int(frac_part);\n\
    \    return number - int_part;\n}", "{\n    float result = number;\n    float\
    \ remainder;\n    float decimals = 1;\n    \n    while(number > 0)\n    {\n  \
    \      remainder = number % 1;\n        number = number / 1;\n        decimals\
    \ = decimals * 10;\n    }\n    \n    result = result * decimals;\n    \n    return\
    \ result;\n}", "{\n    long int int_part = (long) number;\n    float remainder\
    \ = (float) number - int_part;\n    \n    if (remainder > 0.5f) \n    {\n    \
    \    return remainder;\n    }\n    else \n    {\n        return remainder - 1.0f;\n\
    \    }\n}", "{\n    float remainder;\n    int integerPart;\n    \n    integerPart\
    \ = int(number);\n    remainder = number - integerPart;\n    \n    return remainder;\n\
    }", "{\n    float remainder;\n    int integer_part;\n    \n    integer_part =\
    \ trunc(number);\n    remainder = number - integer_part;\n    \n    return remainder;\n\
    }", "{\n    float result = number;\n    float remainder;\n    float decimals;\n\
    \    \n    decimals = number - truncate_float(number);\n    \n    if (number >\
    \ truncate_float(number))\n    {\n        remainder = truncate_float(number);\n\
    \        result = truncate_float(number) + remainder;\n    }\n    else\n    {\n\
    \        result = number;\n    }\n    \n    return result + decimals;\n}", "{\n\
    \    float remainder;\n    int integerPart;\n    \n    integerPart = int(number);\n\
    \    remainder = number - integerPart;\n    \n    return remainder;\n}", "{\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    return decimal_part;\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n    float remainder;\n    float\
    \ integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number-integerPart;\n    \n    if (decimalPart > 0.0) {\n \
    \       remainder = number-integerPart;\n    } else {\n        remainder = 0.0f;\n\
    \    }\n    \n    return remainder;\n}", "{\n    float remainder;\n    float decimals;\n\
    \    int integer;", "{\n    int integer_part;\n    float decimal_part;\n    \n\
    \    integer_part = trunc(number);\n    \n    decimal_part = number - integer_part;\n\
    \    \n    return decimal_part;\n}", "{\n    float result = number;\n    \n  \
    \  int decimals = (int)((result - number) * 100);\n    \n    if (decimals < 0)\n\
    \    {\n        decimals = 0;\n    }\n    \n    return result - decimals;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
