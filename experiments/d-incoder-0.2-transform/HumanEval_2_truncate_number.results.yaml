language: d
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7pshi33t.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pshi33t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_lohxv1c.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_lohxv1c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe5_3a4jp.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe5_3a4jp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    \n    int_part =\
    \ int(frac_part);\n    \n    return frac_part - int_part;\n}\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7dl861bu.d(18): Error: cannot implicitly convert expression `frac_part`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7dl861bu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float int_part = 0.0;\n    float remainder = 0.0;\n    \n    int_part\
    \ = floor(number);\n    \n    if (number - int_part > 0.5) {\n        float temp\
    \ = number - int_part;\n        \n        while(temp > 0.5) {\n            temp\
    \ -= 1.0;\n            decimals += 1.0;\n        }\n        \n        remainder\
    \ = temp;\n    }\n    \n    return int_part + decimals;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsjiopxbp.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f75]

    ??:? void tmpsjiopxbp.__unittest_L34_C1() [0x427c8a]

    ??:? void tmpsjiopxbp.__modtest() [0x427cf8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bddf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac72]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe05]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4302b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd91]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac49]

    ??:? runModuleUnitTests [0x42bbb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    if (decimal_part ==\
    \ 0.0) \n    {\n        return integer_part;\n    }\n    \n    remainder = number\
    \ - integer_part;\n    \n    return remainder + decimal_part;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpglludana.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpglludana.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = int(frac_part);\n\
    \    return number - int_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_iy_9yfc.d(17): Error: cannot implicitly convert expression `frac_part`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_iy_9yfc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals = 1;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 1;\n        number = number / 1;\n\
    \        decimals = decimals * 10;\n    }\n    \n    result = result * decimals;\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164422
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int int_part\
    \ = (long) number;\n    float remainder = (float) number - int_part;\n    \n \
    \   if (remainder > 0.5f) \n    {\n        return remainder;\n    }\n    else\
    \ \n    {\n        return remainder - 1.0f;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkd7ps_qs.d(15): Error: no identifier for declarator `long`

    /tmp/tmpkd7ps_qs.d(15): Error: C style cast illegal, use `cast(long)number`

    /tmp/tmpkd7ps_qs.d(16): Error: C style cast illegal, use `cast(float)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkd7ps_qs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals;\n    \n    decimals = number\
    \ - truncate_float(number);\n    \n    if (number > truncate_float(number))\n\
    \    {\n        remainder = truncate_float(number);\n        result = truncate_float(number)\
    \ + remainder;\n    }\n    else\n    {\n        result = number;\n    }\n    \n\
    \    return result + decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4oarykri.d(19): Error: undefined identifier `truncate_float`

    /tmp/tmp4oarykri.d(21): Error: undefined identifier `truncate_float`

    /tmp/tmp4oarykri.d(23): Error: undefined identifier `truncate_float`

    /tmp/tmp4oarykri.d(24): Error: undefined identifier `truncate_float`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4oarykri.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9dje42t.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9dje42t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number-integerPart;\n    \n    if (decimalPart > 0.0) {\n \
    \       remainder = number-integerPart;\n    } else {\n        remainder = 0.0f;\n\
    \    }\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2h04h2u.d(19): Error: undefined identifier `floorf`, did you mean
    function `floor`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2h04h2u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integer;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzr1wzp_p.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzr1wzp_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqzixekv.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqzixekv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    int decimals = (int)((result - number) * 100);\n    \n\
    \    if (decimals < 0)\n    {\n        decimals = 0;\n    }\n    \n    return\
    \ result - decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgkf_6wfr.d(17): Error: C style cast illegal, use `cast(int)((result
    - number) * 100)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgkf_6wfr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float temp;\n    \n    quotient\
    \ = number / 10;\n    decimals = number % 10;\n    \n    if (decimals > 0) {\n\
    \        temp = quotient * 100;\n        \n        if (temp > number) {\n    \
    \        temp = temp - decimals;\n        }\n        \n        quotient = temp\
    \ / 10;\n        decimals = temp % 10;\n    }\n    \n    if (decimals < 0) {\n\
    \        temp = quotient * 100;\n        \n        if (temp < number) {\n    \
    \        temp = temp + decimals;\n        }\n        \n        quotient = temp\
    \ / 10;\n        decimals = temp % 10;\n    }\n    \n    if (decimals == 0) {\n\
    \        remainder = quotient;\n    } else {\n        remainder = quotient + decimals;\n\
    \    }\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprnyz5y5n.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x427edd]

    ??:? void tmprnyz5y5n.__unittest_L53_C1() [0x427bee]

    ??:? void tmprnyz5y5n.__modtest() [0x427c5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa6d]

    ??:? runModuleUnitTests [0x42b9d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42832c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) \n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqkmqbk6j.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpqkmqbk6j.__unittest_L24_C1() [0x427a7e]

    ??:? void tmpqkmqbk6j.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqucfx4r.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqucfx4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9cp76ppy.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmp9cp76ppy.__unittest_L29_C1() [0x427af6]

    ??:? void tmp9cp76ppy.__modtest() [0x427b64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp911sihlf.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp911sihlf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 1;\n        number = number / 1;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164422
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7pshi33t.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pshi33t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpizt2k06z.d(19): Error: undefined identifier `floorf`, did you mean
    function `floor`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpizt2k06z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1.0f) {\n        result -= 1.0f;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyi3c4k6t.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpyi3c4k6t.__unittest_L23_C1() [0x427ad9]

    ??:? void tmpyi3c4k6t.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqzixekv.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqzixekv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(number > 0.0)\n    {\n\
    \        float remainder = number % 1.0;\n        number = number;\n        decimals\
    \ += remainder;\n    }\n    \n    return result + decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164422
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number % 1;\n    float remainder = number - decimals;\n    float integerPart\
    \ = floor(number);\n    return remainder + decimals;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi_hag6rc.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427edd]

    ??:? void tmpi_hag6rc.__unittest_L20_C1() [0x427bf2]

    ??:? void tmpi_hag6rc.__modtest() [0x427c60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd47]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42abda]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fd6d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43021c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fcf9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42abb1]

    ??:? runModuleUnitTests [0x42bb1d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42832c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgepos4b.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgepos4b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjicadm_d.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjicadm_d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    \n    int_part =\
    \ trunc(frac_part);\n    \n    return int_part + frac_part;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbdd_ei37.d(18): Error: cannot implicitly convert expression `trunc(cast(real)frac_part)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdd_ei37.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number - trunc(number);\n    return decimals;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float trunc_number;\n    float decimal_part;\n    \n    trunc_number = number;\n\
    \    decimal_part = number - trunc_number;\n    \n    while(decimal_part >= 1)\n\
    \    {\n        remainder = decimal_part % 1;\n        decimal_part = decimal_part\
    \ / 1;\n        trunc_number = trunc_number * 10 + remainder;\n    }\n    \n \
    \   return trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1wq0aucp.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmp1wq0aucp.__unittest_L31_C1() [0x427ae2]

    ??:? void tmp1wq0aucp.__modtest() [0x427b50]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(number > 0)\n    {\n      \
    \  remainder = number % 10;\n        number /= 10;\n        result = remainder\
    \ * 10.0 + result;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv8sy_ujm.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpv8sy_ujm.__unittest_L27_C1() [0x427ade]

    ??:? void tmpv8sy_ujm.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    \n    while (result > 1) {\n       \
    \ result /= 10;\n        decimals++;\n    }\n    \n    return result - decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdylmvoyw.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d9d]

    ??:? void tmpdylmvoyw.__unittest_L25_C1() [0x427aae]

    ??:? void tmpdylmvoyw.__modtest() [0x427b1c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff98]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa75]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]

    ??:? runModuleUnitTests [0x42b899]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart =\
    \ (int) number;\n    float decimalPart = number - intPart;\n    \n    return decimalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9jsx63me.d(15): Error: C style cast illegal, use `cast(int)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9jsx63me.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder;\n    float decimal_part;\n    int decimal_part_index;\n\
    \    int decimal_part_count;\n    int i;\n    \n    decimal_part_index = trunc_number\
    \ - trunc_number % 1;\n    \n    decimal_part_count = decimal_part_index + 1;\n\
    \    \n    remainder = trunc_number - decimal_part_index;\n    \n    decimal_part\
    \ = remainder / decimal_part_count;\n    \n    trunc_number = trunc_number - decimal_part\
    \ * decimal_part_count;\n    \n    return trunc_number;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpepf3o_1u.d(22): Error: cannot implicitly convert expression `trunc_number
    - trunc_number % 1.00000F` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpepf3o_1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqucfx4r.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqucfx4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(number > 0)\n    {\n      \
    \  remainder = number % 10;\n        number = number / 10;\n        result = result\
    \ + remainder;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp32lajt3x.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dad]

    ??:? void tmp32lajt3x.__unittest_L27_C1() [0x427ac2]

    ??:? void tmp32lajt3x.__modtest() [0x427b30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffa8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a93d]

    ??:? runModuleUnitTests [0x42b8a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbrlvb_hb.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpbrlvb_hb.__unittest_L23_C1() [0x427a7e]

    ??:? void tmpbrlvb_hb.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqzixekv.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqzixekv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float temp;\n    int exponent;\n\
    \    \n    temp = number;\n    \n    exponent = std.math.frexp(temp, out remainder);\n\
    \    \n    quotient = temp / pow(2, exponent);\n    decimals = temp - quotient\
    \ * pow(2, exponent);\n    \n    return quotient + decimals;\n}\n/*\n Given a\
    \ positive floating point number, it can be decomposed into\n    and integer part\
    \ (largest integer smaller than given number) and decimals\n    (leftover part\
    \ always smaller than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkq7f3cdb.d(23): Error: expression expected, not `out`

    /tmp/tmpkq7f3cdb.d(23): Error: found `remainder` when expecting `,`

    /tmp/tmpkq7f3cdb.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkq7f3cdb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integerPart;\n    \n    integerPart = number;\n\
    \    \n    decimals = number - integerPart;\n    \n    if (decimals < 0.0) \n\
    \    {\n        integerPart -= 1;\n        decimals = -decimals;\n    }\n    \n\
    \    remainder = number-integerPart;\n    \n    return remainder;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeq9yout2.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpeq9yout2.__unittest_L33_C1() [0x427ae2]

    ??:? void tmpeq9yout2.__modtest() [0x427b50]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    \n    if (int_part\
    \ == number) {\n        decimal_part = number;\n    } else {\n        decimal_part\
    \ = number - int_part;\n    }\n    \n    return decimal_part;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_v3vxcww.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_v3vxcww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long int) number;\n    long long int decimalPart = (long long\
    \ int) number - intPart;\n    \n    if (decimalPart > 0)\n        return number\
    \ - decimalPart;\n    else\n        return number;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3aiqiey.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmph3aiqiey.d(15): Error: no identifier for declarator `long`

    /tmp/tmph3aiqiey.d(15): Error: found `long` when expecting `.` following long

    /tmp/tmph3aiqiey.d(15): Error: found `int` when expecting identifier following
    `long`.

    /tmp/tmph3aiqiey.d(15): Error: semicolon expected, not `number`

    /tmp/tmph3aiqiey.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmph3aiqiey.d(16): Error: no identifier for declarator `long`

    /tmp/tmph3aiqiey.d(16): Error: found `long` when expecting `.` following long

    /tmp/tmph3aiqiey.d(16): Error: found `int` when expecting identifier following
    `long`.

    /tmp/tmph3aiqiey.d(16): Error: semicolon expected, not `number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3aiqiey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    \n    while(number > 0)\n    {\n   \
    \     number /= 10;\n        decimals++;\n    }\n    \n    return result / decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo465hym2.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427da5]

    ??:? void tmpo465hym2.__unittest_L26_C1() [0x427ab6]

    ??:? void tmpo465hym2.__modtest() [0x427b24]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bacb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a95e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffa0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa7d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a935]

    ??:? runModuleUnitTests [0x42b8a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281f4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number-integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_wlwnr4g.d(19): Error: undefined identifier `floorf`, did you mean
    function `floor`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wlwnr4g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number-integerPart;\n    \n    if(decimalPart > 0.0f)\n   \
    \ {\n        remainder = number-integerPart;\n        \n        integerPart =\
    \ floorf(remainder);\n        decimalPart = remainder-integerPart;\n    }\n  \
    \  \n    return decimalPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyz4nalm2.d(19): Error: undefined identifier `floorf`, did you mean
    function `floor`?

    /tmp/tmpyz4nalm2.d(26): Error: undefined identifier `floorf`, did you mean function
    `floor`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyz4nalm2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimal;\n    float integer_part;\n    float decimal_part;\n    \n\
    \    integer_part = floor(number);\n    \n    if (integer_part == number)\n  \
    \  {\n        decimal_part = 0.0;\n    }\n    else\n    {\n        decimal_part\
    \ = number - integer_part;\n    }\n    \n    remainder = number - integer_part;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integer;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2rrsiyy.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2rrsiyy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart =\
    \ (int) number;\n    float decimalPart = number - intPart;\n    return decimalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbe9g2u4w.d(15): Error: C style cast illegal, use `cast(int)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbe9g2u4w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    \n   \
    \ while(number > 0.0) {\n        remainder = number % 10.0;\n        number =\
    \ number / 10.0;\n        decimals = decimals + remainder;\n    }\n    \n    result\
    \ = result + decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2r_aeuxo.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmp2r_aeuxo.__unittest_L29_C1() [0x427af6]

    ??:? void tmp2r_aeuxo.__modtest() [0x427b64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ehw0q0_.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ehw0q0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmu68h2ah.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmu68h2ah.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4g93yv36.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmp4g93yv36.__unittest_L27_C1() [0x427ade]

    ??:? void tmp4g93yv36.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    float decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = decimalPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptoh4j6jo.d(19): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptoh4j6jo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphjkgi0ki.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphjkgi0ki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    float remainder;\n    \n    int_part = std.math.trunc(number);\n\
    \    remainder = number - int_part;\n    \n    return remainder;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps02gn7s_.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmps02gn7s_.d(15): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps02gn7s_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) \n\
    \    {\n        remainder = truncate_number(decimalPart);\n    }\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164422
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) \n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqkmqbk6j.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpqkmqbk6j.__unittest_L24_C1() [0x427a7e]

    ??:? void tmpqkmqbk6j.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    while (number > 0)\n    {\n        number\
    \ /= 10;\n        decimals++;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5thq060y.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmp5thq060y.__unittest_L24_C1() [0x427aaa]

    ??:? void tmp5thq060y.__modtest() [0x427b18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd9bfsp67.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    /tmp/tmpd9bfsp67.d(23): Error: cannot implicitly convert expression `cast(real)remainder
    / pow(10.0000, floor(log10(cast(real)remainder)))` of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9bfsp67.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp77ewfpmp.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp77ewfpmp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqucfx4r.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqucfx4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8qe3uoya.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8qe3uoya.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float int_part = 0;\n    float decimal_part = 0;\n    float remainder\
    \ = 0;\n    float temp = 0;\n    int decimal_count = 0;\n    \n    while(trunc_number\
    \ > 0)\n    {\n        remainder = trunc_number % 10;\n        temp = trunc_number\
    \ / 10;\n        \n        int_part = int_part + temp * pow(10, decimal_count);\n\
    \        \n        decimal_part = decimal_part + remainder * pow(10, decimal_count);\n\
    \        \n        trunc_number = trunc_number / 10;\n        \n        decimal_count++;\n\
    \    }\n    \n    return int_part + decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjp6cqshz.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f05]

    ??:? void tmpjp6cqshz.__unittest_L38_C1() [0x427b92]

    ??:? void tmpjp6cqshz.__modtest() [0x427c88]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aabe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430100]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbdd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa95]

    ??:? runModuleUnitTests [0x42ba01]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428354]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = int(number);\n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6i6femoo.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6i6femoo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51gaju8x.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51gaju8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\n    \n    exponent = floor(log10(number));\n\
    \    \n    if(exponent < 0)\n        exponent = 0;\n    \n    remainder = number\
    \ - (float)pow(10.0, -exponent);\n    \n    if(remainder < 1.0e-6)\n        result\
    \ = remainder;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuklrvtvg.d(24): Error: C style cast illegal, use `cast(float)pow(10.0000,
    -exponent)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuklrvtvg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float quotient2\
    \ = 0.0;\n    float quotient3 = 0.0;\n    float quotient4 = 0.0;\n    float quotient5\
    \ = 0.0;\n    float quotient6 = 0.0;\n    float quotient7 = 0.0;\n    float quotient8\
    \ = 0.0;\n    float quotient9 = 0.0;\n    float quotient10 = 0.0;\n    float quotient11\
    \ = 0.0;\n    float quotient12 = 0.0;\n    float quotient13 = 0.0;\n    float\
    \ quotient14 = 0.0;\n    float quotient15 = 0.0;\n    float quotient16 = 0.0;\n\
    \    float quotient17 = 0.0;\n    float quotient18 = 0.0;\n    float quotient19\
    \ = 0.0;\n    float quotient20 = 0.0;\n    float quotient21 = 0.0;\n    float\
    \ quotient22 = 0.0;\n    float quotient23 = 0.0;\n    float quotient24 = 0.0;\n\
    \    float quotient25 = 0.0;\n    float quotient26 = 0.0;\n    float quotient27\
    \ = 0.0;\n    float quotient28 = 0.0;\n    float quotient29 = 0.0;\n    float\
    \ quotient30 = 0.0;\n    float quotient31 = 0.0;\n    float quotient32 = 0.0;\n\
    \    float quotient33 = 0.0;\n    float quotient34 = 0.0;\n    float quotient35\
    \ = 0.0;\n    float quotient36 = 0.0;\n    float quotient37 = 0.0;\n    float\
    \ quotient38 = 0.0;\n    float quotient39 = 0.0;\n    float quotient40 = 0.0;\n\
    \    float quotient41 = 0.0;\n    float quotient42 = 0.0;\n    float quotient43\
    \ = 0.0;\n    float quotient44 = 0.0;\n    float quotient45 = 0.0;\n    float\
    \ quotient46 = 0.0;\n    float quotient47 = 0.0;\n    float quotient48 = 0.0;\n\
    \    float quotient49 = 0.0;\n    float quotient50 = 0.0;\n    float quotient51\
    \ = 0.0;\n    float quotient52 = 0.0;\n    float quotient53 = 0.0;\n    float\
    \ quotient54 = 0.0;\n    float quotient55 = 0.0;\n    float quotient56 = 0.0;\n\
    \    float quotient57 = 0.0;\n    float quotient58 = 0.0;\n    float quotient59\
    \ = 0.0;\n    float quotient60 = 0.0;\n    float quotient61 = 0.\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy99j5ed7.d(78): Error: semicolon expected, not `unittest`

    /tmp/tmpy99j5ed7.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy99j5ed7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptu6h4yvw.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e55]

    ??:? void tmptu6h4yvw.__unittest_L27_C1() [0x427b66]

    ??:? void tmptu6h4yvw.__modtest() [0x427bd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\n</code>\n\
    <|/ a tags=floating-point,c++,truncate |>\n<| a dscore=2 |>\n<code>\nfloat truncate_number(float\
    \ number) \n{\n    float remainder;\n    int integer_part;\n    int decimal_part;\n\
    \    \n    integer_part = trunc(number);\n    \n    remainder = number - integer_part;\n\
    \    \n    decimal_part = remainder / pow(10.0, floor(log10(remainder)));\n  \
    \  \n    return decimal_part;\n}\n</code>\n<|/ a tags=floating-point,c++,truncate\
    \ |>\n<| a tags=floating-point,c++,truncate |>\n<code>\nfloat truncate_number(float\
    \ number) \n{\n    float remainder;\n    int integer_part;\n    int decimal_part;\n\
    \    \n    integer_part = trunc(number);\n    \n    remainder = number - integer_part;\n\
    \    \n    decimal_part = remainder / pow(10.0, floor(log10(remainder)));\n  \
    \  \n    return decimal_part;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=floating-point,c++,truncate\
    \ |>\n<code>\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=floating-point,c++,truncate |>\n<code>\nfloat truncate_number(float\
    \ number) \n{\n    float remainder;\n    int integer_part;\n    int decimal_part;\n\
    \    \n    integer_part = trunc(number);\n    \n    remainder = number - integer_part;\n\
    \    \n    decimal_part = remainder / pow(10.0, floor(log10(remainder)));\n  \
    \  \n    return decimal_part;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=floating-point,c++,truncate\
    \ |>\n<code>\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp41y527te.d(27): Error: declaration expected, not `<`

    /tmp/tmp41y527te.d(37): Error: no identifier for declarator `integer_part`

    /tmp/tmp41y527te.d(37): Error: declaration expected, not `=`

    /tmp/tmp41y527te.d(39): Error: no identifier for declarator `remainder`

    /tmp/tmp41y527te.d(39): Error: declaration expected, not `=`

    /tmp/tmp41y527te.d(41): Error: no identifier for declarator `decimal_part`

    /tmp/tmp41y527te.d(41): Error: declaration expected, not `=`

    /tmp/tmp41y527te.d(43): Error: declaration expected, not `return`

    /tmp/tmp41y527te.d(44): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41y527te.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) {\n\
    \        remainder = truncate_number(decimalPart);\n    } else {\n        remainder\
    \ = 0.0f;\n    }\n    \n    return remainder + integerPart;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164423
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjicadm_d.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjicadm_d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimalPart;\n    \n    decimalPart = number - int(number);\n\
    \    \n    if(decimalPart > 0)\n    {\n        result = result - decimalPart;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_fux249w.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fux249w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(number > 0)\n    {\n      \
    \  remainder = number % 10;\n        number /= 10;\n        result = remainder\
    \ * 10.0 + result;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv8sy_ujm.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpv8sy_ujm.__unittest_L27_C1() [0x427ade]

    ??:? void tmpv8sy_ujm.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj76_7ggw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj76_7ggw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(result > 1) {\n        remainder\
    \ = result % 1;\n        result = result / 1;\n        result = remainder + result;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164423
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnvamk5ti.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnvamk5ti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long int)number;\n    long long int decimalPart = intPart %\
    \ 10;\n    intPart /= 10;\n    \n    if (decimalPart > 0)\n        return number;\n\
    \    \n    return intPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8tty2oxt.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp8tty2oxt.d(15): Error: no identifier for declarator `long`

    /tmp/tmp8tty2oxt.d(15): Error: found `long` when expecting `.` following long

    /tmp/tmp8tty2oxt.d(15): Error: found `int` when expecting identifier following
    `long`.

    /tmp/tmp8tty2oxt.d(15): Error: semicolon expected, not `number`

    /tmp/tmp8tty2oxt.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp8tty2oxt.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8tty2oxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals;\n    int exponent;\n  \
    \  int sign;\n    \n    sign = number < 0.0 ? -1.0 : 1.0;\n    exponent = std.math.trunc(std.math.log2(number));\n\
    \    \n    decimals = number - std.math.pow(10.0, exponent);\n    \n    remainder\
    \ = std.math.pow(10.0, exponent - 1);\n    \n    result = remainder + decimals;\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy3eeim7x.d(21): Error: cannot implicitly convert expression `cast(double)number
    < 0.00000 ? -1 : 1.00000` of type `double` to `int`

    /tmp/tmpy3eeim7x.d(22): Error: cannot implicitly convert expression `trunc(log2(cast(real)number))`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy3eeim7x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphjkgi0ki.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphjkgi0ki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float trunc_number;\n    int decimal_places = 1;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        trunc_number = trunc_number\
    \ + remainder * pow(10.0, decimal_places);\n        number = number / 10;\n  \
    \      decimal_places++;\n    }\n    \n    return trunc_number;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxt75l5up.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f65]

    ??:? void tmpxt75l5up.__unittest_L29_C1() [0x427b52]

    ??:? void tmpxt75l5up.__modtest() [0x427ce8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fcb1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430160]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fc3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aaf5]

    ??:? runModuleUnitTests [0x42ba61]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprtqvqlpz.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprtqvqlpz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number-integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\n/*\n Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp22mqruo3.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp22mqruo3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number - trunc(number);\n    float result = trunc(number);\n    return result\
    \ + decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpek2kc9xz.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e35]

    ??:? void tmpek2kc9xz.__unittest_L19_C1() [0x427b46]

    ??:? void tmpek2kc9xz.__modtest() [0x427bb4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9dd]

    ??:? runModuleUnitTests [0x42b949]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428284]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ehw0q0_.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ehw0q0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = int(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiujz_nxn.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiujz_nxn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder;\n    int decimal_part;\n    \n    decimal_part\
    \ = int(number - trunc_number);\n    \n    if (decimal_part == 0)\n    {\n   \
    \     trunc_number = trunc_number - remainder;\n        decimal_part = 1;\n  \
    \  }\n    \n    return trunc_number + remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplz49_s1u.d(19): Error: cannot implicitly convert expression `number
    - trunc_number` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplz49_s1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder = 0;\n    \n    while(number > 0)\n    {\n  \
    \      remainder = number % 10;\n        number = number / 10;\n        result\
    \ = remainder * 10 + result;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpft5qn4dq.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dbd]

    ??:? void tmpft5qn4dq.__unittest_L27_C1() [0x427ace]

    ??:? void tmpft5qn4dq.__modtest() [0x427b3c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bae3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a976]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb09]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa95]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a94d]

    ??:? runModuleUnitTests [0x42b8b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42820c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgepos4b.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgepos4b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(result > 1.0f) {\n   \
    \     result += 1.0f;\n        decimals++;\n    }\n    \n    return result - decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164423
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long) number;\n    long long int decimalPart = (intPart % 10);\n\
    \    intPart /= 10;\n    \n    if (decimalPart > 0)\n        return number;\n\
    \    \n    return (float) intPart + decimalPart;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmica6ftk.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmpmica6ftk.d(15): Error: no identifier for declarator `long`

    /tmp/tmpmica6ftk.d(15): Error: found `long` when expecting `.` following long

    /tmp/tmpmica6ftk.d(15): Error: found `)` when expecting identifier following `long`.

    /tmp/tmpmica6ftk.d(15): Error: found `number` when expecting `)`

    /tmp/tmpmica6ftk.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmpmica6ftk.d(16): Error: no identifier for declarator `long`

    /tmp/tmpmica6ftk.d(22): Error: C style cast illegal, use `cast(float)intPart`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmica6ftk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    float decimals = number - trunc(number);\n    \n    if\
    \ (decimals > 0.0f)\n    {\n        result = trunc(number);\n    }\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n \
    \   assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n   \
    \ assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1_1yacns.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e45]

    ??:? void tmp1_1yacns.__unittest_L26_C1() [0x427b5a]

    ??:? void tmp1_1yacns.__modtest() [0x427bc8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430058]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ed]

    ??:? runModuleUnitTests [0x42b959]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428294]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp911sihlf.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp911sihlf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float integer = 0.0;\n    \n    while(number > 0.0) {\n        integer\
    \ += number % 10;\n        decimals += number / 10.0;\n        number /= 10.0;\n\
    \    }\n    \n    return decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1qjzjk9b.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmp1qjzjk9b.__unittest_L26_C1() [0x427b06]

    ??:? void tmp1qjzjk9b.__modtest() [0x427b74]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnhlgdaqc.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnhlgdaqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    \n    quotient\
    \ = number;\n    \n    while(quotient > 1.0)\n    {\n        remainder = quotient\
    \ - 1.0;\n        quotient = remainder / 10.0;\n        decimals = decimals +\
    \ 1.0;\n    }\n    \n    return quotient;\n}\n/*\n Given a positive floating point\
    \ number, it can be decomposed into\n    and integer part (largest integer smaller\
    \ than given number) and decimals\n    (leftover part always smaller than 1).\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgczlc5fn.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgczlc5fn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10;\n        \n        if(remainder > 0)\n    \
    \    {\n            decimals = decimals + 1;\n        }\n    }\n    \n    result\
    \ = result / decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy2i6o9yg.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e1d]

    ??:? void tmpy2i6o9yg.__unittest_L35_C1() [0x427b2e]

    ??:? void tmpy2i6o9yg.__modtest() [0x427b9c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb69]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430018]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faf5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ad]

    ??:? runModuleUnitTests [0x42b919]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42826c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integer_part;\n    float decimal_part;\n    \n    integer_part = floor(number);\n\
    \    decimal_part = number - integer_part;\n    \n    if (decimal_part == 0.0f)\n\
    \    {\n        return integer_part;\n    }\n    \n    remainder = number - integer_part;\n\
    \    \n    return remainder + 1.0f;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvqv93q0s.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f0d]

    ??:? void tmpvqv93q0s.__unittest_L31_C1() [0x427c22]

    ??:? void tmpvqv93q0s.__modtest() [0x427c90]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bd77]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac0a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fd9d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43024c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd29]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42abe1]

    ??:? runModuleUnitTests [0x42bb4d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42835c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder = 0;\n    float decimal_part = 0;\n    float\
    \ decimal_part_remainder = 0;\n    float decimal_part_remainder_magnitude = 0;\n\
    \    float decimal_part_remainder_magnitude2 = 0;\n    float decimal_part_remainder_magnitude4\
    \ = 0;\n    float decimal_part_remainder_magnitude8 = 0;\n    float decimal_part_remainder_magnitude16\
    \ = 0;\n    float decimal_part_remainder_magnitude32 = 0;\n    float decimal_part_remainder_magnitude64\
    \ = 0;\n    float decimal_part_remainder_magnitude128 = 0;\n    float decimal_part_remainder_magnitude256\
    \ = 0;\n    float decimal_part_remainder_magnitude512 = 0;\n    float decimal_part_remainder_magnitude1024\
    \ = 0;\n    float decimal_part_remainder_magnitude2048 = 0;\n    float decimal_part_remainder_magnitude4096\
    \ = 0;\n    float decimal_part_remainder_magnitude8192 = 0;\n    float decimal_part_remainder_magnitude16384\
    \ = 0;\n    float decimal_part_remainder_magnitude32768 = 0;\n    float decimal_part_remainder_magnitude65536\
    \ = 0;\n    float decimal_part_remainder_magnitude131072 = 0;\n    float decimal_part_remainder_magnitude262144\
    \ = 0;\n    float decimal_part_remainder_magnitude524288 = 0;\n    float decimal_part_remainder_magnitude1048576\
    \ = 0;\n    float decimal_part_remainder_magnitude2097152 = 0.0;\n    float decimal_part_remainder_magnitude4194304\
    \ = 0.0;\n    float decimal_part_remainder_magnitude8388608 = 0.0;\n    float\
    \ decimal_part_remainder_magnitude16777216 = 0.0;\n    float decimal_part_remainder_magnitude33554432\
    \ = 0.0;\n    float decimal_part_remainder_magnitude67108864 = 0.0;\n    float\
    \ decimal_part_remainder_magnitude134217728 = 0.0;\n    float decimal_part_remainder_magnitude268435456\
    \ = 0.0;\n    float decimal_part_remainder_magnitude536870912 = 0.0;\n    float\
    \ decimal_part_remainder_magnitude1073741824 = 0.0;\n    float decimal_part_remainder_magnitude2147483648\
    \ = 0.0;\n    float decimal_part_remainder_magnitude4294967296 = 0.0;\n    float\
    \ decimal_part_remainder_magnitude8589934592 = 0.0;\n    float decimal_part_remainder_magnitude17179869184\
    \ = 0.0;\n    float decimal_part_remainder_magnitude34359738368 = 0.0;\n    float\
    \ decimal_part_remainder_magnitude68719476736 = 0.0;\n    float decimal_part_remainder_magnitude137438953472\
    \ = 0.0;\n    float decimal_part_remainder_magnitude274877906944 = 0.0;\n    float\
    \ decimal_\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe7g4fq28.d(59): Error: semicolon expected, not `unittest`

    /tmp/tmpe7g4fq28.d(59): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7g4fq28.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc__yu54p.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    /tmp/tmpc__yu54p.d(23): Error: cannot implicitly convert expression `remainder`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc__yu54p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    float decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = decimalPart %\
    \ 1;\n    \n    return remainder;\n}\n</code>\n<|/ a tags=c++,floating-point,truncate\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `truncate_number(-3.5)`\
    \ returns `-3.5` instead of `-3.4999999999999999`.\n<|/ c |>\n<| a tags=c++,floating-point,truncate\
    \ |>\n<code>\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    float decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = decimalPart %\
    \ 1;\n    \n    return remainder;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't work for negative numbers. `truncate_number(-3.5)` returns `-3.5` instead\
    \ of `-3.4999999999999999`.\n<|/ c |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. `truncate_number(-3.5)` returns `-3.5` instead of `-3.4999999999999999`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for negative numbers. `truncate_number(-3.5)`\
    \ returns `-3.5` instead of `-3.4999999999999999`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. `truncate_number(-3.5)` returns `-3.5` instead of\
    \ `-3.4999999999999999`.\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `truncate_number(-3.5)` returns `-3.5` instead of `-3.4999999999999999`.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>\nfloat truncate_number(float number) \n{\n  \
    \  float remainder;\n    int integerPart;\n    float decimalPart;\n    \n    integerPart\
    \ = int(number);\n    decimalPart = number - integerPart;\n    \n    remainder\
    \ = decimalPart % 1;\n    \n    return remainder;\n}\n</code>\n<|/ a tags=c++,floating-point,truncate\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `truncate_number(-3.5)`\
    \ returns `-3.5` instead of `\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_n6dpok.d(26): Error: declaration expected, not `<`

    /tmp/tmps_n6dpok.d(29): Error: unterminated character constant

    /tmp/tmps_n6dpok.d(39): Error: no identifier for declarator `integerPart`

    /tmp/tmps_n6dpok.d(39): Error: declaration expected, not `=`

    /tmp/tmps_n6dpok.d(40): Error: no identifier for declarator `decimalPart`

    /tmp/tmps_n6dpok.d(40): Error: declaration expected, not `=`

    /tmp/tmps_n6dpok.d(42): Error: no identifier for declarator `remainder`

    /tmp/tmps_n6dpok.d(42): Error: declaration expected, not `=`

    /tmp/tmps_n6dpok.d(44): Error: declaration expected, not `return`

    /tmp/tmps_n6dpok.d(45): Error: unrecognized declaration

    /tmp/tmps_n6dpok.d(49): Error: unterminated character constant

    /tmp/tmps_n6dpok.d(52): Error: unterminated character constant

    /tmp/tmps_n6dpok.d(55): Error: unterminated character constant

    /tmp/tmps_n6dpok.d(58): Error: unterminated character constant

    /tmp/tmps_n6dpok.d(61): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps_n6dpok.'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd9ahb15u.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    /tmp/tmpd9ahb15u.d(21): Error: cannot implicitly convert expression `number -
    cast(float)integer_part` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9ahb15u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp911sihlf.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp911sihlf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfs1iqaut.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfs1iqaut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number - integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6paz7kg8.d(19): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    /tmp/tmp6paz7kg8.d(20): Error: cannot implicitly convert expression `number -
    cast(float)integerPart` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6paz7kg8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float int_part = 0.0;\n    float remainder = 0.0;\n    \n    int_part\
    \ = number;\n    \n    while(int_part >= 1.0)\n    {\n        int_part -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    \n    remainder = int_part;\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfs1iqaut.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfs1iqaut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integer;\n    \n    integer = trunc(number);\n\
    \    decimals = number - integer;\n    \n    if (decimals < 0.0) \n    {\n   \
    \     decimals = 0.0;\n    }\n    \n    remainder = number - integer;\n    \n\
    \    return remainder + decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprfs0diey.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e7d]

    ??:? void tmprfs0diey.__unittest_L31_C1() [0x427b8e]

    ??:? void tmprfs0diey.__modtest() [0x427bfc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430090]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa25]

    ??:? runModuleUnitTests [0x42b991]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282cc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ehw0q0_.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ehw0q0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmu68h2ah.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmu68h2ah.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    \n    integerPart = floor(number);\n    decimalPart\
    \ = number - integerPart;\n    \n    return decimalPart;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    int_part = trunc(number);\n    frac_part = number -\
    \ int_part;\n    return frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxxs0ws5o.d(17): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxxs0ws5o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfs1iqaut.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfs1iqaut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplqzixekv.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqzixekv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder = 0;\n    float quotient = 0;\n    float quotient2\
    \ = 0;\n    float quotient3 = 0;\n    float quotient4 = 0;\n    float quotient5\
    \ = 0;\n    float quotient6 = 0;\n    float quotient7 = 0;\n    float quotient8\
    \ = 0;\n    float quotient9 = 0;\n    float quotient10 = 0;\n    float quotient11\
    \ = 0;\n    float quotient12 = 0;\n    float quotient13 = 0;\n    float quotient14\
    \ = 0;\n    float quotient15 = 0;\n    float quotient16 = 0;\n    float quotient17\
    \ = 0;\n    float quotient18 = 0;\n    float quotient19 = 0;\n    float quotient20\
    \ = 0;\n    float quotient21 = 0;\n    float quotient22 = 0;\n    float quotient23\
    \ = 0;\n    float quotient24 = 0;\n    float quotient25 = 0;\n    float quotient26\
    \ = 0;\n    float quotient27 = 0;\n    float quotient28 = 0;\n    float quotient29\
    \ = 0;\n    float quotient30 = 0;\n    float quotient31 = 0;\n    float quotient32\
    \ = 0;\n    float quotient33 = 0;\n    float quotient34 = 0;\n    float quotient35\
    \ = 0;\n    float quotient36 = 0;\n    float quotient37 = 0;\n    float quotient38\
    \ = 0;\n    float quotient39 = 0;\n    float quotient40 = 0;\n    float quotient41\
    \ = 0;\n    float quotient42 = 0;\n    float quotient43 = 0;\n    float quotient44\
    \ = 0;\n    float quotient45 = 0;\n    float quotient46 = 0;\n    float quotient47\
    \ = 0;\n    float quotient48 = 0;\n    float quotient49 = 0;\n    float quotient50\
    \ = 0;\n    float quotient51 = 0;\n    float quotient52 = 0;\n    float quotient53\
    \ = 0;\n    float quotient54 = 0;\n    float quotient55 = 0;\n    float quotient56\
    \ = 0;\n    float quotient57 = 0;\n    float quotient58 = 0;\n    float quotient59\
    \ = 0;\n    float quotient60 = 0;\n    float quotient61 = 0;\n    float quotient62\
    \ = 0;\n    float quotient63 = 0;\n    float quotient64 = 0;\n    float quotient65\
    \ = 0;\n    float quotient66 = 0;\n    float quotient67 = 0;\n    float quotient68\
    \ = 0;\n    float quotient69 = 0;\n    float quotient70 = 0;\n    float quotient71\
    \ = 0;\n    float quotient72 = 0;\n\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdiycal50.d(90): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdiycal50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpah00cq8y.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpah00cq8y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ehw0q0_.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ehw0q0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integer;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2rrsiyy.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2rrsiyy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    \n   \
    \ while(number > 0.0) {\n        remainder = number % 10.0;\n        number =\
    \ number / 10.0;\n        decimals = decimals + remainder;\n    }\n    \n    result\
    \ = result + decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2r_aeuxo.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmp2r_aeuxo.__unittest_L29_C1() [0x427af6]

    ??:? void tmp2r_aeuxo.__modtest() [0x427b64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd9ahb15u.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    /tmp/tmpd9ahb15u.d(21): Error: cannot implicitly convert expression `number -
    cast(float)integer_part` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9ahb15u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    float decimals = number - trunc(number);\n    \n    if\
    \ (number - trunc(number) == 0.5f)\n    {\n        decimals = 0.f;\n    }\n  \
    \  \n    result = trunc(number);\n    \n    return result + decimals;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ozrh10z.d(21): Error: no property `f` for type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ozrh10z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart;\n\
    \    float decimalPart;\n    \n    intPart = (int) number;\n    decimalPart =\
    \ number - intPart;\n    \n    return decimalPart;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3u_51mru.d(18): Error: C style cast illegal, use `cast(int)number`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3u_51mru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0)\n   \
    \ {\n        remainder = truncate_number(decimalPart);\n    }\n    else\n    {\n\
    \        remainder = 0;\n    }\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164423
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(result > 1)\n    {\n      \
    \  remainder = (result % 1);\n        result = floorf(result / 1);\n        if(remainder\
    \ > 0)\n        {\n            result += 1;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5k3cf59.d(21): Error: undefined identifier `floorf`, did you mean
    function `floor`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5k3cf59.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfs1iqaut.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfs1iqaut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = trunc(frac_part);\n\
    \    return int_part + frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2oxw0rd.d(17): Error: cannot implicitly convert expression `trunc(cast(real)frac_part)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2oxw0rd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbrlvb_hb.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpbrlvb_hb.__unittest_L23_C1() [0x427a7e]

    ??:? void tmpbrlvb_hb.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integerPart;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy60b1xen.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy60b1xen.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int intPart\
    \ = (long) number;\n    long int decimalPart = (intPart % 1);\n    intPart /=\
    \ 1;\n    \n    return (float) decimalPart;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpndx9w6re.d(15): Error: no identifier for declarator `long`

    /tmp/tmpndx9w6re.d(15): Error: C style cast illegal, use `cast(long)number`

    /tmp/tmpndx9w6re.d(16): Error: no identifier for declarator `long`

    /tmp/tmpndx9w6re.d(19): Error: C style cast illegal, use `cast(float)decimalPart`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpndx9w6re.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9cp76ppy.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmp9cp76ppy.__unittest_L29_C1() [0x427af6]

    ??:? void tmp9cp76ppy.__modtest() [0x427b64]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnvamk5ti.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnvamk5ti.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpucbueujz.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpucbueujz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integer;\n    float remainder_float;\n    float\
    \ decimal_part;\n    float decimal_part_float;\n    float decimal_part_float2;\n\
    \    float decimal_part_float3;\n    float decimal_part_float4;\n    float decimal_part_float5;\n\
    \    float decimal_part_float6;\n    float decimal_part_float7;\n    float decimal_part_float8;\n\
    \    float decimal_part_float9;\n    float decimal_part_float10;\n    float decimal_part_float11;\n\
    \    float decimal_part_float12;\n    float decimal_part_float13;\n    float decimal_part_float14;\n\
    \    float decimal_part_float15;\n    float decimal_part_float16;\n    float decimal_part_float17;\n\
    \    float decimal_part_float18;\n    float decimal_part_float19;\n    float decimal_part_float20;\n\
    \    float decimal_part_float21;\n    float decimal_part_float22;\n    float decimal_part_float23;\n\
    \    float decimal_part_float24;\n    float decimal_part_float25;\n    float decimal_part_float26;\n\
    \    float decimal_part_float27;\n    float decimal_part_float28;\n    float decimal_part_float29;\n\
    \    float decimal_part_float30;\n    float decimal_part_float31;\n    float decimal_part_float32;\n\
    \    float decimal_part_float33;\n    float decimal_part_float34;\n    float decimal_part_float35;\n\
    \    float decimal_part_float36;\n    float decimal_part_float37;\n    float decimal_part_float38;\n\
    \    float decimal_part_float39;\n    float decimal_part_float40;\n    float decimal_part_float41;\n\
    \    float decimal_part_float42;\n    float decimal_part_float43;\n    float decimal_part_float44;\n\
    \    float decimal_part_float45;\n    float decimal_part_float46;\n    float decimal_part_float47;\n\
    \    float decimal_part_float48;\n    float decimal_part_float49;\n    float decimal_part_float50;\n\
    \    float decimal_part_float51;\n    float decimal_part_float52;\n    float decimal_part_float53;\n\
    \    float decimal_part_float54;\n    float decimal_part_float55;\n    float decimal_part_float56;\n\
    \    float decimal_part_float57;\n    float decimal_part_float58;\n    float decimal_part_float59;\n\
    \    float decimal_part_float60;\n    float decimal_part_float61;\n    float decimal_part_float62;\n\
    \    float decimal_part_float\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5agc5ncv.d(83): Error: semicolon expected, not `unittest`

    /tmp/tmp5agc5ncv.d(83): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5agc5ncv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float result = 0.0;\n    float remainder;\n    int exponent;\n \
    \   \n    exponent = std.math.frexp(number, &remainder);\n    \n    if (exponent\
    \ == 0)\n    {\n        result = number;\n    }\n    else\n    {\n        float\
    \ exponent2 = exponent - 1;\n        float exponent3 = exponent - 2;\n       \
    \ float exponent4 = exponent - 3;\n        float exponent5 = exponent - 4;\n \
    \       float exponent6 = exponent - 5;\n        float exponent7 = exponent -\
    \ 6;\n        float exponent8 = exponent - 7;\n        float exponent9 = exponent\
    \ - 8;\n        float exponent10 = exponent - 9;\n        float exponent11 = exponent\
    \ - 10;\n        float exponent12 = exponent - 11;\n        float exponent13 =\
    \ exponent - 12;\n        float exponent14 = exponent - 13;\n        float exponent15\
    \ = exponent - 14;\n        float exponent16 = exponent - 15;\n        float exponent17\
    \ = exponent - 16;\n        float exponent18 = exponent - 17;\n        float exponent19\
    \ = exponent - 18;\n        float exponent20 = exponent - 19;\n        float exponent21\
    \ = exponent - 20;\n        float exponent22 = exponent - 21;\n        float exponent23\
    \ = exponent - 22;\n        float exponent24 = exponent - 23;\n        float exponent25\
    \ = exponent - 24;\n        float exponent26 = exponent - 25;\n        float exponent27\
    \ = exponent - 26;\n        float exponent28 = exponent - 27;\n        float exponent29\
    \ = exponent - 28;\n        float exponent30 = exponent - 29;\n        float exponent31\
    \ = exponent - 30;\n        float exponent32 = exponent - 31;\n        float exponent33\
    \ = exponent - 32;\n        float exponent34 = exponent - 33;\n        float exponent35\
    \ = exponent - 34;\n        float exponent36 = exponent - 35;\n        float exponent37\
    \ = exponent - 36;\n        float exponent38 = exponent - 37;\n        float exponent39\
    \ = exponent - 38;\n        float exponent40 = exponent - 39;\n        float exponent41\
    \ = exponent - 40;\n        float exponent42 = exponent - 41;\n        float exponent43\
    \ = exponent - 42;\n        float exponent44 = exponent - 43;\n        float exponent45\
    \ = exponent - 44;\n        float exponent46 = exponent - 45;\n        float exponent47\
    \ = exponent - 46;\n        float exponent48 = exponent - 47;\n        float exponent49\
    \ = exponent - 48;\n        float \nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_2os1cqz.d(77): Error: no identifier for declarator `float`

    /tmp/tmp_2os1cqz.d(77): Error: found `unittest` instead of statement

    /tmp/tmp_2os1cqz.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_2os1cqz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpno54i81e.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpno54i81e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51gaju8x.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51gaju8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt79qbljw.d(19): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt79qbljw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part = number - truncate_number(number);\n    \n    integer_part\
    \ = int(number);\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpave6az8e.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpave6az8e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float quotient;\n    float temp;\n    int\
    \ exponent;\n    int decimal_place;\n    int decimal_place_index;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_length;\n    int decimal_part_length;\n    int decimal_part_length;\n\
    \    int decimal_part_\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdlja52oo.d(117): Error: semicolon expected, not `unittest`

    /tmp/tmpdlja52oo.d(117): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdlja52oo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9ydeszw.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9ydeszw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(number > 0.0) {\n    \
    \    number = number - int(number);\n        decimals = decimals + 1;\n    }\n\
    \    \n    return result + decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3bgteyc4.d(19): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3bgteyc4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp442fdi53.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp442fdi53.d(15): Error: no identifier for declarator `long`

    /tmp/tmp442fdi53.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    /tmp/tmp442fdi53.d(16): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp442fdi53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    int decimal_part_length;\n\
    \    int i;\n    \n    integer_part = trunc(number);\n    \n    decimal_part_length\
    \ = number_digits(number);\n    \n    decimal_part = number - integer_part;\n\
    \    \n    remainder = decimal_part % 1;\n    \n    if (remainder > 0)\n    {\n\
    \        decimal_part += 1;\n    }\n    \n    return integer_part + decimal_part\
    \ * pow(10.0, decimal_part_length);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgk51g_9k.d(21): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    /tmp/tmpgk51g_9k.d(23): Error: undefined identifier `number_digits`

    /tmp/tmpgk51g_9k.d(25): Error: cannot implicitly convert expression `number -
    cast(float)integer_part` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgk51g_9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzf495lct.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzf495lct.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd9ahb15u.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    /tmp/tmpd9ahb15u.d(21): Error: cannot implicitly convert expression `number -
    cast(float)integer_part` of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9ahb15u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfs1iqaut.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfs1iqaut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integer_part;\n    float decimal_part;\n    \n    integer_part = floor(number);\n\
    \    \n    if (number - integer_part > 0.5) \n    {\n        decimal_part = number\
    \ - integer_part;\n        remainder = floor(decimal_part * 1000.0f);\n    }\n\
    \    else \n    {\n        decimal_part = floor(number - integer_part);\n    \
    \    remainder = 0;\n    }\n    \n    return remainder + decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo1lz3t_a.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x427f4d]

    ??:? void tmpo1lz3t_a.__unittest_L34_C1() [0x427c5e]

    ??:? void tmpo1lz3t_a.__modtest() [0x427ccc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bdb7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ac4a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fddd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43028c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd69]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ac21]

    ??:? runModuleUnitTests [0x42bb8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp19safidf.d(15): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19safidf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart\
    \ = number - int(number);\n    float integerPart = number - decimalPart;\n   \
    \ return decimalPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5peaaz_a.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5peaaz_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80oqstyp.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80oqstyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7pshi33t.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pshi33t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    float remainder;\n    \n    int exponent = std::frexp(number,\
    \ &remainder);\n    \n    if (exponent == 0)\n    {\n        result = remainder;\n\
    \    }\n    else\n    {\n        result *= std::pow(10.0, -exponent);\n      \
    \  result += remainder;\n    }\n    \n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcomz3sap.d(19): Error: semicolon expected, not `:`

    /tmp/tmpcomz3sap.d(19): Error: found `:` instead of statement

    /tmp/tmpcomz3sap.d(27): Error: found `:` when expecting `;` following statement

    /tmp/tmpcomz3sap.d(27): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcomz3sap.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ehw0q0_.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ehw0q0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpno54i81e.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpno54i81e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4g93yv36.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmp4g93yv36.__unittest_L27_C1() [0x427ade]

    ??:? void tmp4g93yv36.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    \n    quotient = number / float(10);\
    \ // integer part\n    remainder = number % float(10); // decimal part\n    decimals\
    \ = remainder / float(10); // decimal part\n    \n    return quotient + decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf6n2pb_t.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpf6n2pb_t.__unittest_L25_C1() [0x427ac6]

    ??:? void tmpf6n2pb_t.__modtest() [0x427b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5mazgg8o.d(18): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mazgg8o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgepos4b.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgepos4b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 1;\n        number = number / 1;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164422
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_lohxv1c.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_lohxv1c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part = number - truncate_number(truncate_number(number));\n\
    \    int_part = trunc(number);\n    return decimal_part + int_part;\n}\n/*\n Given\
    \ a positive floating point number, it can be decomposed into\n    and integer\
    \ part (largest integer smaller than given number) and decimals\n    (leftover\
    \ part always smaller than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqvsvosd3.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqvsvosd3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164408
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float intPart;\n    float decimalPart;\n    \n    intPart = trunc(number);\n\
    \    decimalPart = number - intPart;\n    \n    if (decimalPart > 0)\n    {\n\
    \        remainder = trunc(decimalPart);\n    }\n    else\n    {\n        remainder\
    \ = 0;\n    }\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiun6uund.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e7d]

    ??:? void tmpiun6uund.__unittest_L33_C1() [0x427b92]

    ??:? void tmpiun6uund.__modtest() [0x427c00]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430090]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa25]

    ??:? runModuleUnitTests [0x42b991]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282cc]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate'
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ehw0q0_.d(15): Error: cannot implicitly convert expression `number`
    of type `float` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ehw0q0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1.0f) {\n        result = result / 10.0f;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplxk2hpa6.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmplxk2hpa6.__unittest_L23_C1() [0x427a7e]

    ??:? void tmplxk2hpa6.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164409
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqucfx4r.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`
    of type `real` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqucfx4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164407
