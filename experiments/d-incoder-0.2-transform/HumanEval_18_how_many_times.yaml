name: HumanEval_18_how_many_times
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string.compare(i, substring.length(), substring) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (case_sensitive)\n\t\t{\n\t\t\tif (string.compare(i, substring.length(),\
    \ substring) == 0)\n\t\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (string.compare(i,\
    \ substring.length(), substring, true) == 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\"\
    )\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case) \n{\n\tlong count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++)\n\t{\n\t\tif (case_sensitive)\n\t\t{\n\t\t\t\
    if (ignore_case)\n\t\t\t{\n\t\t\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (string.compare(i,\
    \ substring.length(), substring, true) == 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tif (ignore_case)\n\t\t\t{\n\t\t\t\tif (string.compare(i,\
    \ substring.length(), substring, true) == 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\
    \telse\n\t\t\t{\n\t\t\t\tif (string.compare(i, substring.length(), substring,\
    \ true) == 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, bool case_sensitive,\
    \ bool ignore_case, bool ignore_", "{\n\tlong count = 0;\n\tfor (int i = 0; i\
    \ < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length(); j++)\
    \ {\n\t\t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end;\
    \ i++) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\
    \t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> ",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long length = 0;\n    \n    while(start < string.length)\n    {\n       \
    \ end = string.find(substring, start);\n        if(end == string.length)\n   \
    \     {\n            count++;\n            start = string.length + 1;\n      \
    \  }\n        else\n        {\n            length = end - start;\n           \
    \ count += length;\n            start = end + 1;\n        }\n    }\n    return\
    \ count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    size_t subpos = 0;\n        \n        while (subpos < sublen) {\n       \
    \     if (string.compare(pos, subpos, sublen, substring) == 0) {\n           \
    \     count++;\n                subpos += sublen;\n            }\n           \
    \ else {\n                subpos++;\n            }\n        }\n        \n    \
    \    pos++;\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n   \
    \ for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(string.charAt(i) ==\
    \ substring.charAt(0))\n        {\n            count++;\n            \n      \
    \      for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count++;\n \
    \               }\n            }\n        }\n    }\n    \n    return count;\n}",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        for(int j = 0; j < substring.length(); j++)\n        {\n       \
    \     if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if the substring appears more than once in the\
    \ string. For example, the string \"aaa\" and the substring \"aa\" will give the\
    \ wrong answer.\n<|/ c |>\n<| c |>\n: I fixed the bug and added a test case.\n\
    <|/ c |>\n<| c |>\n: I added a test case that shows the bug is fixed.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This solution doesn't work for \"aaaaa\" with \"aaa\".\n<|/ c |>\n<| c |>\n: It\
    \ does work, try it out. `how_many_times(\"aaaaa\", \"aa\")` returns `3L`.\n<|/\
    \ c |>\n<| c |>\n: Yes, it does. Try it out yourself. `how_many_times(\"aaaaa\"\
    , \"aa\")` returns `3L`.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it out yourself.\
    \ `how_many_times(\"aaaaa\", \"aa\")` returns `3L`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ it does. Try it out yourself. `how_many_times(\"aaaaa\", \"aa\")` returns `3L`.\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;", "{\n    long count = 0;\n    \n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length())\
    \ == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    \n    for(int i = 0; i < string.length(); i++) {\n        if(string.substr(i,\
    \ substring.length()) == substring) {\n            count++;\n        }\n    }\n\
    \    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.substr(i, substring.length()) == substring)\n\t\t\
    {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start) \n{\n   \
    \ long count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        for(int j = 0; j < substring.length(); j++)\n\
    \        {\n            if(string[i] == substring[j])\n            {\n       \
    \         count++;\n                break;\n            }\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_man", "{\n\tlong count = 0;\n\tfor (auto it = string.begin();\
    \ it != string.end(); ++it) {\n\t\tif (*it == substring[0]) {\n\t\t\tcount +=\
    \ how_many_times(string.substr(1, string.size() - 1), substring);\n\t\t}\n\t\t\
    else if (*it == substring[1]) {\n\t\t\tcount += how_many_times(string.substr(0,\
    \ string.size() - 1), substring);\n\t\t}\n\t\telse if (*it == substring[2]) {\n\
    \t\t\tcount += how_many_times(string.substr(1, string.size() - 1), substring);\n\
    \t\t}\n\t\telse if (*it == substring[3]) {\n\t\t\tcount += how_many_times(string.substr(0,\
    \ string.size() - 1), substring);\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that occurs more than\
    \ once in the original string. For example, `how_many_times(\"aaa\", \"a\")` returns\
    \ `3` instead of `2`.\n<|/ c |>\n<| c |>\nYes, you are right. I missed that case.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThe code doesn't work for `how_many_times(\"\
    aaa\", \"aa\")` because `string.compare(i, substring.length(), substring, 0, substring.length())`\
    \ returns `0` when `i` is `0` and `substring.length()` is `2`.\n<|/ c |>\n<| c\
    \ |>\nYes, you are right. I missed that case. Thanks for pointing it out.\n<|/\
    \ c |>\n<| a tags=string,c++,algorithm |>\n<code>", "{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(long i = 0; i < len; i++)\n    {\n        for(long j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long length = string.length();\n    long substringLength\
    \ = substring.length();\n    \n    while (start < length) {\n        end = start\
    \ + substringLength;\n        if (end > length) {\n            end = length;\n\
    \        }\n        if (string.substring(start, end).equals(substring)) {\n  \
    \          count++;\n            start = end;\n        }\n        else {\n   \
    \         start = end;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis doesn't work if you have a string like \"aba\" and a substring\
    \ like \"ab\"\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out.\
    \ Now it works.\n<|/ c |>\n<| a tags=java,string |>\n<code>\npublic static int\
    \ countSubString(String str, String subStr) {\n    int count = 0;\n    int start\
    \ = 0;\n    int end = 0;\n    int length = str.length();\n    int substringLength\
    \ = subStr.length();", "{\n    long count = 0;\n    long start = 0;\n    long\
    \ end = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    while(start < len) {\n        end = start + sublen;\n        if(string.compare(start,\
    \ sublen, substring, 0, sublen) == 0) {\n            count++;\n            start\
    \ = end + 1;\n        }\n        else if(string.compare(start, sublen, substring,\
    \ sublen, 0) == 0) {\n            count++;\n            start = end + sublen;\n\
    \        }\n        else {\n            start++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,algorithm,c++,substring |>\n<| c |>\n\
    This code doesn't work for \"aaa\" and \"aa\". Your code returns 2 instead of\
    \ 1.\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing it out.\
    \ I've updated the code.\n<|/ c |>\n<| c |>\nThis code doesn't work for \"aaa\"\
    \ and \"aa\". Your code returns 2 instead of 1.\n<|/ c |>\n<| c |>\nYes, I missed\
    \ that case. Thanks for pointing it out. I've updated the code.\n<|/ c |>\n<|\
    \ a dscore=5 |>\nA simple solution in C++:\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\n#include <cstring>", "{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(long i = 0; i < len; ++i)\n    {\n        for(long j = 0; j < sublen;\
    \ ++j)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                ++count;\n                break;\n            }\n        }\n\
    \    }\n    \n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThe `break` statement\
    \ is redundant here. The `for` loop will stop after it finds a match.\n<|/ c |>\n\
    <| c |>\nYes, but it's easier to read and understand if you break out of the inner\
    \ loop as soon as you find a match. Also, it makes it easier to add additional\
    \ conditions later on.\n<|/ c |>\n<| c |>\nI agree with you, it's easier to read,\
    \ but I find it more readable with breaks than nested loops.\n<|/ c |>\n<| c |>\n\
    I agree with you too, but I find it easier to read with breaks than nested loops.\
    \ I find it easier to read and understand with breaks than nested loops.\n<|/\
    \ c |>\n<| c |>\nI agree with you too, but I find it easier to read with breaks\
    \ than nested loops. I find it easier to read and understand with breaks than\
    \ nested loops.\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic int countOccurrences(String\
    \ str, String sub) {\n    int count = 0;\n    int len = str.length();\n    int\
    \ sublen = sub.length();\n    int i = 0;\n    int j = 0;\n    while (i < len)\
    \ {\n        while (j < sublen) {\n            if (str.charAt(i) == sub.charAt(j))\
    \ {\n                count++;\n                j++;\n            } else {\n  \
    \              j++;\n            }\n        }\n        i++;\n        j = 0;\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,java |>\n<| a tags=string,java\
    \ |>\n<code>\npublic int countOccurrences(String str, String sub) {\n    int count\
    \ = 0;\n    int len = str.length();\n    int sublen = sub.length();\n    int i\
    \ = 0;\n    int j = 0;\n    while (i < len) {\n        while (j < sublen) {\n\
    \            if (str.charAt(i) == sub.charAt(j)) {\n                count++;\n\
    \                j++;\n            } else {\n                j++;\n          \
    \  }\n        }\n        i++;\n        j = 0;\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,java |>\n<code>\npublic int countOccurrences(String\
    \ str, String sub) {\n    int count = 0;", "{\n\tlong count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()).equals(substring))\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n    long len\
    \ = string.length();\n    long sublen = substring.length();\n    \n    for(int\
    \ i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen; j++)\n     \
    \   {\n            if(string[i] == substring[j])\n            {\n            \
    \    count++;\n            }\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, bool case_insensitive)\
    \ \n{\n    long count = 0;\n    long len = string.length();\n    long sublen =\
    \ substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n       \
    \ for(int j = 0; j < sublen; j++)\n        {\n            if(case_insensitive)\n\
    \            {\n                if(string[i] == substring[j])\n              \
    \  {\n                    count++;\n                }\n            }\n       \
    \     else\n            {\n                if(string[i].tolower() == substring[j])\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, bool case_insensitive, bool\
    \ ignore_case) \n{\n    long count = 0;\n    long len = string.length();\n   \
    \ long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        for(int j = 0; j < sublen; j++)\n        {\n            if(case_insensitive\
    \ && ignore_case)\n            {\n                if(string[i] == substring[j])\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n            else\n            {\n                if(string[i] == substring[j])\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n \
    \   \n    foreach(char c in substring) \n    {\n        foreach(char c2 in string)\
    \ \n        {\n            if (c == c2) \n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis is not the most efficient solution. `std::count_if` will do\
    \ better than this.\n<|/ c |>\n<| c |>\n: I agree, `std::count_if` would be better.\
    \ But the OP asked for an efficient solution and I wanted to show how to do it\
    \ with loops.\n<|/ c |>\n<| c |>\nI agree that `std::count_if` would be better,\
    \ but I wanted to show how to do it with loops.\n<|/ c |>\n<| c |>\n: I added\
    \ a loop-based solution to my answer.\n<|/ c |>\n<| c |>\n: I added a loop-based\
    \ solution to my answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\
    \tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t{\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\
    \t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i+=step)\n\t{\n\
    \t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()) ==\
    \ substring)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    \n    for(int i = start; i\
    \ < end; i++) {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0) {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    \n    for(int i\
    \ = start; i < end; i += step) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This is not the best solution. `string.compare(i, substring.length(), substring,\
    \ 0, substring.length())` will compare the whole string with substring and `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.compare(i,\
    \ substring.length(), substring, 0, substring.length())` will compare the whole\
    \ string with substring and substring with substring and so on. `string.", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport\
    \ java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nThis does not provide an answer to\
    \ the question. To critique or request clarification from an author, leave a comment\
    \ below their post.\n<|/ c |>\n<| c |>\nThe question was \"How many times a given\
    \ substring can be found in the original string. Count overlaping cases.\" The\
    \ code I posted does exactly that. How does it not answer the question?\n<|/ c\
    \ |>\n<| c |>\nThe question was \"How many times a given substring can be found\
    \ in the original string. Count overlaping cases.\" The code I posted does exactly\
    \ that. How does it not answer the question?\n<|/ c |>\n<| c |>\nThe code you\
    \ posted does not answer the question. The question was \"How many times a given\
    \ substring can be found in the original string. Count overlaping cases.\" The\
    \ code you posted does exactly that. How does it not answer the question?\n<|/\
    \ c |>\n<| c |>\nThe code I posted does exactly that. How does it not answer the\
    \ question?\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis doesn't work if the substring appears more than once in the\
    \ string. For example, `how_many_times(\"aaaa\", \"aa\")` returns `3` instead\
    \ of `2`.\n<|/ c |>\n<| c |>\nI didn't notice that case. Thanks for pointing it\
    \ out. I've updated the code accordingly.\n<|/ c |>\n<| a tags=string,algorithm,c++\
    \ |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>", "{\n    long count = 0;\n    long pos = 0;\n    \n    while(pos\
    \ < string.length())\n    {\n        if(string.find(substring, pos) != string::npos)\n\
    \        {\n            count++;\n            pos = string.find(substring, pos)\
    \ + substring.length();\n        }\n        else\n        {\n            pos =\
    \ string.length();\n        }\n    }\n    \n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start) \n{\n   \
    \ long count = 0;\n    long pos = start;\n    \n    while(pos < string.length())\n\
    \    {\n        if(string.find(substring, pos) != string::npos)\n        {\n \
    \           count++;\n            pos = string.find(substring, pos) + substring.length();\n\
    \        }\n        else\n        {\n            pos = string.length();\n    \
    \    }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long pos = start;\n    \n\
    \    while(pos < string.length())\n    {\n        if(string.find(substring, pos)\
    \ != string::npos)\n        {\n            count++;\n            pos = string.find(substring,\
    \ pos) + substring.length();\n        }\n        else\n        {\n           \
    \ pos = string.length();\n        }\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end,\
    \ long step) \n{\n    long count = 0;\n    long pos = start;\n    \n    while(pos\
    \ < string.length())\n    {\n", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0) {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring) == 0) {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++) {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0) {\n            count++;\n        }\n  \
    \  }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string pattern) \n{\n    ", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = 1; j < sublen; j++)\n            {\n                if(string[i + j] !=\
    \ substring[j])\n                    break;\n            }\n            \n   \
    \         if(j == sublen)\n                count++;\n        }\n    }\n    \n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    The `substring` argument should be `const` since it won't be modified by the function.\n\
    <|/ c |>\n<| c |>\nThanks, I fixed it.\n<|/ c |>\n<| c |>\nThis algorithm is O(n^2)\
    \ because of the nested loops. A better algorithm is O(n).\n<|/ c |>\n<| c |>\n\
    Yes, I agree. But the OP asked for O(n) solution, so I wrote it like that.\n<|/\
    \ c |>\n<| c |>\nThis algorithm is O(n^2) because of the nested loops. A better\
    \ algorithm is O(n).\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tif (string[i] == substring[0])\
    \ \n\t\t{\n\t\t\tfor (int j = 1; j < substring.size(); j++)\n\t\t\t{\n\t\t\t\t\
    if (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\t\
    break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n\
    }", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\
    \tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, string substring2) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t{\n\t\t\tif\
    \ (string.compare(i + substring.length(), string.length(), substring2, 0, substring2.length())\
    \ == 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tif (string.compare(i + substring.length(), string.length(),\
    \ substring2, 0, substring2.length()) == 0)\n\t\t\t{\n\t\t\t\tif (string.compare(i\
    \ + substring2.length(), string.length(), substring3, 0, substring3.length())\
    \ == 0)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3, string substring4) \n{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n\t\t{\n\t\t\tif (string.compare(i + substring.length(),\
    \ string.length(), substring", "{\n    long count = 0;\n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\nThis is not\
    \ the best solution. `string.compare(i, substring.length(), substring) == 0` will\
    \ take O(n) time where n is the length of the string. Instead, `string.find(substring)\
    \ != string::npos` will take O(logn) time.\n<|/ c |>\n<| c |>\nYes, I agree with\
    \ you. But the question was about how to implement the algorithm, not about how\
    \ to optimize it.\n<|/ c |>\n<| c |>\nI agree with you. But the question was about\
    \ how to implement the algorithm, not about how to optimize it.\n<|/ c |>\n<|\
    \ a tags=c++,string,algorithm |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\
    \ \n    {\n        for(int j = 0; j < sublen; j++) \n        {\n            if(string[i]\
    \ == substring[j]) \n            {\n                count++;\n            }\n\
    \        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start) \n{\n    long count\
    \ = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = start; i < len; i++) \n    {\n        for(int j = 0; j\
    \ < sublen; j++) \n        {\n            if(string[i] == substring[j]) \n   \
    \         {\n                count++;\n            }\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = start; i < end;\
    \ i++) \n    {\n        for(int j = 0; j < sublen; j++) \n        {\n        \
    \    if(string[i] == substring[j]) \n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n    long count = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    for(int i = start; i < end; i+=step) \n   \
    \ {\n        for(int j = 0; j < ", "{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"a\"\
    , \"a\", 0)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    3L\n    >>>\
    \ how_many_times(\"aaaa\", \"aa\", 0)\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\", 0, 2)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    3L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0, 2)\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2, 1)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", 0, 2, 1)\n    3", "{\n    long count = 0;\n    long pos = 0;\n \
    \   long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while (pos < len) {\n        pos = string.find(substring, pos);\n       \
    \ if (pos == string.length())\n            break;\n        \n        count +=\
    \ 1;\n        pos += sublen;\n    }\n    \n    return count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"\
    a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n\
    \    long pos = 0;\n    while(pos < string.length()) {\n        pos = string.find(substring,\
    \ pos);\n        if(pos == string.length())\n            break;\n        count++;\n\
    \        pos = pos + 1;\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, long start) \n{\n    long\
    \ count = 0;\n    long pos = start;\n    while(pos < string.length()) {\n    \
    \    pos = string.find(substring, pos);\n        if(pos == string.length())\n\
    \            break;\n        count++;\n        pos = pos + 1;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long pos = start;\n    while(pos\
    \ < string.length()) {\n        pos = string.find(substring, pos);\n        if(pos\
    \ == string.length())\n            break;\n        count++;\n        pos = pos\
    \ + 1;\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    long pos = start;\n\
    \    while(pos < string.length()) {\n        pos = string.find(substring, pos);\n\
    \        if(pos == string.length())\n            break;\n        count++;\n  \
    \      pos = pos + step;\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aa", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    \n    for(int i\
    \ = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    \n    while(end < string.length)\n    {\n     \
    \   start = string.find(substring, start);\n        if(start == string.length)\n\
    \        {\n            count++;\n            end = string.length + 1;\n     \
    \   }\n        else\n        {\n            end = start + 1;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This code doesn't work if the substring appears more than once in the string.\
    \ For example, how_many_times(\"aaaa\", \"aa\") returns 3 instead of 2.\n<|/ c\
    \ |>\n<| c |>\nYes, I forgot about that case. Thanks for pointing it out. I've\
    \ fixed the code now.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    foreach(char c in substring) \n    {\n        foreach(char c2\
    \ in string) \n        {\n            if (c == c2) \n            {\n         \
    \       count++;\n            }\n        }\n    }\n    \n    return count;\n}",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include\
    \ <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>", "{\n\tlong\
    \ count = 0;\n\tfor (int i = 0; i < string.size(); ++i)\n\t{\n\t\tif (string[i]\
    \ == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.size(); ++j)\n\
    \t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < string.size(); ++i)\n\t{\n\t\tif (string[i]\
    \ == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.size(); ++j)\n\
    \t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n\tlong count = 0;\n\tfor (int i = start; i < end; ++i)\n\t{\n\t\tif (string[i]\
    \ == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.size(); ++j)\n\
    \t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\t++count;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step)\n\t\
    {\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.size();\
    \ ++j)\n\t\t\t{\n\t\t\t\tif (string[i + j", "{\n    long count = 0;\n    long\
    \ start = 0;\n    long end = 0;\n    long len = 0;\n    \n    len = string.length();\n\
    \    end = len-1;\n    \n    while(start < end) {\n        while(start < end &&\
    \ string.charAt(start) == substring.charAt(0)) start++;\n        while(start <\
    \ end && string.charAt(end) == substring.charAt(len-1)) end--;\n        \n   \
    \     if(start < end) {\n            count++;\n            start = end;\n    \
    \    }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = 0;\n    \n    len = string.length();\n    end = len-1;\n    \n\
    \    while(start < end) {\n        while(start < end && string.charAt(start) ==\
    \ substring.charAt(0)) start++;\n        while(start < end && string.charAt(end)\
    \ == substring.charAt(len-1)) end--;\n        \n        if(start < end) {\n  \
    \          count++;\n            start = end;\n        }\n    }\n    \n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\", 0)\n  \
    \  0L\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    0L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", 0)\n    0L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, int start, int end) \n{\n    long count = 0;\n    long start = 0;\n\
    \    long end = 0;\n    long len = 0;\n    \n    len = string.length();\n    end\
    \ = len-1;\n    \n    while(start < end) {\n        while(start < end && string.charAt(start)\
    \ == substring.charAt(0)) start++;\n        while(start < end && string.charAt(end)\
    \ == substring.charAt(len-1)) end--;\n        \n        if(start < end) {\n  \
    \          count++;\n            start = end;\n        }\n    }\n    \n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> ", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long length = 0;\n    \n    while(end < string.length)\n\
    \    {\n        length = string.length() - end;\n        \n        if(string.compare(end,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n            end = end + substring.length();\n        }\n \
    \       else\n        {\n            end = end + length;\n        }\n    }\n \
    \   \n    return count;\n}", "{\n    long count = 0;\n    \n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    \n    foreach(char c in substring)\n    {\n        foreach(char c2\
    \ in string)\n        {\n            if(c == c2)\n            {\n            \
    \    count++;\n            }\n        }\n    }\n    \n    return count;\n}", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.compare(i, substring.length(), substring) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"\
    a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    long start = 0;\n    long end = 0;\n    long len = 0;\n    \n    len\
    \ = string.length();\n    end = len-1;\n    \n    while(start < len) {\n     \
    \   while(end >= 0 && string.at(end) == substring.at(start)) {\n            end--;\n\
    \        }\n        \n        if(end >= 0) {\n            count++;\n         \
    \   start = end + 1;\n        }\n        else {\n            start = end;\n  \
    \      }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work for \"aaa\" and \"aa\" because you only count\
    \ the first \"a\" in the first \"aaa\".\n<|/ c |>\n<| c |>\n: Yes, I missed that\
    \ case. Thanks for pointing it out. I've updated the code.\n<|/ c |>\n<| a |>\n\
    <code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\
    \ {\n        if(string.substr(i, substring.length()) == substring) {\n       \
    \     count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis is not the most efficient solution, since it does a lot of\
    \ unnecessary comparisons. For example, `how_many_times(\"aaaa\", \"aa\")` returns\
    \ `3`, but `how_many_times(\"aaaa\", \"aaa\")` returns `2`.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. My solution was just to show a way to solve the problem with\
    \ minimum comparisons. I edited my answer to show a more efficient solution.\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\nusing namespace std;", "{\n    long count =\
    \ 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(long i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(long j = 1; j < sublen; j++)\n            {\n    \
    \            if(string[i + j] != substring[j])\n                {\n          \
    \          break;\n                }\n            }\n            \n          \
    \  if(j == sublen)\n            {\n                count++;\n            }\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int\
    \ i = 0; i < string.size(); i++)\n\t{\n\t\tif (string[i] == substring[0])\n\t\t\
    {\n\t\t\tfor (int j = 1; j < substring.size(); j++)\n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \tcount += j - 1;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(string.charAt(i) == substring.charAt(0))\n\
    \        {\n            count += how_many_times(string.substring(1, i), substring);\n\
    \        }\n        else if(string.charAt(i) == substring.charAt(sublen-1))\n\
    \        {\n            count += how_many_times(string.substring(0, i), substring);\n\
    \        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long len\
    \ = string.length();\n    long sublen = substring.length();\n    \n    for(int\
    \ i = 0; i < len; i++)\n    {\n        if(string.substr(i, sublen) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    long start = 0;\n    long end = 0;\n    long length\
    \ = 0;\n    \n    for(auto c : string)\n    {\n        if(c != substring[start])\n\
    \        {\n            start = end;\n        }\n        else\n        {\n   \
    \         count++;\n        }\n        \n        end++;\n    }\n    \n    for(auto\
    \ c : string)\n    {\n        if(c != substring[end])\n        {\n           \
    \ end = length;\n        }\n        else\n        {\n            length++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int\
    \ i = 0; i < string.length(); i++)\n\t{\n\t\tfor (int j = 0; j < substring.length();\
    \ j++)\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(j))\n\t\t\t{\n\t\
    \t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tfor\
    \ (int j = 0; j < substring.length(); j++)\n\t\t{\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n\tlong count = 0;\n\tfor (int i =\
    \ 0; i < string.length(); i++)\n\t{\n\t\tfor (int j = 0; j < substring.length();\
    \ j++)\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(j))\n\t\t\t{\n\t\
    \t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3, string substring4) \n{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++)\n\t{\n\t\tfor (int j = 0; j < substring.length(); j++)\n\
    \t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(j))\n\t\t\t{\n\t\t\t\tcount++;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count ", "{\n    long\
    \ count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis is not the most\
    \ efficient solution, since it requires O(n^2) time complexity. Using a hash table\
    \ would improve the time complexity to O(n).\n<|/ c |>\n<| c |>\nYes, I agree\
    \ with you. Hash table would be the best solution. Thanks for pointing out.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <vector>\n#include <algorithm>\nusing namespace std;", "{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen\
    \ = substring.length();\n    \n    while (pos < len) {\n        pos = string.find(substring,\
    \ pos);\n        if (pos == string.length())\n            break;\n        \n \
    \       count += 1;\n        pos += sublen;\n    }\n    \n    return count;\n}",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif\
    \ (string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    pos = string.find(substring, pos);\n        if (pos == string.length())\n\
    \            break;\n        \n        if (pos == 0)\n            count++;\n \
    \       \n        count += 1;\n        pos += sublen;\n    }\n    \n    return\
    \ count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if `substring`\
    \ appears more than once in `string`.\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ I missed that case. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if `substring` appears more than once in `string`.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I missed that case. Thanks for pointing it out.\n<|/ c |>\n\
    <| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    \n    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| a |>\nI wrote a solution in\
    \ Python that uses no loops and is O(n) where n is the length of the string. \n\
    <code>\ndef count_substring(string, substring):\n    count = 0\n    i = 0\n  \
    \  while i < len(string):\n        if string[i:i+len(substring)] == substring:\n\
    \            count += 1\n        i += len(substring)\n    return count\n</code>\n\
    <|/ a tags=string,algorithm,c++ dscore=2 |>\n<| a tags=string,algorithm,c++ |>\n\
    <code>\n#include <iostream>\n#include <string>\nusing namespace std;", "{\n  \
    \  long count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n \
    \   size_t sublen = substring.length();\n    \n    while (pos < len) {\n     \
    \   size_t subpos = 0;\n        \n        while (subpos < sublen) {\n        \
    \    if (string[pos] == substring[subpos]) {\n                subpos++;\n    \
    \        }\n            else {\n                break;\n            }\n      \
    \  }\n        \n        if (subpos == sublen) {\n            count++;\n      \
    \      pos++;\n        }\n    }\n    \n    return count;\n}", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\nusing namespace std;", "{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        for(int j = 0; j < substring.length(); j++)\
    \ {\n            if(string[i] == substring[j]) {\n                count++;\n \
    \           }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\"\
    , \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, bool case_sensitive) \n{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ for(int j = 0; j < substring.length(); j++) {\n            if(case_sensitive)\
    \ {\n                if(string[i] == substring[j]) {\n                    count++;\n\
    \                }\n            } else {\n                if(string[i].toLower()\
    \ == substring[j].toLower()) {\n                    count++;\n               \
    \ }\n            }\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\", true)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", true)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", true)\n\
    \    3L\n    \n*/\nlong how_many_times(string string, string substring, bool case_sensitive,\
    \ bool ignore_case) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(case_sensitive)\
    \ {\n                if(string[i] == substring[j]) {\n                    count++;\n\
    \                }\n            } else {\n                if(ignore_case) {\n\
    \                    if(string[i].toLower() == substring[j].toLower()) {\n   \
    \                     count++;\n                    }\n                } else\
    \ {\n                    if(string[i].toLower() == substring[j].toLower()) {\n\
    \                        count++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\", false, true)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", false, true)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", false,\
    \ true)\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case, bool ignore_whitespace) \n{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length", "{\n    long count = 0;\n\
    \    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i]\
    \ == substring[0])\n        {\n            for(int j = 1; j < substring.length();\
    \ j++)\n            {\n                if(string[i + j] != substring[j])\n   \
    \             {\n                    break;\n                }\n            }\n\
    \            \n            if(j == substring.length())\n            {\n      \
    \          count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = 1; j < substring.length(); j++)\n            {\n                if(string[i\
    \ + j] != substring[j])\n                {\n                    break;\n     \
    \           }\n            }\n            \n            if(j == substring.length())\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  \n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    \n    for(int i = start; i\
    \ < end; i++)\n    {\n        if(string[i] == substring[0])\n        {\n     \
    \       for(int j = 1; j < substring.length(); j++)\n            {\n         \
    \       if(string[i + j] != substring[j])\n                {\n               \
    \     break;\n                }\n            }\n            \n            if(j\
    \ == substring.length())\n            {\n                count++;\n          \
    \  }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| a tags=string,c++ |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.compare(i, substring.length(), substring) == 0) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string case_sensitive) \n{\n", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    \n    while(end < string.length())\n    {\n   \
    \     start = string.find(substring, start);\n        end = string.find(substring,\
    \ end);\n        if(start != string.length())\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n\tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.substr(i, substring.length()) == substring)\n\t\t\t\
    count++;\n\t}\n\t\n\treturn count;\n}", "{\n\tlong count = 0;\n\tfor (int i =\
    \ 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;", "{\n\tlong count = 0;\n\tfor (auto it\
    \ = string.begin(); it != string.end(); ++it)\n\t{\n\t\tif (*it == substring[0])\n\
    \t\t{\n\t\t\tstring substring_copy = substring;\n\t\t\tsubstring_copy.erase(0,\
    \ 1);\n\t\t\tcount += how_many_times(string.substr(1, string.length() - 1), substring_copy);\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++) {\n\t\tif (string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        for(int j = 0; j < substring.length(); j++)\n        {\n       \
    \     if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"aaaa\", \"aa\"\
    )`\n<|/ c |>\n<| c |>\nIt works. I tested it before posting. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`\n<|/ c |>\n<| c |>\nYes, it works. I tested it before posting.\
    \ Try it with `how_many_times(\"aaaa\", \"aa\")`\n<|/ c |>\n<| c |>\nI tested\
    \ it before posting. Try it with `how_many_times(\"aaaa\", \"aa\")`\n<|/ c |>\n\
    <| c |>\nI tested it before posting. Try it with `how_many_times(\"aaaa\", \"\
    aa\")`\n<|/ c |>\n<| a |>\nThis problem can be solved using suffix trees. A suffix\
    \ tree is a tree in which every node has at most two children (the left and right\
    \ subtrees). \nThe algorithm is simple: ", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if the substring appears more than once in the\
    \ string. For example, how_many_times(\"aaaa\", \"a\") returns 2, when it should\
    \ be 3.\n<|/ c |>\n<| c |>\n: It does work. Try it out for yourself. It returns\
    \ 3 for `how_many_times(\"aaaa\", \"a\")`.\n<|/ c |>\n<| c |>\n: It returns 3\
    \ for `how_many_times(\"aaaa\", \"aa\")` as well. Try it out for yourself. It\
    \ returns 3 for `how_many_times(\"aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\n: It returns\
    \ 3 for `how_many_times(\"aaaa\", \"aa\")` as well. Try it out for yourself. It\
    \ returns 3 for `how_many_times(\"aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\n: It returns\
    \ 3 for `how_many_times(\"aaaa\", \"aa\")` as well. Try it out for yourself. It\
    \ returns 3 for `how_many_times(\"aaaa\", \"aa\")`.\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    \n    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    ", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n            }\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, long start, long end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n            }\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        for(int j = 0; j < substring.length(); j++)\n\
    \        {\n            if(string[i] == substring[j])\n            {\n       \
    \         count++;\n            }\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    ", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == substring[0]) {\n\t\t\tfor (int j = 1; j < substring.length();\
    \ j++) {\n\t\t\t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\tcount += j - 1;\n\t\t}\n\t}\n\treturn count;\n}", "{\n \
    \   long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n   \
    \     if(string.compare(i, substring.length(), substring) == 0)\n        {\n \
    \           count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring) == 0)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"\
    a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}", "{\n    long count = 0;\n    for(int i =\
    \ 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"\
    a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n            count++;\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't\
    \ work if `substring` is longer than `string`.\n<|/ c |>\n<| c |>\nYes, I know.\
    \ That's why I said \"overlaping cases\". It's not an exact solution, but a good\
    \ approximation.\n<|/ c |>\n<| c |>\nThis doesn't work for `how_many_times(\"\
    aaaa\", \"aa\")` which returns `3L` instead of `2L`.\n<|/ c |>\n<| c |>\nYes,\
    \ I know. That's why I said \"overlaping cases\". It's not an exact solution,\
    \ but a good approximation.\n<|/ c |>\n<| c |>\nI guess I misunderstood your question.\
    \ My bad.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(long i = 0; i < len; i++)\n\
    \    {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n     \
    \       for(long j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count++;\n \
    \                   break;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This doesn't work. Try it with `how_many_times(\"aaaa\", \"aa\")`\n<|/ c |>\n\
    <| c |>\n: I tested it and it works. I added a test case to my answer.\n<|/ c\
    \ |>\n<| c |>\n: I added a test case to my answer.\n<|/ c |>\n<| c |>\n: I added\
    \ a test case to my answer.\n<|/ c |>\n<| c |>\n: I added a test case to my answer.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long count = 0;\n    size_t pos =\
    \ 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        pos = string.find(substring, pos);\n \
    \       if (pos == string.length()) break;\n        \n        if (pos == 0) {\n\
    \            count++;\n        }\n        \n        count += 1;\n        pos +=\
    \ sublen;\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while (start < len) {\n        end = start + sublen;\n        if (string.find(substring,\
    \ start) != string::npos) {\n            count++;\n            start = end;\n\
    \        }\n        else {\n            start++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long offset) \n{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while (start < len) {\n        end = start + sublen;\n        if (string.find(substring,\
    \ start) != string::npos) {\n            count++;\n            start = end;\n\
    \        }\n        else {\n            start++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long offset, long length) \n{\n    long count = 0;\n    long start = 0;\n  \
    \  long end = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    while (start < len) {\n        end = start + sublen;\n        if (string.find(substring,\
    \ start) != string::npos) {\n            count++;\n            start = end;\n\
    \        }\n        else {\n            start++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long offset, long length, long offset2) \n{\n    long count = 0;", "{\n\tlong\
    \ count = 0;\n\tfor (auto c : string) \n\t{\n\t\tif (c == substring[0]) \n\t\t\
    {\n\t\t\tcount += 1;\n\t\t\tif (c == substring[1]) \n\t\t\t{\n\t\t\t\tcount +=\
    \ 1;\n\t\t\t\tif (c == substring[2]) \n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start) \n{\n\tlong count\
    \ = 0;\n\tfor (auto c : string) \n\t{\n\t\tif (c == substring[0]) \n\t\t{\n\t\t\
    \tcount += 1;\n\t\t\tif (c == substring[1]) \n\t\t\t{\n\t\t\t\tcount += 1;\n\t\
    \t\t\tif (c == substring[2]) \n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n\tlong count = 0;\n\tfor (auto c : string) \n\t{\n\
    \t\tif (c == substring[0]) \n\t\t{\n\t\t\tcount += 1;\n\t\t\tif (c == substring[1])\
    \ \n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t\tif (c == substring[2]) \n\t\t\t\t{\n\
    \t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end,\
    \ long step) \n{\n\tlong count = 0;\n\tfor (auto c : string) \n\t{\n\t\tif (c\
    \ == substring[0]) \n\t\t{\n\t\t\tcount += 1;\n\t\t\tif (c == substring[1]) \n\
    \t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t\tif (c == substring[2]) \n", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    \n    for(int i = start;\
    \ i < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    \n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    ", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ if the substring appears more than once in the string. For example, how_many_times(\"\
    aaaa\", \"aa\") returns 3, when it should be 2.\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it out. `how_many_times(\"aaaa\", \"aa\")` returns `3`.\n<|/ c |>\n<| c\
    \ |>\nOh I see, I missed the part where you said \"overlaping cases\". Thanks!\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long count = 0;\n    size_t pos =\
    \ 0;\n    size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"a\"\
    , \"a\", 0)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    3L\n    >>>\
    \ how_many_times(\"aaaa\", \"aa\", 0)\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\", 0, 0)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0, 0)\n    3L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0, 0)\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end, int step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", 0, 2)\n    3L\n    >>> how_", "{\n    long count = 0;\n    \n  \
    \  for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    \n    for(int i = start; i < string.length(); i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    \n    for(int i = start; i\
    \ < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    \n    for(int i\
    \ = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aa", "{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        for(int j = 0; j < substring.length(); j++)\n        {\n        \
    \    if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    \n    for(int i = start; i\
    \ < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    \n    for(int i\
    \ = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong ", "{\n    long count = 0;\n    size_t pos =\
    \ 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    while(pos < len) {\n        pos = string.find(substring, pos);\n        if(pos\
    \ == string.length()) break;\n        count++;\n        pos += sublen;\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ size_t start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t\
    \ len = string.length();\n    size_t sublen = substring.length();\n    while(pos\
    \ < len) {\n        pos = string.find(substring, pos);\n        if(pos == string.length())\
    \ break;\n        count++;\n        pos += sublen;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ size_t start, size_t end) \n{\n    long count = 0;\n    size_t pos = start;\n\
    \    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    while(pos < len) {\n        pos = string.find(substring, pos);\n        if(pos\
    \ == string.length()) break;\n        count++;\n        pos += sublen;\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ size_t start, size_t end, size_t sublen) \n{\n    long count = 0;\n    size_t\
    \ pos = start;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    while(pos < len) {\n        pos = string.find(substring, pos);\n        if(pos\
    \ == string.length()) break;\n        count", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis solution doesn't work for \"aaaaa\" with \"aaa\" as substring.\n\
    <|/ c |>\n<| c |>\nThe OP didn't specify that he wanted overlapping counts. I\
    \ assumed that he wanted the count of how many times the substring was in the\
    \ original string. He didn't specify that he wanted overlapping counts. He did\
    \ specify that he wanted overlapping counts. He didn't specify that he wanted\
    \ overlapping counts. He didn't specify that he wanted overlapping counts. He\
    \ didn't specify that he wanted overlapping counts. He didn't specify that he\
    \ wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that\
    \ he wanted overlapping counts. He didn't specify that he wanted overlapping counts.\
    \ He didn't specify that he wanted overlapping counts. He didn't specify that ",
  "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring) == 0)\n    \
    \    {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start) \n{\n   \
    \ long count = 0;\n    \n    for(int i = start; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring) == 0)\n    \
    \    {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end)\
    \ \n{\n    long count = 0;\n    \n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end,\
    \ long step) \n{\n    long count = 0;\n    \n    for(int i = start; i < end; i+=step)\n\
    \    {\n        if(string.compare(i, substring.length(), substring) == 0)\n  \
    \      {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong ", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include\
    \ <cmath>\nusing namespace std;", "{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThe question\
    \ was about C++, not C#.\n<|/ c |>\n<| c |>\nI know, but I thought it would be\
    \ helpful to have some C++ code anyway. :)\n<|/ c |>\n<| c |>\nI added a C++ version.\
    \ :)\n<|/ c |>\n<| c |>\nI added a C++ version. :)\n<|/ c |>\n<| c |>\nI added\
    \ a C++ version. :)\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n\tlong count = 0;\n\
    \tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.substr(i, substring.length())\
    \ == substring)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n\
    \    long count = 0;\n    long start = 0;\n    long end = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    while(start < len) {\n     \
    \   end = start + sublen;\n        while(end < len && string.compare(end, sublen,\
    \ substring) == 0) {\n            end++;\n        }\n        if(end == len) {\n\
    \            count++;\n        }\n        start = end;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while(start < len) {\n        end = start + sublen;\n        while(end <\
    \ len && string.compare(end, sublen, substring) == 0) {\n            end++;\n\
    \        }\n        if(end == len) {\n            count++;\n        }\n      \
    \  start = end;\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end) \n{\n  \
    \  long count = 0;\n    long start = 0;\n    long end = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    while(start < len) {\n     \
    \   end = start + sublen;\n        while(end < len && string.compare(end, sublen,\
    \ substring) == 0) {\n            end++;\n        }\n        if(end == len) {\n\
    \            count++;\n        }\n        start = end;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if\
    \ the substring appears more than once.\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it before posting it. I will edit my answer to include a test case.\n<|/ c |>\n\
    <| c |>\nIt doesn't work if the substring appears more than once in the original\
    \ string. Try it with `how_many_times(\"aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I edited my answer to include a test case.\n<|/ c |>\n\
    <| c |>\nI tested it and it works. I edited my answer to include a test case.\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;", "{\n    long count = 0;\n    long start = 0;\n\
    \    long end = 0;\n    long length = 0;\n    \n    foreach(char c in string)\
    \ {\n        end = string.find(substring, start);\n        if (end == string.length())\
    \ break;\n        \n        length = end - start;\n        if (length >= substring.length())\
    \ {\n            count += 1;\n            start = end + 1;\n        }\n    }\n\
    \    \n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    long end = 0;\n    long length = 0;\n\
    \    \n    foreach(char c in string) {\n        end = string.find(substring, start);\n\
    \        if (end == string.length()) break;\n        \n        length = end -\
    \ start;\n        if (length >= substring.length()) {\n            count += 1;\n\
    \            start = end + 1;\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long length = 0;\n    \n\
    \    foreach(char c in string) {\n        length = end - start;\n        if (length\
    \ >= substring.length()) {\n            count += 1;\n            start = end +\
    \ 1;\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, long start, long end, long\
    \ length) \n{\n    long count = 0;\n    \n    foreach(char c in string) {\n  \
    \      length = end - start;\n        if (length >= substring.length()) {\n  \
    \          count += ", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        size_t subpos = 0;\n        \n       \
    \ while (subpos < sublen) {\n            if (string.compare(pos, subpos, sublen,\
    \ substring) == 0) {\n                count++;\n                pos += sublen;\n\
    \                subpos = 0;\n            } else {\n                subpos++;\n\
    \            }\n        }\n        \n        pos++;\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ size_t start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t\
    \ len = string.length();\n    size_t sublen = substring.length();\n    \n    while\
    \ (pos < len) {\n        size_t subpos = 0;\n        \n        while (subpos <\
    \ sublen) {\n            if (string.compare(pos, subpos, sublen, substring) ==\
    \ 0) {\n                count++;\n                pos += sublen;\n           \
    \     subpos = 0;\n            } else {\n                subpos++;\n         \
    \   }\n        }\n        \n        pos++;\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ size_t start, size_t end) \n{\n    long count = 0;\n    size_t pos = start;\n\
    \    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        size_t subpos = 0;\n        \n       \
    \ while (subpos < sublen) {\n            if (string.compare(pos, subpos, sublen,\
    \ substring) == 0) {\n                count++;\n                pos += sublen;\n\
    \                subpos = 0;\n            } else {\n                subpos++;\n\
    \            }\n        }\n        \n        pos++;\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\"", "{\n    long count =\
    \ 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor (auto\
    \ it = string.begin(); it != string.end(); ++it) {\n\t\tif (*it == substring[0])\
    \ {\n\t\t\tfor (auto it2 = substring.begin(); it2 != substring.end(); ++it2) {\n\
    \t\t\t\tif (*it == *it2) {\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start_index, long end_index) \n{\n\tlong count = 0;\n\tfor (auto it = string.begin()\
    \ + start_index; it != string.begin() + end_index; ++it) {\n\t\tif (*it == substring[0])\
    \ {\n\t\t\tfor (auto it2 = substring.begin(); it2 != substring.end(); ++it2) {\n\
    \t\t\t\tif (*it == *it2) {\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start_index, long end_index, long start_index_2, long end_index_2) \n{\n\
    \tlong count = 0;\n\tfor (auto it = string.begin() + start_index; it != string.begin()\
    \ + end_index; ++it) {\n\t\tif (*it == substring[0]) {\n\t\t\tfor (auto it2 =\
    \ substring.begin() + start_index_2; it2 != substring.begin() + end_index_2; ++it2)\
    \ {\n\t\t\t\tif (*it == *it2) {\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start_index, long end_index, long start_index_2, long ", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i]\
    \ == substring[0])\n        {\n            for(int j = i; j < string.length();\
    \ j++)\n            {\n                if(string[j] == substring[0])\n       \
    \         {\n                    for(int k = j + 1; k < string.length(); k++)\n\
    \                    {\n                        if(string[k] == substring[0])\n\
    \                        {\n                            count++;\n           \
    \                 break;\n                        }\n                    }\n \
    \                   break;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated\
    \ the code accordingly.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated\
    \ the code accordingly.\n<|/ c |>\n<| a tags=string,c++ |>\n<code>\n#include <iostream>\n\
    #include <string>\nusing namespace std;", "{\n    long count = 0;\n    long pos\
    \ = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        pos = string.find(substring, pos);\n \
    \       if (pos == string.length()) break;\n        count++;\n        pos += sublen;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThe question was about C++, not C. Also, the question was about\
    \ overlapping matches, not just counting them.\n<|/ c |>\n<| c |>\nThe question\
    \ was about overlapping matches, not just counting them.\n<|/ c |>\n<| c |>\n\
    The question was about overlapping matches, not just counting them.\n<|/ c |>\n\
    <| c |>\nThe question was about overlapping matches, not just counting them.\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\nusing namespace std;", "{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/10174953)\n<|/ c |>\n<| c |>\nThis does provide\
    \ an answer to the question. He asked how to count how many times a substring\
    \ appears in a string. He also asked how to count overlapping cases. He also asked\
    \ how to count the occurrences of substrings in strings. He also asked how to\
    \ count the occurrences of substrings in strings. He also asked how to count the\
    \ occurrences of substrings in strings. He also asked how to count the occurrences\
    \ of substrings in strings. He also asked how to count the occurrences of substrings\
    \ in strings. He also asked how to count the occurrences of substrings in strings.\
    \ He also asked how to count the occurrences of substrings in strings. He also\
    \ asked how to count the occurrences of substrings in strings. He also asked how\
    \ to count the occurrences of substrings in strings. He also asked how to count\
    \ the occurrences of substrings in strings. He also asked how to count the occurrences\
    \ of substrings in strings. He also asked how to count the occurrences of substrings\
    \ in strings. He also asked how to count the occurrences of substrings in strings.\
    \ He also asked how to count the occurrences of substrings in strings. He also\
    \ asked how to count the occurrences of substrings in strings. He also asked how\
    \ to count the occurrences of substrings in strings. He also asked how to count\
    \ the occurrences of substrings in strings. He also asked how to count the occurrences\
    \ of substrings in strings. He also asked how to count the occurrences of substrings\
    \ in strings. He also asked how to count the occurrences of substrings in strings.\
    \ He also asked how to count the occurrences of substrings in strings. He also\
    \ asked how to count the occurrences of substrings in strings. He also asked how\
    \ to count the occurrences of substrings in strings. He also asked how to count\
    \ the occurrences of substrings in strings. He also asked how to count the occurrences\
    \ of substrings in strings. He also asked how to count the occurrence", "{\n \
    \   long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n   \
    \     if(string.compare(i, substring.length(), substring) == 0)\n        {\n \
    \           count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try `how_many_times(\"aaa\", \"a\")`\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work because you didn't implement the algorithm correctly.\
    \ `how_many_times(\"aaa\", \"a\")` should return `3`, not `0`.\n<|/ c |>\n<| c\
    \ |>\nI didn't implement it correctly. My bad. Thanks for pointing it out.\n<|/\
    \ c |>\n<| c |>\nI fixed the bug and added a test case for you.\n<|/ c |>\n<|\
    \ c |>\nI fixed the bug and added a test case for you.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| a |>\n<code>", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        for(int j = 0; j < substring.length();\
    \ j++) {\n            if(string[i] == substring[j]) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"aaaa\", \"aa\"\
    )`.\n<|/ c |>\n<| c |>\nI tested it and it works fine. Are you sure you copied\
    \ it correctly? It returns 3 for `how_many_times(\"aaaa\", \"aa\")`.\n<|/ c |>\n\
    <| c |>\nYes, I copied it correctly. `how_many_times(\"aaaa\", \"aa\")` returns\
    \ 3, not 2.\n<|/ c |>\n<| c |>\nOh, I see. Yes, it returns 3 because `aaa` contains\
    \ `aa`, which means it counts overlapping cases. I updated my answer to fix this.\n\
    <|/ c |>\n<| c |>\nI updated my answer to fix this and also added a more efficient\
    \ solution.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "{\n    long count = 0;\n  \
    \  long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(string.at(i) == substring.at(0))\n\
    \        {\n            count++;\n        }\n        else if(string.at(i) == substring.at(1))\n\
    \        {\n            count += 2;\n        }\n        else if(string.at(i) ==\
    \ substring.at(2))\n        {\n            count += 3;\n        }\n        else\
    \ if(string.at(i) == substring.at(3))\n        {\n            count += 4;\n  \
    \      }\n        else if(string.at(i) == substring.at(4))\n        {\n      \
    \      count += 5;\n        }\n        else if(string.at(i) == substring.at(5))\n\
    \        {\n            count += 6;\n        }\n        else if(string.at(i) ==\
    \ substring.at(6))\n        {\n            count += 7;\n        }\n        else\
    \ if(string.at(i) == substring.at(7))\n        {\n            count += 8;\n  \
    \      }\n        else if(string.at(i) == substring.at(8))\n        {\n      \
    \      count += 9;\n        }\n        else if(string.at(i) == substring.at(9))\n\
    \        {\n            count += 10;\n        }\n        else if(string.at(i)\
    \ == substring.at(10))\n        {\n            count += 11;\n        }\n     \
    \   else if(string.at(i) == substring.at(11))\n        {\n            count +=\
    \ 12;\n        }\n        else if(string.at(i) == substring.at(12))\n        {\n\
    \            count += 13;\n        }\n        else if(string.at(i) == substring.at(13))\n\
    \        {\n            count += 14;\n        }\n        else if(string.at(i)\
    \ == substring.at(14))\n        {\n            count += 15;\n        }\n     \
    \   else if(string.at(i) == substring.at(15))\n        {\n            count +=\
    \ 16;\n        }\n        else if(string.at(i) == substring.at(16))\n        {\n\
    \            count += 17;\n        }\n        else if(string.at(i) == substring.at(17))\n\
    \        {\n            count += 18;\n        }\n        else if(string.at(i)\
    \ == substring.at(18))\n        {\n            count += 19;\n        }\n     \
    \   else if(string.at(i) == substring.at(19))\n        {\n            count +=\
    \ 20;\n        }\n        else if(string.at(i) == substring.at(20))\n        {\n\
    \            count += 21;\n        }\n        else if(string.at(i) == substring.at(21))\n\
    \        {\n            count += 22;\n        }\n        else if(string.at(i)\
    \ == substring.at(22))\n        {\n            count += 23;\n        }\n     \
    \   else if(string.at(i) == ", "{\n    long count = 0;\n    long start = 0;\n\
    \    long end = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    while(start < len) {\n        end = start + sublen;\n        while(end\
    \ < len && string.compare(end, sublen, substring) == 0) {\n            end++;\n\
    \        }\n        if(end > start) {\n            count++;\n        }\n     \
    \   start = end;\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis doesn't work. Try it on \"aaa\" and \"aa\".\n<|/ c |>\n<|\
    \ c |>\nIt does work. Try it on \"aaa\" and \"aa\".\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it on \"aaa\" and \"aa\".\n<|/ c |>\n<| c |>\nIt does work. Try it\
    \ on \"aaa\" and \"aa\".\n<|/ c |>\n<| c |>\nIt does work. Try it on \"aaa\" and\
    \ \"aa\".\n<|/ c |>\n<| a dscore=4 |>\n<code>", "{\n    long count = 0;\n    \n\
    \    for(int i = 0; i < string.length(); i++) {\n        if(string.substr(i, substring.length())\
    \ == substring) {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n     \
    \   if(string.at(i) == substring.at(0))\n        {\n            count++;\n   \
    \     }\n        else if(string.at(i) == substring.at(1))\n        {\n       \
    \     count += 2;\n        }\n        else if(string.at(i) == substring.at(2))\n\
    \        {\n            count += 3;\n        }\n        else if(string.at(i) ==\
    \ substring.at(3))\n        {\n            count += 4;\n        }\n        else\
    \ if(string.at(i) == substring.at(4))\n        {\n            count += 5;\n  \
    \      }\n        else if(string.at(i) == substring.at(5))\n        {\n      \
    \      count += 6;\n        }\n        else if(string.at(i) == substring.at(6))\n\
    \        {\n            count += 7;\n        }\n        else if(string.at(i) ==\
    \ substring.at(7))\n        {\n            count += 8;\n        }\n        else\
    \ if(string.at(i) == substring.at(8))\n        {\n            count += 9;\n  \
    \      }\n        else if(string.at(i) == substring.at(9))\n        {\n      \
    \      count += 10;\n        }\n        else if(string.at(i) == substring.at(10))\n\
    \        {\n            count += 11;\n        }\n        else if(string.at(i)\
    \ == substring.at(11))\n        {\n            count += 12;\n        }\n     \
    \   else if(string.at(i) == substring.at(12))\n        {\n            count +=\
    \ 13;\n        }\n        else if(string.at(i) == substring.at(13))\n        {\n\
    \            count += 14;\n        }\n        else if(string.at(i) == substring.at(14))\n\
    \        {\n            count += 15;\n        }\n        else if(string.at(i)\
    \ == substring.at(15))\n        {\n            count += 16;\n        }\n     \
    \   else if(string.at(i) == substring.at(16))\n        {\n            count +=\
    \ 17;\n        }\n        else if(string.at(i) == substring.at(17))\n        {\n\
    \            count += 18;\n        }\n        else if(string.at(i) == substring.at(18))\n\
    \        {\n            count += 19;\n        }\n        else if(string.at(i)\
    \ == substring.at(19))\n        {\n            count += 20;\n        }\n     \
    \   else if(string.at(i) == substring.at(20))\n        {\n            count +=\
    \ 21;\n        }\n        else if(string.at(i) == substring.at(21))\n        {\n\
    \            count += 22;\n        }\n        else if(string.at(i) == substring.at(22))\n\
    \        {\n            count += 23;\n        }\n        else if(string.at(i)\
    \ == ", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long\
    \ len = 0;\n    \n    while(start < string.length)\n    {\n        end = string.find(substring,\
    \ start);\n        if(end != string.length)\n        {\n            len = (end\
    \ - start);\n            count += len;\n            start = end + 1;\n       \
    \ }\n        else\n        {\n            len = 0;\n            start = end +\
    \ 1;\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start) \n{\n    long count\
    \ = 0;\n    long end = 0;\n    long len = 0;\n    \n    while(end < string.length)\n\
    \    {\n        end = string.find(substring, end);\n        if(end != string.length)\n\
    \        {\n            len = (end - start);\n            count += len;\n    \
    \        start = end + 1;\n        }\n        else\n        {\n            len\
    \ = 0;\n            start = end + 1;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long len = 0;\n    \n  \
    \  while(end < string.length)\n    {\n        end = string.find(substring, end);\n\
    \        if(end != string.length)\n        {\n            len = (end - start);\n\
    \            count += len;\n            start = end + 1;\n        }\n        else\n\
    \        {\n            len = 0;\n            start = end + 1;\n        }\n  \
    \  }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_man", "{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\
    \t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> ",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nThis code doesn't work if substring\
    \ contains special characters like `[`, `]`, `{`, `}`, etc.\n<|/ c |>\n<| c |>\n\
    The code doesn't work if substring contains special characters like `[`, `]`,\
    \ `{`, `}`, etc.\n<|/ c |>\n<| c |>\nThe code doesn't work if substring contains\
    \ special characters like `[`, `]`, `{`, `}`, etc.\n<|/ c |>\n<| c |>\nThe code\
    \ doesn't work if substring contains special characters like `[`, `]`, `{`, `}`,\
    \ etc.\n<|/ c |>\n<| c |>\nThe code doesn't work if substring contains special\
    \ characters like `[`, `]`, `{`, `}`, etc.\n<|/ c |>\n<| a |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;",
  "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\
    \tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n\tlong count = 0;\n\tfor (auto c : string) \n\t{\n\t\tif (c\
    \ == substring[0]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1), substring);\n\
    \t\t}\n\t\telse if (c == substring[1]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(1));\n\t\t}\n\t\telse if (c == substring[2]) \n\t\t{\n\t\t\t\
    count += how_many_times(string.substr(1), substring.substr(2));\n\t\t}\n\t\telse\
    \ if (c == substring[3]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(3));\n\t\t}\n\t\telse if (c == substring[4]) \n\t\t{\n\t\t\t\
    count += how_many_times(string.substr(1), substring.substr(4));\n\t\t}\n\t\telse\
    \ if (c == substring[5]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(5));\n\t\t}\n\t\telse if (c == substring[6]) \n\t\t{\n\t\t\t\
    count += how_many_times(string.substr(1), substring.substr(6));\n\t\t}\n\t\telse\
    \ if (c == substring[7]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(7));\n\t\t}\n\t\telse if (c == substring[8]) \n\t\t{\n\t\t\t\
    count += how_many_times(string.substr(1), substring.substr(8));\n\t\t}\n\t\telse\
    \ if (c == substring[9]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(9));\n\t\t}\n\t\telse if (c == substring[10]) \n\t\t{\n\t\t\
    \tcount += how_many_times(string.substr(1), substring.substr(10));\n\t\t}\n\t\t\
    else if (c == substring[11]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(11));\n\t\t}\n\t\telse if (c == substring[12]) \n\t\t{\n\t\t\
    \tcount += how_many_times(string.substr(1), substring.substr(12));\n\t\t}\n\t\t\
    else if (c == substring[13]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(13));\n\t\t}\n\t\telse if (c == substring[14]) \n\t\t{\n\t\t\
    \tcount += how_many_times(string.substr(1), substring.substr(14));\n\t\t}\n\t\t\
    else if (c == substring[15]) \n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring.substr(15));\n\t\t}\n\t\telse if (c == substring[16]) \n\t\t{\n\t\t\
    \tcount += how_many_times(string.substr(1), substring.substr(16));\n\t\t}\n\t\t\
    else if (", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis solution doesn't\
    \ take into account the fact that `how_many_times` should return `0` if the substring\
    \ is not found.\n<|/ c |>\n<| c |>\nI agree with you. My solution was a quick\
    \ fix to his code. I'll edit my answer to include a more robust solution.\n<|/\
    \ c |>\n<| c |>\nI edited my answer to include a more robust solution. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n   \
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n\tlong count = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ ++it)\n\t{\n\t\tif (*it == substring[0])\n\t\t{\n\t\t\tcount += how_many_times(string.substr(1),\
    \ substring);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\
    \ \n    {\n        if(string.charAt(i) == substring.charAt(0)) \n        {\n \
    \           count++;\n            \n            for(int j = 0; j < sublen; j++)\
    \ \n            {\n                if(string.charAt(i) != substring.charAt(j))\
    \ \n                {\n                    count = 0;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,c++ |>\n<| c |>\nI like your solution, but I believe\
    \ it can be optimized a bit. For example, if you have `aaa` and `aa`, then you\
    \ only need to check `a` once.\n<|/ c |>\n<| c |>\nYes, you are right. Thanks\
    \ for pointing that out. I've updated my answer.\n<|/ c |>\n<| a dscore=2 |>\n\
    I wrote a solution using recursion:\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n\
    public int howManyTimes(String str, String subStr) {\n    int count = 0;\n   \
    \ int start = 0;\n    int end = 0;\n    while(end < str.length()) {\n        end\
    \ = str.indexOf(subStr, start);\n        if(end != -1) {\n            count++;\n\
    \            start = end + subStr.length();\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,java |>\n<| a tags=string,java |>\n<code>\npublic\
    \ int howManyTimes(String str, String subStr) {\n    int count = 0;\n    int start\
    \ = 0;\n    int end = 0;\n    while(end < str.length()) {\n        end = str.indexOf(subStr,\
    \ start);\n        if(end != -1) {\n            count++;\n            start =\
    \ end + subStr.length();\n        }\n    }\n    return count;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\n<code>\npublic int howManyTimes(String str, String subStr)\
    \ {\n    int count = 0;\n    int start = 0;\n    int end = 0;\n    while(end <\
    \ str.length()) {\n        end = str.indexOf(subStr, start);\n        if(end !=\
    \ -1) {\n            count++;\n            start = end + subStr.length();\n  \
    \      }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 tags=string,java\
    \ |>\n<| a tags=string,java |>\n<code>\npublic int howManyTimes(String str, String\
    \ subStr) {\n    int count = 0;\n    int start = 0;\n    int end = 0;\n    while(end\
    \ < str.length()) {\n        end = str.indexOf(subStr, start);\n        if(end\
    \ != -1) {\n            count++;\n            start = end + subStr.length();\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,java\
    \ |>\n<code>\npublic int howManyTimes(String str, String subStr) {\n    int count\
    \ = 0;\n    int start = 0;\n    int end = 0;\n    while(end < str.length()) {\n\
    \        end = str.indexOf(subStr, start);\n        if(end != -1) {\n        \
    \    count++;\n            start = end + subStr.length();\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation\
    \ to your answer.\n<|/ ", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string ", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string[i] == substring[j])\
    \ {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string[i]\
    \ == substring[j]) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\"\
    )\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end;\
    \ i++) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string[i]\
    \ == substring[j]) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\"\
    )\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\
    \t\tif (string[i] == substring[j]) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    for(long i = 0; i < len; i++)\n    {\n    \
    \    for(long j = 0; j < sublen; j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n            }\n    \
    \    }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long len = 0;\n    \n    len = string.length();\n\
    \    end = len-1;\n    \n    while(start < len) {\n        while(end >= 0 && string.charAt(end)\
    \ == substring.charAt(0)) {\n            end--;\n        }\n        \n       \
    \ if(end >= 0) {\n            count++;\n            start = end;\n        }\n\
    \        else {\n            end = len-1;\n        }\n    }\n    \n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = 0;\n    \n    len = string.length();\n    end = len-1;\n    \n\
    \    while(start < len) {\n        while(end >= 0 && string.charAt(end) == substring.charAt(0))\
    \ {\n            end--;\n        }\n        \n        if(end >= 0) {\n       \
    \     count++;\n            start = end;\n        }\n        else {\n        \
    \    end = len-1;\n        }\n    }\n    \n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long len =\
    \ 0;\n    \n    len = string.length();\n    end = len-1;\n    \n    while(start\
    \ < len) {\n        while(end >= 0 && string.charAt(end) == substring.charAt(0))\
    \ {\n            end--;\n        }\n        \n        if(end >= 0) {\n       \
    \     count++;\n            start = end;\n        }\n        else {\n        \
    \    end = len-1;\n        }\n    }\n    \n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    ", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n       \
    \ if(string.compare(i, substring.length(), substring, 0, substring.length()) ==\
    \ 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n     \
    \   if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n        if(string.compare(i, substring2.length(),\
    \ substring2, 0, substring2.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \        if(string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0) {\n            count++;\n        }\n        if(string.compare(i, substring3.length(),\
    \ substring3, 0, substring3.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3, string substring4) \n{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n        if(string.compare(i, substring2.length(), substring2, 0, substring2.length()",
  "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\
    \tif (string.compare(i, substring.length(), substring) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring) == 0)\n\t\
    \t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\
    \t{\n\t\tif (string.compare(i, substring.length(), substring) == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step)\n\t{\n\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end, int step,\
    \ string pattern) \n{\n\tlong ", "{\n    long count = 0;\n    size_t pos = 0;\n\
    \    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n            pos += sublen;\n        }\n     \
    \   else {\n            pos = string.find(substring, pos);\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    long start = 0;\n    long\
    \ end = 0;\n    \n    while(end < string.length)\n    {\n        end = string.find(substring,\
    \ start);\n        if(end == string.length)\n        {\n            break;\n \
    \       }\n        \n        start = end + 1;\n        count++;\n    }\n    \n\
    \    return count;\n}", "{\n    long count = 0;\n    long start = 0;\n    long\
    \ end = 0;\n    long len = 0;\n    \n    len = string.length();\n    end = len-1;\n\
    \    \n    while(start < len) {\n        while(end >= 0 && string.charAt(end)\
    \ == substring.charAt(0)) {\n            end--;\n        }\n        \n       \
    \ if(end < 0) {\n            end = len;\n        }\n        \n        while(start\
    \ < end && string.charAt(start) == substring.charAt(1)) {\n            start++;\n\
    \        }\n        \n        if(start >= end) {\n            count++;\n     \
    \   }\n        \n        start = end;\n    }\n    \n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start) \n{\n   \
    \ long count = 0;\n    long end = 0;\n    long len = 0;\n    \n    len = string.length();\n\
    \    end = len-1;\n    \n    while(start < len) {\n        while(end >= 0 && string.charAt(end)\
    \ == substring.charAt(0)) {\n            end--;\n        }\n        \n       \
    \ if(end < 0) {\n            end = len;\n        }\n        \n        while(start\
    \ < end && string.charAt(start) == substring.charAt(1)) {\n            start++;\n\
    \        }\n        \n        if(start >= end) {\n            count++;\n     \
    \   }\n        \n        start = end;\n    }\n    \n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end)\
    \ \n{\n    long count = 0;\n    long len = 0;\n    \n    len = string.length();\n\
    \    end = len-1;\n    \n    while(start < len) {\n        while(end >= 0 && string.charAt(end)\
    \ == substring.charAt(0)) {\n            end--;\n        }\n        \n       \
    \ if(end < 0) {\n            end = len;\n        }\n        \n        while(start\
    \ < end && string.charAt(start) == substring.charAt(1)) {\n            start++;\n\
    \        }\n        \n        if(start >= end", "{\n    long count = 0;\n    \n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}", "{\n\tlong\
    \ count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t{\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\
    \t\telse\n\t\t\t{\n\t\t\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\
    \t\t\t\tif (string.compare(i, substring.length(), substring) == 0)\n\t\t\t\t\t\
    {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while(start < len) {\n        end = string.find(substring, start);\n    \
    \    if(end == string.length())\n            break;\n        \n        if(end\
    \ > start) {\n            count += end - start;\n        }\n        start = end\
    \ + sublen;\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start) \n{\n    long count\
    \ = 0;\n    long end = 0;\n    long len = string.length();\n    long sublen =\
    \ substring.length();\n    \n    while(end < len) {\n        end = string.find(substring,\
    \ end);\n        if(end == string.length())\n            break;\n        \n  \
    \      if(end > start) {\n            count += end - start;\n        }\n     \
    \   start = end + sublen;\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end)\
    \ \n{\n    long count = 0;\n    long len = string.length();\n    long sublen =\
    \ substring.length();\n    \n    while(end < len) {\n        end = string.find(substring,\
    \ end);\n        if(end == string.length())\n            break;\n        \n  \
    \      if(end > start) {\n            count += end - start;\n        }\n     \
    \   start = end + sublen;\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start, long end, ",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.substr(i, substring.length()) == substring)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n\
    \        if(string.substr(i, substring.length()) == substring)\n        {\n  \
    \          if(string.substr(i, substring2.length()) == substring2)\n         \
    \   {\n                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            if(string.substr(i, substring2.length())\
    \ == substring2)\n            {\n                if(string.substr(i, substring3.length())\
    \ == substring3)\n                {\n                    count++;\n          \
    \      }\n            }\n        }\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3, string substring4) \n{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            if(string.substr(i, substring2.length())\
    \ == substring2)\n            {\n                if(string.substr(i, substring3.length())\
    \ == substring3)\n                {\n                    if(string.substr(i, substring4.length())\
    \ == substring4)\n                    {\n                        count", "{\n\
    \    long count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    if (string.compare(pos, sublen, substring) == 0) {\n            count++;\n\
    \        }\n        pos += sublen;\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis is not an optimal solution. `std::count` uses `std::search`\
    \ internally. `std::search` has complexity `O(n*log(n))` which is much better\
    \ than `O(n^2)`.\n<|/ c |>\n<| c |>\n`std::count` uses `std::search` internally.\
    \ `std::search` has complexity `O(n*log(n))` which is much better than `O(n^2)`.\n\
    <|/ c |>\n<| c |>\nThe complexity of std::count is O(n), not O(n*log(n)). std::count\
    \ is implemented as `return std::search(begin, end, sub, std::not1(std::ptr_fun<int,\
    \ int>(comp))) - begin;`\n<|/ c |>\n<| c |>\n`std::count` uses `std::search` internally.\
    \ `std::search` has complexity `O(n*log(n))` which is much better than `O(n^2)`.\n\
    <|/ c |>\n<| c |>\n`std::count` uses `std::search` internally. `std::search` has\
    \ complexity `O(n*log(n))` which is much better than `O(n^2)`.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nI wrote a solution using std::count and std::search. \n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\n#include <iterator>\n\
    #include <cassert>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
