{
  "language": "d",
  "name": "HumanEval_139_special_factorial",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj6xhasx8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpj6xhasx8.__unittest_L28_C1() [0x427a6a]\n??:? void tmpj6xhasx8.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgo46o9e_.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgo46o9e_.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgo46o9e_.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1cmwrhq2.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1cmwrhq2.__unittest_L27_C1() [0x427a66]\n??:? void tmp1cmwrhq2.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgbic8nlu.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgbic8nlu.__unittest_L24_C1() [0x427a66]\n??:? void tmpgbic8nlu.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2u9lr5l1.d(129): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2u9lr5l1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpesun8zy1.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpesun8zy1.__unittest_L27_C1() [0x427a6a]\n??:? void tmpesun8zy1.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfm7qmb4q.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfm7qmb4q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    for(long i = 2; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\n/*\nThe Brazilian fibonacci number is defined as:\n    brazilian_fibonacci(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbbj2cw56.d(23): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbbj2cw56.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpej6_ezed.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpej6_ezed.__unittest_L26_C1() [0x427a6a]\n??:? void tmpej6_ezed.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqdto0tgv.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpqdto0tgv.__unittest_L27_C1() [0x427a6a]\n??:? void tmpqdto0tgv.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzxq4gm48.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpzxq4gm48.__unittest_L27_C1() [0x427a66]\n??:? void tmpzxq4gm48.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgfzqitmp.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgfzqitmp.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgfzqitmp.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1_do8r3f.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1_do8r3f.__unittest_L28_C1() [0x427a6a]\n??:? void tmp1_do8r3f.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1_do8r3f.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1_do8r3f.__unittest_L28_C1() [0x427a6a]\n??:? void tmp1_do8r3f.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa1k1hh_w.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa1k1hh_w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpesun8zy1.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpesun8zy1.__unittest_L27_C1() [0x427a6a]\n??:? void tmpesun8zy1.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++) \n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3ulvr94h.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp3ulvr94h.__unittest_L28_C1() [0x427a6a]\n??:? void tmp3ulvr94h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt9y57cd6.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpt9y57cd6.__unittest_L26_C1() [0x427a6a]\n??:? void tmpt9y57cd6.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9jejzt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpyv9jejzt.__unittest_L24_C1() [0x427a6a]\n??:? void tmpyv9jejzt.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++){\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its factorials.\n    \n    For example:\n    >>> factorial(4L)\n    24L\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpagraoobi.d(25): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpagraoobi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphjbojn29.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphjbojn29.__unittest_L26_C1() [0x427a6a]\n??:? void tmphjbojn29.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptraubs3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptraubs3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmptraubs3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptraubs3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptraubs3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmptraubs3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result = result * i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfyqgb7ro.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpfyqgb7ro.__unittest_L27_C1() [0x427a6a]\n??:? void tmpfyqgb7ro.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * (long)i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq_j_qzpj.d(22): Error: C style cast illegal, use `cast(long)i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_j_qzpj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgfzqitmp.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgfzqitmp.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgfzqitmp.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpej6_ezed.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpej6_ezed.__unittest_L26_C1() [0x427a6a]\n??:? void tmpej6_ezed.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++) \n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of all positive integers less than or equal to that number.\n    \n    For example:\n    >>> factorial(4L)\n    24L\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpum5y1s99.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpum5y1s99.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++) \n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7sw0w1n1.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7sw0w1n1.__unittest_L27_C1() [0x427a62]\n??:? void tmp7sw0w1n1.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    if (n <= 1L) {\n        return 1;\n    }\n    \n    for (i = 2L; i <= n; i++) {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7cc_04cz.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x427d7d]\n??:? void tmp7cc_04cz.__unittest_L31_C1() [0x427a76]\n??:? void tmp7cc_04cz.__modtest() [0x427afc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a936]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]\n??:? runModuleUnitTests [0x42b879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppkumpl3h.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppkumpl3h.__unittest_L24_C1() [0x427a6a]\n??:? void tmppkumpl3h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 1L; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdd_e5vrg.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpdd_e5vrg.__unittest_L27_C1() [0x427a62]\n??:? void tmpdd_e5vrg.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppkumpl3h.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppkumpl3h.__unittest_L24_C1() [0x427a6a]\n??:? void tmppkumpl3h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptraubs3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptraubs3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmptraubs3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk3uc23a_.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpk3uc23a_.__unittest_L27_C1() [0x427a66]\n??:? void tmpk3uc23a_.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpej6_ezed.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpej6_ezed.__unittest_L26_C1() [0x427a6a]\n??:? void tmpej6_ezed.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz2tafwbe.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpz2tafwbe.__unittest_L28_C1() [0x427a6a]\n??:? void tmpz2tafwbe.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnl8d3kla.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpnl8d3kla.__unittest_L24_C1() [0x427a6a]\n??:? void tmpnl8d3kla.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpanifoxty.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpanifoxty.__unittest_L27_C1() [0x427a6a]\n??:? void tmpanifoxty.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) \n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp43qi0brl.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp43qi0brl.__unittest_L27_C1() [0x427a6a]\n??:? void tmp43qi0brl.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgo46o9e_.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgo46o9e_.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgo46o9e_.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2yja_k_t.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp2yja_k_t.__unittest_L28_C1() [0x427a6a]\n??:? void tmp2yja_k_t.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk3uc23a_.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpk3uc23a_.__unittest_L27_C1() [0x427a66]\n??:? void tmpk3uc23a_.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1cmwrhq2.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1cmwrhq2.__unittest_L27_C1() [0x427a66]\n??:? void tmp1cmwrhq2.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5p1a381g.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5p1a381g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1L; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9dk5cx02.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp9dk5cx02.__unittest_L27_C1() [0x427a62]\n??:? void tmp9dk5cx02.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9jejzt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpyv9jejzt.__unittest_L24_C1() [0x427a6a]\n??:? void tmpyv9jejzt.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    for(long i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp682fwy__.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp682fwy__.__unittest_L25_C1() [0x427a62]\n??:? void tmp682fwy__.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgbic8nlu.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgbic8nlu.__unittest_L24_C1() [0x427a66]\n??:? void tmpgbic8nlu.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; ++i)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppoy7y31a.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmppoy7y31a.__unittest_L25_C1() [0x427a62]\n??:? void tmppoy7y31a.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    for(long i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp69dyimv9.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp69dyimv9.__unittest_L23_C1() [0x427a62]\n??:? void tmp69dyimv9.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    for(long i = 1; i <= n; i++)\n    {\n        result *= factorial;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdudnewir.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x427d9d]\n??:? void tmpdudnewir.__unittest_L33_C1() [0x427a9a]\n??:? void tmpdudnewir.__modtest() [0x427b20]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42bac3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a956]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fae9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a92d]\n??:? runModuleUnitTests [0x42b899]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281ec]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz1xny_rb.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpz1xny_rb.__unittest_L27_C1() [0x427a6a]\n??:? void tmpz1xny_rb.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgfzqitmp.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgfzqitmp.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgfzqitmp.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 2; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwaa9xhlj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d75]\n??:? void tmpwaa9xhlj.__unittest_L26_C1() [0x427a6e]\n??:? void tmpwaa9xhlj.__modtest() [0x427af4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a92e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff70]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa4d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]\n??:? runModuleUnitTests [0x42b871]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\n/*\nThe Brazilian fibonacci number is defined as:\n    brazilian_fibonacci(n) = n! * (n-1)! * ... * (n-2)!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvikkjorh.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvikkjorh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgo46o9e_.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgo46o9e_.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgo46o9e_.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzxq4gm48.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpzxq4gm48.__unittest_L27_C1() [0x427a66]\n??:? void tmpzxq4gm48.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5p1a381g.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5p1a381g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpanifoxty.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpanifoxty.__unittest_L27_C1() [0x427a6a]\n??:? void tmpanifoxty.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptg573y5k.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptg573y5k.__unittest_L28_C1() [0x427a6a]\n??:? void tmptg573y5k.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    for (i = 1; i <= n; i++)\n    {\n        result *= factorial;\n        factorial *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplpad4tos.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x427dad]\n??:? void tmplpad4tos.__unittest_L35_C1() [0x427aaa]\n??:? void tmplpad4tos.__modtest() [0x427b30]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42bad3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a966]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa85]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a93d]\n??:? runModuleUnitTests [0x42b8a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281fc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    if (n == 0) \n    {\n        return factorial;\n    }\n    \n    for (i = 1; i <= n; i++) \n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq_yzctoh.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x427d7d]\n??:? void tmpq_yzctoh.__unittest_L33_C1() [0x427a7a]\n??:? void tmpq_yzctoh.__modtest() [0x427b00]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a936]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]\n??:? runModuleUnitTests [0x42b879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2yja_k_t.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp2yja_k_t.__unittest_L28_C1() [0x427a6a]\n??:? void tmp2yja_k_t.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgo46o9e_.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgo46o9e_.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgo46o9e_.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        factorial *= i;\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuncm_6ek.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpuncm_6ek.__unittest_L24_C1() [0x427a6a]\n??:? void tmpuncm_6ek.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgfzqitmp.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgfzqitmp.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgfzqitmp.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++){\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuahkl3to.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpuahkl3to.__unittest_L25_C1() [0x427a6a]\n??:? void tmpuahkl3to.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 2; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmg4u7tkc.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpmg4u7tkc.__unittest_L25_C1() [0x427a66]\n??:? void tmpmg4u7tkc.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    if (n == 0)\n        return 1;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplcjikg1r.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x427d85]\n??:? void tmplcjikg1r.__unittest_L29_C1() [0x427a7e]\n??:? void tmplcjikg1r.__modtest() [0x427b04]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a93e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fad1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff80]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a915]\n??:? runModuleUnitTests [0x42b881]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9jejzt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpyv9jejzt.__unittest_L24_C1() [0x427a6a]\n??:? void tmpyv9jejzt.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(4L)\n    24L\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps4u0xu78.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4u0xu78.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt9y57cd6.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpt9y57cd6.__unittest_L26_C1() [0x427a6a]\n??:? void tmpt9y57cd6.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmrig2__c.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpmrig2__c.__unittest_L27_C1() [0x427a62]\n??:? void tmpmrig2__c.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1b9bok2z.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1b9bok2z.__unittest_L27_C1() [0x427a6a]\n??:? void tmp1b9bok2z.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++) \n        fact *= i;\n    return fact;\n}\n/*\nThe Brazilian fibonacci number is defined as:\n    brazilian_fibonacci(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppn2s7d6b.d(24): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppn2s7d6b.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = 1; i < n; i++) {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9m8rj1t7.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp9m8rj1t7.__unittest_L24_C1() [0x427a62]\n??:? void tmp9m8rj1t7.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        factorial *= i;\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuncm_6ek.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpuncm_6ek.__unittest_L24_C1() [0x427a6a]\n??:? void tmpuncm_6ek.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppkumpl3h.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppkumpl3h.__unittest_L24_C1() [0x427a6a]\n??:? void tmppkumpl3h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk3uc23a_.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpk3uc23a_.__unittest_L27_C1() [0x427a66]\n??:? void tmpk3uc23a_.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphjbojn29.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphjbojn29.__unittest_L26_C1() [0x427a6a]\n??:? void tmphjbojn29.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphjbojn29.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphjbojn29.__unittest_L26_C1() [0x427a6a]\n??:? void tmphjbojn29.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1L; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpi5rdy0q8.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpi5rdy0q8.__unittest_L26_C1() [0x427a6a]\n??:? void tmpi5rdy0q8.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7q39whb2.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7q39whb2.__unittest_L24_C1() [0x427a62]\n??:? void tmp7q39whb2.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9jejzt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpyv9jejzt.__unittest_L24_C1() [0x427a6a]\n??:? void tmpyv9jejzt.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9jejzt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpyv9jejzt.__unittest_L24_C1() [0x427a6a]\n??:? void tmpyv9jejzt.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long factorial = 1;\n    \n    while (n > 0)\n    {\n        factorial *= n;\n        n -= 1;\n    }\n    \n    while (factorial > 0)\n    {\n        result *= factorial;\n        factorial -= 1;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbkka3tp8.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x427d7d]\n??:? void tmpbkka3tp8.__unittest_L35_C1() [0x427a7a]\n??:? void tmpbkka3tp8.__modtest() [0x427b00]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a936]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]\n??:? runModuleUnitTests [0x42b879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk3uc23a_.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpk3uc23a_.__unittest_L27_C1() [0x427a66]\n??:? void tmpk3uc23a_.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmrig2__c.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpmrig2__c.__unittest_L27_C1() [0x427a62]\n??:? void tmpmrig2__c.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++){\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj9h1y6ja.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpj9h1y6ja.__unittest_L25_C1() [0x427a6a]\n??:? void tmpj9h1y6ja.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++) \n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of all positive integers less than or equal to it.\n    \n    For example:\n    >>> factorial(4L)\n    24L\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgi5qg1tt.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgi5qg1tt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    if (n <= 1L) \n    {\n        return factorial;\n    }\n    \n    for (i = 2L; i <= n; i++) \n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfa79siub.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x427d7d]\n??:? void tmpfa79siub.__unittest_L33_C1() [0x427a7a]\n??:? void tmpfa79siub.__modtest() [0x427b00]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a936]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]\n??:? runModuleUnitTests [0x42b879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgfzqitmp.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgfzqitmp.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgfzqitmp.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyn5qralx.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpyn5qralx.__unittest_L27_C1() [0x427a62]\n??:? void tmpyn5qralx.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj6xhasx8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpj6xhasx8.__unittest_L28_C1() [0x427a6a]\n??:? void tmpj6xhasx8.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for(long i = 1; i <= n; i++) \n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6a7f_gmq.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp6a7f_gmq.__unittest_L25_C1() [0x427a62]\n??:? void tmp6a7f_gmq.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++){\n        factorial *= i;\n    }\n    return factorial;\n}\n/*\nThe Brazilian fibonacci number is defined as:\n    brazilian_fibonacci(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdzdov71w.d(25): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzdov71w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1cmwrhq2.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1cmwrhq2.__unittest_L27_C1() [0x427a66]\n??:? void tmp1cmwrhq2.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphswrm04d.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphswrm04d.__unittest_L27_C1() [0x427a6a]\n??:? void tmphswrm04d.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe Brazilian fibonacci number is defined as:\n    brazilian_fibonacci(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo0i99btl.d(27): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo0i99btl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz1xny_rb.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpz1xny_rb.__unittest_L27_C1() [0x427a6a]\n??:? void tmpz1xny_rb.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact = fact * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyv9jejzt.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpyv9jejzt.__unittest_L24_C1() [0x427a6a]\n??:? void tmpyv9jejzt.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1L; i <= n; i++)\n        factorial *= i;\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp_l20l7w.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpp_l20l7w.__unittest_L24_C1() [0x427a6a]\n??:? void tmpp_l20l7w.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1b9bok2z.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1b9bok2z.__unittest_L27_C1() [0x427a6a]\n??:? void tmp1b9bok2z.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2yja_k_t.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp2yja_k_t.__unittest_L28_C1() [0x427a6a]\n??:? void tmp2yja_k_t.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk3uc23a_.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpk3uc23a_.__unittest_L27_C1() [0x427a66]\n??:? void tmpk3uc23a_.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyn5qralx.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpyn5qralx.__unittest_L27_C1() [0x427a62]\n??:? void tmpyn5qralx.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsqy2yxlx.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpsqy2yxlx.__unittest_L25_C1() [0x427a6a]\n??:? void tmpsqy2yxlx.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++){\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppnfi369p.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmppnfi369p.__unittest_L26_C1() [0x427a62]\n??:? void tmppnfi369p.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppkumpl3h.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppkumpl3h.__unittest_L24_C1() [0x427a6a]\n??:? void tmppkumpl3h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; i++) \n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits. \nThe factorial of 0 is 1, the factorial of 1 is 1, the factorial of 2 is 2, \nthe factorial of 3 is 6 and so on. \nThe factorial of n is n*(n-1)*(n-2)*...*1 \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; i++) \n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits. \nThe factorial of 0 is 1, the factorial of 1 is 1, the factorial of 2 is 2, \nthe factorial of 3 is 6 and so on. \nThe factorial of n is n*(n-1)*(n-2)*...*1 \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; i++) \n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits. \nThe factorial of 0 is 1, the factorial of 1 is 1, the factorial of 2 is 2, \nthe factorial of 3 is 6 and so on. \nThe factorial of n is n*(n-1)*(n-2)*...*1 \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; i++) \n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits. \nThe factorial of 0 is 1, the factorial of 1 is 1, the factorial of 2 is 2, \nthe factorial of 3 is 6 and so on. \nThe factorial of n is n*(n-1)*(n-2)*...*1 \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; i++) \n    {\n        result = result * i;\n    }\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits. \nThe factorial of 0 is 1, the factorial of 1 is 1, the factorial of 2 is 2, \nthe factorial of 3 is 6 and so on. \nThe factorial of n is n*(n-1)*(n-2)*...*1 \n*/\nlong factorial(long \nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx0dtibbu.d(92): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx0dtibbu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppkumpl3h.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppkumpl3h.__unittest_L24_C1() [0x427a6a]\n??:? void tmppkumpl3h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpej6_ezed.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpej6_ezed.__unittest_L26_C1() [0x427a6a]\n??:? void tmpej6_ezed.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is a product of factorials of smaller numbers.\n    \n    For example:\n    >>> factorial(4L)\n    24L\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6d2e5lm4.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6d2e5lm4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpej6_ezed.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpej6_ezed.__unittest_L26_C1() [0x427a6a]\n??:? void tmpej6_ezed.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk3uc23a_.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpk3uc23a_.__unittest_L27_C1() [0x427a66]\n??:? void tmpk3uc23a_.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++) \n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnxjbbe4v.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpnxjbbe4v.__unittest_L26_C1() [0x427a62]\n??:? void tmpnxjbbe4v.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgo46o9e_.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgo46o9e_.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgo46o9e_.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5668zo6y.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp5668zo6y.__unittest_L27_C1() [0x427a62]\n??:? void tmp5668zo6y.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++) \n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppgj9wcjq.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppgj9wcjq.__unittest_L26_C1() [0x427a6a]\n??:? void tmppgj9wcjq.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa1k1hh_w.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa1k1hh_w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163963
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2yja_k_t.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp2yja_k_t.__unittest_L28_C1() [0x427a6a]\n??:? void tmp2yja_k_t.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++){\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp49xgi8ig.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp49xgi8ig.__unittest_L26_C1() [0x427a62]\n??:? void tmp49xgi8ig.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; ++i)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppoy7y31a.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmppoy7y31a.__unittest_L25_C1() [0x427a62]\n??:? void tmppoy7y31a.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5668zo6y.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp5668zo6y.__unittest_L27_C1() [0x427a62]\n??:? void tmp5668zo6y.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt9y57cd6.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpt9y57cd6.__unittest_L26_C1() [0x427a6a]\n??:? void tmpt9y57cd6.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpej6_ezed.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpej6_ezed.__unittest_L26_C1() [0x427a6a]\n??:? void tmpej6_ezed.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1b9bok2z.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1b9bok2z.__unittest_L27_C1() [0x427a6a]\n??:? void tmp1b9bok2z.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfcuyay_x.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpfcuyay_x.__unittest_L27_C1() [0x427a6a]\n??:? void tmpfcuyay_x.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppkumpl3h.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmppkumpl3h.__unittest_L24_C1() [0x427a6a]\n??:? void tmppkumpl3h.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpesun8zy1.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpesun8zy1.__unittest_L27_C1() [0x427a6a]\n??:? void tmpesun8zy1.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp81ceucvj.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp81ceucvj.__unittest_L26_C1() [0x427a6a]\n??:? void tmp81ceucvj.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1cmwrhq2.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp1cmwrhq2.__unittest_L27_C1() [0x427a66]\n??:? void tmp1cmwrhq2.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphjbojn29.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphjbojn29.__unittest_L26_C1() [0x427a6a]\n??:? void tmphjbojn29.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    if (n <= 1L) \n    {\n        return 1;\n    }\n    \n    for (i = 2L; i <= n; i++) \n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpec0yill9.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x427d7d]\n??:? void tmpec0yill9.__unittest_L33_C1() [0x427a76]\n??:? void tmpec0yill9.__modtest() [0x427afc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42baa3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a936]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fac9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a90d]\n??:? runModuleUnitTests [0x42b879]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmrig2__c.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpmrig2__c.__unittest_L27_C1() [0x427a62]\n??:? void tmpmrig2__c.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long result = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        result *= i;\n    return result;\n}\n/*\nThe factorial of a number is the product of its digits:\n    \nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3gqnvmj3.d(124): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3gqnvmj3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt9y57cd6.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpt9y57cd6.__unittest_L26_C1() [0x427a6a]\n??:? void tmpt9y57cd6.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphjbojn29.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphjbojn29.__unittest_L26_C1() [0x427a6a]\n??:? void tmphjbojn29.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for (long i = 1; i <= n; i++) {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0cf8sqmy.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp0cf8sqmy.__unittest_L26_C1() [0x427a62]\n??:? void tmp0cf8sqmy.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result = result * i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfyqgb7ro.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpfyqgb7ro.__unittest_L27_C1() [0x427a6a]\n??:? void tmpfyqgb7ro.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptraubs3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptraubs3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmptraubs3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    for (i = 1; i <= n; i++)\n    {\n        result *= factorial;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgqlxzx07.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x427da5]\n??:? void tmpgqlxzx07.__unittest_L34_C1() [0x427a9e]\n??:? void tmpgqlxzx07.__modtest() [0x427b24]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42bacb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a95e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42faf1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa7d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a935]\n??:? runModuleUnitTests [0x42b8a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281f4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n        factorial *= i;\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuncm_6ek.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpuncm_6ek.__unittest_L24_C1() [0x427a6a]\n??:? void tmpuncm_6ek.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2e2mz3hi.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp2e2mz3hi.__unittest_L27_C1() [0x427a66]\n??:? void tmp2e2mz3hi.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqdto0tgv.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpqdto0tgv.__unittest_L27_C1() [0x427a6a]\n??:? void tmpqdto0tgv.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe Brazilian fibonacci number is defined as:\n    brazilian_fibonacci(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9xizi399.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9xizi399.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7x28w5au.d(26): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7x28w5au.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptg573y5k.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptg573y5k.__unittest_L28_C1() [0x427a6a]\n??:? void tmptg573y5k.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for(i = 1; i <= n; i++) \n    {\n        fact = fact * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpprhvu1te.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpprhvu1te.__unittest_L27_C1() [0x427a6a]\n??:? void tmpprhvu1te.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for (long i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7q39whb2.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7q39whb2.__unittest_L24_C1() [0x427a62]\n??:? void tmp7q39whb2.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptraubs3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptraubs3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmptraubs3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpma7y4jis.d(131): Error: found `unittest` instead of statement\n/tmp/tmpma7y4jis.d(140): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpma7y4jis.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for (long i = 1L; i <= n; i++) {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpa0ulqagz.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpa0ulqagz.__unittest_L26_C1() [0x427a62]\n??:? void tmpa0ulqagz.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n        fact *= i;\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptraubs3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptraubs3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmptraubs3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    for(long i = 1L; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcz1t6wm7.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmpcz1t6wm7.__unittest_L25_C1() [0x427a62]\n??:? void tmpcz1t6wm7.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of all its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of all its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of all its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of all its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe factorial of a number is the product of all its digits:\n    factorial(n) = n * factorial(n-1)\n    \n    For example:\n    >>> factorial(5)\n    120\n    \n    The function will receive an integer as input and should return the factorial\n    of this integer.\n    \n*/\nlong factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1r6e5pv1.d(131): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1r6e5pv1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    \n    for(long i = 2; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzxq4gm48.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpzxq4gm48.__unittest_L27_C1() [0x427a66]\n??:? void tmpzxq4gm48.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2yja_k_t.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp2yja_k_t.__unittest_L28_C1() [0x427a6a]\n??:? void tmp2yja_k_t.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    for(long i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp69dyimv9.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp69dyimv9.__unittest_L23_C1() [0x427a62]\n??:? void tmp69dyimv9.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpz2tafwbe.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpz2tafwbe.__unittest_L28_C1() [0x427a6a]\n??:? void tmpz2tafwbe.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7yexxyp3.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d65]\n??:? void tmp7yexxyp3.__unittest_L27_C1() [0x427a62]\n??:? void tmp7yexxyp3.__modtest() [0x427ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a91e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]\n??:? runModuleUnitTests [0x42b861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281b4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    \n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmps3mu08dc.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmps3mu08dc.__unittest_L28_C1() [0x427a6a]\n??:? void tmps3mu08dc.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163965
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++)\n    {\n        result = result * i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptg573y5k.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmptg573y5k.__unittest_L28_C1() [0x427a6a]\n??:? void tmptg573y5k.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long fact = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpgfzqitmp.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpgfzqitmp.__unittest_L26_C1() [0x427a6a]\n??:? void tmpgfzqitmp.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp49xc6_z8.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmp49xc6_z8.__unittest_L26_C1() [0x427a6a]\n??:? void tmp49xc6_z8.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163966
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long factorial = 1;\n    long i;\n    for(i = 1; i <= n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwcbb1r3l.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmpwcbb1r3l.__unittest_L26_C1() [0x427a6a]\n??:? void tmpwcbb1r3l.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n    long result = 1;\n    long i;\n    \n    for (i = 1; i <= n; i++) {\n        result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphbb3jurf.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x427d6d]\n??:? void tmphbb3jurf.__unittest_L27_C1() [0x427a6a]\n??:? void tmphbb3jurf.__modtest() [0x427af0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4281bc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163964
    }
  ]
}