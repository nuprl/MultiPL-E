name: HumanEval_21_rescale_to_unit
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at\
  \ least two elements), apply a linear transform to that list,\n    such that the\
  \ smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
  \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
  \ numbers) \n"
tests: "unittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0,\
  \ 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n\
  \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n\
  \    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n\
  \    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n\
  }\nvoid main(){}"
completions: ["{\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        min = min(min, numbers[i]);\n\
    \        max = max(max, numbers[i]);\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        numbers[i]\
    \ = (float)(numbers[i] - min) / scale;\n    }\n    return numbers;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the list is all zero. `rescale_to_unit([0.0])`\
    \ returns `[1.0]`\n<|/ c |>\n<| c |>\nI added a version that works with zero and\
    \ negative numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the list is all zero. `rescale_to_unit([0.0])` returns `[1.0]`\n<|/\
    \ c |>\n<| c |>\nI added a version that works with zero and negative numbers.\
    \ I tested it and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if the list\
    \ is all zero. `rescale_to_unit([0.0])` returns `[1.0]`\n<|/ c |>\n<| a tags=arrays,c#,math\
    \ |>\n<code>\npublic static double[] rescaleToUnit(double[] numbers)\n{\n    double\
    \ min = numbers.Min();\n    double max = numbers.Max();\n    double scale = (max\
    \ - min) / (double)(numbers.Length - 1);\n    double[] result = new double[numbers.Length];\n\
    \    for (int i = 0; i < numbers.Length; i++)\n    {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] /= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static double[] rescaleToUnit(double[]\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double scale = (max - min) / (double)(numbers.Length - 1);\n    double[]\
    \ result = new double[numbers.Length];\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] /= scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,math |>\n<| a dscore=1\
    \ |>\n<code>\npublic static double[] rescaleToUnit(double[] numbers)\n{\n    double\
    \ min = numbers.Min();\n    double max = numbers.Max();\n    double scale = (max\
    \ - ", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \         max = numbers[i];\n        if (numbers[i] < min)\n            min =\
    \ numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n  \
    \  for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<|\
    \ c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0,\
    \ 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]`\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    float[] result = new float[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm dscore=5\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([", "{\n    float min\
    \ = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float sum = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n\
    \        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=java,arrays,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers in the array. `rescale_to_unit([-10,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-10, -5, -4, -3, -2, -1, 0,\
    \ 1, 2, 3, 4, 5]` instead of `[-0.5, -0.25, 0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 2.5,\
    \ 3.0, 3.5, 4.0, 4.5]`.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static float[]\
    \ rescale(float[] numbers) {\n    float min = Float.MAX_VALUE;\n    float max\
    \ = Float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if(numbers[i] > max)\n         \
    \   max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return\
    \ numbers;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n<| a tags=java,arrays,algorithm\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min\
    \ = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    float sum = 0;\n \
    \   for(int i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n  \
    \      if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++) {\n   \
    \     numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=java,arrays,algorithm |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n\
    \    float sum = 0;\n    for(int i = 0; i < numbers.length; i++) {\n        sum\
    \ += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \        if(numbers[i] < min)\n            min = ", "{\n    float[] result = new\
    \ float[numbers.length];\n    float minValue = numbers[0];\n    float maxValue\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n        }\n    \
    \    if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \        }\n    }\n    float scale = (maxValue - minValue) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - minValue;\n        result[i] *= scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if you have negative numbers.\
    \ Try rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have negative numbers. Try rescale_to_unit([-5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])\n<|/ c |>\n<| a tags=c#,math |>\nI wrote\
    \ a small C# program to solve this problem. \n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;", "{\n \
    \   float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        float number = numbers[i];\n        if (number < min)\n       \
    \     min = number;\n        if (number > max)\n            max = number;\n  \
    \  }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for (int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] - min;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n        result[i] *= scale;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work.\
    \ `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI added a\
    \ version that works with floats.\n<|/ c |>\n<| c |>\nThis doesn't work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ floats.\n<|/ c |>\n<| c |>\nThis doesn't work. `rescale_to_unit([1.0, 2.0, 3.0,\
    \ 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]`\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n\
    \        if (number < min) {\n            min = number;\n        }\n        if\
    \ (number > max) {\n            max = number;\n        }\n    }\n    float scale\
    \ = (max - min) / (float) (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math |>\n<| a |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n\
    \        if (number < min) {\n            min = number;\n        }\n        if\
    \ (number > max) {\n            max = number;\n        }\n    }\n    float scale\
    \ = (max - min) / (float) (number", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] - min;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n        result[i] *= scale;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI came up with a simple\
    \ solution that doesn't require any external libraries:\n<code>\npublic static\
    \ float[] rescale(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++) {\n        if(numbers[i] > max) {\n            max\
    \ = numbers[i];\n        }\n        if(numbers[i] < min) {\n            min =\
    \ numbers[i];\n        }\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,rescale |>\n<| a |>\nI came up with this solution:\n<code>\n\
    public static float[] rescale(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float scale = (max\
    \ - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] - min;\n        result[i] *= scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=java,arrays,rescale\
    \ |>\n<| a tags=java,arrays,rescale |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float scale = (max - min) / (",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays,math |>\n<| a |>\n<code>\npublic static float[]\
    \ rescale(float[] numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        sum\
    \ += numbers[i];\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    float[] result = new float[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=java,arrays,math\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale(float[] numbers)\
    \ {\n    float min = numbers[0];\n    float max = numbers[0];\n    float sum =\
    \ 0;\n    for (int i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    float[] result = new float[numbers.length];\n   \
    \ for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] *\
    \ scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n\
    <| a |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max)\n            max = numbers[i];\n        if (numbers[i] < min)\n     \
    \       min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n\
    \    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 tags=java,arrays,math |>\n<| a tags=java,arrays,",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        float number = numbers[i];\n        if(number < min)\n         \
    \   min = number;\n        if(number > max)\n            max = number;\n     \
    \   result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=c#,math,algorithm,.net |>\n<| c |>\nThis doesn't work. Try\
    \ rescale_to_unit([0.5, 0.5, 0.5, 0.5]). You'll get [0.0, 0.0, 0.0, 0.0].\n<|/\
    \ c |>\n<| c |>\n: Yes, you're right. I've fixed it now. Thanks.\n<|/ c |>\n<|\
    \ a tags=c#,math,algorithm,.net |>\n<code>\npublic static float RescaleToUnit(float\
    \ value)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n\
    \    float scale = 1;\n    float result = value;\n    float increment = max -\
    \ min;\n    while (result > max)\n    {\n        result += increment;\n      \
    \  scale *= 2;\n    }\n    while (result < min)\n    {\n        result -= increment;\n\
    \        scale /= 2;\n    }\n    return result / scale;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=c#,math,algorithm,.net |>\n<code>\npublic static float RescaleToUnit(float\
    \ value)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n\
    \    float scale = 1;\n    float result = value;\n    float increment = max -\
    \ min;\n    while (result > max)\n    {\n        result += increment;\n      \
    \  scale *= 2;\n    }\n    while (result < min)\n    {\n        result -= increment;\n\
    \        scale /= 2;\n    }\n    return result / scale;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static float RescaleToUnit(float value)\n\
    {\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    float\
    \ scale = 1;\n    float result = value;\n    float increment = max - min;\n  \
    \  while (result > max)\n    {\n        result += increment;\n        scale *=\
    \ 2;\n    }\n    while (result < min)\n    {\n        result -= increment;\n \
    \       scale /= 2;\n    }\n    return result / scale;\n}\n</code>\n<|/ a tags=c#,math,algorithm,.net\
    \ |>\n<|", "{\n    float[] result = new float[numbers.length];\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    for (int i = 0; i < numbers.length; i++)\n    {\n  \
    \      result[i] = numbers[i] - min;\n        result[i] /= range;\n    }\n   \
    \ return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ the numbers are in descending order. For example, `[10, 9, 8, 7, 6, 5, 4, 3,\
    \ 2, 1]` will give `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]`\n<|/ c |>\n<| c |>\n:\
    \ Yes, I noticed that and fixed it. I also added a version that doesn't require\
    \ the numbers to be in descending order.\n<|/ c |>\n<| c |>\nThanks for the fix!\
    \ I didn't realize that `std::minmax` was a thing.\n<|/ c |>\n<| c |>\n: Yes,\
    \ `std::minmax` is very useful.\n<|/ c |>\n<| a tags=c++,math,algorithm |>\nThis\
    \ should do it:\n<code>\nfloat rescale_to_unit(float numbers[], int length)\n\
    {\n    float min = numbers[0];\n    float max = numbers[0];\n    for (int i =\
    \ 0; i < length; i++)\n    {\n        if (numbers[i] > max)\n            max =\
    \ numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float result[] = new float[length];\n\
    \    for (int i = 0; i < length; i++)\n    {\n        result[i] = numbers[i] -\
    \ min;\n        result[i] /= range;\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work if the numbers are in descending order.\
    \ For example, `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]` will give `[10, 9, 8, 7, 6, 5,\
    \ 4, 3, 2, 1, 0]`\n<|/ c |>\n<| c |>\n: Yes, I noticed that and fixed it. I also\
    \ added a version that doesn't require the numbers to be in descending order.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nfloat rescale_to_unit(float numbers[], int\
    \ length)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for\
    \ (int i = 0; i < length; i++)\n    {\n        if (numbers[i] > max)\n       \
    \     max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; ++i) {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max) {\n            max = numbers[i];\n        } else\
    \ if (numbers[i] < min) {\n            min = numbers[i];\n        }\n    }\n \
    \   float scale = 1.0f / (max - min);\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }", "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n     \
    \       min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=c++,math,algorithm\
    \ |>\n<| c |>\nThis doesn't work when numbers are negative.\n<|/ c |>\n<| c |>\n\
    It doesn't work when numbers are negative.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ when numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't work when numbers\
    \ are negative.\n<|/ c |>\n<| c |>\nIt doesn't work when numbers are negative.\n\
    <|/ c |>\n<| a dscore=5 |>\nI wrote a small program to solve this problem in C++.\n\
    <code>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n      \
    \      min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm,.net |>\n\
    <| c |>\nThis doesn't work if there are negative numbers in the list. Try it with\
    \ the list `[1.0, 2.0, 3.0, -4.0, 5.0]`.\n<|/ c |>\n<| c |>\n: Yes, I know. That's\
    \ why I wrote \"of at least two elements\". Of course you can add more checks\
    \ to make sure you only have positive numbers in the list. I'll add that to the\
    \ answer.\n<|/ c |>\n<| c |>\n: I added a version that doesn't require any checks.\n\
    <|/ c |>\n<| c |>\n: I added a version that doesn't require any checks.\n<|/ c\
    \ |>\n<| c |>\n: I added a version that doesn't require any checks.\n<|/ c |>\n\
    <| a tags=c#,math,algorithm,.net |>\n<code>\npublic static float RescaleToUnit(this\
    \ float[] numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n\
    \    float sum = numbers.Sum();\n    float scale = 1.0f / (max - min);\n    float\
    \ result = numbers.Select(x => x * scale).Sum();\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis doesn't work if there are negative numbers in\
    \ the list. Try it with the list `[1.0, 2.0, 3.0, -4.0, 5.0]`.\n<|/ c |>\n<| c\
    \ |>\n: I added a version that doesn't require any checks.\n<|/ c |>\n<| c |>\n\
    : I added a version that doesn't require any checks.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that doesn't require any checks.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    public static float RescaleToUnit(this float[] numbers)\n{\n    float min = numbers.Min();\n\
    \    float max = numbers.Max();\n    float sum = numbers.Sum();\n    float scale\
    \ = 1.0f / (max - ", "{\n    float[] result = new float[numbers.length];\n   \
    \ float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n \
    \   for (int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; ++i)\n      \
    \  result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=c#,math,algorithm |>\nI wrote a C# version that uses LINQ to calculate\
    \ the cumulative sum and then divides the result by the sum of the original numbers:\n\
    <code>\npublic static IEnumerable<double> LinearTransform(IEnumerable<double>\
    \ numbers)\n{\n    double sum = numbers.Sum();\n    double cumulativeSum = numbers.Sum(x\
    \ => x);\n    double result = cumulativeSum / sum;\n    return numbers.Select(x\
    \ => result * x);\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static IEnumerable<double> LinearTransform(IEnumerable<double>\
    \ numbers)\n{\n    double sum = numbers.Sum();\n    double cumulativeSum = numbers.Sum(x\
    \ => x);\n    double result = cumulativeSum / sum;\n    return numbers.Select(x\
    \ => result * x);\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static IEnumerable<double> LinearTransform(IEnumerable<double>\
    \ numbers)\n{\n    double sum = numbers.Sum();\n    double cumulativeSum = numbers.Sum(x\
    \ => x);\n    double result = cumulativeSum / sum;\n    return numbers.Select(x\
    \ => result * x);\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\npublic static\
    \ IEnumerable<double> LinearTransform(IEnumerable<double> numbers)\n{\n    double\
    \ sum = numbers.Sum();\n    double cumulativeSum = numbers.Sum(x => x);\n    double\
    \ result = cumulativeSum / sum;\n    return numbers.Select(x => result * x);\n\
    }\n</code>\n<|/ a dscore=2 tags=c#,math,algorithm |>\n<| a dscore=1 |>\n<code>\n\
    public static IEnumerable<double> LinearTransform(IEnumerable<double> numbers)",
  "{\n    float[] result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    for(int i = 0; i < numbers.length; ++i)\n\
    \    {\n        float number = numbers[i];\n        min = min(number, min);\n\
    \        max = max(number, max);\n        result[i] = (number - min) / (max -\
    \ min);\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n\
    <| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine for me. Can you give an example\
    \ where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it and it works fine for\
    \ me. Can you give an example where it doesn't work?\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine for me. Can you give an example where it doesn't work?\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine for me. Can you give an example\
    \ where it doesn't work?\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n    \
    \    min = Math.min(number, min);\n        max = Math.max(number, max);\n    \
    \    result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays,math |>\n<| a dscore=2 |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n    \
    \    min = Math.min(number, min);\n        max = Math.max(number, max);\n    \
    \    result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays,math |>\n<| a tags=java,arrays,math |>\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers) {\n    float[] result =\
    \ new float[numbers.length];\n    float min = Float.", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static IEnumerable<float>\
    \ RescaleToUnit(this IEnumerable<float> numbers)\n{\n    var min = numbers.Min();\n\
    \    var max = numbers.Max();\n    var sum = numbers.Sum();\n    var scale = 1.0f\
    \ / (max - min);\n    return numbers.Select(x => x * scale);\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static IEnumerable<float>\
    \ RescaleToUnit(this IEnumerable<float> numbers)\n{\n    var min = numbers.Min();\n\
    \    var max = numbers.Max();\n    var sum = numbers.Sum();\n    var scale = 1.0f\
    \ / (max - min);\n    return numbers.Select(x => x * scale);\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static IEnumerable<float> RescaleToUnit(this\
    \ IEnumerable<float> numbers)\n{\n    var min = numbers.Min();\n    var max =\
    \ numbers.Max();\n    var sum = numbers.Sum();\n    var scale = 1.0f / (max -\
    \ min);\n    return numbers.Select(x => x * scale);\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static IEnumerable<float> RescaleToUnit(this\
    \ IEnumerable<float> numbers)\n{\n    var min = numbers.Min();\n    var max =\
    \ numbers.Max();\n    var sum = numbers.Sum();\n    var scale = 1.0f / (max -\
    \ min);\n    return numbers.Select(x => x * scale);\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static IEnumerable<float>\
    \ RescaleToUnit(this IEnumerable<float> numbers)\n{\n    var min = numbers.Min();\n\
    \    var max = numbers.Max();\n    var sum = numbers.Sum();\n    var scale = 1.0f\
    \ / (max - min);\n    return numbers.", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}", "{\n    float min = numbers[0];\n \
    \   float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n   \
    \ {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n\
    \    float scale = 1.0f / range;\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=math,c#,algorithm,.net\
    \ |>\nI wrote this in C#:\n<code>\npublic static class Math\n{\n    public static\
    \ double Min(params double[] values)\n    {\n        double min = double.MaxValue;\n\
    \        foreach (double value in values)\n        {\n            if (value <\
    \ min)\n                min = value;\n        }\n        return min;\n    }",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ 1.0f / (max - min);\n    for (int i = 0; i < numbers.length; ++i)\n    {\n \
    \       result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=math,c#,algorithm,linear-algebra |>\n<| c |>\nThis doesn't seem to\
    \ work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]). Result: [0.0, 0.25, 0.5,\
    \ 0.75, 1.0]\n<|/ c |>\n<| c |>\n: It works fine for me. Did you copy the code\
    \ correctly? The code I posted is exactly the same as the code you posted in the\
    \ question.\n<|/ c |>\n<| c |>\n: I see what you mean. Yes, I did copy the code\
    \ correctly. Sorry for the confusion.\n<|/ c |>\n<| c |>\n: I added a version\
    \ that does what you want.\n<|/ c |>\n<| c |>\n: I added a version that does what\
    \ you want.\n<|/ c |>\n<| a tags=math,c#,algorithm,linear-algebra |>\nThe algorithm\
    \ is simple:", "{\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n\
    \    return numbers;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work\
    \ if you have negative numbers. Try `rescale_to_unit([-10, -5, -2, 0, 2, 5, 10])`\
    \ which should return `[-10, -5, -2, 0, 2, 5, 10]` but returns `[-10, -5, -2,\
    \ 0, 2, 5, 10]`.\n<|/ c |>\n<| c |>\nI fixed the negative numbers by adding `if\
    \ (numbers[i] < 0)` before `min = numbers[i];`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try `rescale_to_unit([-10, -5, -2, 0, 2,\
    \ 5, 10])` which should return `[-10, -5, -2, 0, 2, 5, 10]` but returns `[-10,\
    \ -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| c |>\nI fixed the negative numbers by adding\
    \ `if (numbers[i] < 0)` before `min = numbers[i];`\n<|/ c |>\n<| a |>\nI came\
    \ up with another solution that is more efficient than others posted here.\n<code>\n\
    public static float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n\
    \        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return\
    \ numbers;\n}\n</code>\n<|/ a dscore=3 tags=math,java,rescale,arrays |>\n<| c\
    \ |>\nThis doesn't work if you have negative numbers. Try `rescaleToUnit([-10,\
    \ -5, -2, 0, 2, 5, 10])` which should return `[-10, -5, -2, 0, 2, 5, 10]` but\
    \ returns `[-10, -5, -2, 0, 2, 5, 10]`.\n<|/ c |>\n<| a tags=math,java,rescale,arrays\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float ",
  "{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \       min = numbers[i];\n        else if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    \n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    \n    float[] result = new float[numbers.length];\n    for(int i\
    \ = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n   \
    \ \n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| c |>\n\
    This doesn't work if you have negative numbers. For example, `rescale_to_unit([-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]`.\n<|/ c |>\n<| c\
    \ |>\nI added a version that handles negative numbers. I tested it and it works.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers. For example,\
    \ `rescale_to_unit([-10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0,\
    \ -0.0])` returns `[-10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0,\
    \ 0.0]`.\n<|/ c |>\n<| c |>\nI added a version that handles negative numbers.\
    \ I tested it and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ negative numbers. For example, `rescale_to_unit([-10.0, -9.0, -8.0, -7.0, -6.0,\
    \ -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0, -9.0, -8.0, -7.0, -6.0,\
    \ -5.0, -4.0, -3.0, -2.0, -1.0, 0.0]`.\n<|/ c |>\n<| a dscore=5 |>\nThe easiest\
    \ way is to use Apache Commons Math library:\n<code>\nimport org.apache.commons.math3.analysis.function.Sigmoid;\n\
    import org.apache.commons.math3.analysis.function.Transform;\nimport org.apache.commons.math3.analysis.function.TransformType;\n\
    import org.apache.commons.math3.analysis.function.SigmoidType;\nimport org.apache.commons.math3.analysis.function.TransformType;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
