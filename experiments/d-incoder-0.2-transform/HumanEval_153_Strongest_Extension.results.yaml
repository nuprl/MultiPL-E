language: d
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map_reverse;\n    map<string, int> extension_count_map;\n\
    \    map<string, int> extension_count_map_reverse;\n    map<string, int> extension_count_map_reverse2;\n\
    \    map<string, int> extension_count_map_reverse3;\n    map<string, int> extension_count_map_reverse4;\n\
    \    map<string, int> extension_count_map_reverse5;\n    map<string, int> extension_count_map_reverse6;\n\
    \    map<string, int> extension_count_map_reverse7;\n    map<string, int> extension_count_map_reverse8;\n\
    \    map<string, int> extension_count_map_reverse9;\n    map<string, int> extension_count_map_reverse10;\n\
    \    map<string, int> extension_count_map_reverse11;\n    map<string, int> extension_count_map_reverse12;\n\
    \    map<string, int> extension_count_map_reverse13;\n    map<string, int> extension_count_map_reverse14;\n\
    \    map<string, int> extension_count_map_reverse15;\n    map<string, int> extension_count_map_reverse16;\n\
    \    map<string, int> extension_count_map_reverse17;\n    map<string, int> extension_count_map_reverse18;\n\
    \    map<string, int> extension_count_map_reverse19;\n    map<string, int> extension_count_map_reverse20;\n\
    \    map<string, int> extension_count_map_reverse21;\n    map<string, int> extension_count_map_reverse22;\n\
    \    map<string, int> extension_count_map_reverse23;\n    map<string, int> extension_count_map_reverse24;\n\
    \    map<string, int> extension_count_map_reverse25;\n    map<string, int> extension_count_map_reverse26;\n\
    \    map<string, int> extension_count_map_reverse27;\n    map<string, int> extension_count_map_reverse28;\n\
    \    map<string, int> extension_count_map_reverse29;\n    map<string, int> extension_count_map_reverse30;\n\
    \    map<string, int> extension_count_map_reverse31;\n    map<string, int> extension_count_map_reverse32;\n\
    \    map<string, int> extension_count_map_reverse33;\n    map<string, int> extension_count_map_reverse34;\n\
    \    map<string, int> extension_count_map_reverse35;\n    map<\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1gbix7q0.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmp1gbix7q0.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmp1gbix7q0.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmp1gbix7q0.d(26): Error:
    found `>` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(27): Error: found
    `>` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(28): Error: found `>`
    when expecting `.` following int\n/tmp/tmp1gbix7q0.d(29): Error: found `>` when
    expecting `.` following int\n/tmp/tmp1gbix7q0.d(30): Error: found `>` when expecting
    `.` following int\n/tmp/tmp1gbix7q0.d(31): Error: found `>` when expecting `.`
    following int\n/tmp/tmp1gbix7q0.d(32): Error: found `>` when expecting `.` following
    int\n/tmp/tmp1gbix7q0.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(34):
    Error: found `>` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(35): Error:
    found `>` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(36): Error: found
    `>` when expecting `.` following int\n/tmp/tmp1gbix7q0.d(37): Error: found `>`
    when expecting `.` following int\n/tmp/tmp1gbix7q0.d(38): Error: found `>` when
    expecting `.` following int\n/tmp/tmp1gbix7q0.d(39): Error: found `>` when expecting
    `.` following int\n/tmp/tmp1gbix7q0.d(40): Error: found `>` when expecting `.`
    following int\n/tmp/tmp1gbix7q0.d(41): Error: found `>` when expecting `.` following
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1gbix7q0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map_reverse;\n    map<int, string> extension_map_reverse2;\n\
    \    map<int, string> extension_map_reverse3;\n    map<int, string> extension_map_reverse4;\n\
    \    map<int, string> extension_map_reverse5;\n    map<int, string> extension_map_reverse6;\n\
    \    map<int, string> extension_map_reverse7;\n    map<int, string> extension_map_reverse8;\n\
    \    map<int, string> extension_map_reverse9;\n    map<int, string> extension_map_reverse10;\n\
    \    map<int, string> extension_map_reverse11;\n    map<int, string> extension_map_reverse12;\n\
    \    map<int, string> extension_map_reverse13;\n    map<int, string> extension_map_reverse14;\n\
    \    map<int, string> extension_map_reverse15;\n    map<int, string> extension_map_reverse16;\n\
    \    map<int, string> extension_map_reverse17;\n    map<int, string> extension_map_reverse18;\n\
    \    map<int, string> extension_map_reverse19;\n    map<int, string> extension_map_reverse20;\n\
    \    map<int, string> extension_map_reverse21;\n    map<int, string> extension_map_reverse22;\n\
    \    map<int, string> extension_map_reverse23;\n    map<int, string> extension_map_reverse24;\n\
    \    map<int, string> extension_map_reverse25;\n    map<int, string> extension_map_reverse26;\n\
    \    map<int, string> extension_map_reverse27;\n    map<int, string> extension_map_reverse28;\n\
    \    map<int, string> extension_map_reverse29;\n    map<int, string> extension_map_reverse30;\n\
    \    map<int, string> extension_map_reverse31;\n    map<int, string> extension_map_reverse32;\n\
    \    map<int, string> extension_map_reverse33;\n    map<int, string> extension_map_reverse34;\n\
    \    map<int, string> extension_map_reverse35;\n    map<int, string> extension_map_reverse36;\n\
    \    map<int, string> extension_map_reverse37;\n    map<int, string> extension_map_reverse38;\n\
    \    map<int, string> extension_map_reverse39;\n    map<int, string> extension_map_reverse40\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3s2jfc_p.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmp3s2jfc_p.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmp3s2jfc_p.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmp3s2jfc_p.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmp3s2jfc_p.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmp3s2jfc_p.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmp3s2jfc_p.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3s2jfc_p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, int> extension_map;\n    map<int, int>::iterator\
    \ it;\n    int max_strength = 0;\n    for(it = extension_map.begin(); it != extension_map.end();\
    \ ++it)\n    {\n        int extension_strength = it->second;\n        int class_strength\
    \ = class_name.size();\n        int extension_class_strength = extension_strength\
    \ - class_strength;\n        if(extension_class_strength > max_strength)\n   \
    \     {\n            max_strength = extension_class_strength;\n        }\n   \
    \ }\n    string extension_name = \"\";\n    for(it = extension_map.begin(); it\
    \ != extension_map.end(); ++it)\n    {\n        int extension_strength = it->second;\n\
    \        int class_strength = class_name.size();\n        int extension_class_strength\
    \ = extension_strength - class_strength;\n        if(extension_class_strength\
    \ == max_strength)\n        {\n            extension_name = it->first;\n     \
    \   }\n    }\n    return class_name + extension_name;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for your answer. Unfortunately I cannot use any external\
    \ libraries. I only can use std.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ using any external libraries.\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\
    #include <cctype>\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq19xho2t.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmpq19xho2t.d(24): Error: found `int` when expecting identifier following
    `int`.\n/tmp/tmpq19xho2t.d(24): Error: found `>` when expecting `;` following
    statement\n/tmp/tmpq19xho2t.d(25): Error: found `,` when expecting `.` following
    int\n/tmp/tmpq19xho2t.d(25): Error: found `int` when expecting identifier following
    `int`.\n/tmp/tmpq19xho2t.d(25): Error: found `>` when expecting `;` following
    statement\n/tmp/tmpq19xho2t.d(25): Error: found `:` instead of statement\n/tmp/tmpq19xho2t.d(29):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpq19xho2t.d(40): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpq19xho2t.d(45): Error: use `.` for member
    lookup, not `->`\n/tmp/tmpq19xho2t.d(50): Error: declaration expected, not `<`\n/tmp/tmpq19xho2t.d(69):
    Error: declaration expected, not `assert`\n/tmp/tmpq19xho2t.d(70): Error: declaration
    expected, not `assert`\n/tmp/tmpq19xho2t.d(71): Error: declaration expected, not
    `assert`\n/tmp/tmpq19xho2t.d(72): Error: declaration expected, not `assert`\n/tmp/tmpq19xho2t.d(73):
    Error: declaration expected, not `assert`\n/tmp/tmpq19xho2t.d(74): Error: declaration
    expected, not `assert`\n/tmp/tmpq19xho2t.d(75): Error: declaration expected, not
    `assert`\n/tmp/tmpq19xho2t.d(76): Error: declaration expected, not `assert`\n/tmp/tmpq19xho2t.d(77):
    Error: declaration expected, not `assert`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq19xho2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap = 0;\n    int sm = 0;\n    for(int i =\
    \ 0; i < extensions.length; i++)\n    {\n        cap += extensions[i].length()\
    \ - extensions[i].toUppercase().length();\n        sm += extensions[i].length()\
    \ - extensions[i].toLowercase().length();\n    }\n    float strength = cap - sm;\n\
    \    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i].toUppercase()\
    \ == class_name)\n            return class_name + extensions[i].toUppercase()\
    \ + \".\" + extensions[i].toUppercase().toLowercase();\n        if(extensions[i].toLowercase()\
    \ == class_name)\n            return class_name + extensions[i].toLowercase()\
    \ + \".\" + extensions[i].toLowercase().toUppercase();\n    }\n    return class_name\
    \ + \".\" + extensions[extensions.length-1];\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI didn't downvote, but I suspect it's because you didn't explain how\
    \ this works. You don't explain how you arrived at the solution, or how it works.\
    \ You don't explain why you think it works. You don't explain why you think it\
    \ works. You don't explain why you think it works. You don't explain why you think\
    \ it works. You don't explain why you think it works. You don't explain why you\
    \ think it works. You don't explain why you think it works. You don't explain\
    \ why you think it works. You don't explain why you think it works. You don't\
    \ explain why you think it works. You don't explain why you think it works. You\
    \ don't explain why you think it works. You don't explain why you think it works.\
    \ You don't explain why you think it works. You don't explain why you think it\
    \ works. You don't explain why you think it works. You don't explain why you think\
    \ it works. You don't explain why you think it works. You don't explain why you\
    \ think it works. You don't explain why you think it works. You don't explain\
    \ why you think it works. You don't explain why you think it works. You don't\
    \ explain why you think it works. You don't explain why you think it works. You\
    \ don't explain why you think it works. You don't explain why you think it works.\
    \ You don't explain why you think it works. You don't explain why you think it\
    \ works. You don't explain why you think it works. You don't explain why you think\
    \ it works. You don't explain why you think it works. You don't \nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7nq7qerd.d(41): Error: declaration expected, not `<`\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated
    character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated
    character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated
    character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated
    character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated
    character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated
    character constant\n/tmp/tmp7nq7qerd.d(44): Error: unterminated character constant\n/tmp/tmp7nq7qerd.d(44):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp7nq7qerd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    for(auto\
    \ &extension : extensions)\n    {\n        auto pos = extension.find_first_of(\"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        if(pos != string::npos)\n        {\n \
    \           auto extension_strength = extension.find_first_of(\"0123456789\");\n\
    \            if(extension_strength != string::npos)\n            {\n         \
    \       extension_map[extension_strength] = extension;\n            }\n      \
    \  }\n    }\n    \n    auto max_strength = extension_map.begin()->first;\n   \
    \ for(auto &extension : extensions)\n    {\n        auto pos = extension.find_first_of(\"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n        if(pos != string::npos)\n        {\n \
    \           auto extension_strength = extension.find_first_of(\"0123456789\");\n\
    \            if(extension_strength != string::npos)\n            {\n         \
    \       if(extension_map[extension_strength] > max_strength)\n               \
    \ {\n                    max_strength = extension_map[extension_strength];\n \
    \               }\n            }\n        }\n    }\n    return class_name + extension_map[max_strength];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptc8i_8it.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmptc8i_8it.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmptc8i_8it.d(25):
    Error: basic type expected, not `&`\n/tmp/tmptc8i_8it.d(25): Error: no identifier
    for declarator `_error_`\n/tmp/tmptc8i_8it.d(25): Error: found `:` when expecting
    `;` following `for` condition\n/tmp/tmptc8i_8it.d(28): Error: found `:` when expecting
    `)`\n/tmp/tmptc8i_8it.d(28): Error: found `:` instead of statement\n/tmp/tmptc8i_8it.d(31):
    Error: found `:` when expecting `)`\n/tmp/tmptc8i_8it.d(31): Error: found `:`
    instead of statement\n/tmp/tmptc8i_8it.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptc8i_8it.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap_num = 0, sm_num = 0;\n    for(int i =\
    \ 0; i < extensions.length; ++i)\n    {\n        string extension = extensions[i];\n\
    \        for(int j = 0; j < extension.length(); ++j)\n        {\n            if(extension[j]\
    \ == toupper(extension[j]))\n                ++cap_num;\n            else\n  \
    \              ++sm_num;\n        }\n    }\n    return class_name + extensions[(cap_num\
    \ - sm_num) * -1];\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++,algorithm |>\n\
    I wrote a solution in Python that uses regular expressions to find the longest\
    \ extension of a given class name. It also uses regular expressions to find the\
    \ longest extension of a given class name that starts with a given prefix. \n\
    <code>\nimport re\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n\
    \    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    );\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\"\
    , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) ==\
    \ \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\"\
    , [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    );\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    ]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"])\
    \ == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgz0u0del.d(38): Error: declaration expected, not `<`\n/tmp/tmpgz0u0del.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmpgz0u0del.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmpgz0u0del.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmpgz0u0del.d(51): Error: declaration expected, not `assert`\n/tmp/tmpgz0u0del.d(52):
    Error: declaration expected, not `assert`\n/tmp/tmpgz0u0del.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpgz0u0del.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmpgz0u0del.d(55): Error: declaration expected, not `assert`\n/tmp/tmpgz0u0del.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpgz0u0del.d(57): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz0u0del.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    for(int i\
    \ = 0; i < extensions.length; ++i)\n    {\n        string extension = extensions[i];\n\
    \        for(int j = 0; j < extension.length(); ++j)\n        {\n            char\
    \ c = extension[j];\n            int index = toupper(c) - 'A';\n            extension_map[index]\
    \ = extension;\n        }\n    }\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    for(auto it = extension_map.begin(); it != extension_map.end();\
    \ ++it)\n    {\n        int strength = it->first;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = it->second;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I'm sorry I didn't\
    \ specify it clearly but I'm looking for a solution that doesn't involve any additional\
    \ libraries. I edited my question to make it more clear.\n<|/ c |>\n<| c |>\n\
    I added a solution that doesn't use any additional libraries.\n<|/ c |>\n<| a\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <map>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgri_au_p.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmpgri_au_p.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmpgri_au_p.d(39):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpgri_au_p.d(43): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpgri_au_p.d(48): Error: declaration expected,
    not `<`\n/tmp/tmpgri_au_p.d(51): Error: unterminated character constant\n/tmp/tmpgri_au_p.d(51):
    Error: unterminated character constant\n/tmp/tmpgri_au_p.d(51): Error: unterminated
    character constant\n/tmp/tmpgri_au_p.d(51): Error: unterminated character constant\n/tmp/tmpgri_au_p.d(54):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpgri_au_p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map2;\n    map<int, string> extension_map3;\n    map<int,\
    \ string> extension_map4;\n    map<int, string> extension_map5;\n    map<int,\
    \ string> extension_map6;\n    map<int, string> extension_map7;\n    map<int,\
    \ string> extension_map8;\n    map<int, string> extension_map9;\n    map<int,\
    \ string> extension_map10;\n    map<int, string> extension_map11;\n    map<int,\
    \ string> extension_map12;\n    map<int, string> extension_map13;\n    map<int,\
    \ string> extension_map14;\n    map<int, string> extension_map15;\n    map<int,\
    \ string> extension_map16;\n    map<int, string> extension_map17;\n    map<int,\
    \ string> extension_map18;\n    map<int, string> extension_map19;\n    map<int,\
    \ string> extension_map20;\n    map<int, string> extension_map21;\n    map<int,\
    \ string> extension_map22;\n    map<int, string> extension_map23;\n    map<int,\
    \ string> extension_map24;\n    map<int, string> extension_map25;\n    map<int,\
    \ string> extension_map26;\n    map<int, string> extension_map27;\n    map<int,\
    \ string> extension_map28;\n    map<int, string> extension_map29;\n    map<int,\
    \ string> extension_map30;\n    map<int, string> extension_map31;\n    map<int,\
    \ string> extension_map32;\n    map<int, string> extension_map33;\n    map<int,\
    \ string> extension_map34;\n    map<int, string> extension_map35;\n    map<int,\
    \ string> extension_map36;\n    map<int, string> extension_map37;\n    map<int,\
    \ string> extension_map38;\n    map<int, string> extension_map39;\n    map<int,\
    \ string> extension_map40;\n    map<int, string> extension_map41;\n    map<int,\
    \ string> extension_map42;\n    map<int, string> extension_map43;\n    map<int,\
    \ string> extension_map44;\n    \nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphpsj0rtc.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmphpsj0rtc.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmphpsj0rtc.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmphpsj0rtc.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmphpsj0rtc.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmphpsj0rtc.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmphpsj0rtc.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmphpsj0rtc.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmphpsj0rtc.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmphpsj0rtc.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmphpsj0rtc.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmphpsj0rtc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map_reverse;\n    map<int, string> extension_map_reverse2;\n\
    \    map<int, string> extension_map_reverse3;\n    map<int, string> extension_map_reverse4;\n\
    \    map<int, string> extension_map_reverse5;\n    map<int, string> extension_map_reverse6;\n\
    \    map<int, string> extension_map_reverse7;\n    map<int, string> extension_map_reverse8;\n\
    \    map<int, string> extension_map_reverse9;\n    map<int, string> extension_map_reverse10;\n\
    \    map<int, string> extension_map_reverse11;\n    map<int, string> extension_map_reverse12;\n\
    \    map<int, string> extension_map_reverse13;\n    map<int, string> extension_map_reverse14;\n\
    \    map<int, string> extension_map_reverse15;\n    map<int, string> extension_map_reverse16;\n\
    \    map<int, string> extension_map_reverse17;\n    map<int, string> extension_map_reverse18;\n\
    \    map<int, string> extension_map_reverse19;\n    map<int, string> extension_map_reverse20;\n\
    \    map<int, string> extension_map_reverse21;\n    map<int, string> extension_map_reverse22;\n\
    \    map<int, string> extension_map_reverse23;\n    map<int, string> extension_map_reverse24;\n\
    \    map<int, string> extension_map_reverse25;\n    map<int, string> extension_map_reverse26;\n\
    \    map<int, string> extension_map_reverse27;\n    map<int, string> extension_map_reverse28;\n\
    \    map<int, string> extension_map_reverse29;\n    map<int, string> extension_map_reverse30;\n\
    \    map<int, string> extension_map_reverse31;\n    map<int, string> extension_map_reverse32;\n\
    \    map<int, string> extension_map_reverse33;\n    map<int, string> extension_map_reverse34;\n\
    \    map<int, string> extension_map_reverse35;\n    map<int, string> extension_map_reverse36;\n\
    \    map<int, string> extension_map_reverse37;\n    map<int, string> extension_map_reverse38;\n\
    \    map<int, string> extension_map_reverse39;\n    map<int, string> extension_map_reverse40\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3s2jfc_p.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmp3s2jfc_p.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmp3s2jfc_p.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmp3s2jfc_p.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmp3s2jfc_p.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmp3s2jfc_p.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmp3s2jfc_p.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3s2jfc_p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap_counter = 0;\n    int sm_counter = 0;\n\
    \    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i].length()\
    \ > cap_counter)\n        {\n            cap_counter = extensions[i].length();\n\
    \        }\n        if(extensions[i].length() > sm_counter)\n        {\n     \
    \       sm_counter = extensions[i].length();\n        }\n    }\n    int strength\
    \ = cap_counter - sm_counter;\n    for(int i = 0; i < extensions.length; i++)\n\
    \    {\n        if(extensions[i].length() == strength)\n        {\n          \
    \  return class_name + \".\" + extensions[i];\n        }\n    }\n    return class_name;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your help but I don't understand\
    \ how this works. I understand that I need to find the strongest extension, but\
    \ I don't understand how this works. I understand that I need to find the strongest\
    \ extension, but I don't understand how this works. I understand that I need to\
    \ find the strongest extension, but I don't understand how this works. I understand\
    \ that I need to find the strongest extension, but I don't understand how this\
    \ works. I understand that I need to find the strongest extension, but I don't\
    \ understand how this works. I understand that I need to find the strongest extension,\
    \ but I don't understand how this works. I understand that I need to find the\
    \ strongest extension, but I don't understand how this works. I understand that\
    \ I need to find the strongest extension, but I don't understand how this works.\
    \ I understand that I need to find the strongest extension, but I don't understand\
    \ how this works. I understand that I need to find the strongest extension, but\
    \ I don't understand how this works. I understand that I need to find the strongest\
    \ extension, but I don't understand how this works. I understand that I need to\
    \ find the strongest extension, but I don't understand how this works. I understand\
    \ that I need to find the strongest extension, but I don't understand how this\
    \ works. I understand that I need to find the strongest extension, but I don't\
    \ understand how this works. I understand that I need to find the strongest extension,\
    \ but I don't understand how this works. I understand that I need to find the\
    \ strongest extension, but I don't understand how this works. I understand that\
    \ I need to find the strongest extension, but I don't understand how this works.\
    \ I understand that I need to find the strongest extension, but I don't understand\
    \ how this works. I understand that I need to find the strongest extension, but\
    \ I don't understand how this works. I understand that I need to find the strongest\
    \ extension, but I don't understand how this works. I understand that I need to\
    \ find the strongest extension, but I don't understand how this works. I understand\
    \ that I need to find the strongest extension, but I don't understand how this\
    \ works. I understand that I need to find the strongest extension, but I don't\
    \ understand how this work\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnnq21zkz.d(47): Error: declaration expected, not `<`\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated
    character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated
    character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated
    character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated
    character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated
    character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated
    character constant\n/tmp/tmpnnq21zkz.d(50): Error: unterminated character constant\n/tmp/tmpnnq21zkz.d(50):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpnnq21zkz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap = class_name.size();\n    int sm = extensions[0].size();\n\
    \    int strength = cap - sm;\n    for(int i = 1; i < extensions.length; i++)\n\
    \    {\n        cap = extensions[i].size();\n        sm = extensions[0].size();\n\
    \        strength = cap - sm;\n        if(strength > 0)\n        {\n         \
    \   break;\n        }\n    }\n    return class_name + extensions[extensions.length\
    \ - 1];\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are\
    \ two extensions with the same strength.\n<|/ c |>\n<| c |>\nI added a test case\
    \ that shows it works.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nstring Strongest_Extension(string\
    \ class_name, string[] extensions) \n{\n    string strongest = \"\";\n    int\
    \ max = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int\
    \ len = extensions[i].size();\n        if(len > max)\n        {\n            max\
    \ = len;\n            strongest = extensions[i];\n        }\n    }\n    return\
    \ class_name + strongest;\n}\n</code>\n<|/ a tags=c++ |>\n<| a |>\n<code>\nstring\
    \ Strongest_Extension(string class_name, string[] extensions) \n{\n    string\
    \ strongest = \"\";\n    int max = 0;\n    for(int i = 0; i < extensions.length;\
    \ i++)\n    {\n        int len = extensions[i].size();\n        if(len > max)\n\
    \        {\n            max = len;\n            strongest = extensions[i];\n \
    \       }\n    }\n    return class_name + strongest;\n}\n</code>\n<|/ a tags=c++\
    \ dscore=0 |>\n<| c |>\nPlease add some explanation to your answer.\n<|/ c |>\n\
    <| a tags=c++ |>\n<code>\nstring Strongest_Extension(string class_name, string[]\
    \ extensions) \n{\n    string strongest = \"\";\n    int max = 0;\n    for(int\
    \ i = 0; i < extensions.length; i++)\n    {\n        int len = extensions[i].size();\n\
    \        if(len > max)\n        {\n            max = len;\n            strongest\
    \ = extensions[i];\n        }\n    }\n    return class_name + strongest;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=c++ |>\n<code>\nstring Strongest_Extension(string\
    \ class_name, string[] extensions) \n{\n    string strongest = \"\";\n    int\
    \ max = 0;\n    for(int i = 0; i < extensions.length; i++)\n    {\n        int\
    \ len = extensions[i].size();\n        if(len > max)\n        {\n            max\
    \ = len;\n            stron\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvfckgfdw.d(39): Error: declaration expected, not `<`\n/tmp/tmpvfckgfdw.d(42):
    Error: unterminated character constant\n/tmp/tmpvfckgfdw.d(53): Error: declaration
    expected, not `for`\n/tmp/tmpvfckgfdw.d(53): Error: no identifier for declarator
    `i`\n/tmp/tmpvfckgfdw.d(53): Error: declaration expected, not `<`\n/tmp/tmpvfckgfdw.d(53):
    Error: no identifier for declarator `i`\n/tmp/tmpvfckgfdw.d(53): Error: declaration
    expected, not `++`\n/tmp/tmpvfckgfdw.d(56): Error: declaration expected, not `if`\n/tmp/tmpvfckgfdw.d(59):
    Error: no identifier for declarator `strongest`\n/tmp/tmpvfckgfdw.d(59): Error:
    declaration expected, not `=`\n/tmp/tmpvfckgfdw.d(60): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfckgfdw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map_reverse;\n    map<int, string> extension_map_reverse2;\n\
    \    map<int, string> extension_map_reverse3;\n    map<int, string> extension_map_reverse4;\n\
    \    map<int, string> extension_map_reverse5;\n    map<int, string> extension_map_reverse6;\n\
    \    map<int, string> extension_map_reverse7;\n    map<int, string> extension_map_reverse8;\n\
    \    map<int, string> extension_map_reverse9;\n    map<int, string> extension_map_reverse10;\n\
    \    map<int, string> extension_map_reverse11;\n    map<int, string> extension_map_reverse12;\n\
    \    map<int, string> extension_map_reverse13;\n    map<int, string> extension_map_reverse14;\n\
    \    map<int, string> extension_map_reverse15;\n    map<int, string> extension_map_reverse16;\n\
    \    map<int, string> extension_map_reverse17;\n    map<int, string> extension_map_reverse18;\n\
    \    map<int, string> extension_map_reverse19;\n    map<int, string> extension_map_reverse20;\n\
    \    map<int, string> extension_map_reverse21;\n    map<int, string> extension_map_reverse22;\n\
    \    map<int, string> extension_map_reverse23;\n    map<int, string> extension_map_reverse24;\n\
    \    map<int, string> extension_map_reverse25;\n    map<int, string> extension_map_reverse26;\n\
    \    map<int, string> extension_map_reverse27;\n    map<int, string> extension_map_reverse28;\n\
    \    map<int, string> extension_map_reverse29;\n    map<int, string> extension_map_reverse30;\n\
    \    map<int, string> extension_map_reverse31;\n    map<int, string> extension_map_reverse32;\n\
    \    map<int, string> extension_map_reverse33;\n    map<int, string> extension_map_reverse34;\n\
    \    map<int, string> extension_map_reverse35;\n    map<int, string> extension_map_reverse36;\n\
    \    map<int, string> extension_map_reverse37;\n    map<int, string> extension_map_reverse38;\n\
    \    map<int, string> extension_map_reverse39;\n    map<int, string> extension_map_reverse40\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3s2jfc_p.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmp3s2jfc_p.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmp3s2jfc_p.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmp3s2jfc_p.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmp3s2jfc_p.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmp3s2jfc_p.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmp3s2jfc_p.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3s2jfc_p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map_reverse;\n    map<int, string> extension_map_reverse2;\n\
    \    map<int, string> extension_map_reverse3;\n    map<int, string> extension_map_reverse4;\n\
    \    map<int, string> extension_map_reverse5;\n    map<int, string> extension_map_reverse6;\n\
    \    map<int, string> extension_map_reverse7;\n    map<int, string> extension_map_reverse8;\n\
    \    map<int, string> extension_map_reverse9;\n    map<int, string> extension_map_reverse10;\n\
    \    map<int, string> extension_map_reverse11;\n    map<int, string> extension_map_reverse12;\n\
    \    map<int, string> extension_map_reverse13;\n    map<int, string> extension_map_reverse14;\n\
    \    map<int, string> extension_map_reverse15;\n    map<int, string> extension_map_reverse16;\n\
    \    map<int, string> extension_map_reverse17;\n    map<int, string> extension_map_reverse18;\n\
    \    map<int, string> extension_map_reverse19;\n    map<int, string> extension_map_reverse20;\n\
    \    map<int, string> extension_map_reverse21;\n    map<int, string> extension_map_reverse22;\n\
    \    map<int, string> extension_map_reverse23;\n    map<int, string> extension_map_reverse24;\n\
    \    map<int, string> extension_map_reverse25;\n    map<int, string> extension_map_reverse26;\n\
    \    map<int, string> extension_map_reverse27;\n    map<int, string> extension_map_reverse28;\n\
    \    map<int, string> extension_map_reverse29;\n    map<int, string> extension_map_reverse30;\n\
    \    map<int, string> extension_map_reverse31;\n    map<int, string> extension_map_reverse32;\n\
    \    map<int, string> extension_map_reverse33;\n    map<int, string> extension_map_reverse34;\n\
    \    map<int, string> extension_map_reverse35;\n    map<int, string> extension_map_reverse36;\n\
    \    map<int, string> extension_map_reverse37;\n    map<int, string> extension_map_reverse38;\n\
    \    map<int, string> extension_map_reverse39;\n    map<int, string> extension_map_reverse40\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3s2jfc_p.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmp3s2jfc_p.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmp3s2jfc_p.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmp3s2jfc_p.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmp3s2jfc_p.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmp3s2jfc_p.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmp3s2jfc_p.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3s2jfc_p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap_counter = 0;\n    int sm_counter = 0;\n\
    \    for(int i = 0; i < extensions.length; i++)\n    {\n        if(extensions[i].length()\
    \ > cap_counter)\n        {\n            cap_counter = extensions[i].length();\n\
    \        }\n        if(extensions[i].length() > sm_counter)\n        {\n     \
    \       sm_counter = extensions[i].length();\n        }\n    }\n    int strength\
    \ = cap_counter - sm_counter;\n    for(int i = 0; i < extensions.length; i++)\n\
    \    {\n        if(extensions[i].length() == strength)\n        {\n          \
    \  return class_name + extensions[i];\n        }\n    }\n    return class_name\
    \ + extensions[0];\n}\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThanks for\
    \ your answer! I appreciate it! But I still don't understand how this works. Could\
    \ you please explain how this works?\n<|/ c |>\n<| c |>\nI added some comments\
    \ to my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer! I appreciate\
    \ it! But I still don't understand how this works. Could you please explain how\
    \ this works?\n<|/ c |>\n<| c |>\nI added some comments to my answer. Hope it\
    \ helps.\n<|/ c |>\n<| a tags=c++,string |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9qvi0p0h.d(47): Error: declaration expected, not `<`\n/tmp/tmp9qvi0p0h.d(50):
    Error: unterminated character constant\n/tmp/tmp9qvi0p0h.d(56): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qvi0p0h.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap_counter = 0;\n    int sm_counter = 0;\n\
    \    for(int i = 0; i < extensions.length; i++)\n    {\n        string extension\
    \ = extensions[i];\n        for(int j = 0; j < extension.length(); j++)\n    \
    \    {\n            if(extension[j] == toupper(extension[j]))\n            {\n\
    \                cap_counter++;\n            }\n            else\n           \
    \ {\n                sm_counter++;\n            }\n        }\n    }\n    float\
    \ strength = cap_counter - sm_counter;\n    for(int i = 0; i < extensions.length;\
    \ i++)\n    {\n        string extension = extensions[i];\n        for(int j =\
    \ 0; j < extension.length(); j++)\n        {\n            if(extension[j] == toupper(extension[j]))\n\
    \            {\n                cap_counter--;\n            }\n            else\n\
    \            {\n                sm_counter--;\n            }\n        }\n    }\n\
    \    if(cap_counter > sm_counter)\n    {\n        return class_name + extensions[0];\n\
    \    }\n    else\n    {\n        return class_name + extensions[extensions.length\
    \ - 1];\n    }\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\nThanks\
    \ for your answer. I'm sorry I didn't make it clear enough in my question, but\
    \ I want the algorithm to return the extension with the strongest strength. For\
    \ example, if the class name is \"Slices\" and a list of extensions is [\"SErviNGSliCes\"\
    , \"Cheese\", \"StuFfed\"] then it should return \"SErviNGSliCes\" since it's\
    \ the strongest extension (its strength is -1). I'll edit my question to make\
    \ it clearer.\n<|/ c |>\n<| c |>\nI edited my answer to include a function that\
    \ does exactly what you want.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm\
    \ sorry I didn't make it clear enough in my question, but I want the algorithm\
    \ to return the extension with the strongest strength. For example, if the class\
    \ name is \"Slices\" and a list of extensions is [\"SErviNGSliCes\", \"Cheese\"\
    , \"StuFfed\"] then it should return \"SErviNGSliCes\" since it's the strongest\
    \ extension (its strength is -1). I'll edit my question to make it clearer.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a function that does exactly\
    \ what you want.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry I didn't\
    \ make it clear enough in my question, but I want the algorithm to return the\
    \ extension with the strongest strength. For example, if the class name is \"\
    Slices\" and a list of extensions is [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    ] \nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwsh1yaee.d(66): Error: declaration expected, not `<`\n/tmp/tmpwsh1yaee.d(69):
    Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(69): Error: unterminated
    character constant\n/tmp/tmpwsh1yaee.d(69): Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(69):
    Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(75): Error: unterminated
    character constant\n/tmp/tmpwsh1yaee.d(75): Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(75):
    Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(75): Error: unterminated
    character constant\n/tmp/tmpwsh1yaee.d(81): Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(81):
    Error: unterminated character constant\n/tmp/tmpwsh1yaee.d(86): Error: declaration
    expected, not `assert`\n/tmp/tmpwsh1yaee.d(87): Error: declaration expected, not
    `assert`\n/tmp/tmpwsh1yaee.d(88): Error: declaration expected, not `assert`\n/tmp/tmpwsh1yaee.d(89):
    Error: declaration expected, not `assert`\n/tmp/tmpwsh1yaee.d(90): Error: declaration
    expected, not `assert`\n/tmp/tmpwsh1yaee.d(91): Error: declaration expected, not
    `assert`\n/tmp/tmpwsh1yaee.d(92): Error: declaration expected, not `assert`\n/tmp/tmpwsh1yaee.d(93):
    Error: declaration expected, not `assert`\n/tmp/tmpwsh1yaee.d(94): Error: declaration
    expected, not `assert`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsh1yaee.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap = class_name.size();\n    int sm = extensions[0].size();\n\
    \    int strength = cap - sm;\n    \n    for(int i = 1; i < extensions.length;\
    \ i++)\n    {\n        if(extensions[i].size() != extensions[0].size())\n    \
    \    {\n            int cap2 = extensions[i].size();\n            int sm2 = extensions[0].size();\n\
    \            int strength2 = cap2 - sm2;\n            if(strength2 > strength)\n\
    \            {\n                strength = strength2;\n            }\n       \
    \ }\n    }\n    \n    return class_name + extensions[0] + extensions[extensions.length\
    \ - 1];\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\nI like the idea\
    \ of using extensions to find the strongest extension. I'm going to try this out\
    \ and see how it works.\n<|/ c |>\n<| c |>\nI added a solution that uses extensions\
    \ to find the strongest extension.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ uses extensions to find the strongest extension.\n<|/ c |>\n<| a tags=c++,string,algorithm\
    \ |>\nI wrote a solution that uses extensions to find the strongest extension.\n\
    <code>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\
    using namespace std;\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9007wl7w.d(44): Error: declaration expected, not `<`\n/tmp/tmp9007wl7w.d(47):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp9007wl7w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int cap_num = 0, sm_num = 0;\n    for(int i =\
    \ 0; i < extensions.length; i++){\n        if(extensions[i].length() > cap_num){\n\
    \            cap_num = extensions[i].length();\n        }\n        if(extensions[i].length()\
    \ < sm_num){\n            sm_num = extensions[i].length();\n        }\n    }\n\
    \    float strength = cap_num - sm_num;\n    for(int i = 0; i < extensions.length;\
    \ i++){\n        if(extensions[i].length() == cap_num){\n            extensions[i]\
    \ = extensions[i].substr(0, sm_num);\n        }\n        if(extensions[i].length()\
    \ == sm_num){\n            extensions[i] = extensions[i].substr(cap_num);\n  \
    \      }\n    }\n    string extension_name = \"\";\n    for(int i = 0; i < extensions.length;\
    \ i++){\n        extension_name += extensions[i] + \".\";\n    }\n    extension_name\
    \ = extension_name.substr(0, extension_name.length() - 1);\n    return class_name\
    \ + extension_name;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem\
    \ to work. `Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])` returns\
    \ `\"my_class.AA\"`.\n<|/ c |>\n<| c |>\nI tested it and it works. I edited the\
    \ answer to include the code I used.\n<|/ c |>\n<| c |>\nI tested it again and\
    \ it works. I edited the answer to include the code I used.\n<|/ c |>\n<| c |>\n\
    I tested it again and it works. I edited the answer to include the code I used.\n\
    <|/ c |>\n<| a tags=c++ |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <vector>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqsqod49m.d(49): Error: declaration expected, not `<`\n/tmp/tmpqsqod49m.d(52):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpqsqod49m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map2;\n    map<int, string> extension_map3;\n    map<int,\
    \ string> extension_map4;\n    map<int, string> extension_map5;\n    map<int,\
    \ string> extension_map6;\n    map<int, string> extension_map7;\n    map<int,\
    \ string> extension_map8;\n    map<int, string> extension_map9;\n    map<int,\
    \ string> extension_map10;\n    map<int, string> extension_map11;\n    map<int,\
    \ string> extension_map12;\n    map<int, string> extension_map13;\n    map<int,\
    \ string> extension_map14;\n    map<int, string> extension_map15;\n    map<int,\
    \ string> extension_map16;\n    map<int, string> extension_map17;\n    map<int,\
    \ string> extension_map18;\n    map<int, string> extension_map19;\n    map<int,\
    \ string> extension_map20;\n    map<int, string> extension_map21;\n    map<int,\
    \ string> extension_map22;\n    map<int, string> extension_map23;\n    map<int,\
    \ string> extension_map24;\n    map<int, string> extension_map25;\n    map<int,\
    \ string> extension_map26;\n    map<int, string> extension_map27;\n    map<int,\
    \ string> extension_map28;\n    map<int, string> extension_map29;\n    map<int,\
    \ string> extension_map30;\n    map<int, string> extension_map31;\n    map<int,\
    \ string> extension_map32;\n    map<int, string> extension_map33;\n    map<int,\
    \ string> extension_map34;\n    map<int, string> extension_map35;\n    map<int,\
    \ string> extension_map36;\n    map<int, string> extension_map37;\n    map<int,\
    \ string> extension_map38;\n    map<int, string> extension_map39;\n    map<int,\
    \ string> extension_map40;\n    map<int, string> extension_map41;\n    map<int,\
    \ string> extension_map42;\n    map<int, string> extension_map43;\n    map<int,\
    \ string> extension_map44;\n    \nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphpsj0rtc.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmphpsj0rtc.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmphpsj0rtc.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmphpsj0rtc.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmphpsj0rtc.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmphpsj0rtc.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmphpsj0rtc.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmphpsj0rtc.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmphpsj0rtc.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmphpsj0rtc.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmphpsj0rtc.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmphpsj0rtc.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmphpsj0rtc.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmphpsj0rtc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int CAP = class_name.size();\n    int SM = extensions[0].size();\n\
    \    int strength = 0;\n    for(int i=0; i<extensions.length; i++){\n        int\
    \ extCAP = extensions[i].size();\n        int extSM = extensions[i].size();\n\
    \        strength += extCAP - extSM;\n    }\n    string strongest_extension =\
    \ \"\";\n    for(int i=0; i<extensions.length; i++){\n        if(strength == CAP\
    \ - SM){\n            strongest_extension = class_name + extensions[i];\n    \
    \        break;\n        }\n        if(strength > CAP - SM){\n            strongest_extension\
    \ = class_name + extensions[i];\n            break;\n        }\n    }\n    return\
    \ strongest_extension;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,algorithm\
    \ |>\nI wrote a solution in Python, hope it helps.\n<code>\ndef strongest_extension(class_name,\
    \ extensions):\n    extensions_set = set(extensions)\n    extensions_set.discard(\"\
    \")\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(None)\n    extensions_set.discard(None)\n    extensions_set.discard(None)\n\
    \    extensions_set.discard(\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdvtfwm8h.d(45): Error: declaration expected, not `<`\n/tmp/tmpdvtfwm8h.d(97):
    Error: declaration expected, not `assert`\n/tmp/tmpdvtfwm8h.d(98): Error: declaration
    expected, not `assert`\n/tmp/tmpdvtfwm8h.d(99): Error: declaration expected, not
    `assert`\n/tmp/tmpdvtfwm8h.d(100): Error: declaration expected, not `assert`\n/tmp/tmpdvtfwm8h.d(101):
    Error: declaration expected, not `assert`\n/tmp/tmpdvtfwm8h.d(102): Error: declaration
    expected, not `assert`\n/tmp/tmpdvtfwm8h.d(103): Error: declaration expected,
    not `assert`\n/tmp/tmpdvtfwm8h.d(104): Error: declaration expected, not `assert`\n/tmp/tmpdvtfwm8h.d(105):
    Error: declaration expected, not `assert`\n/tmp/tmpdvtfwm8h.d(106): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdvtfwm8h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    map<int, string> extension_map;\n    map<int,\
    \ string> extension_map_reverse;\n    map<int, string> extension_map_reverse2;\n\
    \    map<int, string> extension_map_reverse3;\n    map<int, string> extension_map_reverse4;\n\
    \    map<int, string> extension_map_reverse5;\n    map<int, string> extension_map_reverse6;\n\
    \    map<int, string> extension_map_reverse7;\n    map<int, string> extension_map_reverse8;\n\
    \    map<int, string> extension_map_reverse9;\n    map<int, string> extension_map_reverse10;\n\
    \    map<int, string> extension_map_reverse11;\n    map<int, string> extension_map_reverse12;\n\
    \    map<int, string> extension_map_reverse13;\n    map<int, string> extension_map_reverse14;\n\
    \    map<int, string> extension_map_reverse15;\n    map<int, string> extension_map_reverse16;\n\
    \    map<int, string> extension_map_reverse17;\n    map<int, string> extension_map_reverse18;\n\
    \    map<int, string> extension_map_reverse19;\n    map<int, string> extension_map_reverse20;\n\
    \    map<int, string> extension_map_reverse21;\n    map<int, string> extension_map_reverse22;\n\
    \    map<int, string> extension_map_reverse23;\n    map<int, string> extension_map_reverse24;\n\
    \    map<int, string> extension_map_reverse25;\n    map<int, string> extension_map_reverse26;\n\
    \    map<int, string> extension_map_reverse27;\n    map<int, string> extension_map_reverse28;\n\
    \    map<int, string> extension_map_reverse29;\n    map<int, string> extension_map_reverse30;\n\
    \    map<int, string> extension_map_reverse31;\n    map<int, string> extension_map_reverse32;\n\
    \    map<int, string> extension_map_reverse33;\n    map<int, string> extension_map_reverse34;\n\
    \    map<int, string> extension_map_reverse35;\n    map<int, string> extension_map_reverse36;\n\
    \    map<int, string> extension_map_reverse37;\n    map<int, string> extension_map_reverse38;\n\
    \    map<int, string> extension_map_reverse39;\n    map<int, string> extension_map_reverse40\n\
    unittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3s2jfc_p.d(24): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(24): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(25):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(25): Error:
    found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(26): Error:
    found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(26): Error: found
    `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(27): Error: found
    `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(27): Error: found `>`
    when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(28): Error: found `,`
    when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(28): Error: found `>` when
    expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(29): Error: found `,` when
    expecting `.` following int\n/tmp/tmp3s2jfc_p.d(29): Error: found `>` when expecting
    `;` following statement\n/tmp/tmp3s2jfc_p.d(30): Error: found `,` when expecting
    `.` following int\n/tmp/tmp3s2jfc_p.d(30): Error: found `>` when expecting `;`
    following statement\n/tmp/tmp3s2jfc_p.d(31): Error: found `,` when expecting `.`
    following int\n/tmp/tmp3s2jfc_p.d(31): Error: found `>` when expecting `;` following
    statement\n/tmp/tmp3s2jfc_p.d(32): Error: found `,` when expecting `.` following
    int\n/tmp/tmp3s2jfc_p.d(32): Error: found `>` when expecting `;` following statement\n/tmp/tmp3s2jfc_p.d(33):
    Error: found `,` when expecting `.` following int\n/tmp/tmp3s2jfc_p.d(33): Error:
    found `>` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3s2jfc_p.d", "-I/tmp"]\n'''
  stdout: b''
