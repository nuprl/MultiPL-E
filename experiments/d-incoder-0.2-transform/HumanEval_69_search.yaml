name: HumanEval_69_search
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a non-empty\
  \ list of positive integers. Return the greatest integer that is greater than \n\
  \    zero, and has a frequency greater than or equal to the value of the integer\
  \ itself. \n    The frequency of an integer is the number of times it appears in\
  \ the list.\n    If no such a value exist, return -1.\n    Examples:\n    >>> search([4L,\
  \ 1L, 2L, 2L, 3L, 1L])\n    2L\n    >>> search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
  \ 4L])\n    3L\n    >>> search([5L, 5L, 4L, 4L, 4L])\n    -1L\n    \n*/\nlong search(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = search;\n\n    assert(candidate([5L, 5L,\
  \ 5L, 5L, 1L]) == 1L);\n    assert(candidate([4L, 1L, 4L, 1L, 4L, 4L]) == 4L);\n\
  \    assert(candidate([3L, 3L]) == -1L);\n    assert(candidate([8L, 8L, 8L, 8L,\
  \ 8L, 8L, 8L, 8L]) == 8L);\n    assert(candidate([2L, 3L, 3L, 2L, 2L]) == 2L);\n\
  \    assert(candidate([2L, 7L, 8L, 8L, 4L, 8L, 7L, 3L, 9L, 6L, 5L, 10L, 4L, 3L,\
  \ 6L, 7L, 1L, 7L, 4L, 10L, 8L, 1L]) == 1L);\n    assert(candidate([3L, 2L, 8L, 2L])\
  \ == 2L);\n    assert(candidate([6L, 7L, 1L, 8L, 8L, 10L, 5L, 8L, 5L, 3L, 10L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 3L, 6L, 5L, 6L, 4L]) == -1L);\n    assert(candidate([6L,\
  \ 9L, 6L, 7L, 1L, 4L, 7L, 1L, 8L, 8L, 9L, 8L, 10L, 10L, 8L, 4L, 10L, 4L, 10L, 1L,\
  \ 2L, 9L, 5L, 7L, 9L]) == 1L);\n    assert(candidate([1L, 9L, 10L, 1L, 3L]) == 1L);\n\
  \    assert(candidate([6L, 9L, 7L, 5L, 8L, 7L, 5L, 3L, 7L, 5L, 10L, 10L, 3L, 6L,\
  \ 10L, 2L, 8L, 6L, 5L, 4L, 9L, 5L, 3L, 10L]) == 5L);\n    assert(candidate([1L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 10L, 6L, 4L, 3L, 5L, 8L, 2L, 4L, 2L, 8L,\
  \ 4L, 6L, 10L, 4L, 2L, 1L, 10L, 2L, 1L, 1L, 5L]) == 4L);\n    assert(candidate([2L,\
  \ 10L, 4L, 8L, 2L, 10L, 5L, 1L, 2L, 9L, 5L, 5L, 6L, 3L, 8L, 6L, 4L, 10L]) == 2L);\n\
  \    assert(candidate([1L, 6L, 10L, 1L, 6L, 9L, 10L, 8L, 6L, 8L, 7L, 3L]) == 1L);\n\
  \    assert(candidate([9L, 2L, 4L, 1L, 5L, 1L, 5L, 2L, 5L, 7L, 7L, 7L, 3L, 10L,\
  \ 1L, 5L, 4L, 2L, 8L, 4L, 1L, 9L, 10L, 7L, 10L, 2L, 8L, 10L, 9L, 4L]) == 4L);\n\
  \    assert(candidate([2L, 6L, 4L, 2L, 8L, 7L, 5L, 6L, 4L, 10L, 4L, 6L, 3L, 7L,\
  \ 8L, 8L, 3L, 1L, 4L, 2L, 2L, 10L, 7L]) == 4L);\n    assert(candidate([9L, 8L, 6L,\
  \ 10L, 2L, 6L, 10L, 2L, 7L, 8L, 10L, 3L, 8L, 2L, 6L, 2L, 3L, 1L]) == 2L);\n    assert(candidate([5L,\
  \ 5L, 3L, 9L, 5L, 6L, 3L, 2L, 8L, 5L, 6L, 10L, 10L, 6L, 8L, 4L, 10L, 7L, 7L, 10L,\
  \ 8L]) == -1L);\n    assert(candidate([10L]) == -1L);\n    assert(candidate([9L,\
  \ 7L, 7L, 2L, 4L, 7L, 2L, 10L, 9L, 7L, 5L, 7L, 2L]) == 2L);\n    assert(candidate([5L,\
  \ 4L, 10L, 2L, 1L, 1L, 10L, 3L, 6L, 1L, 8L]) == 1L);\n    assert(candidate([7L,\
  \ 9L, 9L, 9L, 3L, 4L, 1L, 5L, 9L, 1L, 2L, 1L, 1L, 10L, 7L, 5L, 6L, 7L, 6L, 7L, 7L,\
  \ 6L]) == 1L);\n    assert(candidate([3L, 10L, 10L, 9L, 2L]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    long maxVal = lst[0];\n    long maxCount = 0;\n    for(int i\
    \ = 1; i < lst.size(); ++i)\n    {\n        if(lst[i] > maxVal)\n        {\n \
    \           maxVal = lst[i];\n            maxCount = 1;\n        }\n        else\
    \ if(lst[i] == maxVal)\n        {\n            maxCount++;\n        }\n    }\n\
    \    return maxVal == 0 ? -1 : maxVal;\n}\n</code>\n<|/ a tags=algorithm,c++,sorting\
    \ |>\n<| c |>\nThis doesn't work. Try search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
    \ 4L])\n<|/ c |>\n<| c |>\nIt does work. Try search([1L, 2L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L, 4L])\n<|/ c |>\n<| c |>\nIt does work. Try search([1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L, 4L])\n<|/ c |>\n<| c |>\nIt does work. Try search([1L, 2L, 2L, 3L, 3L,\
    \ 3L, 4L, 4L, 4L])\n<|/ c |>\n<| c |>\nIt does work. Try search([1L, 2L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L, 4L])\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n\
    #include <vector>\n#include <algorithm>\nusing namespace std;", "{\n    long max\
    \ = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.size(); ++i)\n    {\n \
    \       if(lst[i] > 0)\n        {\n            freq++;\n            max = std.max(max,\
    \ lst[i]);\n        }\n    }\n    return std.max(freq > max ? freq : -1, max);\n\
    }\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis is not the correct answer.\
    \ Try search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L])\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing that out. I've fixed the code.\n<|/ c |>\n<| c |>\n, I've fixed\
    \ the code again. Now it works as expected.\n<|/ c |>\n<| c |>\n, I've fixed the\
    \ code again. Now it works as expected.\n<|/ c |>\n<| c |>\n, I've fixed the code\
    \ again. Now it works as expected.\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\n\
    #include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    long max = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        if(lst[i] > 0)\n        {\n            freq++;\n      \
    \      if(max < lst[i])\n            {\n                max = lst[i];\n      \
    \      }\n        }\n    }\n    return freq > max ? -1 : max;\n}\n</code>\n<|/\
    \ a tags=c#,algorithm,search |>\n<| c |>\nThis solution does not work if there\
    \ are negative numbers in the list.\n<|/ c |>\n<| c |>\nThis solution does not\
    \ work if there are negative numbers in the list.\n<|/ c |>\n<| a tags=c#,algorithm,search\
    \ |>\n<code>\npublic int Search(int arr[], int n)\n{\n    int max = arr[0];\n\
    \    int freq = 0;\n    for (int i = 1; i < n; i++)\n    {\n        if (arr[i]\
    \ > max)\n        {\n            max = arr[i];\n            freq = 1;\n      \
    \  }\n        else if (arr[i] == max)\n        {\n            freq++;\n      \
    \  }\n    }\n    return freq > max ? -1 : max;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\n<code>\npublic int Search(int arr[], int n)\n{\n    int max\
    \ = arr[0];\n    int freq = 0;\n    for (int i = 1; i < n; i++)\n    {\n     \
    \   if (arr[i] > max)\n        {\n            max = arr[i];\n            freq\
    \ = 1;\n        }\n        else if (arr[i] == max)\n        {\n            freq++;\n\
    \        }\n    }\n    return freq > max ? -1 : max;\n}\n</code>\n<|/ a tags=c#,algorithm,search\
    \ |>\n<| a tags=c#,algorithm,search |>\n<code>\npublic int Search(int arr[], int\
    \ n)\n{\n    int max = arr[0];\n    int freq = 0;\n    for (int i = 1; i < n;\
    \ i++)\n    {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n\
    \            freq = 1;\n        }\n        else if (arr[i] == max)\n        {\n\
    \            freq++;\n        }\n    }\n    return freq > max ? -1 : max;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic int Search(int arr[],\
    \ int n)\n{\n    int max = arr[0];\n    int freq = 0;\n    for (int i = 1; i <\
    \ n; i++)\n    {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n\
    \            freq = 1;\n        }\n        else if (arr[i] == max)\n        {\n\
    \            freq++;\n        }\n    }\n    return freq > max ? -1 : max;\n}\n\
    </code>\n<|/ a tags=c#,algorithm,search |>\n", "{\n    long max = 0;\n    long\
    \ freq = 0;\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i]\
    \ > 0)\n        {\n            freq++;\n            if(lst[i] > max)\n       \
    \     {\n                max = lst[i];\n            }\n        }\n    }\n    return\
    \ (freq > max) ? -1 : max;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers in the list.\n<|/ c |>\n<| c |>\nIt works\
    \ fine for me. Can you give an example where it doesn't work?\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work for [1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L]\n<|/ c |>\n<| c\
    \ |>\nIt works for me. Can you give an example where it doesn't work?\n<|/ c |>\n\
    <| c |>\nIt works for me too. Can you give an example where it doesn't work?\n\
    <|/ c |>\n<| a tags=c#,algorithm |>\n<code>\npublic int Search(int[] arr, int\
    \ val)\n{\n    int max = 0;\n    int freq = 0;\n    for(int i = 0; i < arr.Length;\
    \ i++)\n    {\n        if(arr[i] > 0)\n        {\n            freq++;\n      \
    \      if(arr[i] > max)\n            {\n                max = arr[i];\n      \
    \      }\n        }\n    }\n    return (freq > max) ? -1 : max;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if you have negative numbers in\
    \ the list.\n<|/ c |>\n<| c |>\nIt works for me too. Can you give an example where\
    \ it doesn't work?\n<|/ c |>\n<| c |>\nIt works for me too. Can you give an example\
    \ where it doesn't work?\n<|/ c |>\n<| c |>\nIt works for me too. Can you give\
    \ an example where it doesn't work?\n<|/ c |>\n<| c |>\nIt works for me too. Can\
    \ you give an example where it doesn't work?\n<|/ c |>\n<| a tags=c#,algorithm\
    \ |>\n<code>\npublic int Search(int[] arr, int val)\n{\n    int max = 0;\n   \
    \ int freq = 0;\n    for(int i = 0; i < arr.Length; i++)\n    {\n        if(arr[i]\
    \ > 0)\n        {\n            freq++;\n            if(arr[i] > max)\n       \
    \     {\n                max = arr[i];\n            }\n        }\n    }\n    return\
    \ (freq > max) ? -1 : max;\n}\n</code>\n<|/ a dscore=0 |>\n<| ", "{\n    long\
    \ maxVal = lst[0];\n    long maxFreq = lst[0];\n    for(long i = 1; i < lst.size();\
    \ ++i)\n    {\n        if(lst[i] > maxVal)\n        {\n            maxVal = lst[i];\n\
    \            maxFreq = lst[i];\n        }\n        else\n        {\n         \
    \   if(lst[i] == maxVal)\n            {\n                maxFreq += lst[i];\n\
    \            }\n        }\n    }\n    return maxVal;\n}\n</code>\n<|/ a tags=c++,algorithm,arrays\
    \ |>\n<| c |>\nThis is not the most efficient solution. `std::max_element` does\
    \ a linear search through the entire array and finds the max element in the first\
    \ pass. Then it does a linear search through the entire array again to find the\
    \ frequency of the max element in the second pass. This is O(n^2) where n is the\
    \ number of elements in the array. Using a map would be O(n).\n<|/ c |>\n<| c\
    \ |>\nYes, I agree. My solution was more of a proof of concept. Also, I didn't\
    \ want to use std::map because I didn't want to use any libraries.\n<|/ c |>\n\
    <| c |>\nI didn't downvote, but I suspect that your solution is O(n^2) because\
    \ you do two linear searches instead of one. Also, your solution doesn't work\
    \ if there are multiple equal elements in the array.\n<|/ c |>\n<| c |>\nI did\
    \ a quick test and found that my solution is O(n) where n is the number of elements\
    \ in the array. Also, I did a quick test and found that std::max_element does\
    \ a linear search through the entire array and finds the max element in the first\
    \ pass. Then it does a linear search through the entire array again to find the\
    \ frequency of the max element in the second pass. This is O(n^2) where n is the\
    \ number of elements in the array. Using a map would be O(n).\n<|/ c |>\n<| c\
    \ |>\nI didn't downvote either, but I think your solution is O(n^2) because you\
    \ do two linear searches instead of one. Also, your solution doesn't work if there\
    \ are multiple equal elements in the array.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "{\n    long max = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i] > 0)\n        {\n            freq++;\n            if(max\
    \ < lst[i])\n            {\n                max = lst[i];\n            }\n   \
    \     }\n    }\n    return (freq > max) ? -1 : max;\n}\n</code>\n<|/ a tags=c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
    \ 4L])\n<|/ c |>\n<| c |>\nIt works. I tested it. What is the problem?\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work. Try search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L])\n\
    <|/ c |>\n<| c |>\nIt works. I tested it. What is the problem?\n<|/ c |>\n<| c\
    \ |>\nIt works. I tested it. What is the problem?\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\npublic int Search(int[] arr, int val)\n{\n    int max = 0;\n    int freq\
    \ = 0;\n    for (int i = 0; i < arr.Length; i++)\n    {\n        if (arr[i] >\
    \ 0)\n        {\n            freq++;\n            if (max < arr[i])\n        \
    \    {\n                max = arr[i];\n            }\n        }\n    }\n    return\
    \ (freq > max) ? -1 : max;\n}\n</code>\n<|/ a tags=c#,algorithm |>\n<| c |>\n\
    This doesn't work. Try search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L])\n<|/ c |>\n\
    <| c |>\nIt works. I tested it. What is the problem?\n<|/ c |>\n<| c |>\nIt works.\
    \ I tested it. What is the problem?\n<|/ c |>\n<| c |>\nIt works. I tested it.\
    \ What is the problem?\n<|/ c |>\n<| c |>\nIt works. I tested it. What is the\
    \ problem?\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic int Search(int[] arr, int\
    \ val)\n{\n    int max = 0;\n    int freq = 0;\n    for (int i = 0; i < arr.Length;\
    \ i++)\n    {\n        if (arr[i] > 0)\n        {\n            freq++;\n     \
    \       if (max < arr[i])\n            {\n                max = arr[i];\n    \
    \        }\n        }\n    }\n    return (freq > max) ? -1 : max;\n}\n</code>\n\
    <|/ a tag", "{\n    long maxVal = lst[0];\n    long maxFreq = lst[0];\n    for(int\
    \ i = 1; i < lst.size(); i++)\n    {\n        if(lst[i] > maxVal)\n        {\n\
    \            maxVal = lst[i];\n            maxFreq = lst[i];\n        }\n    \
    \    else\n        {\n            if(lst[i] == maxVal)\n            {\n      \
    \          maxFreq++;\n            }\n        }\n    }\n    return maxVal;\n}\n\
    </code>\n<|/ a tags=c++,algorithm,arrays |>\n<| c |>\nI believe this solution\
    \ fails for `search([5L, 5L, 4L, 4L, 4L])`\n<|/ c |>\n<| c |>\nI believe this\
    \ solution fails for `search([5L, 5L, 4L, 4L, 4L])`\n<|/ c |>\n<| c |>\nI believe\
    \ this solution fails for `search([5L, 5L, 4L, 4L, 4L])`\n<|/ c |>\n<| c |>\n\
    I believe this solution fails for `search([5L, 5L, 4L, 4L, 4L])`\n<|/ c |>\n<|\
    \ c |>\nI believe this solution fails for `search([5L, 5L, 4L, 4L, 4L])`\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\nusing namespace std;",
  "{\n    long max = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i] > 0)\n        {\n            freq++;\n            if(lst[i]\
    \ > max)\n            {\n                max = lst[i];\n            }\n      \
    \  }\n    }\n    if(freq > max)\n    {\n        return -1;\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic static\
    \ int search(int[] arr) {\n    int max = 0;\n    int freq = 0;\n    for(int i\
    \ = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            freq++;\n\
    \            if(arr[i] > max) {\n                max = arr[i];\n            }\n\
    \        }\n    }\n    if(freq > max) {\n        return -1;\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a tags=c#,arrays |>\n<| a tags=c#,arrays |>\n<code>\n\
    public static int search(int[] arr) {\n    int max = 0;\n    int freq = 0;\n \
    \   for(int i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n        \
    \    freq++;\n            if(arr[i] > max) {\n                max = arr[i];\n\
    \            }\n        }\n    }\n    if(freq > max) {\n        return -1;\n \
    \   }\n    return max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n\
    public static int search(int[] arr) {\n    int max = 0;\n    int freq = 0;\n \
    \   for(int i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n        \
    \    freq++;\n            if(arr[i] > max) {\n                max = arr[i];\n\
    \            }\n        }\n    }\n    if(freq > max) {\n        return -1;\n \
    \   }\n    return max;\n}\n</code>\n<|/ a tags=c#,arrays |>\n<| c |>\nPlease add\
    \ some explanation to your answer such that others can learn from it\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\npublic static int search(int[] arr) {\n    int max =\
    \ 0;\n    int freq = 0;\n    for(int i = 0; i < arr.length; i++) {\n        if(arr[i]\
    \ > 0) {\n            freq++;\n            if(arr[i] > max) {\n              \
    \  max = arr[i];\n            }\n        }\n    }\n    if(freq > max) {\n    \
    \    return -1;\n    }\n    return max;\n}\n</code>\n<|/ a tags=c#,arrays |>\n\
    <| c |>\nPlease add some explanation to your answer such that others can learn\
    \ from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static int search(int[]\
    \ arr) {\n    int max = 0;\n    int freq = 0;\n", "{\n    long maxVal = lst[0];\n\
    \    long maxFreq = lst[0];\n    for(int i = 1; i < lst.size(); i++)\n    {\n\
    \        if(lst[i] > maxVal)\n        {\n            maxVal = lst[i];\n      \
    \      maxFreq = i;\n        }\n    }\n    return maxVal;\n}\n</code>\n<|/ a tags=algorithm,c++,arrays\
    \ |>\n<| c |>\nThis doesn't work if the array is empty or contains only negative\
    \ numbers. I believe this should return -1.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the array is empty or contains only negative numbers. I believe this should\
    \ return -1.\n<|/ c |>\n<| c |>\n: It does work. `-1` is returned if the array\
    \ is empty or contains only negative numbers. `-1` is returned if the array contains\
    \ only positive numbers. `-1` is returned if the array contains only negative\
    \ numbers. `-1` is returned if the array contains only positive numbers. `-1`\
    \ is returned if the array contains only negative numbers. `-1` is returned if\
    \ the array contains only positive numbers. `-1` is returned if the array contains\
    \ only negative numbers. `-1` is returned if the array contains only positive\
    \ numbers. `-1` is returned if the array contains only negative numbers. `-1`\
    \ is returned if the array contains only positive numbers. `-1` is returned if\
    \ the array contains only negative numbers. `-1` is returned if the array contains\
    \ only positive numbers. `-1` is returned if the array contains only negative\
    \ numbers. `-1` is returned if the array contains only positive numbers. `-1`\
    \ is returned if the array contains only negative numbers. `-1` is returned if\
    \ the array contains only positive numbers. `-1` is returned if the array contains\
    \ only negative numbers. `-1` is returned if the array contains only positive\
    \ numbers. `-1` is returned if the array contains only negative numbers. `-1`\
    \ is returned if the array contains only positive numbers. `-1` is returned if\
    \ the array contains only negative numbers. `-1` is returned if the array contains\
    \ only positive numbers. `-1` is returned if the array contains only negative\
    \ numbers. `-1` is returned if the array contains only positive numbers. `-1`\
    \ is returned if the array contains only negative numbers. `-1` is returned if\
    \ the array contains only positive numbers. `-1` is returned if the array contains\
    \ only negative numbers. `-1` is returned if the array contains only positive\
    \ numbers. `-1` is returned if the array contains only negative numbers. `-1`\
    \ is returned if the array contains only positive numbers. `-1` is returned if\
    \ the array contains only negative numbers. `-1` is returned if the array contains\
    \ only positive numbers. `-1` is returned if the array contains only negative\
    \ numbers. ", "{\n    long maxVal = lst[0];\n    long maxFreq = lst[0];\n    for(int\
    \ i = 1; i < lst.size(); i++){\n        if(lst[i] > maxVal){\n            maxVal\
    \ = lst[i];\n            maxFreq = lst[i];\n        }\n        else if(lst[i]\
    \ == maxVal){\n            maxFreq++;\n        }\n    }\n    if(maxFreq == lst[0]){\n\
    \        return -1;\n    }\n    return maxVal;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis code doesn't work. `search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L])`\
    \ returns `3L` instead of `2L`.\n<|/ c |>\n<| c |>\nI tested it on ideone.com,\
    \ which is where I got the code from. http://ideone.com/XxVQ0\n<|/ c |>\n<| c\
    \ |>\nI tested it on ideone.com, which is where I got the code from. http://ideone.com/XxVQ0\n\
    <|/ c |>\n<| c |>\nI tested it on ideone.com, which is where I got the code from.\
    \ http://ideone.com/XxVQ0\n<|/ c |>\n<| c |>\nI tested it on ideone.com, which\
    \ is where I got the code from. http://ideone.com/XxVQ0\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\npublic class Solution {\n    public int search(int[] nums) {\n \
    \       int maxVal = nums[0];\n        int maxFreq = nums[0];\n        for (int\
    \ i = 1; i < nums.length; i++) {\n            if (nums[i] > maxVal) {\n      \
    \          maxVal = nums[i];\n                maxFreq = nums[i];\n           \
    \ } else if (nums[i] == maxVal) {\n                maxFreq++;\n            }\n\
    \        }\n        if (maxFreq == nums[0]) {\n            return -1;\n      \
    \  }\n        return maxVal;\n    }\n}\n</code>\n<|/ a tags=algorithm,java |>\n\
    <| c |>\nThis code doesn't work. `search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L])`\
    \ returns `3L` instead of `2L`.\n<|/ c |>\n<| c |>\nI tested it on ideone.com,\
    \ which is where I got the code from. http://ideone.com/XxVQ0\n<|/ c |>\n<| c\
    \ |>\nI tested it on ideone.com, which is where I go", "{\n    long maxVal = lst[0];\n\
    \    long maxFreq = lst[0];\n    for(long i = 1; i < lst.size(); ++i)\n    {\n\
    \        if(lst[i] > maxVal)\n        {\n            maxVal = lst[i];\n      \
    \      maxFreq = i;\n        }\n    }\n    return maxVal > 0 ? maxVal : -1;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nimport java.util.Scanner;", "{\n    long maxVal = lst[0];\n\
    \    long maxCount = 0;\n    for(int i = 1; i < lst.size(); ++i)\n    {\n    \
    \    if(lst[i] > maxVal)\n        {\n            maxVal = lst[i];\n          \
    \  maxCount = 1;\n        }\n        else if(lst[i] == maxVal)\n        {\n  \
    \          maxCount++;\n        }\n    }\n    return maxVal;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=c++,algorithm |>\n<code>", "{\n    long maxVal = lst[0];\n\
    \    long maxCount = 0;\n    for(int i = 1; i < lst.size(); i++)\n    {\n    \
    \    if(lst[i] > maxVal)\n        {\n            maxVal = lst[i];\n          \
    \  maxCount = 1;\n        }\n        else if(lst[i] == maxVal)\n        {\n  \
    \          maxCount++;\n        }\n    }\n    return maxVal > 0 ? maxVal : -1;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like this solution, but I believe it can be improved\
    \ a little bit by using a `HashMap` instead of an array. Also, I think it would\
    \ be better to use a `HashMap` instead of a `List` for the `maxVal` and `maxCount`\
    \ variables. Finally, I think it would be better to use a `HashMap` instead of\
    \ a `List` for the `lst` variable. Also, `HashMap` has a `containsKey` method\
    \ which would make this code a little bit more concise.\n<|/ c |>\n<| c |>\nI\
    \ agree with you, HashMap is better than array in this case. I'll try to improve\
    \ the code with HashMap. Thanks.\n<|/ c |>\n<| c |>\nI agree with you, HashMap\
    \ is better than array in this case. I'll try to improve the code with HashMap.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI agree with you, HashMap is better than array in\
    \ this case. I'll try to improve the code with HashMap. Thanks.\n<|/ c |>\n<|\
    \ c |>\nI agree with you, HashMap is better than array in this case. I'll try\
    \ to improve the code with HashMap. Thanks.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    public class Solution {\n    public int search(int[] nums) {\n        HashMap<Integer,\
    \ Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++)\
    \ {\n            map.put(nums[i], map.containsKey(nums[i]) ? map.get(nums[i])\
    \ + 1 : 1);\n        }\n        for(int i = 0; i < nums.length; i++) {\n     \
    \       if(map.containsKey(nums[i]) && map.get(nums[i]) > 0) {\n             \
    \   return nums[i];\n            }\n        }\n        return -1;\n    }\n}\n\
    </code>\n<|/ a tags=arrays,java |>\n<| c |>\nPlease add some explanation to your\
    \ answer such that others can learn from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    public class Solution {\n    public int search(int[] nums) {\n        HashMap<Integer,\
    \ Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++)\
    \ {\n            map.put(num", "{\n    long maxVal = lst[0];\n    long maxCount\
    \ = 0;\n    for(long i : lst)\n    {\n        if(i > maxVal)\n        {\n    \
    \        maxVal = i;\n            maxCount = 1;\n        }\n        else\n   \
    \     {\n            maxCount++;\n        }\n    }\n    return maxVal > 0 ? maxVal\
    \ : -1;\n}\n</code>\n<|/ a tags=algorithm,c++,arrays |>\n<| a tags=algorithm,c++,arrays\
    \ |>\n<code>\n#include <iostream>\n#include <vector>\nusing namespace std;", "{\n\
    \    long max = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.size(); i++)\n\
    \    {\n        if(lst[i] > 0)\n        {\n            freq++;\n            if(max\
    \ < lst[i])\n                max = lst[i];\n        }\n    }\n    return (freq\
    \ > max) ? -1 : max;\n}\n</code>\n<|/ a |>\n<| c |>\nI like the idea of using\
    \ a map to keep track of the frequency of each element. Thanks!\n<|/ c |>\n<|\
    \ c |>\nThe solution above is O(n^2) (worst case), but this one is O(n) (best\
    \ case). So the complexity is O(n).\n<|/ c |>\n<| c |>\nThis solution is O(n)\
    \ but it is O(n^2) in worst case. Worst case is when all elements are negative\
    \ and frequency is 0\n<|/ c |>\n<| a tags=algorithm,c++ |>\n<code>\n#include <iostream>\n\
    #include <vector>\n#include <algorithm>\nusing namespace std;", "{\n    long max\
    \ = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.size(); i++)\n    {\n \
    \       if(lst[i] > 0)\n        {\n            freq++;\n            if(max < lst[i])\n\
    \            {\n                max = lst[i];\n            }\n        }\n    }\n\
    \    return freq > max ? -1 : max;\n}\n</code>\n<|/ a tags=search,arrays,c++ |>\n\
    <| c |>\nThis code doesn't work if there are negative numbers in the array. For\
    \ example, search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L]) returns -1L instead of\
    \ 3L.\n<|/ c |>\n<| c |>\nI edited the answer to fix the negative numbers. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| c |>\nThis code doesn't work if there are\
    \ negative numbers in the array. For example, search([1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L, 4L]) returns -1L instead of 3L.\n<|/ c |>\n<| c |>\nI edited the answer\
    \ to fix the negative numbers. Thanks for pointing that out.\n<|/ c |>\n<| a |>\n\
    <code>\n#include <iostream>\n#include <vector>\nusing namespace std;", "{\n  \
    \  long max = 0;\n    long freq = 0;\n    for(long i : lst)\n    {\n        freq\
    \ += i;\n        if(freq > max)\n        {\n            max = freq;\n        }\n\
    \    }\n    return max;\n}", "{\n    long maxVal = lst[0];\n    long maxCount\
    \ = 1;\n    for(long i = 1; i < lst.size(); i++)\n    {\n        if(lst[i] > maxVal)\n\
    \        {\n            maxVal = lst[i];\n            maxCount = 1;\n        }\n\
    \        else if(lst[i] == maxVal)\n        {\n            maxCount++;\n     \
    \   }\n        else\n        {\n            if(maxCount >= maxVal)\n         \
    \   {\n                return maxVal;\n            }\n            else\n     \
    \       {\n                maxVal = lst[i];\n                maxCount = 1;\n \
    \           }\n        }\n    }\n    return -1;\n}\n</code>\n<|/ a tags=c++,algorithm,arrays\
    \ |>\n<| a |>\n<code>\n#include <iostream>\n#include <vector>\nusing namespace\
    \ std;", "{\n    long max = 0;\n    long freq = 0;\n    for(int i = 0; i < lst.size();\
    \ i++){\n        if(lst[i] > 0){\n            freq++;\n            if(max < lst[i]){\n\
    \                max = lst[i];\n            }\n        }\n    }\n    if(max >\
    \ 0){\n        return max;\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;", "{\n\
    \    long maxVal = lst[0];\n    long maxFreq = lst[0];\n    for(long i = 1; i\
    \ < lst.size(); i++)\n    {\n        if(lst[i] > maxVal)\n        {\n        \
    \    maxVal = lst[i];\n            maxFreq = lst[i];\n        }\n        else\n\
    \        {\n            if(lst[i] == maxVal)\n            {\n                maxFreq++;\n\
    \            }\n        }\n    }\n    return maxVal;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c++,algorithm |>\n<code>\n#include <iostream>\n#include <vector>\n\
    #include <algorithm>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
