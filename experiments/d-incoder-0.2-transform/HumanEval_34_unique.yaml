name: HumanEval_34_unique
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique elements\
  \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
  \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n"
tests: "unittest\n{\n    alias candidate = unique;\n\n    assert(candidate([5L, 3L,\
  \ 5L, 2L, 3L, 3L, 9L, 0L, 123L]) == [0L, 2L, 3L, 5L, 9L, 123L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[l.length];\n    long[] seen = new long[l.length];\n\
    \    \n    for(int i = 0; i < l.length; i++)\n    {\n        if(!seen[l[i]])\n\
    \        {\n            result[i] = l[i];\n            seen[l[i]] = true;\n  \
    \      }\n    }\n    \n    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tfor (int j = i + 1; j < l.length;\
    \ j++)\n\t\t{\n\t\t\tif (l[i] == l[j])\n\t\t\t{\n\t\t\t\tfor (int k = j; k < l.length;\
    \ k++)\n\t\t\t\t{\n\t\t\t\t\tl[k] = l[k + 1];\n\t\t\t\t}\n\t\t\t\tl.length--;\n\
    \t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tresult[i] = l[i];\n\t}\n\t\n\treturn result;\n\
    }", "{\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n    for(int\
    \ i = 0; i < l.length; i++)\n        result[i] = l[i];\n    return result;\n}",
  "{\n    long[] result = new long[l.length];\n    long prev = 0;\n    long cur =\
    \ 0;\n    for (int i = 0; i < l.length; i++)\n    {\n        cur = l[i];\n   \
    \     if (cur != prev)\n        {\n            result[i - 1] = cur;\n        \
    \    prev = cur;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,c#,sorting,arrays\
    \ |>\n<| c |>\nThis code doesn't work if there are duplicates in the array. For\
    \ example, unique([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "{\n    long[] res = new long[l.length];\n    long last = 0;\n    long cur = 0;\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        cur = l[i];\n        if(cur\
    \ != last)\n        {\n            res[res.length-1] = cur;\n            last\
    \ = cur;\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=c#,algorithm,sorting |>\n<code>\npublic static void Main()\n{\n    int[]\
    \ arr = new int[] { 5, 3, 5, 4, 2, 3, 4, 3, 9, 0, 123 };\n    arr = arr.OrderBy(x\
    \ => x).ToArray();\n    Console.WriteLine(string.Join(\",\", arr));\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=c#,algorithm,sorting |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;", "{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  long current = l[i];\n        int j = 0;\n        while(j < result.length &&\
    \ result[j] == current)\n        {\n            j++;\n        }\n        if(j\
    \ == result.length)\n        {\n            result[i] = current;\n        }\n\
    \        else\n        {\n            int k = j;\n            while(j > 0 && result[j-1]\
    \ > current)\n            {\n                result[k] = result[j-1];\n      \
    \          j--;\n            }\n            result[k] = current;\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,sorting,algorithm,c#\
    \ |>\n<| c |>\nThis code doesn't work. Try it with a list with duplicate elements.\
    \ For example, `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns `[0, 2,\
    \ 3, 4, 5, 9, 123]` instead of `[0, 2, 3, 4, 5, 123]`.\n<|/ c |>\n<| c |>\n: I\
    \ tested it and it works fine. Can you give an example where it fails?\n<|/ c\
    \ |>\n<| c |>\n: I tested it and it works fine. Can you give an example where\
    \ it fails?\n<|/ c |>\n<| c |>\n: I tested it and it works fine. Can you give\
    \ an example where it fails?\n<|/ c |>\n<| c |>\n: I tested it and it works fine.\
    \ Can you give an example where it fails?\n<|/ c |>\n<| a tags=arrays,sorting,algorithm,c#\
    \ |>\n<code>\npublic static int[] unique(int[] arr)\n{\n    int[] result = new\
    \ int[arr.Length];\n    Array.Sort(arr);\n    List<int> list = new List<int>(arr);\n\
    \    list.RemoveAll(x => list.Contains(x));\n    list.Sort();\n    Array.Copy(list.ToArray(),\
    \ result, list.Count);\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis code doesn't work. Try it with a list with duplicate elements. For\
    \ example, `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns `[0, 2, 3,\
    \ 4, 5, 9, 123]` instead of `[0, 2, 3, 4, 5, 123]`.\n<|/ c |>\n<| c |>\n: I tested\
    \ it and it works fine. Can you give an example where it fails?\n<|/ c |>\n<|\
    \ c |>\n: I tested ", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        long current = l[i];\n        for(int\
    \ j = i + 1; j < l.length; j++) \n        {\n            if(l[j] == current) \n\
    \            {\n                current = l[j];\n            }\n        }\n  \
    \      result[i] = current;\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,sorting,algorithm\
    \ |>\n<| c |>\nThis code does not work. Try it with a list with duplicates. For\
    \ example, `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns `[0, 2, 3,\
    \ 4, 5, 9, 123]` instead of `[0, 2, 3, 4, 5, 9, 123, 5]`.\n<|/ c |>\n<| c |>\n\
    I fixed the bug, thanks for pointing it out. Now it works as expected.\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>\npublic static void Main(string[] args)\n{\n  \
    \  int[] arr = new int[] { 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, ", "{\n    long[]\
    \ u = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n        u[l.indexOf(l[i])]\
    \ = l[i];\n    return u;\n}", "{\n\tlong[] u = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; ++i)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n\
    }", "{\n    long[] res = new long[l.length];\n    long curr = l[0];\n    int i\
    \ = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i] != curr)\n      \
    \  {\n            res[i - 1] = curr;\n            curr = l[i];\n        }\n  \
    \  }\n    res[i - 1] = curr;\n    return res;\n}", "{\n    long[] result = new\
    \ long[l.length];\n    long[] tmp = new long[l.length];\n    int j = 0;\n    for\
    \ (int i = 0; i < l.length; i++) \n    {\n        if (tmp[j] == l[i]) \n     \
    \   {\n            continue;\n        }\n        result[j++] = l[i];\n       \
    \ tmp[j++] = l[i];\n    }\n    result[j++] = l[i];\n    return result;\n}\n</code>\n\
    <|/ a tags=sorting,arrays,c# |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the list. For example, unique([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "{\n\tlong[] u = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\t\
    u[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n}", "{\n\tlong[] u = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\t\
    return u;\n}", "{\n    long[] u = new long[l.length];\n    for(int i = 0; i <\
    \ l.length; i++) \n    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n \
    \   return u;\n}", "{\n    long[] result = new long[l.length];\n    long last\
    \ = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n\
    \        {\n            result[result.length-1] = l[i];\n            last = l[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in\
    \ a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end) \n\
    {\n    long[] result = new long[end-start];\n    long last = 0;\n    for(int i\
    \ = start; i < end; i++)\n    {\n        if(l[i] != last)\n        {\n       \
    \     result[result.length-1] = l[i];\n            last = l[i];\n        }\n \
    \   }\n    return result;\n}\n/*\nReturn sorted unique elements in a list\n  \
    \  >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L,\
    \ 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end, int step) \n{\n\
    \    long[] result = new long[end-start];\n    long last = 0;\n    for(int i =\
    \ start; i < end; i+=step)\n    {\n        if(l[i] != last)\n        {\n     \
    \       result[result.length-1] = l[i];\n            last = l[i];\n        }\n\
    \    }\n    return result;\n}\n/*\nReturn sorted unique elements in a list\n \
    \   >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L,\
    \ 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end, int step, long\
    \ stepSize) \n{\n    long[] result = new long[end-start];\n    long last = 0;\n\
    \    for(int i = start; i < end; i+=step, last+=stepSize)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[result.length-1] = l[i];\n         \
    \   last = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step, long stepSize, long stepSize2) ", "{\n    long[] u = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n        u[i]\
    \ = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n}", "{\n\tlong[] u = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tu[i] = l[i];\n\t\
    Arrays.sort(u);\n\treturn u;\n}", "{\n\tlong[] u = new long[l.length];\n\tfor\
    \ (int i = 0; i < l.length; i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn\
    \ u;\n}", "{\n\tlong[] u = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  long current = l[i];\n        for(int j = i; j < l.length; j++)\n        {\n\
    \            if(l[j] == current)\n            {\n                result[j] = current;\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end) \n{\n    long[] result = new long[end - start];\n   \
    \ for(int i = start; i < end; i++)\n    {\n        long current = l[i];\n    \
    \    for(int j = i; j < end; j++)\n        {\n            if(l[j] == current)\n\
    \            {\n                result[j - start] = current;\n               \
    \ break;\n            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step) \n{\n    long[] result = new long[end - start];\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        long current = l[i];\n      \
    \  for(int j = i; j < end; j += step)\n        {\n            if(l[j] == current)\n\
    \            {\n                result[j - start] = current;\n               \
    \ break;\n            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step, long stepSize) \n{\n    long[] result = new long[end - start];\n\
    \    for(int i = start; i < end; i += step)\n    {\n        long current = l[i];\n\
    \        for(int j = i; j < end; j += step)\n        {\n            if(l[j] ==\
    \ current)\n            {\n                result[j - start] = current;\n    \
    \            break;\n            }\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [", "{\n    long[] result = new long[l.length];\n  \
    \  for(int i = 0; i < l.length; ++i)\n        result[l.indexOf(l[i])] = l[i];\n\
    \    return result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, long key) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        result[l.indexOf(l[i], key)] =\
    \ l[i];\n    return result;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key, long key2) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n      \
    \  result[l.indexOf(l[i], key, key2)] = l[i];\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,\
    \ long key, long key2, long key3) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        result[l.indexOf(l[i], key, key2,\
    \ key3)] = l[i];\n    return result;\n}\n/*\nReturn sorted unique elements in\
    \ a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key, long key2, long\
    \ key3, long key4) \n{\n    long[] result = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; ++i)\n        result[l.indexOf(l[i], key, key2, key3, key4)]\
    \ = l[i];\n    return result;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key, long key2, ", "{\n  \
    \  long[] result = new long[l.length];\n    long prev = 0;\n    long curr = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(curr == l[i])\n    \
    \    {\n            continue;\n        }\n        prev = curr;\n        curr =\
    \ l[i];\n        result[i - 1] = prev;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,linq,.net,arrays |>\n<| c |>\nThis is not the correct answer. `unique`\
    \ returns unique elements in the order they appear in the original list, not in\
    \ the order they appear in the original list. `unique` should return `[1L, 2L,\
    \ 3L, 4L, 5L]` instead of `[1L, 2L, 3L, 4L, 5L, 3L]`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ you are right. I missed that part. Thanks for pointing it out. I've updated\
    \ my answer.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nvar result = list.GroupBy(x\
    \ => x).Select(x => x.First()).ToArray();\n</code>\n<|/ a tags=c#,linq,.net,arrays\
    \ |>\n<| c |>\nThis is not the correct answer. `GroupBy` returns unique elements\
    \ in the order they appear in the original list, not in the order they appear\
    \ in the original list. `GroupBy` should return `[1L, 2L, 3L, 4L, 5L]` instead\
    \ of `[1L, 2L, 3L, 4L, 5L, 3L]`.\n<|/ c |>\n<| c |>\n: Yes, you are right. I missed\
    \ that part. Thanks for pointing it out. I've updated my answer.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>\nvar result = list.Distinct().ToArray();\n</code>\n<|/\
    \ a tags=c#,linq,.net,arrays |>\n<| c |>\nThis is not the correct answer. `Distinct`\
    \ returns unique elements in the order they appear in the original list, not in\
    \ the order they appear in the original list. `Distinct` should return `[1L, 2L,\
    \ 3L, 4L, 5L]` instead of `[1L, 2L, 3L, 4L, 5L, 3L]`.\n<|/ c |>\n<| c |>\nThis\
    \ is not the correct answer. `Distinct` returns unique elements in the order they\
    \ appear in the original list, not in the order they appear in the original list.\
    \ `Distinct` should return `", "{\n    long[] u = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++)\n    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n\
    \    return u;\n}\n</code>\n<|/ a tags=arrays,sorting,c# |>\n<| c |>\nThis doesn't\
    \ work if you have a duplicate number in the array. For example, if you have `[1,\
    \ 1, 2, 3]` the result will be `[1, 2]`.\n<|/ c |>\n<| c |>\nI believe this solution\
    \ will work fine for duplicate numbers. I tested it on `[1, 1, 2, 3]` and it returned\
    \ `[1, 2]`.\n<|/ c |>\n<| c |>\nIt will work if you use Linq's Distinct() method.\
    \ `var unique = l.Distinct().ToArray();`\n<|/ c |>\n<| c |>\nThis solution does\
    \ not work if you have a duplicate number in the array. For example, if you have\
    \ `[1, 1, 2, 3]` the result will be `[1, 2]`.\n<|/ c |>\n<| c |>\nI believe this\
    \ solution will work fine for duplicate numbers. I tested it on `[1, 1, 2, 3]`\
    \ and it returned `[1, 2]`.\n<|/ c |>\n<| a tags=arrays,sorting,c# |>\n<code>\n\
    public int[] uniqueSort(int[] array)\n{\n    int[] result = new int[array.Length];\n\
    \    int j = 0;\n    for (int i = 0; i < array.Length; i++)\n    {\n        if\
    \ (j < result.Length)\n        {\n            if (array[i] > result[j])\n    \
    \        {\n                result[j] = array[i];\n                j++;\n    \
    \        }\n        }\n        else\n        {\n            result[j] = array[i];\n\
    \            j++;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis solution does not work if you have a duplicate number in the\
    \ array. For example, if you have `[1, 1, 2, 3]` the result will be `[1, 2]`.\n\
    <|/ c |>\n<| c |>\nThis solution does not work if you have a duplicate number\
    \ in the array. For example, if you have `[1, 1, 2, 3]` the result will be `[1,\
    \ 2]`.\n<|/ c |>\n<| c |>\nThis solution does not work if you have a duplicate\
    \ number in the array. For example, if you have `[1, 1, 2, 3]` the result will\
    \ be `[1, 2]`.\n<|/ c |>\n<| c |>\nThis solution does not work if you have a duplicate\
    \ number in the array. For example, if you have `[1, 1, 2, 3]` the result will\
    \ be `[1, 2]`.\n<|/ c ", "{\n\tlong[] u = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tu[i] = l[i];\n\t}\n\tArrays.sort(u);\n\treturn\
    \ u;\n}", "{\n\tlong[] result = new long[l.length];\n\t\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t{\n\t\tint j;\n\t\tfor (j = 0; j < i; j++)\n\t\t{\n\t\t\t\
    if (l[j] == l[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i)\n\t\t\tresult[i] = l[i];\n\
    \t}\n\t\n\treturn result;\n}", "{\n\tlong[] u = new long[l.length];\n\tlong ux\
    \ = 0;\n\tlong uy = 0;\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ > ux) \n\t\t{\n\t\t\tux = l[i];\n\t\t}\n\t\tif (l[i] < uy) \n\t\t{\n\t\t\tuy\
    \ = l[i];\n\t\t}\n\t}\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ == ux) \n\t\t{\n\t\t\tu[i] = uy;\n\t\t}\n\t\telse if (l[i] > uy) \n\t\t{\n\t\
    \t\tu[i] = ux;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tu[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ u;\n}", "{\n    long[] result = new long[l.length];\n    for(int i = 0; i <\
    \ l.length; i++)\n        result[i] = l[i];\n    Arrays.sort(result);\n    return\
    \ result;\n}", "{\n    long[] result = new long[l.length];\n    long[] seen =\
    \ new long[l.length];\n    \n    for (int i = 0; i < l.length; ++i)\n    {\n \
    \       if (!seen[i])\n        {\n            result[i] = l[i];\n            seen[i]\
    \ = 1;\n        }\n    }\n    \n    return result;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    long prev = 0;\n    long cur = 0;\n    for (int i\
    \ = 0; i < l.length; i++) \n    {\n        cur = l[i];\n        if (cur != prev)\
    \ \n        {\n            result[i - 1] = cur;\n            prev = cur;\n   \
    \     }\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,sorting |>\n\
    <| c |>\nThis doesn't work for me. `unique` returns `[1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 17L, 18L, 19L, 20L, 21L, 22L,\
    \ 23L, 24L, 25L, 26L, 27L, 28L, 29L, 30L, 31L, 32L, 33L, 34L, 35L, 36L, 37L, 38L,\
    \ 39L, 40L, 41L, 42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L,\
    \ 55L, 56L, 57L, 58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L, 69L, 70L,\
    \ 71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 84L, 85L, 86L,\
    \ 87L, 88L, 89L, 90L, 91L, 92L, 93L, 94L, 95L, 96L, 97L, 98L, 99L, 100L, 101L,\
    \ 102L, 103L, 104L, 105L, 106L, 107L, 108L, 109L, 110L, 111L, 112L, 113L, 114L,\
    \ 115L, 116L, 117L, 118L, 119L, 120L, 121L, 122L, 123L, 124L, 125L, 126L, 127L,\
    \ 128L, 129L, 130L, 131L, 132L, 133L, 134L, 135L, 136L, 137L, 138L, 139L, 140L,\
    \ 141L, 142L, 143L, 144L, 145L, 146L, 147L, 148L, 149L, 150L, 151L, 152L, 153L,\
    \ 154L, 155L, 156L, 157L, 158L, 159L, 160L, 161L, 162L, 163L, 164L, 165L, 166L,\
    \ 167L, 168L, 169L, 170L, 171L, 172L, 173L, 174L, 175L, 176L, 177L, 178L, 179L,\
    \ 180L, 181L, 182L, 183L, 184L, 185L, 186L, 187L, 188L, 189L, 190L, 191L, 192L,\
    \ 193L, 194L, 195L, 196L, 197L, 198L, 199L, 200", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] = l[i];\n\tArrays.sort(result);\n\
    \treturn result;\n}", "{\n    long[] res = new long[l.length];\n    long last\
    \ = 0;\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] != last)\n\
    \        {\n            last = l[i];\n            res[i] = last;\n        }\n\
    \    }\n    return res;\n}\n</code>\n<|/ a tags=arrays,c#,sorting |>\n<| a dscore=0\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;", "{\n    long[] result = new long[l.length];\n    long[] seen\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  seen[i] = 0;\n        result[i] = l[i];\n    }\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        for(int j = i + 1; j < l.length; j++)\n        {\n    \
    \        if(l[i] == l[j])\n            {\n                seen[j]++;\n       \
    \     }\n        }\n    }\n    for(int i = 0; i < l.length; i++)\n    {\n    \
    \    if(seen[i] > 1)\n        {\n            result[i] = l[i];\n        }\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm |>\n<| c\
    \ |>\nThis is not an efficient solution. Sorting takes O(n log n) time. Your solution\
    \ takes O(n^2) time.\n<|/ c |>\n<| c |>\n: I agree with you. But the OP asked\
    \ for efficient solution. He didn't ask about efficient sorting algorithm. He\
    \ asked for efficient solution for unique elements in a list. He didn't ask about\
    \ efficient sorting algorithm. He asked for efficient solution for unique elements\
    \ in a list. He didn't ask about efficient sorting algorithm. He asked for efficient\
    \ solution for unique elements in a list. He didn't ask about efficient sorting\
    \ algorithm. He asked for efficient solution for unique elements in a list. He\
    \ didn't ask about efficient sorting algorithm. He asked for efficient solution\
    \ for unique elements in a list. He didn't ask about efficient sorting algorithm.\
    \ He asked for efficient solution for unique elements in a list. He didn't ask\
    \ about efficient sorting algorithm. He asked for efficient solution for unique\
    \ elements in a list. He didn't ask about efficient sorting algorithm. He asked\
    \ for efficient solution for unique elements in a list. He didn't ask about efficient\
    \ sorting algorithm. He asked for efficient solution for unique elements in a\
    \ list. He didn't ask about efficient sorting algorithm. He asked for efficient\
    \ solution for unique elements in a list. He didn't ask about efficient sorting\
    \ algorithm. He asked for efficient solution for unique elements in a list. He\
    \ didn't ask about efficient sorting algorithm. He asked for efficient solution\
    \ for unique elements in a list. He didn't ask about efficient sorting algorithm.\
    \ He asked for efficient solution for unique elements in a list. He didn't ask\
    \ about efficient sorting algorithm. He asked for efficient solution for unique\
    \ elements in a list. He didn't ask about efficient sorting algorithm. He asked\
    \ for efficient ", "{\n    long[] result = new long[l.length];\n    long prev\
    \ = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != prev)\n\
    \        {\n            result[i - 1] = l[i];\n            prev = l[i];\n    \
    \    }\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,linq,.net,sorting\
    \ |>\n<| a tags=c#,linq,.net,sorting |>\n<code>\nvar result = new List<int>()\
    \ { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i => i).ToList();\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nvar result = new List<int>()\
    \ { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i => i).ToList();\n\
    </code>\n<|/ a tags=c#,linq,.net,sorting |>\n<| a tags=c#,linq,.net,sorting |>\n\
    <code>\nvar result = new List<int>() { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i\
    \ => i).ToList();\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nvar result = new\
    \ List<int>() { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i => i).ToList();\n\
    </code>\n<|/ a tags=c#,linq,.net,sorting dscore=2 |>\n<| a tags=c#,linq,.net,sorting\
    \ |>\n<code>\nvar result = new List<int>() { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i\
    \ => i).ToList();\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,linq,.net,sorting\
    \ |>\n<code>\nvar result = new List<int>() { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i\
    \ => i).ToList();\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nvar result\
    \ = new List<int>() { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(i\
    \ => i).ToList();\n</code>\n<|/ a tags=c#,linq,.net,sorting |>\n<| a dscore=1\
    \ |>\n<code>\nvar result = new List<int>() { 1, 2, 3, 4 };\nvar unique = result.Distinct().OrderBy(",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\
    \ \n    {\n        long current = l[i];\n        for(int j = i + 1; j < l.length;\
    \ j++) \n        {\n            if(l[j] == current) \n            {\n        \
    \        current = l[j];\n            }\n        }\n        result[i] = current;\n\
    \    }\n    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++)\n\t{\n\t\tfor (int j = i+1; j < l.length; j++)\n\
    \t\t{\n\t\t\tif (l[i] == l[j])\n\t\t\t{\n\t\t\t\tfor (int k = j; k < l.length;\
    \ k++)\n\t\t\t\t{\n\t\t\t\t\tl[k] = l[k+1];\n\t\t\t\t}\n\t\t\t\tl.length--;\n\t\
    \t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \        result[i] = l[i];\n    Arrays.sort(result);\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,c#,sorting |>\n<| c |>\nThis doesn't work if there\
    \ are duplicate elements in the list\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate elements in the list\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are duplicate elements in the list\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are duplicate elements in the list\n<|/ c |>\n<| a tags=arrays,c#,sorting\
    \ |>\n<code>\npublic static int[] SortUnique(int[] array)\n{\n    int[] result\
    \ = new int[array.Length];\n    Array.Sort(array);\n    HashSet<int> set = new\
    \ HashSet<int>();\n    for (int i = 0; i < array.Length; i++)\n    {\n       \
    \ if (!set.Add(array[i]))\n        {\n            result[i] = array[i];\n    \
    \    }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't work if there are duplicate elements in the list\n<|/ c |>\n<| c |>\n\
    This doesn't work if there are duplicate elements in the list\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if there are duplicate elements in the list\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are duplicate elements in the list\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "{\n\tlong[] u = new long[l.length];\n\t\
    long last = 0;\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] != last)\n\
    \t\t{\n\t\t\tlast = l[i];\n\t\t\tu[i] = last;\n\t\t}\n\t}\n\treturn u;\n}", "{\n\
    \tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\
    \tresult[i] = l[i];\n\tArrays.sort(result);\n\treturn result;\n}", "{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       long val = l[i];\n        for(int j = i; j < l.length; j++) \n       \
    \ {\n            if(l[j] == val) \n            {\n                res[j - i] =\
    \ val;\n                break;\n            }\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,c#,algorithm |>\nI wrote a C#\
    \ version using Linq:\n<code>\npublic static int[] Unique(int[] array)\n{\n  \
    \  return array.Distinct().OrderBy(i => i).ToArray();\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=arrays,c#,algorithm |>\n<code>\npublic static int[] Unique(int[]\
    \ array)\n{\n    HashSet<int> set = new HashSet<int>();\n    foreach (int i in\
    \ array)\n    {\n        if (set.Add(i))\n        {\n            array.Remove(i);\n\
    \        }\n    }\n    return array.ToArray();\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't work if you pass in an array like {1,2,2,3,3,3,4} because\
    \ it will return {1,2,3} instead of {1,2,3,4}\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you pass in an array like {1,2,2,3,3,3,4} because it will return {1,2,3}\
    \ instead of {1,2,3,4}\n<|/ c |>\n<| a tags=arrays,c#,algorithm |>\n<code>\npublic\
    \ static int[] Unique(int[] array)\n{\n    HashSet<int> set = new HashSet<int>();\n\
    \    foreach (int i in array)\n    {\n        if (set.Add(i))\n        {\n   \
    \         array.Remove(i);\n        }\n    }\n    return array.ToArray();\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static int[] Unique(int[]\
    \ array)\n{\n    HashSet<int> set = new HashSet<int>();\n    foreach (int i in\
    \ array)\n    {\n        if (set.Add(i))\n        {\n            array.Remove(i);\n\
    \        }\n    }\n    return array.ToArray();\n}\n</code>\n<|/ a tags=arrays,c#,algorithm\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static int[] Unique(int[] array)\n{\n \
    \   HashSet<int> set = new HashSet<int>();\n    foreach (int i in array)\n   \
    \ {\n        if (set.Add(i))\n        {\n            array.Remove(i);\n      \
    \  }\n    }\n    return array.", "{\n    long[] res = new long[l.length];\n  \
    \  long last = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ != last)\n        {\n            last = l[i];\n            res[i] = last;\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn sorted unique elements in a\
    \ list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L,\
    \ 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key) \n{\n    long[] res\
    \ = new long[l.length];\n    long last = 0;\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last && l[i] == key)\n        {\n          \
    \  last = l[i];\n            res[i] = last;\n        }\n    }\n    return res;\n\
    }\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int key) \n{\n    long[] res = new long[l.length];\n    long last = 0;\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last && l[i]\
    \ == key)\n        {\n            last = l[i];\n            res[i] = last;\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key, int key2) \n{\n    long[]\
    \ res = new long[l.length];\n    long last = 0;\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last && l[i] == key && l[i] == key2)\n     \
    \   {\n            last = l[i];\n            res[i] = last;\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int key, int key2) \n{\n    long[] res = new long[l.length];\n\
    \    long last = 0;\n    for(int i = 0; i < l.length; i++)\n    {", "{\n    long[]\
    \ res = new long[l.length];\n    long[] seen = new long[l.length];\n    int j\
    \ = 0;\n    for(int i = 0; i < l.length; i++) \n    {\n        if(!seen[i]) \n\
    \        {\n            seen[i] = 1;\n            res[j] = l[i];\n           \
    \ j++;\n        }\n    }\n    return res;\n}", "{\n    long[] u = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        u[l.indexOf(l[i])] = l[i];\n\
    \    }\n    return u;\n}\n</code>\n<|/ a tags=java,arrays,sorting |>\n<| c |>\n\
    This is not the best solution, since it requires O(n^2) time complexity (where\
    \ n is the number of elements in the array). A better solution would be to sort\
    \ the array and remove duplicates in O(n) time complexity.\n<|/ c |>\n<| c |>\n\
    This is not the best solution, since it requires O(n^2) time complexity (where\
    \ n is the number of elements in the array). A better solution would be to sort\
    \ the array and remove duplicates in O(n) time complexity.\n<|/ c |>\n<| c |>\n\
    This is not the best solution, since it requires O(n^2) time complexity (where\
    \ n is the number of elements in the array). A better solution would be to sort\
    \ the array and remove duplicates in O(n) time complexity.\n<|/ c |>\n<| c |>\n\
    This is not the best solution, since it requires O(n^2) time complexity (where\
    \ n is the number of elements in the array). A better solution would be to sort\
    \ the array and remove duplicates in O(n) time complexity.\n<|/ c |>\n<| c |>\n\
    This is not the best solution, since it requires O(n^2) time complexity (where\
    \ n is the number of elements in the array). A better solution would be to sort\
    \ the array and remove duplicates in O(n) time complexity.\n<|/ c |>\n<| a |>\n\
    <code>\nimport java.util.Arrays;", "{\n    long[] result = new long[l.length];\n\
    \    Arrays.sort(l);\n    for(int i = 0; i < l.length; i++)\n        result[i]\
    \ = l[i];\n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long[] seen = new long[l.length];\n    \n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        if (!seen[i])\n        {\n            seen[i] = 1;\n  \
    \          result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;", "{\n\tlong[] result =\
    \ new long[l.length];\n\t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tint\
    \ j;\n\t\tfor (j = 0; j < i; j++)\n\t\t{\n\t\t\tif (l[j] == l[i])\n\t\t\t\tbreak;\n\
    \t\t}\n\t\t\n\t\tif (j == i)\n\t\t\tresult[i] = l[i];\n\t}\n\t\n\treturn result;\n\
    }", "{\n    long[] res = new long[l.length];\n    long last = 0;\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        if(l[i] != last)\n        {\n   \
    \         last = l[i];\n            res[i] = last;\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;", "{\n    long[] result\
    \ = new long[l.length];\n    long last = 0;\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last)\n        {\n            result[result.length-1]\
    \ = l[i];\n            last = l[i];\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        long current = l[i];\n        for(int j = i; j < l.length; j++)\n\
    \        {\n            if(l[j] == current)\n            {\n                long\
    \ tmp = l[j];\n                l[j] = l[i];\n                l[i] = tmp;\n   \
    \         }\n        }\n        result[i] = current;\n    }\n    return result;\n\
    }\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, long compare) \n{\n    long[] result = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; i++)\n    {\n        long current = l[i];\n        for(int\
    \ j = i; j < l.length; j++)\n        {\n            if(l[j] == current && compare(l[j],\
    \ current))\n            {\n                long tmp = l[j];\n               \
    \ l[j] = l[i];\n                l[i] = tmp;\n            }\n        }\n      \
    \  result[i] = current;\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], std.math.Ordering.LT)\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, Ordering compare)\
    \ \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        long current = l[i];\n        for(int j = i; j < l.length;\
    \ j++)\n        {\n            if(l[j] == current && compare(current, l[j]))\n\
    \            {\n                long tmp = l[j];\n                l[j] = l[i];\n\
    \                l[i] = tmp;\n            }\n        }\n        result[i] = current;\n\
    \    }\n    return result;\n}\n/*\nReturn sorted unique elements in a list\n \
    \   >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], std.math.Ordering.LT)\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, Ordering compare,\
    \ long compare2) \n{\n    long[] result = new long[l.length];\n    for(int i =\
    \ 0; i < l.length; i++)\n    {\n        long current = l[i];\n        for(int\
    \ j = i; j < l.length; j++)\n        {\n            if(l[j] == current && compare(current,\
    \ l[j]", "{\n\tlong[] u = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tArrays.sort(l);\n\tfor (int i = 0; i < l.length; i++)\n\
    \t\tresult[i] = l[i];\n\treturn result;\n}", "{\n    long[] u = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        u[i] = l[i];\n    }\n\
    \    Arrays.sort(u);\n    return u;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't work if you have a list of `long[]`s, as `Arrays.sort` doesn't know\
    \ how to compare them.\n<|/ c |>\n<| c |>\nI added a version that works with lists\
    \ of arrays as well.\n<|/ c |>\n<| a tags=sorting,arrays,java |>\n<code>\nimport\
    \ java.util.Arrays;", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        long current = l[i];\n        for(int\
    \ j = i; j < l.length; j++) \n        {\n            if(l[j] == current) \n  \
    \          {\n                result[j] = current;\n                break;\n \
    \           }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list.\
    \ Try it with `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if there are duplicate elements in the list. Try it with\
    \ `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\n<|/ c |>\n<| c |>\nIt does\
    \ work, if you change `if(l[j] == current)` to `if(l[j] == current && l[j] !=\
    \ l[i])`\n<|/ c |>\n<| c |>\nIt does work, if you change `if(l[j] == current)`\
    \ to `if(l[j] == current && l[j] != l[i])`\n<|/ c |>\n<| c |>\nIt does work, if\
    \ you change `if(l[j] == current)` to `if(l[j] == current && l[j] != l[i])`\n\
    <|/ c |>\n<| a tags=arrays,c#,algorithm |>\n<code>\npublic static int[] unique(int[]\
    \ array)\n{\n    int[] result = new int[array.Length];\n    HashSet<int> set =\
    \ new HashSet<int>();\n    for (int i = 0; i < array.Length; i++)\n    {\n   \
    \     if (!set.Contains(array[i]))\n        {\n            result[i] = array[i];\n\
    \            set.Add(array[i]);\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicate elements\
    \ in the list. Try it with `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\n\
    <|/ c |>\n<| c |>\nIt does work, if you change `if (!set.Contains(array[i]))`\
    \ to `if (set.Contains(array[i]))`\n<|/ c |>\n<| c |>\nIt does work, if you change\
    \ `if (!set.Contains(array[i]))` to `if (set.Contains(array[i]))`\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>\npublic static int[] unique(int[] array)\n{\n    Hash",
  "{\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n    for(int i\
    \ = 0; i < l.length; i++)\n        result[i] = l[i];\n    return result;\n}",
  "{\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n    for(int i\
    \ = 0; i < l.length; i++) \n        result[i] = l[i];\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,c#,sorting |>\n<| c |>\nI believe this answer was posted\
    \ before the question was edited to include a C# tag.\n<|/ c |>\n<| c |>\nI believe\
    \ this answer was posted before the question was edited to include a C# tag.\n\
    <|/ c |>\n<| c |>\nI believe this answer was posted before the question was edited\
    \ to include a C# tag.\n<|/ c |>\n<| a tags=arrays,c#,sorting |>\n<code>\nusing\
    \ System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;",
  "{\n    long[] result = new long[l.length];\n    long prev = 0;\n    long cur =\
    \ 0;\n    for (int i = 0; i < l.length; i++) \n    {\n        cur = l[i];\n  \
    \      if (cur != prev) \n        {\n            result[i - 1] = cur;\n      \
    \      prev = cur;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;", "{\n    long[] result = new long[l.length];\n    long\
    \ last = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] !=\
    \ last)\n        {\n            result[result.length - 1] = l[i];\n          \
    \  last = l[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,linq,.net,c#-4.0\
    \ |>\n<| c |>\nI like your solution, but I believe it can be optimized a bit.\
    \ `var result = l.OrderBy(i => i).Distinct().ToArray();` should be faster.\n<|/\
    \ c |>\n<| c |>\n: I believe that `Distinct` will sort all elements and then remove\
    \ duplicates. So this solution is O(nlogn) instead of O(n).\n<|/ c |>\n<| c |>\n\
    : Yes, you are right. `Distinct` will sort all elements and then remove duplicates.\
    \ So this solution is O(nlogn) instead of O(n).\n<|/ c |>\n<| c |>\n: Yes, you\
    \ are right. `Distinct` will sort all elements and then remove duplicates. So\
    \ this solution is O(nlogn) instead of O(n).\n<|/ c |>\n<| c |>\n: Yes, you are\
    \ right. `Distinct` will sort all elements and then remove duplicates. So this\
    \ solution is O(nlogn) instead of O(n).\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    var result = l.OrderBy(i => i).Distinct().ToArray();\n</code>\n<|/ a tags=c#,linq,.net,c#-4.0\
    \ |>\n<| c |>\nThis doesn't work if your list contains duplicates.\n<|/ c |>\n\
    <| c |>\n: It does work if your list contains duplicates. Try it yourself.\n<|/\
    \ c |>\n<| c |>\n: It does work if your list contains duplicates. Try it yourself.\n\
    <|/ c |>\n<| c |>\n: It does work if your list contains duplicates. Try it yourself.\n\
    <|/ c |>\n<| c |>\n: It does work if your list contains duplicates. Try it yourself.\n\
    <|/ c |>\n<| a tags=c#,linq,.net,c#-4.0 |>\n<code>\nvar result = l.OrderBy(i =>\
    \ i).Distinct().ToArray();\n</code>\n<|/ a dscore=4 |>\n<|", "{\n\tlong[] u =\
    \ new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tfor(int\
    \ j = i+1; j < l.length; j++) \n\t\t{\n\t\t\tif(l[i] < l[j]) \n\t\t\t{\n\t\t\t\
    \tlong tmp = l[i];\n\t\t\t\tl[i] = l[j];\n\t\t\t\tl[j] = tmp;\n\t\t\t}\n\t\t}\n\
    \t}\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tu[l.length - 1 - i] = l[i];\n\
    \t}\n\treturn u;\n}", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++)\n    {\n        long x = l[i];\n        int j = 0;\n\
    \        for(; j < i; j++)\n        {\n            if(l[j] == x)\n           \
    \     break;\n        }\n        result[i] = l[j];\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int start, int end) \n{\n    long[] result = new long[end\
    \ - start];\n    for(int i = start; i < end; i++)\n    {\n        long x = l[i];\n\
    \        int j = 0;\n        for(; j < i; j++)\n        {\n            if(l[j]\
    \ == x)\n                break;\n        }\n        result[i - start] = l[j];\n\
    \    }\n    Arrays.sort(result);\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step) \n{\n    long[] result = new long[end - start];\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        long x = l[i];\n        int j\
    \ = 0;\n        for(; j < i; j++)\n        {\n            if(l[j] == x)\n    \
    \            break;\n        }\n        result[i - start] = l[j];\n    }\n   \
    \ Arrays.sort(result);\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end,\
    \ int step, long gap) \n{\n    long[] result = new long[end - start];\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        long x = l[i];\n        int j\
    \ = 0;\n        for(; j < i; j++)\n        {\n            if(l[j] == x)\n    \
    \            break;\n        }\n        result[i - start] = l[j];\n    }\n   \
    \ Arrays.sort(result);\n    for(int i = start; i < end; i += step)\n    {\n  \
    \      if(result[i] == gap)\n            result[i] = 0;\n    }\n    return result;\n\
    }\n/*", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tresult[i] = l[i];\n\tArrays.sort(result);\n\treturn result;\n}", "{\n\
    \    long[] result = new long[l.length];\n    Arrays.sort(l);\n    for(int i =\
    \ 0; i < l.length; i++)\n        result[l.length - 1 - i] = l[i];\n    return\
    \ result;\n}", "{\n    long[] result = new long[l.length];\n    long last = 0;\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n    \
    \    {\n            result[i - 1] = l[i];\n            last = l[i];\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long last = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[i - 1] = l[i];\n            last = l[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,algorithm,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])` returns `[123L, 0L, 2L, 3L, 5L, 9L]`\n<|/ c |>\n<| c |>\nIt works\
    \ on my machine. Are you sure you copied it correctly?\n<|/ c |>\n<| c |>\nI copied\
    \ it exactly as you wrote it. I also tried it on ideone.com. I'm running it on\
    \ Mono 2.10.8.\n<|/ c |>\n<| c |>\nI tested it on Mono 2.10.8 and it works. I\
    \ guess you didn't copy it correctly. Try copying it again and make sure you don't\
    \ have any typos.\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I also\
    \ tried it on ideone.com. I'm running it on Mono 2.10.8. I'm going to try it on\
    \ Mono 2.10.8 and see if it works.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic\
    \ static int[] unique(int[] arr) {\n    int[] result = new int[arr.length];\n\
    \    int last = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i]\
    \ != last) {\n            result[i - 1] = arr[i];\n            last = arr[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,algorithm,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])` returns `[123L, 0L, 2L, 3L, 5L, 9L]`\n<|/ c |>\n<| c |>\nThis code\
    \ works fine for me on Mono 2.10.8. Are you sure you copied it correctly?\n<|/\
    \ c |>\n<| c |>\nI copied it exactly as you wrote it. I also tried it on ideone.com.\
    \ I'm running it on Mono 2.10.8. I'm going to try it on Mono 2.10.8 and see if\
    \ it works.\n<|/ c |>\n<| c |>\nI ", "{\n    long[] u = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        u[l.indexOf(l[i])] = l[i];\n \
    \   return u;\n}", "{\n    long[] res = new long[l.length];\n    for(int i = 0;\
    \ i < l.length; i++)\n    {\n        long x = l[i];\n        for(int j = i; j\
    \ < l.length; j++)\n        {\n            if(l[j] == x)\n            {\n    \
    \            res[j-1] = x;\n                break;\n            }\n        }\n\
    \    }\n    return res;\n}", "{\n\tlong[] u = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tu[i] = l[i];\n\t}\n\tArrays.sort(u);\n\t\
    return u;\n}", "{\n    long[] result = new long[l.length];\n    long[] seen =\
    \ new long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n    {\n\
    \        long x = l[i];\n        if (seen[x] == 0)\n        {\n            seen[x]\
    \ = 1;\n            result[i] = x;\n        }\n    }\n    return result;\n}",
  "{\n    long[] res = new long[l.length];\n    long last = 0;\n    long cur = 0;\n\
    \    for (int i = 0; i < l.length; i++)\n    {\n        if (l[i] != last)\n  \
    \      {\n            res[cur++] = l[i];\n            last = l[i];\n        }\n\
    \    }\n    Arrays.sort(res);\n    return res;\n}", "{\n    long[] res = new long[l.length];\n\
    \    long last = 0;\n    long cur = 0;\n    for (int i = 0; i < l.length; i++)\
    \ \n    {\n        cur = l[i];\n        if (cur != last) \n        {\n       \
    \     res[i - 1] = cur;\n            last = cur;\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a tags=c#,list,arrays |>\n<| a tags=c#,list,arrays |>\n\
    <code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;", "{\n    long[] result = new\
    \ long[l.length];\n    Arrays.sort(l);\n    for(int i = 0; i < l.length; i++)\n\
    \        result[i] = l[i];\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long cmp) \n{\n   \
    \ long[] result = new long[l.length];\n    Arrays.sort(l, cmp);\n    for(int i\
    \ = 0; i < l.length; i++)\n        result[i] = l[i];\n    return result;\n}\n\
    /*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int cmp) \n{\n    long[] result = new long[l.length];\n    Arrays.sort(l,\
    \ cmp);\n    for(int i = 0; i < l.length; i++)\n        result[i] = l[i];\n  \
    \  return result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, long cmp, int cmp2) \n{\n    long[] result = new long[l.length];\n\
    \    Arrays.sort(l, cmp, cmp2);\n    for(int i = 0; i < l.length; i++)\n     \
    \   result[i] = l[i];\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int cmp, int cmp2)\
    \ \n{\n    long[] result = new long[l.length];\n    Arrays.sort(l, cmp, cmp2);\n\
    \    for(int i = 0; i < l.length; i++)\n        result[i] = l[i];\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, long cmp, int cmp2, int cmp3) \n{\n    long[] result =\
    \ new long[l.length];\n    Arrays.sort(", "{\n    long[] u = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        u[l.indexOf(l[i])] = l[i];\n \
    \   return u;\n}", "{\n    long[] result = new long[l.length];\n    long last\
    \ = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n\
    \        {\n            result[result.length - 1] = l[i];\n            last =\
    \ l[i];\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n        long\
    \ current = l[i];\n        for(int j = i; j < l.length; j++)\n        {\n    \
    \        if(l[j] == current)\n            {\n                current = l[j];\n\
    \            }\n        }\n        result[i] = current;\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code doesn't\
    \ work. `Arrays.sort` sorts array in place, so `result` array will be sorted after\
    \ `Arrays.sort(result);` call.\n<|/ c |>\n<| c |>\nYes, you are right. I've edited\
    \ my answer. Thanks.\n<|/ c |>\n<| a tags=arrays,java |>\n<code>\npublic static\
    \ void main(String[] args) {\n    int[] arr = new int[]{5,3,5,2,3,3,9,0,123};\n\
    \    Arrays.sort(arr);\n    System.out.println(Arrays.toString(arr));\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>\nimport java.util.Arrays;", "{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n      \
    \  result[i] = l[i];\n    Arrays.sort(result);\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if you have duplicate elements in\
    \ the list. For example, `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns\
    \ `[123L, 0L, 2L, 3L, 5L, 9L]` instead of `[123L, 0L, 2L, 3L, 5L, 9L, 123L]`.\n\
    <|/ c |>\n<| c |>\nYes, it does work. Try it yourself and see for yourself. It\
    \ does return `[123L, 0L, 2L, 3L, 5L, 9L, 123L]` as requested.\n<|/ c |>\n<| c\
    \ |>\nI tested it and it doesn't work. Try it yourself and see for yourself. It\
    \ returns `[123L, 0L, 2L, 3L, 5L, 9L]` instead of `[123L, 0L, 2L, 3L, 5L, 9L,\
    \ 123L]`.\n<|/ c |>\n<| c |>\nI tested it and it does work. Try it yourself and\
    \ see for yourself. It returns `[123L, 0L, 2L, 3L, 5L, 9L, 123L]` as requested.\n\
    <|/ c |>\n<| c |>\nI tested it and it does work. Try it yourself and see for yourself.\
    \ It returns `[123L, 0L, 2L, 3L, 5L, 9L, 123L]` as requested.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\npublic static <T> List<T> uniqueSorted(List<T> list) {\n\
    \    Set<T> set = new HashSet<>();\n    List<T> result = new ArrayList<>();\n\
    \    for (T t : list) {\n        if (!set.add(t)) {\n            result.add(t);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,list\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| c |>\nThis doesn't work if you have duplicate elements\
    \ in the list. For example, `uniqueSorted([1L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L])`\
    \ returns `[1L, 2L, 3L, 3", "{\n\tlong[] result = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t\tresult[i] = l[i];\n\tArrays.sort(result);\n\t\
    return result;\n}", "{\n    long[] result = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; i++)\n        result[i] = l[i];\n    Arrays.sort(result);\n\
    \    return result;\n}", "{\n    long[] result = new long[l.length];\n    long[]\
    \ seen = new long[l.length];\n    int j = 0;\n    for (int i = 0; i < l.length;\
    \ i++) \n    {\n        if (seen[l[i]] == 0) \n        {\n            result[j]\
    \ = l[i];\n            seen[l[i]] = 1;\n            j++;\n        }\n    }\n \
    \   return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,sorting\
    \ |>\n<code>\npublic static List<int> Sort(List<int> list)\n{\n    List<int> result\
    \ = new List<int>();\n    List<int> temp = new List<int>();\n    bool found =\
    \ false;\n    foreach (int i in list)\n    {\n        if (found == false)\n  \
    \      {\n            if (i == 0)\n            {\n                found = true;\n\
    \            }\n            else\n            {\n                temp.Add(i);\n\
    \            }\n        }\n        else\n        {\n            if (i == 0)\n\
    \            {\n                found = true;\n            }\n            else\n\
    \            {\n                if (temp[0] != i)\n                {\n       \
    \             result.Add(temp[0]);\n                    temp.Clear();\n      \
    \              temp.Add(i);\n                }\n                else\n       \
    \         {\n                    temp.Add(i);\n                }\n           \
    \ }\n        }\n    }\n    if (temp.Count > 0)\n    {\n        result.Add(temp[0]);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\npublic static List<int> Sort(List<int> list)\n{\n    List<int> result\
    \ = new List<int>();\n    List<int> temp = new List<int>();\n    bool found =\
    \ false;\n    foreach (int i in list)\n    {\n        if (found == false)\n  \
    \      {\n            if (i == 0)\n            {\n                found = true;\n\
    \            }\n            else\n            {\n                temp.Add(i);\n\
    \            }\n        }\n        else\n        {\n            if (i == 0)\n\
    \            {\n                found = true;\n            }\n            else\n\
    \            {\n                if (temp[0] != i)\n                {\n       \
    \             result.Add(temp[0]);\n                    temp.Clear();\n      \
    \              temp.Add(i);\n                }\n                else\n       \
    \         {\n                    temp.Add(i);\n                }\n           \
    \ }\n        }\n    }\n    if (temp.Count > 0)\n    {\n        result.Add(temp[0]);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<|\
    \ a |>\n<code>\npublic static List<int> Sort(List<int> list)\n{\n    List<int>\
    \ result = new List<int>();\n    List<int> temp = new List<int>();\n    bool found\
    \ = false;\n    foreach (int i in list)\n    {\n        if (found == false)\n\
    \        {", "{\n    long[] res = new long[l.length];\n    long last = l[0];\n\
    \    int j = 0;\n    for (int i = 1; i < l.length; i++) \n    {\n        if (l[i]\
    \ != last) \n        {\n            res[j++] = l[i];\n            last = l[i];\n\
    \        }\n    }\n    res[j++] = last;\n    return res;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm\
    \ |>\n<| c |>\nThis is not an answer to the question. He asked for C#, not Java.\n\
    <|/ c |>\n<| c |>\nI didn't see that he was looking for C#. My bad.\n<|/ c |>\n\
    <| c |>\nI added a C# implementation to the answer\n<|/ c |>\n<| a |>\n<code>\n\
    var unique = new HashSet<long>(list);\n</code>\n<|/ a tags=c#,arrays,algorithm\
    \ dscore=2 |>\n<| c |>\nThis is not an answer to the question. He asked for C#,\
    \ not Java.\n<|/ c |>\n<| c |>\nI added a C# implementation to the answer\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>\nvar unique = new HashSet<long>(list);\n</code>\n\
    <|/ a tags=c#,arrays,algorithm |>\n<| c |>\nThis is not an answer to the question.\
    \ He asked for C#, not Java.\n<|/ c |>\n<| a tags=c#,arrays,algorithm |>\n<code>\n\
    var unique = new HashSet<long>(list);\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,arrays,algorithm\
    \ |>\n<code>\nvar unique = new HashSet<long>(list);\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\n<code>\nvar unique = new HashSet<long>(list);\n</code>\n<|/\
    \ a tags=c#,arrays,algorithm |>\n<| a tags=c#,arrays,algorithm |>\n<code>\nvar\
    \ unique = new HashSet<long>(list);\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,arrays,algorithm\
    \ |>\n<code>\nvar unique = new HashSet<long>(list);\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=c#,arrays,algorithm |>\n<code>\nvar unique = new HashSet<long>(list);\n\
    </code>\n<|/ a dscore=1 |>\n<| a tag", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        long x = l[i];\n      \
    \  int j = 0;\n        for(; j < i; ++j)\n        {\n            if(l[j] == x)\n\
    \                break;\n        }\n        result[i] = l[j];\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int start, int end) \n{\n    long[] result = new long[end\
    \ - start];\n    for(int i = start; i < end; ++i)\n    {\n        long x = l[i];\n\
    \        int j = 0;\n        for(; j < i; ++j)\n        {\n            if(l[j]\
    \ == x)\n                break;\n        }\n        result[i - start] = l[j];\n\
    \    }\n    Arrays.sort(result);\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step) \n{\n    long[] result = new long[end - start];\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        long x = l[i];\n        int j\
    \ = 0;\n        for(; j < i; ++j)\n        {\n            if(l[j] == x)\n    \
    \            break;\n        }\n        result[i - start] = l[j];\n    }\n   \
    \ Arrays.sort(result);\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end,\
    \ int step, long stepSize) \n{\n    long[] result = new long[end - start];\n \
    \   for(int i = start; i < end; i += step)\n    {\n        long x = l[i];\n  \
    \      int j = 0;\n        for(; j < i; ++j)\n        {\n            if(l[j] ==\
    \ x)\n                break;\n        }\n        result[i - start] = l[j];\n \
    \   }\n    Arrays.sort(result);\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, ", "{\n    long[] result\
    \ = new long[l.length];\n    long last = 0;\n    long lastIdx = -1;\n    for(int\
    \ i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n        {\n    \
    \        last = l[i];\n            lastIdx = i;\n        }\n    }\n    for(int\
    \ i = lastIdx; i >= 0; i--)\n    {\n        result[i] = l[i];\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}", "{\n    long[] res = new long[l.length];\n    Arrays.sort(l);\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        res[i] = l[i];\n    }\n\
    \    return res;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int start, int end) \n{\n    long[] res = new long[end\
    \ - start];\n    Arrays.sort(l, start, end);\n    for(int i = 0; i < end - start;\
    \ i++)\n    {\n        res[i] = l[i + start];\n    }\n    return res;\n}\n/*\n\
    Return sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end, int step) \n{\n    long[] res = new long[end - start];\n\
    \    Arrays.sort(l, start, end, step);\n    for(int i = 0; i < end - start; i++)\n\
    \    {\n        res[i] = l[i + start];\n    }\n    return res;\n}\n/*\nReturn\
    \ sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,\
    \ int start, int end, int step, long cmp) \n{\n    long[] res = new long[end -\
    \ start];\n    Arrays.sort(l, start, end, step, cmp);\n    for(int i = 0; i <\
    \ end - start; i++)\n    {\n        res[i] = l[i + start];\n    }\n    return\
    \ res;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, int start, int end, int step, long cmp, int fromIndex) \n{\n\
    \    long[] res = new long[end - start];\n    Arrays.sort(l, start, end, step,\
    \ cmp, fromIndex);\n    for(int i = 0; i < end - start; i++)\n    {\n        res[i]\
    \ = l[i + start];\n    }\n    return res;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, ", "{\n    long[] result\
    \ = new long[l.length];\n    int j = 0;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        while (j < result.length && l[i] == result[j])\n            j++;\n\
    \        result[j++] = l[i];\n    }\n    return result;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] =\
    \ l[i];\n\tArrays.sort(result);\n\treturn result;\n}", "{\n    long[] u = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n        u[i]\
    \ = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end) \n{\n    long[] u = new long[end - start];\n    for(int i = start;\
    \ i < end; i++) \n    {\n        u[i - start] = l[i];\n    }\n    Arrays.sort(u);\n\
    \    return u;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int start, int end, int step) \n{\n    long[] u = new\
    \ long[end - start];\n    for(int i = start; i < end; i += step) \n    {\n   \
    \     u[i - start] = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n}\n/*\n\
    Return sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end, int step, long cmp) \n{\n    long[] u = new long[end\
    \ - start];\n    for(int i = start; i < end; i += step) \n    {\n        u[i -\
    \ start] = l[i];\n    }\n    Arrays.sort(u, cmp);\n    return u;\n}\n/*\nReturn\
    \ sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,\
    \ int start, int end, int step, long cmp, int step2) \n{\n    long[] u = new long[end\
    \ - start];\n    for(int i = start; i < end; i += step) \n    {\n        u[i -\
    \ start] = l[i];\n    }\n    Arrays.sort(u, cmp);\n    return u;\n}\n/*\nReturn\
    \ sorted unique elements in a list\n    >>> unique([5L, ", "{\n    long[] result\
    \ = new long[l.length];\n    long[] seen = new long[l.length];\n    \n    for\
    \ (int i = 0; i < l.length; i++)\n    {\n        if (!seen[l[i]])\n        {\n\
    \            result[i] = l[i];\n            seen[l[i]] = 1;\n        }\n    }\n\
    \    \n    return result;\n}", "{\n    long[] u = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++)\n    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n\
    \    return u;\n}\n</code>\n<|/ a tags=c#,arrays,sorting,unique |>\n<| a tags=c#,arrays,sorting,unique\
    \ |>\n<code>\npublic static int[] unique(int[] array)\n{\n    HashSet<int> set\
    \ = new HashSet<int>();\n    foreach(int i in array)\n    {\n        if(!set.Add(i))\n\
    \        {\n            array.Remove(i);\n        }\n    }\n    return array.ToArray();\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does not provide an answer to the\
    \ question. To critique or request clarification from an author, leave a comment\
    \ below their post.\n<|/ c |>\n<| c |>\nThis answer does provide an answer to\
    \ the question. HashSet is a data structure that stores unique elements. If the\
    \ array contains duplicates, it removes them and returns the unique elements.\
    \ I tested it and it works.\n<|/ c |>\n<| c |>\nThis answer does not provide an\
    \ answer to the question. While it may answer the question, please be sure to\
    \ explain how it works and why it is the best solution to the problem, so others\
    \ can learn from your answer\n<|/ c |>\n<| a tags=c#,arrays,sorting,unique |>\n\
    <code>\npublic static int[] unique(int[] array)\n{\n    HashSet<int> set = new\
    \ HashSet<int>();\n    foreach(int i in array)\n    {\n        if(!set.Add(i))\n\
    \        {\n            array.Remove(i);\n        }\n    }\n    return array.ToArray();\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,arrays,sorting,unique |>\n<code>\n\
    public static int[] unique(int[] array)\n{\n    HashSet<int> set = new HashSet<int>();\n\
    \    foreach(int i in array)\n    {\n        if(!set.Add(i))\n        {\n    \
    \        array.Remove(i);\n        }\n    }\n    return array.ToArray();\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static int[] unique(int[]\
    \ array)\n{\n    HashSet<int> set = new HashSet<int>();\n    foreach(int i in\
    \ array)\n    {\n        if(!set.Add(i))\n        {\n            array.Remove(i);\n\
    \        }\n    }\n    return array.ToArray();\n}\n</code>\n<|/ a ", "{\n    long[]\
    \ result = new long[l.length];\n    \n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        long current = l[i];\n        for(int j = i; j < l.length; j++)\n\
    \        {\n            if(l[j] == current)\n            {\n                result[j]\
    \ = current;\n                break;\n            }\n        }\n    }\n    \n\
    \    return result;\n}", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        long x = l[i];\n        for(int j\
    \ = i; j < l.length; ++j)\n        {\n            if(l[j] == x)\n            {\n\
    \                result[j] = x;\n                break;\n            }\n     \
    \   }\n    }\n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    Arrays.sort(l);\n    int i = 0;\n    for(; i < l.length; ++i)\n    {\n  \
    \      if(l[i] == l[i - 1])\n            continue;\n        result[i - 1] = l[i];\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n        result[i] = l[i];\n    Arrays.sort(result);\n\
    \    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not an answer\
    \ to the question. An answer should contain an explanation of what was wrong in\
    \ the original code and how it solves the problem.\n<|/ c |>\n<| c |>\nI added\
    \ some explanation to the answer\n<|/ c |>\n<| c |>\nThe explanation is good,\
    \ but you still haven't explained why you think this works.\n<|/ c |>\n<| c |>\n\
    I added some explanation to the answer\n<|/ c |>\n<| c |>\nThe explanation is\
    \ good, but you still haven't explained why you think this works.\n<|/ c |>\n\
    <| a tags=java,arrays,sorting |>\n<code>\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;",
  "{\n    long[] u = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \        u[i] = l[i];\n    Arrays.sort(u);\n    return u;\n}", "{\n    long[]\
    \ u = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n   \
    \     u[i] = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;", "{\n    long[] res = new long[l.length];\n    long curr\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] != curr)\n\
    \        {\n            res[i - 1] = curr;\n            curr = l[i];\n       \
    \ }\n    }\n    res[l.length - 1] = curr;\n    return res;\n}", "{\n    long[]\
    \ result = new long[l.length];\n    Arrays.sort(l);\n    int i = 0;\n    for(long\
    \ j : l)\n    {\n        if(j != l[i])\n            result[i++] = j;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=java,arrays,sorting\
    \ |>\n<code>\nimport java.util.Arrays;", "{\n    long[] res = new long[l.length];\n\
    \    long[] seen = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        long x = l[i];\n        if(seen[x] == 0)\n        {\n        \
    \    seen[x] = 1;\n            res[i] = x;\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a tags=arrays,c#,sorting |>\n<| c |>\nThis is not the fastest\
    \ solution. There are better ways to do this.\n<|/ c |>\n<| c |>\nThis is not\
    \ the fastest solution. There are better ways to do this.\n<|/ c |>\n<| c |>\n\
    : I agree, but I wanted to show a solution that is easy to understand and implement.\n\
    <|/ c |>\n<| c |>\n: I agree, but I wanted to show a solution that is easy to\
    \ understand and implement.\n<|/ c |>\n<| c |>\n: I agree, but I wanted to show\
    \ a solution that is easy to understand and implement.\n<|/ c |>\n<| a tags=arrays,c#,sorting\
    \ |>\n<code>", "{\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n\
    \    int i = 0;\n    for(; i < l.length; ++i)\n        result[i] = l[i];\n   \
    \ for(; i < result.length; ++i)\n        result[i] = 0L;\n    return result;\n\
    }", "{\n\tlong[] res = new long[l.length];\n\tlong last = 0;\n\tfor (int i = 0;\
    \ i < l.length; i++)\n\t{\n\t\tif (l[i] != last)\n\t\t{\n\t\t\tres[l.length-1-l.indexof(last)]\
    \ = l[i];\n\t\t\tlast = l[i];\n\t\t}\n\t}\n\treturn res;\n}", "{\n\tlong[] result\
    \ = new long[l.length];\n\tArrays.sort(l);\n\tfor (int i = 0; i < l.length; i++)\n\
    \t\tresult[i] = l[i];\n\treturn result;\n}", "{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        long x = l[i];\n      \
    \  for(int j = i; j < l.length; j++)\n        {\n            if(l[j] == x)\n \
    \           {\n                res[j-1] = x;\n                break;\n       \
    \     }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis algorithm is O(n^2) in worst case and O(n) in best case. Though it\
    \ does have O(n) space complexity.\n<|/ c |>\n<| c |>\nYes, but it's also O(n)\
    \ in best case. O(n^2) is worst case.\n<|/ c |>\n<| c |>\nO(n^2) is worst case\
    \ and O(n) is best case. O(n^2) is worst case and O(n) is best case. O(n^2) is\
    \ worst case and O(n) is best case. O(n^2) is worst case and O(n) is best case.\
    \ O(n^2) is worst case and O(n) is best case. O(n^2) is worst case and O(n) is\
    \ best case. O(n^2) is worst case and O(n) is best case. O(n^2) is worst case\
    \ and O(n) is best case. O(n^2) is worst case and O(n) is best case. O(n^2) is\
    \ worst case and O(n) is best case. O(n^2) is worst case and O(n) is best case.\
    \ O(n^2) is worst case and O(n) is best case. O(n^2) is worst case and O(n) is\
    \ best case. O(n^2) is worst case and O(n) is best case. O(n^2) is worst case\
    \ and O(n) is best case. O(n^2) is worst case and O(n) is best case. O(n^2) is\
    \ worst case and O(n) is best case. O(n^2) is worst case and O(n) is best case.\
    \ O(n^2) is worst case and O(n) is best case. O(n^2) is worst case and O(n) is\
    \ best case. O(n^2) is worst case and O(n) is best case. O(n^2) is worst case\
    \ and O(n) is best case. O(n^2) is worst case and O(n) is best case. O(n^2) is\
    \ worst case and O(n) is ", "{\n    long[] result = new long[l.length];\n    long[]\
    \ seen = new long[l.length];\n    \n    for (int i = 0; i < l.length; i++)\n \
    \   {\n        if (!seen[l[i]])\n        {\n            result[i] = l[i];\n  \
    \          seen[l[i]] = true;\n        }\n    }\n    \n    return result;\n}",
  "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \        result[l.indexOf(l[i])] = l[i];\n    return result;\n}", "{\n\tlong[]\
    \ u = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tu[i] = l[i];\n\
    \tArrays.sort(u);\n\treturn u;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long[] seen = new long[l.length];\n    \n    for (int i = 0; i < l.length;\
    \ ++i)\n    {\n        long x = l[i];\n        \n        if (seen[x] == 0)\n \
    \       {\n            seen[x] = 1;\n            result[i] = x;\n        }\n \
    \   }\n    \n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long last = 0;\n    long lastCount = 0;\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last)\n        {\n            last = l[i];\n\
    \            lastCount = 1;\n        }\n        else\n        {\n            lastCount++;\n\
    \        }\n        result[i] = last;\n    }\n    for(int i = l.length - 1; i\
    \ >= 0; i--)\n    {\n        if(l[i] != last)\n        {\n            result[l.length\
    \ - 1 - i] = last;\n            lastCount = 1;\n        }\n        else\n    \
    \    {\n            lastCount++;\n        }\n        if(lastCount > 1)\n     \
    \   {\n            for(int j = i; j >= 0; j--)\n            {\n              \
    \  if(l[j] != last)\n                {\n                    result[j] = last;\n\
    \                    lastCount = 1;\n                    break;\n            \
    \    }\n                else\n                {\n                    lastCount++;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n/*\n\
    Return sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end) \n{\n    long[] result = new long[end - start];\n   \
    \ long last = 0;\n    long lastCount = 0;\n    for(int i = start; i < end; i++)\n\
    \    {\n        if(l[i] != last)\n        {\n            last = l[i];\n      \
    \      lastCount = 1;\n        }\n        else\n        {\n            lastCount++;\n\
    \        }\n        result[i - start] = last;\n    }\n    for(int i = end - 1;\
    \ i >= start; i--)\n    {\n        if(l[i] != last)\n        {\n            result[i\
    \ - start] = last;\n            lastCount = 1;\n        }\n        else\n    \
    \    {\n            lastCount++;\n        }\n        if(lastCount > 1)\n     \
    \   {\n            for(int j = i; j >= start; j--)\n            {\n          \
    \      if(l[j] != last)\n                {\n                    result[j] = last;\n\
    \                    lastCount = 1;\n                    break;\n            \
    \    }\n                else\n                {\n                    lastCount++;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n/*\n\
    Return sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end, int step) \n{\n    long[] result = new long[", "{\n \
    \   long[] result = new long[l.length];\n    long last = 0;\n    for(int i = 0;\
    \ i < l.length; i++)\n    {\n        if(l[i] != last)\n        {\n           \
    \ result[i - 1] = l[i];\n            last = l[i];\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,arrays,sorting |>\n<code>\n\
    public static int[] SortArray(int[] array)\n{\n    Array.Sort(array);\n    int[]\
    \ result = new int[array.Length];\n    int j = 0;\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[j] = array[i];\n        j++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static\
    \ int[] SortArray(int[] array)\n{\n    Array.Sort(array);\n    int[] result =\
    \ new int[array.Length];\n    int j = 0;\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[j] = array[i];\n        j++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c#,arrays,sorting |>\n<| a dscore=1 |>\n<code>\n\
    public static int[] SortArray(int[] array)\n{\n    Array.Sort(array);\n    int[]\
    \ result = new int[array.Length];\n    int j = 0;\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[j] = array[i];\n        j++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c#,arrays,sorting |>\n<| a |>\n<code>\npublic\
    \ static int[] SortArray(int[] array)\n{\n    Array.Sort(array);\n    int[] result\
    \ = new int[array.Length];\n    int j = 0;\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[j] = array[i];\n        j++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 tags=c#,arrays,sorting |>\n<| a tags=c#,arrays,sorting\
    \ |>\n<code>\npublic static int[] SortArray(int[] array)\n{\n    Array.Sort(array);\n\
    \    int[] result = new int[array.Length];\n    int j = 0;\n    for (int i = 0;\
    \ i < array.Length; i++)\n    {\n        result[j] = array[i];\n        j++;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\npublic static int[] SortArray(int[] array)\n{\n    Array.Sort(array);\n\
    \    int[] result = new int[array.Length];\n    int j = 0;\n    for (int i = 0;\
    \ i < array.Length; i++)\n    {\n", "{\n    long[] result = new long[l.length];\n\
    \    long last = 0;\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[i - 1] = l[i];\n            last = l[i];\n\
    \        }\n    }\n    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tArrays.sort(l);\n\tint j = 0;\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\
    \tif (i == 0 || l[j] != l[i])\n\t\t{\n\t\t\tresult[j] = l[i];\n\t\t\tj++;\n\t\t\
    }\n\t}\n\treturn result;\n}", "{\n    long[] result = new long[l.length];\n  \
    \  long last = 0;\n    int i = 0;\n    for (; i < l.length; ++i)\n    {\n    \
    \    if (l[i] != last)\n        {\n            result[i - 1] = l[i];\n       \
    \     last = l[i];\n        }\n    }\n    result[result.length - 1] = last;\n\
    \    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\t\n\tfor\
    \ (int i = 0; i < l.length; i++)\n\t{\n\t\tfor (int j = i + 1; j < l.length; j++)\n\
    \t\t{\n\t\t\tif (l[i] == l[j])\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (j == l.length)\n\
    \t\t\tresult[i] = l[i];\n\t}\n\t\n\treturn result;\n}", "{\n\tlong[] result =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] = l[i];\n\
    \tArrays.sort(result);\n\treturn result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        result[i] = l[i];\n    Arrays.sort(result);\n\
    \    return result;\n}", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        long x = l[i];\n        for(int j\
    \ = i; j < l.length; j++) \n        {\n            if(l[j] == x) \n          \
    \  {\n                result[j] = x;\n                break;\n            }\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,sorting\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static int[] SortArray(int[] array)\n{\n\
    \    int[] result = new int[array.Length];\n    int j = 0;\n    for (int i = 0;\
    \ i < array.Length; i++)\n    {\n        if (array[i] != array[j])\n        {\n\
    \            result[j] = array[i];\n            j++;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,c#,sorting |>\n<| a tags=arrays,c#,sorting\
    \ |>\n<code>\npublic static int[] SortArray(int[] array)\n{\n    int[] result\
    \ = new int[array.Length];\n    int j = 0;\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        if (array[i] != array[j])\n        {\n            result[j]\
    \ = array[i];\n            j++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer.\n<|/ c\
    \ |>\n<| a tags=arrays,c#,sorting |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;", "{\n    long[] u = new long[l.length];\n\
    \    long u_index = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n       \
    \ if(l[i] != l[u_index])\n        {\n            u[u_index] = l[i];\n        \
    \    u_index++;\n        }\n    }\n    return u;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] u) \n\
    {\n    long[] u = new long[l.length];\n    long u_index = 0;\n    for(int i =\
    \ 0; i < l.length; i++)\n    {\n        if(l[i] != l[u_index])\n        {\n  \
    \          u[u_index] = l[i];\n            u_index++;\n        }\n    }\n    return\
    \ u;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, long[] u, long[] v) \n{\n    long[] u = new long[l.length];\n\
    \    long u_index = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n       \
    \ if(l[i] != l[u_index])\n        {\n            u[u_index] = l[i];\n        \
    \    u_index++;\n        }\n    }\n    return u;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] u, long[]\
    \ v, long[] w) \n{\n    long[] u = new long[l.length];\n    long u_index = 0;\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != l[u_index])\n\
    \        {\n            u[u_index] = l[i];\n            u_index++;\n        }\n\
    \    }\n    return u;\n}\n/*\nReturn sorted unique elements in a list\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l, long[] u, long[] v, long[] w, long[] x) ",
  "{\n    long[] u = new long[l.length];\n    int j = 0;\n    for (int i = 0; i <\
    \ l.length; i++) \n    {\n        if (u[j] == l[i]) \n        {\n            j++;\n\
    \        } \n        else \n        {\n            u[j] = l[i];\n            j++;\n\
    \        }\n    }\n    return u;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end) \n{\n    long[]\
    \ u = new long[end - start];\n    int j = 0;\n    for (int i = start; i < end;\
    \ i++) \n    {\n        if (u[j] == l[i]) \n        {\n            j++;\n    \
    \    } \n        else \n        {\n            u[j] = l[i];\n            j++;\n\
    \        }\n    }\n    return u;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end, int step) \n\
    {\n    long[] u = new long[end - start];\n    int j = 0;\n    for (int i = start;\
    \ i < end; i += step) \n    {\n        if (u[j] == l[i]) \n        {\n       \
    \     j++;\n        } \n        else \n        {\n            u[j] = l[i];\n \
    \           j++;\n        }\n    }\n    return u;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step, long stepSize) \n{\n    long[] u = new long[end - start];\n\
    \    int j = 0;\n    for (int i = start; i < end; i += step) \n    {\n       \
    \ if (u[j] == l[i]) \n        {\n            j++;\n        } \n        else \n\
    \        {\n            u[j] = l[i];\n            j++;\n        }\n    }\n   \
    \ return u;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] ", "{\n    long[] result = new long[l.length];\n    \n    for(int i = 0;\
    \ i < l.length; i++) \n    {\n        long current = l[i];\n        \n       \
    \ for(int j = 0; j < i; j++) \n        {\n            if(l[j] == current) \n \
    \           {\n                long tmp = l[j];\n                l[j] = l[i];\n\
    \                l[i] = tmp;\n            }\n        }\n        \n        result[i]\
    \ = current;\n    }\n    \n    return result;\n}", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] = l[i];\n\tArrays.sort(result);\n\
    \treturn result;\n}", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++)\n        result[i] = l[i];\n    Arrays.sort(result);\n\
    \    return result;\n}", "{\n    long[] u = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; i++) \n    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n\
    \    return u;\n}", "{\n    long[] res = new long[l.length];\n    for(int i =\
    \ 0; i < l.length; ++i)\n    {\n        long val = l[i];\n        for(int j =\
    \ i; j < l.length; ++j)\n        {\n            if(l[j] == val)\n            {\n\
    \                res[j - i] = val;\n                break;\n            }\n  \
    \      }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    import java.util.*;\npublic class Unique\n{\n    public static void main(String\
    \ args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"\
    Enter the number\");\n        int n = sc.nextInt();\n        Set<Integer> set\
    \ = new HashSet<Integer>();\n        for(int i=0;i<n;i++)\n        {\n       \
    \     int x = sc.nextInt();\n            set.add(x);\n        }\n        System.out.println(set);\n\
    \    }\n}\n</code>\n<|/ a tags=java,arrays |>\n<| c |>\nPlease add some explanation\
    \ to your answer such that others can learn from it\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nimport java.util.*;\npublic class Unique\n{\n    public static void main(String\
    \ args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"\
    Enter the number\");\n        int n = sc.nextInt();\n        Set<Integer> set\
    \ = new HashSet<Integer>();\n        for(int i=0;i<n;i++)\n        {\n       \
    \     int x = sc.nextInt();\n            set.add(x);\n        }\n        System.out.println(set);\n\
    \    }\n}\n</code>\n<|/ a tags=java,arrays |>\n<| c |>\nPlease add some explanation\
    \ to your answer such that others can learn from it\n<|/ c |>\n<| a tags=java,arrays\
    \ |>\n<code>\nimport java.util.*;\npublic class Unique\n{\n    public static void\
    \ main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n \
    \       System.out.println(\"Enter the number\");\n        int n = sc.nextInt();\n\
    \        Set<Integer> set = new HashSet<Integer>();\n        for(int i=0;i<n;i++)\n\
    \        {\n            int x = sc.nextInt();\n            set.add(x);\n     \
    \   }\n        System.out.println(set);\n    }\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nPlease add some explanation to your answer such that others can learn\
    \ from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\npublic class\
    \ Unique\n{\n    public static void main(String args[])\n    {\n        Scan",
  "{\n    long[] u = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static <T> List<T> uniqueList(List<T>\
    \ list) {\n    Set<T> set = new HashSet<>();\n    List<T> result = new ArrayList<>();\n\
    \    for (T t : list) {\n        if (!set.add(t)) {\n            result.add(t);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,sorting\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static <T> List<T> uniqueList(List<T> list)\
    \ {\n    Set<T> set = new HashSet<>();\n    List<T> result = new ArrayList<>();\n\
    \    for (T t : list) {\n        if (!set.add(t)) {\n            result.add(t);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,sorting\
    \ |>\n<| a tags=java,arrays,sorting |>\n<code>\npublic static <T> List<T> uniqueList(List<T>\
    \ list) {\n    Set<T> set = new HashSet<>();\n    List<T> result = new ArrayList<>();\n\
    \    for (T t : list) {\n        if (!set.add(t)) {\n            result.add(t);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Please add some explanation to your answer such that others can learn from it\n\
    <|/ c |>\n<| a tags=java,arrays,sorting |>\n<code>\npublic static <T> List<T>\
    \ uniqueList(List<T> list) {\n    Set<T> set = new HashSet<>();\n    List<T> result\
    \ = new ArrayList<>();\n    for (T t : list) {\n        if (!set.add(t)) {\n \
    \           result.add(t);\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that\
    \ others can learn from it\n<|/ c |>\n<| a tags=java,arrays,sorting |>\n<code>\n\
    public static <T> List<T> uniqueList(List<T> list) {\n    Set<T> set = new HashSet<>();\n\
    \    List<T> result = new ArrayList<>();\n    for (T t : list) {\n        if (!set.add(t))\
    \ {\n            result.add(t);\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that\
    \ others can learn from it\n<|/ c |>", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n        result[i] = l[i];\n    Arrays.sort(result);\n\
    \    return result;\n}", "{\n\tlong[] u = new long[l.length];\n\tfor (int i =\
    \ 0; i < l.length; i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n}",
  "{\n    long[] result = new long[l.length];\n    long prev = 0;\n    long cur =\
    \ 0;\n    for(int i = 0; i < l.length; i++) \n    {\n        cur = l[i];\n   \
    \     if(cur != prev)\n        {\n            result[i - 1] = cur;\n         \
    \   prev = cur;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n    long[] result = new long[l.length];\n\
    \    \n    for(int i = 0; i < l.length; i++)\n    {\n        long current = l[i];\n\
    \        for(int j = i + 1; j < l.length; j++)\n        {\n            if(l[j]\
    \ == current)\n            {\n                long temp = l[i];\n            \
    \    l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n  \
    \      result[i] = current;\n    }\n    \n    return result;\n}", "{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n  \
    \      long v = l[i];\n        for(int j = i; j < l.length; ++j)\n        {\n\
    \            if(l[j] == v)\n            {\n                res[j - i] = v;\n \
    \               break;\n            }\n        }\n    }\n    return res;\n}",
  "{\n    long[] result = new long[l.length];\n    long[] seen = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        seen[i] = 0;\n        result[i]\
    \ = l[i];\n    }\n    for(int i = 0; i < l.length; ++i)\n    {\n        for(int\
    \ j = i + 1; j < l.length; ++j)\n        {\n            if(l[i] == l[j])\n   \
    \         {\n                seen[j]++;\n            }\n        }\n    }\n   \
    \ for(int i = 0; i < l.length; ++i)\n    {\n        if(seen[i] > 1)\n        {\n\
    \            result[i] = l[i];\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[l.length];\n    int j = 0;\n    for (int i = 0;\
    \ i < l.length; i++) \n    {\n        if (j == result.length) \n        {\n  \
    \          long[] n = new long[result.length * 2];\n            System.arraycopy(result,\
    \ 0, n, 0, j);\n            System.arraycopy(result, 0, n, j, n);\n          \
    \  result = n;\n        }\n        if (l[i] != result[j]) \n        {\n      \
    \      result[j++] = l[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is not an answer to the question. Also, please\
    \ don't post code as screenshots. It's better to copy and paste it into the answer\
    \ box and format it properly.\n<|/ c |>\n<| c |>\nI agree with you, however I\
    \ didn't want to post the code as screenshots because I thought it would be too\
    \ much to post the whole code here. I thought it would be better to post the code\
    \ as screenshots because I thought it would be better to post the whole code here.\
    \ I thought it would be better to post the whole code here because I thought it\
    \ would be better to post the whole code here because I thought it would be better\
    \ to post the whole code here because I thought it would be better to post the\
    \ whole code here because I thought it would be better to post the whole code\
    \ here because I thought it would be better to post the whole code here because\
    \ I thought it would be better to post the whole code here because I thought it\
    \ would be better to post the whole code here because I thought it would be better\
    \ to post the whole code here because I thought it would be better to post the\
    \ whole code here because I thought it would be better to post the whole code\
    \ here because I thought it would be better to post the whole code here because\
    \ I thought it would be better to post the whole code here because I thought it\
    \ would be better to post the whole code here because I thought it would be better\
    \ to post the whole code here because I thought it would be better to post the\
    \ whole code here because I thought it would be better to post the whole code\
    \ here because I thought it would be better to post the whole code here because\
    \ I thought it would be better to post the whole code here because I thought it\
    \ would be better to post the whole code here because I thought it would be better\
    \ to post the whole code here because I thought it would be better to post the\
    \ whole code here because I thought it would be better to post the whole code\
    \ here because I thought it would be better to post the whole code here because\
    \ I thought it would be better to post the whole code here because I ", "{\n \
    \   long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \        result[i] = l[i];\n    Arrays.sort(result);\n    return result;\n}",
  "{\n    long[] result = new long[l.length];\n    long[] seen = new long[l.length];\n\
    \    long last;\n    int i;\n    \n    for (i = 0; i < l.length; i++) \n    {\n\
    \        last = l[i];\n        seen[i] = last;\n    }\n    \n    for (i = 0; i\
    \ < l.length; i++) \n    {\n        long current = l[i];\n        \n        while\
    \ (i < l.length && current == l[i]) \n        {\n            i++;\n        }\n\
    \        \n        if (i < l.length) \n        {\n            result[i - 1] =\
    \ current;\n            seen[i - 1] = 1;\n        }\n    }\n    \n    long[] res\
    \ = new long[result.length];\n    \n    for (i = 0; i < result.length; i++) \n\
    \    {\n        if (seen[i] == 1) \n        {\n            res[i] = result[i];\n\
    \        }\n    }\n    \n    return res;\n}", "{\n    long[] u = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        long x = l[i];\n      \
    \  for(int j = i; j < l.length; ++j)\n        {\n            if(l[j] == x)\n \
    \           {\n                u[j-1] = x;\n                break;\n         \
    \   }\n        }\n    }\n    return u;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long[] seen = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        long x = l[i];\n        if(seen[x] == 0)\n        {\n        \
    \    seen[x] = 1;\n            result[i] = x;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=algorithm,c#,sorting,arrays |>\n<| c |>\nThis is not the\
    \ fastest solution, since it requires O(n^2) memory and O(n^2) time.\n<|/ c |>\n\
    <| c |>\n: I agree, this is O(n^2) memory and O(n^2) time. However it is the fastest\
    \ solution for small arrays. I believe it is the fastest solution for large arrays,\
    \ since it requires O(n) memory and O(n) time.\n<|/ c |>\n<| c |>\n: I believe\
    \ it is the fastest solution for large arrays, since it requires O(n) memory and\
    \ O(n) time.\n<|/ c |>\n<| c |>\n: I believe it is the fastest solution for large\
    \ arrays, since it requires O(n) memory and O(n) time.\n<|/ c |>\n<| c |>\n: I\
    \ believe it is the fastest solution for large arrays, since it requires O(n)\
    \ memory and O(n) time.\n<|/ c |>\n<| a tags=algorithm,c#,sorting,arrays |>\n\
    <code>\npublic static int[] SortUnique(int[] array)\n{\n    int[] result = new\
    \ int[array.Length];\n    HashSet<int> set = new HashSet<int>();\n    for (int\
    \ i = 0; i < array.Length; i++)\n    {\n        if (set.Add(array[i]))\n     \
    \       result[i] = array[i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis solution is O(n^2) memory and O(n^2) time.\n<|/ c |>\n<| c\
    \ |>\n: I believe it is the fastest solution for large arrays, since it requires\
    \ O(n) memory and O(n) time.\n<|/ c |>\n<| c |>\n: I believe it is the fastest\
    \ solution for large arrays, since it requires O(n) memory and O(n) time.\n<|/\
    \ c |>\n<| c |>\n: I believe it is the fastest solution for large arrays, since\
    \ it requires O(n) memory and O(n) time.\n<|/ c |>\n<| c |>\n: ", "{\n    long[]\
    \ result = new long[l.length];\n    \n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        long current = l[i];\n        \n        for(int j = i; j < l.length;\
    \ j++)\n        {\n            if(l[j] == current)\n            {\n          \
    \      current = l[j];\n            }\n        }\n        \n        result[i]\
    \ = current;\n    }\n    \n    Arrays.sort(result);\n    \n    return result;\n\
    }", "{\n\tlong[] u = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n}", "{\n\tlong[] result = new\
    \ long[l.length];\n\t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tint j;\n\
    \t\tfor (j = 0; j < i; j++)\n\t\t\tif (l[j] == l[i])\n\t\t\t\tbreak;\n\t\t\n\t\
    \tif (j == i)\n\t\t\tresult[i] = l[i];\n\t}\n\t\n\treturn result;\n}", "{\n  \
    \  long[] u = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n   \
    \     u[i] = l[i];\n    Arrays.sort(u);\n    return u;\n}", "{\n\tlong[] u = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tint j = std.math.min(i+1,\
    \ l.length);\n\t\twhile(j > 0 && l[i] == l[j-1]) j--;\n\t\tu[i] = l[j];\n\t}\n\
    \treturn u;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++)\n\t{\n\t\tint j;\n\t\tfor (j = 0; j < i; j++)\n\t\t\tif (l[j]\
    \ == l[i])\n\t\t\t\tbreak;\n\t\tif (j == i)\n\t\t\tresult[i] = l[i];\n\t}\n\t\
    return result;\n}", "{\n    long[] result = new long[l.length];\n    for(int i\
    \ = 0; i < l.length; i++)\n    {\n        long current = l[i];\n        for(int\
    \ j = i; j < l.length; j++)\n        {\n            if(l[j] == current)\n    \
    \        {\n                result[j] = current;\n                break;\n   \
    \         }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end) \n{\n    long[] result = new long[end - start];\n    for(int i = start;\
    \ i < end; i++)\n    {\n        long current = l[i];\n        for(int j = i; j\
    \ < end; j++)\n        {\n            if(l[j] == current)\n            {\n   \
    \             result[j - start] = current;\n                break;\n         \
    \   }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end,\
    \ int step) \n{\n    long[] result = new long[end - start];\n    for(int i = start;\
    \ i < end; i += step)\n    {\n        long current = l[i];\n        for(int j\
    \ = i; j < end; j += step)\n        {\n            if(l[j] == current)\n     \
    \       {\n                result[j - start] = current;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step, long stepSize) \n{\n    long[] result = new long[end - start];\n\
    \    for(int i = start; i < end; i += step)\n    {\n        long current = l[i];\n\
    \        for(int j = i; j < end; j += step)\n        {\n            if(l[j] ==\
    \ current)\n            {\n                result[j - start] = current;\n    \
    \            break;\n            }\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [", "{\n    long[] result = new long[l.length];\n  \
    \  for(int i = 0; i < l.length; ++i)\n        result[l.indexOf(l[i])] = l[i];\n\
    \    return result;\n}\n</code>\n<|/ a tags=arrays,sorting,c#,algorithm |>\n<|\
    \ c |>\nThis doesn't work if the array is sorted.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the array is sorted.\n<|/ c |>\n<| c |>\nThis doesn't work if the array\
    \ is sorted.\n<|/ c |>\n<| c |>\nThis doesn't work if the array is sorted.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if the array is sorted.\n<|/ c |>\n<| a tags=arrays,sorting,c#,algorithm\
    \ |>\n<code>\npublic static int[] SortUnique(int[] array)\n{\n    int[] result\
    \ = new int[array.Length];\n    int j = 0;\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        while (j < result.Length && array[i] > result[j])\n   \
    \     {\n            result[j++] = array[i];\n        }\n        result[j++] =\
    \ array[i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This doesn't work if the array is sorted.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the array is sorted.\n<|/ c |>\n<| c |>\nThis doesn't work if the array is\
    \ sorted.\n<|/ c |>\n<| c |>\nThis doesn't work if the array is sorted.\n<|/ c\
    \ |>\n<| a dscore=4 |>\n<code>\npublic static int[] SortUnique(int[] array)\n\
    {\n    int[] result = new int[array.Length];\n    int j = 0;\n    for (int i =\
    \ 0; i < array.Length; i++)\n    {\n        while (j < result.Length && array[i]\
    \ > result[j])\n        {\n            result[j++] = array[i];\n        }\n  \
    \      result[j++] = array[i];\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,sorting,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work if the array is sorted.\n<|/ c |>\n<| c |>\n\
    This doesn't work if the array is sorted.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    public static int[] SortUnique(int[] array)\n{\n    int[] result = new int[array.Length];\n\
    \    int j = 0;\n    for (int i = 0; i < array.Length; i++)\n    {\n        while\
    \ (j < result.Length && array[i] > result[j])\n        {\n            result[j++]\
    \ = array[i];\n", "{\n    long[] result = new long[l.length];\n    long[] sorted\
    \ = sort(l);\n    for(int i = 0; i < sorted.length; i++) \n    {\n        for(int\
    \ j = i; j < sorted.length; j++) \n        {\n            if(sorted[i] == sorted[j])\
    \ \n            {\n                long temp = sorted[i];\n                sorted[i]\
    \ = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n\
    \    }\n    for(int i = 0; i < sorted.length; i++) \n    {\n        result[sorted.length\
    \ - 1 - i] = sorted[i];\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] r) \n\
    {\n    long[] result = new long[l.length];\n    long[] sorted = sort(l);\n   \
    \ for(int i = 0; i < sorted.length; i++) \n    {\n        for(int j = i; j < sorted.length;\
    \ j++) \n        {\n            if(sorted[i] == sorted[j]) \n            {\n \
    \               long temp = sorted[i];\n                sorted[i] = sorted[j];\n\
    \                sorted[j] = temp;\n            }\n        }\n    }\n    for(int\
    \ i = 0; i < sorted.length; i++) \n    {\n        result[sorted.length - 1 - i]\
    \ = sorted[i];\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] r, long[] s)\
    \ \n{\n    long[] result = new long[l.length];\n    long[] sorted = sort(l);\n\
    \    for(int i = 0; i < sorted.length; i++) \n    {\n        for(int j = i; j\
    \ < sorted.length; j++) \n        {\n            if(sorted[i] == sorted[j]) \n\
    \            {\n                long temp = sorted[i];\n                sorted[i]\
    \ = sorted[j];\n                sorted[j] = temp;\n            }\n        }\n\
    \    }\n    for(int i = 0; i < sorted.length; i++) \n    {\n        result[sorted.length\
    \ - 1 - i] = sorted[i];\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] r, long[] ",
  "{\n\tlong[] u = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\t\
    u[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n}", "{\n    long[] result = new\
    \ long[l.length];\n    long[] seen = new long[l.length];\n    int i = 0;\n   \
    \ for (; i < l.length; ++i)\n    {\n        long x = l[i];\n        if (seen[x]\
    \ == 0)\n        {\n            seen[x] = 1;\n            result[i] = x;\n   \
    \     }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in a\
    \ list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L,\
    \ 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] seen) \n{\n    long[]\
    \ result = new long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n\
    \    {\n        long x = l[i];\n        if (seen[x] == 0)\n        {\n       \
    \     seen[x] = 1;\n            result[i] = x;\n        }\n    }\n    return result;\n\
    }\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end) \n{\n    long[] result = new long[end - start];\n   \
    \ int i = 0;\n    for (; i < l.length; ++i)\n    {\n        long x = l[i];\n \
    \       if (i == start)\n        {\n            result[i] = x;\n        }\n  \
    \      else if (x < result[i - 1])\n        {\n            result[i] = x;\n  \
    \      }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in a\
    \ list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L,\
    \ 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end, long[]\
    \ seen) \n{\n    long[] result = new long[end - start];\n    int i = 0;\n    for\
    \ (; i < l.length; ++i)\n    {\n        long x = l[i];\n        if (i == start)\n\
    \        {\n            result[i] = x;\n        }\n        else if (x < result[i\
    \ - 1])\n        {\n            result[i] = x;\n        }\n        else if (seen[x]\
    \ == 0)\n        {\n            seen[x] = 1;\n            result[i] = x;\n   \
    \     }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in a\
    \ list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L,\
    \ 5L, 9L, 123L]\n    \n*/", "{\n\tlong[] u = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tu[i] = l[i];\n\t}\n\tArrays.sort(u);\n\t\
    return u;\n}", "{\n    long[] result = new long[l.length];\n    \n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        long current = l[i];\n        for(int\
    \ j = i + 1; j < l.length; ++j)\n        {\n            if(l[j] == current)\n\
    \            {\n                current = l[j];\n            }\n        }\n  \
    \      result[i] = current;\n    }\n    \n    return result;\n}", "{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        long x = l[i];\n        for(int j = i; j < l.length; j++)\n        {\n\
    \            if(l[j] == x)\n            {\n                j++;\n            }\n\
    \        }\n        result[i] = x;\n    }\n    Arrays.sort(result);\n    return\
    \ result;\n}", "{\n    long[] result = new long[l.length];\n    for(int i = 0;\
    \ i < l.length; i++)\n    {\n        long x = l[i];\n        for(int j = i; j\
    \ < l.length; j++)\n        {\n            if(l[j] == x)\n            {\n    \
    \            result[j] = x;\n                break;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long lastValue = l[0];\n    int i = 0;\n    for(; i < l.length; ++i)\n  \
    \  {\n        if(l[i] != lastValue)\n        {\n            result[result.length\
    \ - 1] = lastValue;\n            lastValue = l[i];\n        }\n    }\n    result[result.length\
    \ - 1] = lastValue;\n    return result;\n}", "{\n    long[] result = new long[l.length];\n\
    \    long last = 0;\n    long lastCount = 0;\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last)\n        {\n            last = l[i];\n\
    \            lastCount = 1;\n        }\n        else\n        {\n            lastCount++;\n\
    \        }\n        result[i] = last;\n    }\n    for(int i = l.length - 1; i\
    \ >= 0; i--)\n    {\n        if(l[i] != last)\n        {\n            result[l.length\
    \ - 1 - i] = last;\n            last = l[i];\n            lastCount = 1;\n   \
    \     }\n        else\n        {\n            lastCount++;\n        }\n    }\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n    \
    \    {\n            result[l.length - 1 - i] = last;\n            last = l[i];\n\
    \            lastCount = 1;\n        }\n        else\n        {\n            lastCount++;\n\
    \        }\n    }\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[l.length - 1 - i] = last;\n        \
    \    last = l[i];\n            lastCount = 1;\n        }\n        else\n     \
    \   {\n            lastCount++;\n        }\n    }\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last)\n        {\n            result[l.length\
    \ - 1 - i] = last;\n            last = l[i];\n            lastCount = 1;\n   \
    \     }\n        else\n        {\n            lastCount++;\n        }\n    }\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n    \
    \    {\n            result[l.length - 1 - i] = last;\n            last = l[i];\n\
    \            lastCount = 1;\n        }\n        else\n        {\n            lastCount++;\n\
    \        }\n    }\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[l.length - 1 - i] = last;\n        \
    \    last = l[i];\n            lastCount = 1;\n        }\n        else\n     \
    \   {\n            lastCount++;\n        }\n    }\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] != last)\n        {\n            result[l.length\
    \ - 1 - i] = last;\n            last = l[i];\n            lastCount = 1;\n   \
    \     }\n        else\n        {\n            lastCount++;\n        }\n    }\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n    \
    \    {\n            result[l.length - 1 - i] = last;\n            last = l[i];\n\
    \            lastCount = 1;\n        }\n        else\n        {\n            lastCount++;\n\
    \        }\n    }\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[l.length - 1 - i] = last;\n        \
    \    last = l[i];\n            lastCount = 1;\n", "{\n    long[] result = new\
    \ long[l.length];\n    long prev = 0;\n    long cur = 0;\n    int i = 0;\n   \
    \ for(; i < l.length; ++i)\n    {\n        cur = l[i];\n        if(cur != prev)\n\
    \        {\n            result[i - 1] = cur;\n            prev = cur;\n      \
    \  }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work\
    \ for me. I'm getting a null pointer exception when I try to run it.\n<|/ c |>\n\
    <| c |>\n: I tested it before posting it, and it worked for me. Did you try the\
    \ code I posted?\n<|/ c |>\n<| c |>\nYes, I did. I'm getting a null pointer exception\
    \ when I try to run it.\n<|/ c |>\n<| c |>\n: I tested it before posting it, and\
    \ it worked for me. Did you try the code I posted?\n<|/ c |>\n<| c |>\nYes, I\
    \ did. I'm getting a null pointer exception when I try to run it.\n<|/ c |>\n\
    <| a tags=java,arrays |>\n<code>\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\
    import java.util.Iterator;", "{\n    long[] result = new long[l.length];\n   \
    \ long last = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[result.length - 1] = l[i];\n       \
    \     last = l[i];\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  long current = l[i];\n        for(int j = i; j < l.length; j++)\n        {\n\
    \            if(l[j] == current)\n            {\n                current = l[j];\n\
    \            }\n        }\n        result[i] = current;\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n</code>\n<|/ a tags=c++,algorithm,sorting |>\n<| a dscore=0\
    \ |>\nI wrote a solution in Java which uses Arrays.sort and Arrays.binarySearch.\
    \ \n<code>\nimport java.util.Arrays;", "{\n\tlong[] res = new long[l.length];\n\
    \tArrays.sort(l);\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i];\n\t\
    return res;\n}", "{\n    long[] u = new long[l.length];\n    int j = 0;\n    for\
    \ (int i = 0; i < l.length; i++) \n    {\n        if (u[j] == l[i]) \n       \
    \ {\n            j++;\n        } \n        else \n        {\n            u[j]\
    \ = l[i];\n            j++;\n        }\n    }\n    return u;\n}\n</code>\n<|/\
    \ a tags=c#,arrays,sorting |>\n<| c |>\nThis doesn't work. Try it with `unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\n<|/ c |>\n<| c |>\nIt works fine for me.\
    \ Are you sure you copied it correctly?\n<|/ c |>\n<| c |>\nYes, I copied it correctly.\
    \ Try it with `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\n<|/ c |>\n<| c\
    \ |>\nI see what you mean. I've updated my answer to account for that.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work. Try it with `unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])`\n<|/ c |>\n<| a |>\n<code>", "{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] = l[i];\n\tArrays.sort(result);\n\
    \treturn result;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tfor (int j = i + 1; j < l.length; j++) \n\
    \t\t{\n\t\t\tif (l[i] == l[j]) \n\t\t\t{\n\t\t\t\tfor (int k = j; k < l.length;\
    \ k++) \n\t\t\t\t{\n\t\t\t\t\tl[k] = l[k + 1];\n\t\t\t\t}\n\t\t\t\tl[l.length\
    \ - 1] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn sorted\
    \ unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end) \n{\n\tlong[] result = new long[end - start];\n\tfor (int i = start;\
    \ i < end; i++) \n\t{\n\t\tfor (int j = i + 1; j < end; j++) \n\t\t{\n\t\t\tif\
    \ (l[i] == l[j]) \n\t\t\t{\n\t\t\t\tfor (int k = j; k < end; k++) \n\t\t\t\t{\n\
    \t\t\t\t\tl[k] = l[k + 1];\n\t\t\t\t}\n\t\t\t\tresult[i - start] = 0;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = start; i < end; i++) \n\t{\n\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end, int step) \n\
    {\n\tlong[] result = new long[end - start];\n\tfor (int i = start; i < end; i\
    \ += step) \n\t{\n\t\tfor (int j = i + 1; j < end; j += step) \n\t\t{\n\t\t\t\
    if (l[i] == l[j]) \n\t\t\t{\n\t\t\t\tfor (int k = j; k < end; k += step) \n\t\t\
    \t\t{\n\t\t\t\t\tl[k] = l[k + 1];\n\t\t\t\t}\n\t\t\t\tresult[i - start] = 0;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = start; i < end; i += step)\
    \ \n\t{\n\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    ", "{\n    long[] u = new long[l.length];\n\
    \    int j = 0;\n    for (int i = 0; i < l.length; i++)\n    {\n        if (u[j]\
    \ == l[i])\n        {\n            continue;\n        }\n        u[j] = l[i];\n\
    \        j++;\n    }\n    return u;\n}\n</code>\n<|/ a tags=c#,linq,c#-4.0 |>\n\
    <| c |>\nThis doesn't answer the question, which is about sorting and removing\
    \ duplicates.\n<|/ c |>\n<| c |>\nI believe this does answer the question. He\
    \ wants to remove duplicates and then sort the list. He also wants to know if\
    \ there is a better way to do this in C# than what he has already written.\n<|/\
    \ c |>\n<| c |>\nThis doesn't answer the question. He wants to remove duplicates\
    \ and then sort the list. He also wants to know if there is a better way to do\
    \ this in C# than what he has already written.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ answer the question. He wants to remove duplicates and then sort the list. He\
    \ also wants to know if there is a better way to do this in C# than what he has\
    \ already written.\n<|/ c |>\n<| c |>\nThis doesn't answer the question. He wants\
    \ to remove duplicates and then sort the list. He also wants to know if there\
    \ is a better way to do this in C# than what he has already written.\n<|/ c |>\n\
    <| a tags=c#,linq,c#-4.0 |>\n<code>\nvar unique = list.GroupBy(x => x).Select(x\
    \ => x.First()).ToList();\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't answer\
    \ the question, which is about sorting and removing duplicates.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't answer the question, which is about sorting and removing\
    \ duplicates.\n<|/ c |>\n<| c |>\nThis doesn't answer the question, which is about\
    \ sorting and removing duplicates.\n<|/ c |>\n<| c |>\nThis doesn't answer the\
    \ question, which is about sorting and removing duplicates.\n<|/ c |>\n<| c |>\n\
    This doesn't answer the question, which is about sorting and removing duplicates.\n\
    <|/ c |>\n<| a tags=c#,linq,c#-4.0 |>\n<code>\nvar unique = list.Distinct().ToList();\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't answer the question, which is ",
  "{\n    long[] result = new long[l.length];\n    long[] seen = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(!seen[i])\n        {\n\
    \            seen[i] = 1;\n            result[i] = l[i];\n        }\n    }\n \
    \   return result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor (int i =\
    \ 0; i < l.length; i++)\n\t\tres[i] = l[i];\n\tArrays.sort(res);\n\treturn res;\n\
    }", "{\n\tlong[] u = new long[l.length];\n\tlong last = 0;\n\tfor (int i = 0;\
    \ i < l.length; i++)\n\t{\n\t\tif (l[i] != last)\n\t\t{\n\t\t\tlast = l[i];\n\t\
    \t\tu[i] = last;\n\t\t}\n\t}\n\treturn u;\n}", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        result[l.indexOf(l[i])] = l[i];\n\
    \    return result;\n}", "{\n    long[] result = new long[l.length];\n    long\
    \ last = 0;\n    long count = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] != last)\n        {\n            result[count++] = l[i];\n  \
    \          last = l[i];\n        }\n    }\n    Arrays.sort(result);\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,c#,sorting |>\n<| a tags=arrays,c#,sorting\
    \ |>\n<code>\nvar unique = new HashSet<int>();\nforeach (var item in array)\n\
    {\n    if (!unique.Add(item))\n    {\n        array.Remove(item);\n    }\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nvar unique = new HashSet<int>(array);\n\
    </code>\n<|/ a tags=arrays,c#,sorting dscore=2 |>\n<| a tags=arrays,c#,sorting\
    \ |>\n<code>\nvar unique = array.Distinct().ToArray();\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=arrays,c#,sorting |>\n<code>\nvar unique = array.Distinct().ToArray();\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=arrays,c#,sorting |>\n<code>\nvar unique\
    \ = array.Distinct().ToArray();\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,c#,sorting\
    \ |>\n<code>\nvar unique = array.Distinct().ToArray();\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=arrays,c#,sorting |>\n<code>\nvar unique = array.Distinct().ToArray();\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nvar unique = array.Distinct().ToArray();\n\
    </code>\n<|/ a tags=arrays,c#,sorting |>\n<| a dscore=2 |>\n<code>\nvar unique\
    \ = array.Distinct().ToArray();\n</code>\n<|/ a tags=arrays,c#,sorting |>\n<|\
    \ a dscore=2 |>\n<code>\nvar unique = array.Distinct().ToArray();\n</code>\n<|/\
    \ a tags=arrays,c#,sorting |>\n<| a |>\n<code>\nvar unique = array.Distinct().ToArray();\n\
    </code>\n<|/ a tags=arrays,c#,sorting dscore=2 |>\n<| a dscore=2 |>\n<code>\n\
    var unique = array.Distinct", "{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t\tres[i] = l[i];\n\tArrays.sort(res);\n\treturn\
    \ res;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, int start, int end) \n{\n\tlong[] res = new long[end - start];\n\
    \tfor(int i = start; i < end; i++)\n\t\tres[i - start] = l[i];\n\tArrays.sort(res);\n\
    \treturn res;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int start, int end, int step) \n{\n\tlong[] res = new\
    \ long[end - start];\n\tfor(int i = start; i < end; i += step)\n\t\tres[i - start]\
    \ = l[i];\n\tArrays.sort(res);\n\treturn res;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end,\
    \ int step, long cmp) \n{\n\tlong[] res = new long[end - start];\n\tfor(int i\
    \ = start; i < end; i += step)\n\t\tres[i - start] = l[i];\n\tArrays.sort(res,\
    \ cmp);\n\treturn res;\n}\n/*\nReturn sorted unique elements in a list\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l, int start, int end, int step, long cmp, int\
    \ step2) \n{\n\tlong[] res = new long[end - start];\n\tfor(int i = start; i <\
    \ end; i += step) {\n\t\tlong x = l[i];\n\t\tfor(int j = i; j < end; j += step2)\n\
    \t\t\tif(l[j] == x)\n\t\t\t\tbreak;\n\t\tres[i - start] = x;\n\t}\n\tArrays.sort(res,\
    \ cmp);\n\treturn res;\n}\n/*\nReturn sorted unique elements in a list\n    >>> ",
  "{\n    long[] res = new long[l.length];\n    long last = 0;\n    long cur = 0;\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n    \
    \    {\n            last = l[i];\n            cur = i;\n        }\n    }\n   \
    \ res[cur] = last;\n    for(int i = cur + 1; i < l.length; i++)\n    {\n     \
    \   if(l[i] != last)\n        {\n            res[cur] = l[i];\n            cur++;\n\
    \        }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not\
    \ an answer to the question. OP wants to know why his code is not working and\
    \ how to fix it.\n<|/ c |>\n<| c |>\nThe question was \"Why my code is not working?\"\
    \ I answered that question by providing working code. He asked \"How to fix it?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked \"Why my code is not working?\"\
    \ I provided a working solution. He also asked ", "{\n\tlong[] res = new long[l.length];\n\
    \tlong prev = 0;\n\tlong cur = 0;\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\
    \tcur = l[i];\n\t\twhile(cur != prev)\n\t\t{\n\t\t\tres[res.length-1] = cur;\n\
    \t\t\tprev = cur;\n\t\t\tcur = l[++i];\n\t\t}\n\t}\n\treturn res;\n}", "{\n\t\
    long[] result = new long[l.length];\n\tlong[] tmp = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\ttmp[i] = l[i];\n\t}\n\tArrays.sort(tmp);\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tresult[i] = tmp[i];\n\t}\n\treturn\
    \ result;\n}", "{\n    long[] u = new long[l.length];\n    for(int i = 0; i <\
    \ l.length; i++)\n    {\n        long x = l[i];\n        int j = 0;\n        while(j\
    \ < u.length && u[j] == x)\n        {\n            j++;\n        }\n        u[j]\
    \ = x;\n    }\n    return u;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\npublic static int[] unique(int[] arr) {\n    Set<Integer> set = new HashSet<Integer>();\n\
    \    for(int i : arr) {\n        if(!set.contains(i)) {\n            set.add(i);\n\
    \        }\n    }\n    return set.toArray(new int[set.size()]);\n}\n</code>\n\
    <|/ a tags=arrays,java |>\n<| a dscore=1 |>\n<code>\npublic static int[] unique(int[]\
    \ arr) {\n    Set<Integer> set = new HashSet<Integer>();\n    for(int i : arr)\
    \ {\n        if(!set.contains(i)) {\n            set.add(i);\n        }\n    }\n\
    \    return set.toArray(new int[set.size()]);\n}\n</code>\n<|/ a tags=arrays,java\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static void main(String[] args) {\n   \
    \ int[] arr = {1, 2, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\
    \ 6, 6, 6, 6, 6, 6, 6, 6, 6, ", "{\n\tlong[] u = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn u;\n\
    }", "{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        long current = l[i];\n        for(int j = i; j < l.length;\
    \ j++)\n        {\n            if(l[j] == current)\n            {\n          \
    \      current = l[j];\n            }\n        }\n        result[i] = current;\n\
    \    }\n    Arrays.sort(result);\n    return result;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting,c#\
    \ |>\n<| c |>\nThis is not O(n) complexity, it's O(n^2) (quadratic time).\n<|/\
    \ c |>\n<| c |>\nYes, I know, but I thought it would be easier to understand this\
    \ way. Also, I didn't want to use LINQ or any other libraries.\n<|/ c |>\n<| c\
    \ |>\nThis is not O(n) complexity, it's O(n^2) (quadratic time).\n<|/ c |>\n<|\
    \ c |>\nYes, I know, but I thought it would be easier to understand this way.\
    \ Also, I didn't want to use LINQ or any other libraries.\n<|/ c |>\n<| c |>\n\
    This is not O(n) complexity, it's O(n^2) (quadratic time).\n<|/ c |>\n<| a tags=arrays,algorithm,sorting,c#\
    \ |>\n<code>\npublic static int[] SortUnique(int[] array)\n{\n    int[] result\
    \ = new int[array.Length];\n    HashSet<int> set = new HashSet<int>();\n    for\
    \ (int i = 0; i < array.Length; i++)\n    {\n        if (!set.Add(array[i]))\n\
    \        {\n            result[i] = array[i];\n        }\n    }\n    return result.OrderBy(x\
    \ => x).ToArray();\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is not O(n) complexity,\
    \ it's O(n^2) (quadratic time).\n<|/ c |>\n<| c |>\nThis is not O(n) complexity,\
    \ it's O(n^2) (quadratic time).\n<|/ c |>\n<| c |>\nThis is not O(n) complexity,\
    \ it's O(n^2) (quadratic time).\n<|/ c |>\n<| c |>\nThis is not O(n) complexity,\
    \ it's O(n^2) (quadratic time).\n<|/ c |>\n<| c |>\nThis is not O(n) complexity,\
    \ it's O(n^2) (quadratic time).\n<|/ c |>\n<| a |>\n<code>\npublic static int[]\
    \ SortUnique(int[] array)\n{", "{\n    long[] result = new long[l.length];\n \
    \   long[] seen = new long[l.length];\n    int i = 0;\n    for(; i < l.length;\
    \ ++i)\n    {\n        long x = l[i];\n        if(seen[x] == 0)\n        {\n \
    \           result[i] = x;\n            seen[x] = 1;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<| c |>\nThis doesn't\
    \ work if there are duplicate elements in the list. For example, unique([1,2,2,3,4,5,5,6,6,6,7,8,9])\
    \ = [1,2,3,4,5,6,7,8,9].\n<|/ c |>\n<| c |>\nYes, I know. I just posted this answer\
    \ because I thought it might be useful to someone. I've edited my answer to include\
    \ a solution that doesn't require a sorted list.\n<|/ c |>\n<| c |>\nI believe\
    \ this solution has O(n^2) complexity, which is too slow for large arrays.\n<|/\
    \ c |>\n<| c |>\nThis solution has O(n) complexity, which is much faster than\
    \ the accepted answer. I've tested it on large arrays and it works fine.\n<|/\
    \ c |>\n<| c |>\nThis solution has O(n) complexity, which is much faster than\
    \ the accepted answer. I've tested it on large arrays and it works fine.\n<|/\
    \ c |>\n<| a dscore=5 tags=c#,arrays,algorithm |>\n<code>\npublic static int[]\
    \ Unique(int[] array)\n{\n    HashSet<int> set = new HashSet<int>();\n    foreach(int\
    \ i in array)\n    {\n        if(!set.Add(i))\n        {\n            array.Remove(i);\n\
    \        }\n    }\n    return array.ToArray();\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This solution has O(n) complexity, which is much faster than the accepted answer.\
    \ I've tested it on large arrays and it works fine.\n<|/ c |>\n<| c |>\nThis solution\
    \ has O(n) complexity, which is much faster than the accepted answer. I've tested\
    \ it on large arrays and it works fine.\n<|/ c |>\n<| c |>\nThis solution has\
    \ O(n) complexity, which is much faster than the accepted answer. I've tested\
    \ it on large arrays and it works fine.\n<|/ c |>\n<| c |>\nThis solution has\
    \ O(n) complexity, which is much faster than the accepted answer. I've tested\
    \ it on large arrays and ", "{\n    long[] result = new long[l.length];\n    long\
    \ last = l[0];\n    long i = 0;\n    for(; i < l.length; ++i)\n    {\n       \
    \ if(l[i] != last)\n        {\n            result[i] = l[i];\n            last\
    \ = l[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work for me. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns\
    \ `[5, 3, 9, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for me. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns\
    \ `[5, 3, 9, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for me. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns\
    \ `[5, 3, 9, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for me. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns\
    \ `[5, 3, 9, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n<|/ c |>\n<| a tags=arrays,sorting,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;", "{\n    long[] result = new long[l.length];\n    long prev\
    \ = 0;\n    long cur = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n    \
    \    cur = l[i];\n        if(cur != prev)\n        {\n            result[i - 1]\
    \ = cur;\n            prev = cur;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        long x = l[i];\n        int j = 0;\n        for(; j < i; j++)\
    \ \n        {\n            if(l[j] == x) \n            {\n                break;\n\
    \            }\n        }\n        if(j == i) \n        {\n            res[i]\
    \ = x;\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post.\n<|/ c |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/10305641)\n\
    <|/ c |>\n<| c |>\nI disagree. While the code does solve the problem of removing\
    \ duplicates, it does so by iterating over the list twice. While this may be a\
    \ good solution for small lists, it does have some overhead for large lists. I\
    \ believe this solution is more efficient than using an `ArrayList`.\n<|/ c |>\n\
    <| c |>\nI agree with you, this is more efficient than ArrayList. But I believe\
    \ this solution is more readable and easy to understand.\n<|/ c |>\n<| c |>\n\
    I agree with you, this is more efficient than ArrayList. But I believe this solution\
    \ is more readable and easy to understand.\n<|/ c |>\n<| a tags=arraylist,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport\
    \ java.util.List;", "{\n    long[] res = new long[l.length];\n    long last =\
    \ 0;\n    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] != last)\n\
    \        {\n            last = l[i];\n            res[i] = last;\n        }\n\
    \    }\n    return res;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| c\
    \ |>\nThis doesn't work if the list contains duplicates.\n<|/ c |>\n<| c |>\n\
    This doesn't work if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the list contains duplicates.\n<|/ c |>\n<| a tags=c#,algorithm,sorting |>\n\
    <code>\npublic static List<int> SortUnique(List<int> list)\n{\n    List<int> result\
    \ = new List<int>();\n    HashSet<int> set = new HashSet<int>();\n    foreach\
    \ (int i in list)\n    {\n        if (set.Add(i))\n        {\n            result.Add(i);\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This doesn't work if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work if the list\
    \ contains duplicates.\n<|/ c |>\n<| a |>\n<code>\npublic static List<int> SortUnique(List<int>\
    \ list)\n{\n    List<int> result = new List<int>();\n    HashSet<int> set = new\
    \ HashSet<int>();\n    foreach (int i in list)\n    {\n        if (set.Add(i))\n\
    \        {\n            result.Add(i);\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,sorting dscore=5 |>\n<| c |>\nThis doesn't\
    \ work if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the list contains duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work if the\
    \ list contains duplicates.\n<|/ c |>\n<| a |>\n<code>\npublic static List<int>\
    \ SortUnique(List<int> list)\n{\n    List<int> result = new List<int>();\n   \
    \ HashSet<int> set = new HashSet<int", "{\n    long[] result = new long[l.length];\n\
    \    long[] tmp = new long[l.length];\n    int j = 0;\n    for (int i = 0; i <\
    \ l.length; i++) \n    {\n        if (tmp[j] != l[i]) \n        {\n          \
    \  result[j] = l[i];\n            j++;\n        }\n    }\n    result.length =\
    \ j;\n    return result;\n}\n</code>\n<|/ a tags=c#,sorting,arrays |>\n<| c |>\n\
    This is not the fastest solution, but it is very readable and easy to understand.\n\
    <|/ c |>\n<| c |>\nThis solution doesn't work if there are duplicate numbers in\
    \ the input array. For example, unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\
    \ returns [123L, 0L, 2L, 3L, 5L, 9L].\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it before posting it. The code in the answer returns [123L, 0L, 2L, 3L, 5L,\
    \ 9L]\n<|/ c |>\n<| c |>\nI tested it again and you are right. Sorry about that.\
    \ My bad.\n<|/ c |>\n<| c |>\nThis solution doesn't work if there are duplicate\
    \ numbers in the input array. For example, unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L]) returns [123L, 0L, 2L, 3L, 5L, 9L].\n<|/ c |>\n<| a |>\n<code>\n\
    var unique = array.Distinct().ToArray();\n</code>\n<|/ a dscore=5 tags=c#,sorting,arrays\
    \ |>\n<| c |>\nThis solution doesn't work if there are duplicate numbers in the\
    \ input array. For example, unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L]) returns\
    \ [123L, 0L, 2L, 3L, 5L, 9L].\n<|/ c |>\n<| c |>\nThis solution doesn't work if\
    \ there are duplicate numbers in the input array. For example, unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L]) returns [123L, 0L, 2L, 3L, 5L, 9L].\n<|/ c |>\n\
    <| c |>\nThis solution doesn't work if there are duplicate numbers in the input\
    \ array. For example, unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L]) returns [123L,\
    \ 0L, 2L, 3L, 5L, 9L].\n", "{\n    long[] result = new long[l.length];\n    long[]\
    \ seen = new long[l.length];\n    int j = 0;\n    for (int i = 0; i < l.length;\
    \ ++i) {\n        if (seen[i] == 0) {\n            result[j] = l[i];\n       \
    \     seen[i] = 1;\n            j++;\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,sorting,c# |>\n<code>\npublic\
    \ static int[] Sort(int[] array)\n{\n    int[] result = new int[array.Length];\n\
    \    Array.Sort(array);\n    for(int i = 0; i < array.Length; i++)\n    {\n  \
    \      result[i] = array[i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=algorithm,sorting,c# |>\n<code>\npublic static int[] Sort(int[]\
    \ array)\n{\n    int[] result = new int[array.Length];\n    Array.Sort(array);\n\
    \    for(int i = 0; i < array.Length; i++)\n    {\n        result[i] = array[i];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add\
    \ some explanation to your answer such that others can learn from it\n<|/ c |>\n\
    <| a |>\n<code>\npublic static int[] Sort(int[] array)\n{\n    int[] result =\
    \ new int[array.Length];\n    Array.Sort(array);\n    for(int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[i] = array[i];\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 tags=algorithm,sorting,c# |>\n<| c |>\nPlease add some explanation\
    \ to your answer such that others can learn from it\n<|/ c |>\n<| a tags=algorithm,sorting,c#\
    \ |>\n<code>\npublic static int[] Sort(int[] array)\n{\n    int[] result = new\
    \ int[array.Length];\n    Array.Sort(array);\n    for(int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[i] = array[i];\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic static int[] Sort(int[] array)\n\
    {\n    int[] result = new int[array.Length];\n    Array.Sort(array);\n    for(int\
    \ i = 0; i < array.Length; i++)\n    {\n        result[i] = array[i];\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=algorithm,sorting,c# |>\n<| c |>\n\
    Please add some explanation to your answer such that others can learn from it\n\
    <|/ c |>\n", "{\n    long[] u = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n\
    }\n</code>\n<|/ a tags=arrays,sorting,java |>\n<| c |>\nThis solution has O(n^2)\
    \ time complexity. Not very efficient.\n<|/ c |>\n<| c |>\n: I believe this is\
    \ O(nlogn) time complexity. Can you please elaborate on why you believe so?\n\
    <|/ c |>\n<| c |>\n: I believe that this is O(nlogn) time complexity because of\
    \ the sort operation. Sorting is a O(nlogn) operation. Sorting takes O(nlogn)\
    \ time complexity because of the comparison operation. Comparison takes O(n) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because of the comparison operation. Sorting takes O(nlogn) time\
    \ complexity because ", "{\n    long[] result = new long[l.length];\n    long\
    \ last = l[0];\n    int i = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i]\
    \ != last)\n        {\n            result[i - 1] = l[i];\n            last = l[i];\n\
    \        }\n    }\n    result[i - 1] = last;\n    return result;\n}", "{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i];\n\tArrays.sort(res);\n\treturn res;\n}", "{\n\tlong[] u = new long[l.length];\n\
    \tfor(int i = 0; i < u.length; i++)\n\t\tu[i] = l[i];\n\tArrays.sort(u);\n\treturn\
    \ u;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, int start, int end) \n{\n\tlong[] u = new long[end - start];\n\
    \tfor(int i = start; i < end; i++)\n\t\tu[i - start] = l[i];\n\tArrays.sort(u);\n\
    \treturn u;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int start, int end, int step) \n{\n\tlong[] u = new long[end\
    \ - start];\n\tfor(int i = start; i < end; i += step)\n\t\tu[i - start] = l[i];\n\
    \tArrays.sort(u);\n\treturn u;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end, int step, long\
    \ cmp) \n{\n\tlong[] u = new long[end - start];\n\tfor(int i = start; i < end;\
    \ i += step)\n\t\tu[i - start] = l[i];\n\tArrays.sort(u, cmp);\n\treturn u;\n\
    }\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end, int step, long cmp, int step2) \n{\n\tlong[] u = new\
    \ long[end - start];\n\tfor(int i = start; i < end; i += step)\n\t\tu[i - start]\
    \ = l[i];\n\tArrays.sort(u, cmp, step2);\n\treturn u;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n",
  "{\n    long[] res = new long[l.length];\n    long last = 0;\n    for(int i = 0;\
    \ i < l.length; i++) \n    {\n        if(l[i] != last) \n        {\n         \
    \   last = l[i];\n            res[i] = last;\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,sorting |>\n<code>\npublic\
    \ static class Extensions\n{\n    public static IEnumerable<T> Sort<T>(this IEnumerable<T>\
    \ source)\n    {\n        List<T> list = new List<T>(source);\n        list.Sort();\n\
    \        return list;\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,sorting\
    \ |>\n<code>\npublic static class Extensions\n{\n    public static IEnumerable<T>\
    \ Sort<T>(this IEnumerable<T> source)\n    {\n        List<T> list = new List<T>(source);\n\
    \        list.Sort();\n        return list;\n    }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static class Extensions\n{\n    public\
    \ static IEnumerable<T> Sort<T>(this IEnumerable<T> source)\n    {\n        List<T>\
    \ list = new List<T>(source);\n        list.Sort();\n        return list;\n  \
    \  }\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| a tags=c#,algorithm,sorting\
    \ |>\n<code>\npublic static class Extensions\n{\n    public static IEnumerable<T>\
    \ Sort<T>(this IEnumerable<T> source)\n    {\n        List<T> list = new List<T>(source);\n\
    \        list.Sort();\n        return list;\n    }\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c#,algorithm,sorting |>\n<code>\npublic static class Extensions\n\
    {\n    public static IEnumerable<T> Sort<T>(this IEnumerable<T> source)\n    {\n\
    \        List<T> list = new List<T>(source);\n        list.Sort();\n        return\
    \ list;\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic\
    \ static class Extensions\n{\n    public static IEnumerable<T> Sort<T>(this IEnumerable<T>\
    \ source)\n    {\n        List<T> list = new List<T>(source);\n        list.Sort();\n\
    \        return list;\n    }\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n\
    <| a tags=c#,algorithm,sorting |>\n<code>\npublic static class Extensions\n",
  "{\n    long[] res = new long[l.length];\n    Arrays.sort(l);\n    for(int i = 0;\
    \ i < l.length; i++)\n        res[i] = l[i];\n    return res;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\nI wrote a library that does this for you:\n\
    https://github.com/jamie-johnson/unique-array\n<code>\nimport std.array;\nimport\
    \ std.algorithm;\nimport std.conv;\nimport std.conv.to;\nimport std.range;\nimport\
    \ std.string;", "{\n    long[] result = new long[l.length];\n    for(int i = 0;\
    \ i < l.length; i++)\n    {\n        long current = l[i];\n        for(int j =\
    \ i + 1; j < l.length; j++)\n        {\n            if(l[j] == current)\n    \
    \        {\n                current = l[j];\n            }\n        }\n      \
    \  result[i] = current;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[l.length];\n    Arrays.sort(l);\n    for(int i = 0; i < l.length;\
    \ i++)\n        result[i] = l[i];\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key)\n\
    {\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n    for(int i\
    \ = 0; i < l.length; i++)\n        if(l[i] == key)\n            result[i] = l[i];\n\
    \    return result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int key)\n{\n    long[] result = new long[l.length];\n\
    \    Arrays.sort(l);\n    for(int i = 0; i < l.length; i++)\n        if(l[i] ==\
    \ key)\n            result[i] = l[i];\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long key, int\
    \ key)\n{\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n    for(int\
    \ i = 0; i < l.length; i++)\n        if(l[i] == key)\n            result[i] =\
    \ l[i];\n    return result;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int key, int key)\n{\n    long[]\
    \ result = new long[l.length];\n    Arrays.sort(l);\n    for(int i = 0; i < l.length;\
    \ i++)\n        if(l[i] == key)\n            result[i] = l[i];\n    return result;\n\
    }\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, long key, long key)\n{\n    long[] result = new long[l.length];\n    Arrays.sort(",
  "{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\
    \t{\n\t\tfor(int j = i + 1; j < l.length; j++) \n\t\t{\n\t\t\tif(l[i] == l[j])\
    \ \n\t\t\t{\n\t\t\t\tresult[i] = l[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return result;\n}", "{\n    long[] result = new long[l.length];\n    int j = 0;\n\
    \    for (int i = 0; i < l.length; i++) \n    {\n        if (j == i) \n      \
    \  {\n            result[i] = l[i];\n        }\n        else if (l[i] != l[j])\
    \ \n        {\n            result[i] = l[j];\n            j++;\n        }\n  \
    \  }\n    return result;\n}", "{\n    long[] result = new long[l.length];\n  \
    \  long last = 0;\n    long count = 0;\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] != last)\n        {\n            result[count++] = l[i];\n\
    \            last = l[i];\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ u = new long[l.length];\n    long uval = l[0];\n    for(int i = 1; i < l.length;\
    \ i++) \n    {\n        if(l[i] != uval) \n        {\n            u[i] = uval;\n\
    \        }\n        uval = l[i];\n    }\n    return u;\n}\n/*\nReturn sorted unique\
    \ elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long u) \n\
    {\n    long[] u = new long[l.length];\n    long uval = l[0];\n    for(int i =\
    \ 1; i < l.length; i++) \n    {\n        if(l[i] != uval) \n        {\n      \
    \      u[i] = uval;\n        }\n        uval = l[i];\n    }\n    return u;\n}\n\
    /*\nReturn sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int u) \n{\n    long[] u = new long[l.length];\n    long uval = l[0];\n \
    \   for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] != uval) \n   \
    \     {\n            u[i] = uval;\n        }\n        uval = l[i];\n    }\n  \
    \  return u;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, long u, int u) \n{\n    long[] u = new long[l.length];\n\
    \    long uval = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n      \
    \  if(l[i] != uval) \n        {\n            u[i] = uval;\n        }\n       \
    \ uval = l[i];\n    }\n    return u;\n}\n/*\nReturn sorted unique elements in\
    \ a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int u, int u) \n{\n   \
    \ long[] u = new long[l.length];", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n        result[i] = l[i];\n    Arrays.sort(result);\n\
    \    return result;\n}", "{\n\tlong[] u = new long[l.length];\n\tfor (int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tu[i] = l[i];\n\t}\n\tArrays.sort(u);\n\treturn\
    \ u;\n}", "{\n    long[] u = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        u[i] = l[i];\n    }\n    Arrays.sort(u);\n    return u;\n\
    }", "{\n    long[] result = new long[l.length];\n    int j = 0;\n    for (int\
    \ i = 0; i < l.length; i++)\n    {\n        if (result[j] == l[i])\n        {\n\
    \            continue;\n        }\n        result[j] = l[i];\n        j++;\n \
    \   }\n    return Arrays.copyOf(result, j);\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end)\
    \ \n{\n    long[] result = new long[end - start];\n    int j = 0;\n    for (int\
    \ i = start; i < end; i++)\n    {\n        if (result[j] == l[i])\n        {\n\
    \            continue;\n        }\n        result[j] = l[i];\n        j++;\n \
    \   }\n    return Arrays.copyOf(result, j);\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end,\
    \ int step) \n{\n    long[] result = new long[end - start];\n    int j = 0;\n\
    \    for (int i = start; i < end; i += step)\n    {\n        if (result[j] ==\
    \ l[i])\n        {\n            continue;\n        }\n        result[j] = l[i];\n\
    \        j++;\n    }\n    return Arrays.copyOf(result, j);\n}\n/*\nReturn sorted\
    \ unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step, long stepSize) \n{\n    long[] result = new long[end - start];\n\
    \    int j = 0;\n    for (int i = start; i < end; i += step, j++)\n    {\n   \
    \     if (result[j] == l[i])\n        {\n            continue;\n        }\n  \
    \      result[j] = l[i];\n    }\n    return Arrays.copyOf(result, j);\n}\n/*\n\
    Return sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int start, int end, int step, long stepSize, long stepSize2) ", "{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       long current = l[i];\n        for(int j = i + 1; j < l.length; j++) \n\
    \        {\n            if(l[j] == current) \n            {\n                res[i]\
    \ = l[j];\n                res[j] = current;\n                break;\n       \
    \     }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=1 |>\n<code>\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.List;", "{\n    long[] result = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        long current = l[i];\n        int\
    \ j = 0;\n        for(; j < i; j++) \n        {\n            if(l[j] == current)\
    \ \n            {\n                break;\n            }\n        }\n        result[i]\
    \ = l[j];\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    <code>\npublic static List<Integer> getUnique(List<Integer> list) {\n    List<Integer>\
    \ result = new ArrayList<Integer>();\n    Set<Integer> set = new HashSet<Integer>();\n\
    \    for(Integer i : list) {\n        if(!set.contains(i)) {\n            result.add(i);\n\
    \            set.add(i);\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a tags=java,arrays |>\n<| a tags=java,arrays |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\
    import java.util.HashSet;", "{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        long x = l[i];\n        int j = 0;\n\
    \        while(j < res.length && x == res[j]) \n        {\n            j++;\n\
    \        }\n        if(j < res.length) \n        {\n            res[j] = x;\n\
    \        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=c#,arrays,sorting |>\n\
    <| c |>\nThis algorithm is O(n^2) in worst case and O(n) in best case. Not very\
    \ efficient.\n<|/ c |>\n<| c |>\nYes, I know. But the question was about sorting\
    \ and I thought that would be the most efficient way. Of course the best case\
    \ is O(n). But I thought that would be the most efficient way too.\n<|/ c |>\n\
    <| c |>\nThis algorithm is O(n^2) in worst case and O(n) in best case. Not very\
    \ efficient.\n<|/ c |>\n<| c |>\nThe question was about sorting and I thought\
    \ that would be the most efficient way. Of course the best case is O(n). But I\
    \ thought that would be the most efficient way too.\n<|/ c |>\n<| c |>\nThe question\
    \ was about sorting and I thought that would be the most efficient way. Of course\
    \ the best case is O(n). But I thought that would be the most efficient way too.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\nvar unique = array.Distinct().ToArray();\n\
    </code>\n<|/ a tags=c#,arrays,sorting |>\n<| c |>\nThis algorithm is O(n^2) in\
    \ worst case and O(n) in best case. Not very efficient.\n<|/ c |>\n<| c |>\nThe\
    \ question was about sorting and I thought that would be the most efficient way.\
    \ Of course the best case is O(n). But I thought that would be the most efficient\
    \ way too.\n<|/ c |>\n<| c |>\nThe question was about sorting and I thought that\
    \ would be the most efficient way. Of course the best case is O(n). But I thought\
    \ that would be the most efficient way too.\n<|/ c |>\n<| c |>\nThe question was\
    \ about sorting and I thought that would be the most efficient way. Of course\
    \ the best case is O(n). But I thought that would be the most efficient way too.\n\
    <|/ c |>\n<| c |>\nThe question was ", "{\n\tlong[] result = new long[l.length];\n\
    \t\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tint j = 0;\n\t\twhile (j <\
    \ result.length && l[i] == result[j]) j++;\n\t\t\n\t\tif (j == result.length)\
    \ result[i] = l[i];\n\t\telse \n\t\t{\n\t\t\tfor (int k = j; k < result.length;\
    \ k++) \n\t\t\t\tif (l[i] < result[k]) \n\t\t\t\t{\n\t\t\t\t\tresult[k] = l[i];\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n\tlong[]\
    \ result = new long[l.length];\n\t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\
    \t\tint j;\n\t\tfor (j = 0; j < i; j++)\n\t\t{\n\t\t\tif (l[i] == l[j])\n\t\t\t\
    \tbreak;\n\t\t}\n\t\t\n\t\tif (j == i)\n\t\t\tresult[i] = l[i];\n\t}\n\t\n\treturn\
    \ result;\n}", "{\n    long[] result = new long[l.length];\n    for(int i = 0;\
    \ i < l.length; ++i)\n        result[l.indexOf(l[i])] = l[i];\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays,sorting |>\n<| a dscore=0 |>\n<code>\nimport\
    \ java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport\
    \ java.util.stream.Collectors;", "{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        long current = l[i];\n\
    \        for(int j = i + 1; j < l.length; j++)\n        {\n            if(l[j]\
    \ == current)\n            {\n                current = l[j];\n            }\n\
    \        }\n        result[i] = current;\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,\
    \ int start, int end) \n{\n    long[] result = new long[end - start];\n    for(int\
    \ i = start; i < end; i++)\n    {\n        long current = l[i];\n        for(int\
    \ j = i + 1; j < end; j++)\n        {\n            if(l[j] == current)\n     \
    \       {\n                current = l[j];\n            }\n        }\n       \
    \ result[i - start] = current;\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start,\
    \ int end, int step) \n{\n    long[] result = new long[end - start];\n    for(int\
    \ i = start; i < end; i += step)\n    {\n        long current = l[i];\n      \
    \  for(int j = i + 1; j < end; j += step)\n        {\n            if(l[j] == current)\n\
    \            {\n                current = l[j];\n            }\n        }\n  \
    \      result[i - start] = current;\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,\
    \ int start, int end, int step, long stepSize) \n{\n    long[] result = new long[end\
    \ - start];\n    for(int i = start; i < end; i += step)\n    {\n        long current\
    \ = l[i];\n        for(int j = i + 1; j < end; j += step)\n        {\n       \
    \     if(l[j] == current)\n            {\n                current = l[j];\n  \
    \          }\n        }\n        result[i - start] = current;\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements in a list\n    >>> unique([5L,\
    \ 3L, 5", "{\n    long[] result = new long[l.length];\n    for(int i = 0; i <\
    \ l.length; i++)\n    {\n        long x = l[i];\n        for(int j = i; j < l.length;\
    \ j++)\n        {\n            if(l[j] == x)\n            {\n                result[j]\
    \ = x;\n                break;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;", "{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n        res[i] = l[i];\n\
    \    Arrays.sort(res);\n    return res;\n}\n</code>\n<|/ a tags=c#,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input array.\n\
    <|/ c |>\n<| c |>\n: It does. I tested it before posting.\n<|/ c |>\n<| c |>\n\
    : I tested it before posting too. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\
    \ returns `[0, 2, 3, 4, 5, 9, 123]`.\n<|/ c |>\n<| c |>\n: I tested it before\
    \ posting too. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns `[0, 2,\
    \ 3, 4, 5, 9, 123]`.\n<|/ c |>\n<| c |>\n: I tested it before posting too. `unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns `[0, 2, 3, 4, 5, 9, 123]`.\n<|/\
    \ c |>\n<| a |>\n<code>\nvar unique = array.Distinct().ToArray();\n</code>\n<|/\
    \ a dscore=5 tags=c#,arrays,sorting |>\n<| c |>\nThis doesn't work if there are\
    \ duplicates in the input array.\n<|/ c |>\n<| c |>\n: It does. I tested it before\
    \ posting.\n<|/ c |>\n<| c |>\n: I tested it before posting too. `unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])` returns `[0, 2, 3, 4, 5, 9, 123]`.\n<|/\
    \ c |>\n<| c |>\n: I tested it before posting too. `unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])` returns `[0, 2, 3, 4, 5, 9, 123]`.\n<|/ c |>\n<| c |>\n\
    : I tested it before posting too. `unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])`\
    \ returns `[0, 2, 3, 4, 5, 9, 123]`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nvar\
    \ unique = array.Distinct().ToArray();\n</code>\n<|/ a tags=", "{\n\tlong[] result\
    \ = new long[l.length];\n\t\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    for (int j = i + 1; j < l.length; j++) \n\t\t{\n\t\t\tif (l[i] > l[j]) \n\t\t\t\
    {\n\t\t\t\tlong temp = l[i];\n\t\t\t\tl[i] = l[j];\n\t\t\t\tl[j] = temp;\n\t\t\
    \t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tresult[i]\
    \ = l[i];\n\t}\n\t\n\tArrays.sort(result);\n\t\n\treturn result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
