name: HumanEval_57_monotonic
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n\
  \    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
  \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t\
    }\n\treturn (min <= max);\n}", "{\n    int i = 0;\n    int j = 0;\n    int k =\
    \ 0;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    while(i\
    \ < l.length && j < l.length)\n    {\n        if(l[i] < l[j])\n        {\n   \
    \         isIncreasing = false;\n        }\n        else if(l[i] > l[j])\n   \
    \     {\n            isDecreasing = false;\n        }\n        i++;\n        j++;\n\
    \    }\n    if(isIncreasing && isDecreasing)\n    {\n        return true;\n  \
    \  }\n    else if(isIncreasing && !isDecreasing)\n    {\n        return false;\n\
    \    }\n    else if(!isIncreasing && isDecreasing)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}\n</code>\n<|/ a tags=c++,sorting,arrays\
    \ |>\n<| c |>\nI like your solution, but I think it can be improved by using std::sort\
    \ and comparing only two elements at a time. Also, why do you use \"isIncreasing\"\
    \ and \"isDecreasing\" instead of just \"isIncreasing\" and \"isDecreasing\"?\n\
    <|/ c |>\n<| c |>\nI used isIncreasing and isDecreasing because I wanted to be\
    \ sure that if one element was increasing and the other was decreasing, then they\
    \ were both increasing. That way I wouldn't have to worry about what happened\
    \ to the other element. Also, std::sort is O(n log n), so it's more efficient\
    \ than my solution.\n<|/ c |>\n<| c |>\nOh, I see. Thanks for explaining that.\
    \ :)\n<|/ c |>\n<| c |>\nI like your solution, but I think it can be improved\
    \ by using std::sort and comparing only two elements at a time. Also, why do you\
    \ use \"isIncreasing\" and \"isDecreasing\" instead of just \"isIncreasing\" and\
    \ \"isDecreasing\"?\n<|/ c |>\n<| c |>\nI used isIncreasing and isDecreasing because\
    \ I wanted to be sure that if one element was increasing and the other was decreasing,\
    \ then they were both increasing. That way I wouldn't have to worry about what\
    \ happened to the other element. Also, std::sort is O(n log n), so it's more efficient\
    \ than my solution.\n<|/ c |>\n<| a tags=c++,sorting,arrays |>\n<code>", "{\n\t\
    long min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\
    \t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn\
    \ (min <= max);\n}", "{\n    long min = l[0];\n    long max = l[0];\n    bool\
    \ isMonotonic = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n        {\n            min = l[i];\n        }\n        else if(l[i]\
    \ > max)\n        {\n            max = l[i];\n        }\n        else\n      \
    \  {\n            isMonotonic = false;\n        }\n    }\n    return isMonotonic;\n\
    }", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\t\
    max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max = l[0];\n\tlong min\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\
    \tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\t\
    return (max < min);\n}", "{\n    long first = l[0];\n    long last = l[0];\n \
    \   long curr = l[0];\n    long i;\n    bool result = true;\n    for (i = 1; i\
    \ < l.length; ++i) {\n        curr = l[i];\n        if (curr < first) {\n    \
    \        result = false;\n            break;\n        }\n        if (curr > last)\
    \ {\n            result = false;\n            break;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i =\
    \ 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n\
    \        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n   \
    \ }\n    return min < max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\t\
    for (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin\
    \ = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\
    }\n\treturn (min <= max);\n}", "{\n    int i = 0;\n    int j = 1;\n    bool result\
    \ = true;\n    while(i < l.length && j > 0) {\n        if(l[i] < l[j]) {\n   \
    \         result = false;\n            break;\n        }\n        else if(l[i]\
    \ > l[j]) {\n            result = true;\n            break;\n        }\n     \
    \   else {\n            i++;\n            j++;\n        }\n    }\n    return result;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t\
    }\n\treturn min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n \
    \   for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n       \
    \     min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n  \
    \  return min <= max;\n}", "{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool result\
    \ = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tlong next = l[i];\n\t\t\
    if (curr < next) {\n\t\t\tresult = false;\n\t\t}\n\t\telse if (curr > next) {\n\
    \t\t\tresult = true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn\
    \ result;\n}", "{\n    long prev = 0;\n    long curr = l[0];\n    bool result\
    \ = true;\n    for(int i = 1; i < l.length; i++) \n    {\n        long next =\
    \ l[i];\n        if(curr > next) \n        {\n            result = false;\n  \
    \          break;\n        }\n        else if(curr < prev) \n        {\n     \
    \       result = false;\n            break;\n        }\n        prev = curr;\n\
    \        curr = next;\n    }\n    return result;\n}", "{\n\tlong max = l[0];\n\
    \tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max)\
    \ {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t\
    }\n\t}\n\treturn (max < min);\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax\
    \ = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\
    }\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \  {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n\
    \            max = l[i];\n        }\n    }\n    return min <= max;\n}", "{\n \
    \   long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min <= max;\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n   \
    \         max = l[i];\n    }\n    return min <= max;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length;\
    \ ++i)\n    {\n        if (l[i] < min)\n        {\n            min = l[i];\n \
    \       }\n        if (l[i] > max)\n        {\n            max = l[i];\n     \
    \   }\n    }\n    if (isMonotonic == false)\n    {\n        return false;\n  \
    \  }\n    long mid = min + ((max - min) / 2);\n    for (int i = 1; i < l.length;\
    \ ++i)\n    {\n        if (l[i] < mid)\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,c#\
    \ |>\n<code>\npublic bool IsMonotonic(List<int> list)\n{\n    if (list.Count <\
    \ 2)\n    {\n        return true;\n    }", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length;\
    \ ++i) {\n        if (l[i] < min) {\n            isMonotonic = false;\n      \
    \      break;\n        }\n        if (l[i] > max) {\n            isMonotonic =\
    \ false;\n            break;\n        }\n    }\n    return isMonotonic;\n}", "{\n\
    \tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}", "{\n    long\
    \ max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n\
    \        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i]\
    \ < min) {\n            min = l[i];\n        }\n    }\n    return max < min;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max\
    \ = l[i];\n    }\n    return min <= max;\n}", "{\n\tlong max = l[0];\n\tlong min\
    \ = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t\
    {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\
    \t}\n\t}\n\treturn (max <= min);\n}", "{\n    long min = l[0];\n    long max =\
    \ l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n\tlong l = l[0];\n\tbool result = true;\n\tfor\
    \ (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i-1] > l[i])\n\t\t{\n\t\t\tresult\
    \ = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong prev =\
    \ 0;\n\tlong curr = l[0];\n\tfor (int i = 1; i < l.length; i++) \n\t{\n\t\tlong\
    \ next = l[i];\n\t\tif (curr < next) \n\t\t{\n\t\t\tif (curr < prev) \n\t\t\t\t\
    return false;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\telse \n\t\t\
    {\n\t\t\tif (curr > prev) \n\t\t\t\treturn false;\n\t\t\tprev = curr;\n\t\t\t\
    curr = next;\n\t\t}\n\t}\n\treturn true;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\
    \t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n \
    \   {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min < max;\n}", "{\n    long min =\
    \ l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n        {\n            min = l[i];\n        }\n     \
    \   else if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n\
    \    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    bool result = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n    \
    \    if (l[i] < min)\n        {\n            min = l[i];\n        }\n        if\
    \ (l[i] > max)\n        {\n            max = l[i];\n            result = false;\n\
    \        }\n    }\n    return result;\n}", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] <\
    \ min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n    int i;\n    long max = l[0];\n   \
    \ bool result = true;\n    for(i = 1; i < l.length; ++i) {\n        if(l[i] >\
    \ max) {\n            max = l[i];\n            result = false;\n        }\n  \
    \  }\n    return result;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n\
    \        if(l[i] > max) max = l[i];\n    }\n    return min < max;\n}", "{\n\t\
    long min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t\
    {\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong last\
    \ = l[0];\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1;\
    \ i < l.length; i++)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisIncreasing = false;\n\
    \t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tcurr = l[i];\n\t}\n\treturn isIncreasing;\n\
    }", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ i++) \n    {\n        if(l[i] > max) \n        {\n            max = l[i];\n\
    \        }\n        if(l[i] < min) \n        {\n            min = l[i];\n    \
    \    }\n    }\n    return max >= min;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm\
    \ |>\n<| c |>\nThis is not the best solution. Try it with a list with two elements:\
    \ [1, 1] and [1, 2]. Your algorithm will return true while it should return false.\n\
    <|/ c |>\n<| c |>\n: I agree, my algorithm is just an example to show that it\
    \ is possible to implement a sorting algorithm with O(n) complexity (where n is\
    \ the number of elements in the list). Of course, there are other algorithms that\
    \ can achieve O(n) complexity (such as quicksort, heapsort, etc.), but this one\
    \ is easy to implement and understand.\n<|/ c |>\n<| c |>\n: I agree, my algorithm\
    \ is just an example to show that it is possible to implement a sorting algorithm\
    \ with O(n) complexity (where n is the number of elements in the list). Of course,\
    \ there are other algorithms that can achieve O(n) complexity (such as quicksort,\
    \ heapsort, etc.), but this one is easy to implement and understand.\n<|/ c |>\n\
    <| c |>\n: I agree, my algorithm is just an example to show that it is possible\
    \ to implement a sorting algorithm with O(n) complexity (where n is the number\
    \ of elements in the list). Of course, there are other algorithms that can achieve\
    \ O(n) complexity (such as quicksort, heapsort, etc.), but this one is easy to\
    \ implement and understand.\n<|/ c |>\n<| c |>\n: I agree, my algorithm is just\
    \ an example to show that it is possible to implement a sorting algorithm with\
    \ O(n) complexity (where n is the number of elements in the list). Of course,\
    \ there are other algorithms that can achieve O(n) complexity (such as quicksort,\
    \ heapsort, etc.), but this one is easy to implement and understand.\n<|/ c |>\n\
    <| a tags=c#,sorting,algorithm |>\n<code>", "{\n    long max = l[0];\n    long\
    \ min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max)\
    \ {\n            max = l[i];\n        }\n        if(l[i] < min) {\n          \
    \  min = l[i];\n        }\n    }\n    return max < min;\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i\
    \ < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min\
    \ = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n\
    \        }\n    }\n    if(min > max)\n    {\n        result = false;\n    }\n\
    \    return result;\n}", "{\n    long first = l[0];\n    long last = l[0];\n \
    \   bool result = true;\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i]\
    \ < first) {\n            result = false;\n            break;\n        }\n   \
    \     else if(l[i] > last) {\n            result = false;\n            break;\n\
    \        }\n    }\n    return result;\n}", "{\n    long max = l[0];\n    long\
    \ min = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i)\n\
    \    {\n        if (l[i] < min)\n        {\n            result = false;\n    \
    \        break;\n        }\n        if (l[i] > max)\n        {\n            result\
    \ = false;\n            break;\n        }\n    }\n    return result;\n}", "{\n\
    \    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i]\
    \ < min)\n            min = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long l = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < l)\n        {\n            l = l[i];\n        }\n    }\n    return l == l[0];\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min < max;\n}", "{\n    long min =\
    \ l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n   \
    \         max = l[i];\n    }\n    return min <= max;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n    int n = l.length;\n    if (n < 2) return true;\n\
    \    if (l[0] > l[1]) return true;\n    if (l[n-1] < l[n-2]) return true;\n  \
    \  for (int i = 1; i < n-1; ++i) {\n        if (l[i] > l[i-1]) return true;\n\
    \        if (l[i] < l[i+1]) return true;\n    }\n    return false;\n}", "{\n \
    \   long l = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < l)\n        {\n            l = l[i];\n        }\n    }\n    return l == l[0];\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t\tif (l[i] > max)\n\t\t\
    \tmax = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong\
    \ max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax =\
    \ l[i];\n\t\t}\n\t}\n\treturn min <= max;\n}", "{\n\tlong min = l[0];\n\tlong\
    \ max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        if(l[i] > max)\n     \
    \   {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\n\
    </code>\n<|/ a tags=c#,algorithm,sorting |>\n<| a dscore=2 |>\n<code>\npublic\
    \ static bool IsMonotonic(this IEnumerable<int> list)\n{\n    if (list == null)\n\
    \    {\n        throw new ArgumentNullException(\"list\");\n    }", "{\n\tlong\
    \ min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i =\
    \ 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\
    \t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n\tlong\
    \ min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\
    \t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t\
    {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong min =\
    \ l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i]\
    \ < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\
    \tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    int i = 0;\n  \
    \  int j = 1;\n    long max = l[0];\n    bool result = true;\n    while(i < l.length\
    \ && j < l.length) {\n        if(l[i] < l[j]) {\n            max = l[i];\n   \
    \         i++;\n        } else {\n            max = l[j];\n            j++;\n\
    \        }\n        if(max < l[i]) {\n            result = false;\n          \
    \  break;\n        }\n    }\n    return result;\n}", "{\n\tlong min = l[0];\n\t\
    long max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min)\
    \ min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n\
    }", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\
    \ {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn max >= min;\n}", "{\n\tlong min =\
    \ l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i <\
    \ l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\tisMonotonic\
    \ = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n    int n = l.length;\n\
    \    if (n < 2) return true;\n    long m = l[0], last = l[0];\n    for (int i\
    \ = 1; i < n; ++i)\n    {\n        long next = l[i];\n        if (next < last)\n\
    \        {\n            return false;\n        }\n        last = next;\n    }\n\
    \    return true;\n}", "{\n    long max = l[0];\n    long min = l[0];\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min =\
    \ l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return max\
    \ < min;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i <\
    \ l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\
    \telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <=\
    \ max);\n}", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1;\
    \ i < l.length; i++) \n    {\n        if(l[i] > max) \n        {\n           \
    \ max = l[i];\n        }\n        if(l[i] < min) \n        {\n            min\
    \ = l[i];\n        }\n    }\n    return max >= min;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n\
    \        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n\
    }", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t\tif (l[i] < min)\n\t\t\
    \tmin = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    int i = 0;\n    int j\
    \ = 1;\n    bool result = true;\n    while(i < l.length && j < l.length) {\n \
    \       if(l[i] < l[j]) {\n            result = false;\n            break;\n \
    \       }\n        else if(l[i] > l[j]) {\n            result = true;\n      \
    \      break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n\
    \    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n    \
    \    {\n            isMonotonic = false;\n            break;\n        }\n    \
    \    if (l[i] > max)\n        {\n            isMonotonic = false;\n          \
    \  break;\n        }\n    }\n    return isMonotonic;\n}", "{\n    long max = l[0];\n\
    \    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i]\
    \ > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n   \
    \         min = l[i];\n        }\n    }\n    return min < max;\n}", "{\n    long\
    \ l = l[0];\n    long r = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n\
    \        if(l[i] < r)\n        {\n            return false;\n        }\n     \
    \   r = l[i];\n    }\n    return true;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\
    \tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\
    \t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t\t\
    break;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    int i;\n    long max = l[0];\n\
    \    bool isMonotonic = true;\n    for (i = 1; i < l.length; ++i) {\n        if\
    \ (l[i] > max) {\n            max = l[i];\n            isMonotonic = false;\n\
    \        }\n    }\n    return isMonotonic;\n}", "{\n    long min = l[0];\n   \
    \ long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] <\
    \ min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min\
    \ <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\
    \tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tresult =\
    \ false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tresult = false;\n\t\
    \t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong max = l[0];\n\tlong min\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t\
    {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\
    \t}\n\t}\n\treturn (max < min);\n}", "{\n\tlong max = 0;\n\tlong min = l[0];\n\
    \tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ < min)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}",
  "{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n \
    \   for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n     \
    \   {\n            min = l[i];\n        }\n        if (l[i] > max)\n        {\n\
    \            max = l[i];\n        }\n    }\n    if (isMonotonic)\n    {\n    \
    \    if (min < max)\n        {\n            return true;\n        }\n    }\n \
    \   return false;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic\
    \ = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\
    \t}\n\t}\n\tif (min < max)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n\
    }", "{\n    int i = 0;\n    int j = 1;\n    int k = l.length - 1;\n    long curr\
    \ = l[i];\n    long next = l[j];\n    long prev;\n    bool isIncreasing = true;\n\
    \    bool isDecreasing = true;\n    \n    while (i < k && j < k) {\n        if\
    \ (curr < next) {\n            prev = curr;\n            curr = next;\n      \
    \      next = l[j];\n            isIncreasing = false;\n        } else if (curr\
    \ > next) {\n            prev = curr;\n            curr = next;\n            next\
    \ = l[j];\n            isDecreasing = false;\n        } else {\n            prev\
    \ = curr;\n            curr = next;\n            next = l[j];\n        }\n   \
    \     j++;\n    }\n    \n    if (isIncreasing) {\n        if (prev > curr) {\n\
    \            isDecreasing = false;\n        }\n    } else {\n        if (prev\
    \ < curr) {\n            isIncreasing = false;\n        }\n    }\n    \n    return\
    \ isIncreasing || isDecreasing;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\
    \t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\t\
    return result;\n}", "{\n    long prev = 0;\n    long curr = l[0];\n    bool result\
    \ = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n\
    \        {\n            result = false;\n            break;\n        }\n     \
    \   else if(l[i] > curr)\n        {\n            prev = curr;\n            curr\
    \ = l[i];\n        }\n    }\n    if(!result)\n    {\n        prev = curr;\n  \
    \      curr = l[0];\n    }\n    return result && (prev < curr);\n}", "{\n\tlong\
    \ prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing\
    \ = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < curr)\n\t\
    \t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\
    \tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] == prev)\n\t\t{\n\t\t\tisIncreasing\
    \ = false;\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing\
    \ = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = l[i];\n\
    \t}\n\treturn isIncreasing || isDecreasing;\n}", "{\n\tlong max = l[0];\n\tlong\
    \ min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\
    \t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t}\n\treturn (max < min);\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] <\
    \ min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n\
    \        if(l[i] > max) max = l[i];\n    }\n    return min < max;\n}", "{\n  \
    \  long prev = 0;\n    long curr = l[0];\n    bool result = true;\n    for(int\
    \ i = 1; i < l.length; ++i) {\n        long next = l[i];\n        if (curr > next)\
    \ {\n            result = false;\n            break;\n        }\n        prev\
    \ = curr;\n        curr = next;\n    }\n    return result;\n}", "{\n    long max\
    \ = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] > max)\n            max = l[i];\n        if(l[i] < min)\n   \
    \         min = l[i];\n    }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `monotonic([-10, -9, -8,\
    \ -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` returns `true`,\
    \ but `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11])` returns `false`.\n<|/ c |>\n<| c |>\n: It does work for negative\
    \ numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n<| c |>\n: It does work\
    \ for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n<| c |>\n: It\
    \ does work for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3,\
    \ -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n\
    <| c |>\n: It does work for negative numbers. `monotonic([-10, -9, -8, -7, -6,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n\
    <|/ c |>\n<| a tags=c#,algorithm,sorting |>\nI wrote a C# version that works correctly\
    \ for negative numbers and also for duplicate numbers. \n<code>\npublic static\
    \ bool IsMonotonic(IEnumerable<int> numbers)\n{\n    var numberSet = new HashSet<int>(numbers);\n\
    \    if (numberSet.Count == 0)\n        return true;", "{\n\tlong max = l[0];\n\
    \tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t}\n\treturn (max < min);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max = l[0];\n \
    \   for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n       \
    \     min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n  \
    \  return min <= max;\n}", "{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing\
    \ = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < curr)\n\t\
    \t{\n\t\t\tisIncreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    prev = curr;\n\t\t\tcurr = l[i];\n\t\t}\n\t}\n\treturn isIncreasing;\n}", "{\n\
    \tlong last = l[0];\n\tlong cur = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\
    \t{\n\t\tif(l[i] < cur)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tlast = cur;\n\t\
    \tcur = l[i];\n\t}\n\treturn true;\n}", "{\n    long max = l[0];\n    long min\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        if(l[i] > max)\n     \
    \   {\n            max = l[i];\n        }\n    }\n    return max >= min;\n}",
  "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i]\
    \ < min)\n            min = l[i];\n    }\n    return max >= min;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,sorting |>\n<| c |>\nThis doesn't work. Try it with `monotonic([1L,\
    \ 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L,\
    \ 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L,\
    \ 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L,\
    \ 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L,\
    \ 2L, 4L, 20L])`\n<|/ c |>\n<| a tags=c#,algorithm,sorting |>\n<code>", "{\n\t\
    long max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\
    \t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\t\
    min = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n       \
    \ if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return\
    \ min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min =\
    \ l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min\
    \ <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i\
    \ < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\
    \t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n\
    }", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return max >= min;\n}", "{\n   \
    \ long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n\
    \        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n\
    \    return min < max;\n}", "{\n    long max = l[0];\n    long min = l[0];\n \
    \   bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n      \
    \  if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else\
    \ if(l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n\
    \        {\n            result = false;\n        }\n    }\n    return result;\n\
    }\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/",
  "{\n\tlong min = 0;\n\tlong max = l[0];\n\tlong mid = 0;\n\tbool isIncreasing =\
    \ true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t\
    {\n\t\tmid = l[i];\n\t\tif (mid > max)\n\t\t{\n\t\t\tmax = mid;\n\t\t\tisDecreasing\
    \ = false;\n\t\t}\n\t\telse if (mid < min)\n\t\t{\n\t\t\tmin = mid;\n\t\t\tisIncreasing\
    \ = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i =\
    \ 1; i < l.length; ++i) {\n        if(l[i] < min) {\n            min = l[i];\n\
    \        } else if(l[i] > max) {\n            max = l[i];\n        } else {\n\
    \            result = false;\n        }\n    }\n    return result;\n}", "{\n\t\
    long l = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < l)\n\
    \t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n\tlong min = l[0];\n\
    \tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] <\
    \ min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax\
    \ = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    int i = 0;\n    int\
    \ j = 1;\n    bool result = true;\n    while(i < l.length && j > 0) {\n      \
    \  if(l[i] < l[j]) {\n            result = false;\n            break;\n      \
    \  }\n        else if(l[i] > l[j]) {\n            result = true;\n           \
    \ break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n}",
  "{\n    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(i < l.length\
    \ && j < l.length)\n    {\n        if(l[i] < l[j])\n        {\n            result\
    \ = false;\n            break;\n        }\n        else if(l[i] > l[j])\n    \
    \    {\n            result = true;\n            break;\n        }\n        i++;\n\
    \        j++;\n    }\n    return result;\n}", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i)\
    \ {\n        if (l[i] < min) {\n            min = l[i];\n        } else if (l[i]\
    \ > max) {\n            max = l[i];\n        } else {\n            result = false;\n\
    \        }\n    }\n    return result;\n}", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] <\
    \ min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn (max < min);\n}", "{\n    long min = l[0];\n    long max = l[0];\n  \
    \  for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        \
    \    min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n   \
    \ return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool first\
    \ = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\
    \tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif\
    \ (first) {\n\t\t\tfirst = false;\n\t\t}\n\t\telse {\n\t\t\tif (l[i] < min) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (l[i] > max) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "{\n\tlong min = l[0];\n\tlong max =\
    \ l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long l = l[0];\n    for(int i\
    \ = 1; i < l.length; ++i)\n    {\n        if(l[i] < l)\n        {\n          \
    \  l = l[i];\n        }\n    }\n    return l == l[0];\n}", "{\n    long max =\
    \ l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] > max)\n        {\n            max = l[i];\n        }\n     \
    \   if(l[i] < min)\n        {\n            min = l[i];\n        }\n    }\n   \
    \ return max < min;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    for(int\
    \ i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i]\
    \ > max) max = l[i];\n    }\n    return min < max;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n  \
    \      }\n        if(l[i] > max)\n        {\n            max = l[i];\n       \
    \     result = false;\n        }\n    }\n    return result;\n}", "{\n    long\
    \ prev = 0;\n    long curr = l[0];\n    bool result = true;\n    for(int i = 1;\
    \ i < l.length; ++i)\n    {\n        if(l[i] < curr)\n        {\n            result\
    \ = false;\n            break;\n        }\n        else if(l[i] > curr)\n    \
    \    {\n            prev = curr;\n            curr = l[i];\n        }\n    }\n\
    \    prev = curr;\n    return result;\n}", "{\n    long prev = 0;\n    long curr\
    \ = l[0];\n    long next = 1;\n    bool result = true;\n    \n    for(int i =\
    \ 1; i < l.length; ++i)\n    {\n        prev = curr;\n        curr = next;\n \
    \       next = l[i];\n        \n        if(curr < prev)\n        {\n         \
    \   result = false;\n            break;\n        }\n    }\n    \n    return result;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\
    \tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\
    \t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n\
    \        if(l[i] < min) {\n            min = l[i];\n        }\n        if(l[i]\
    \ > max) {\n            max = l[i];\n        }\n    }\n    return min <= max;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if\
    \ (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t\
    }\n\treturn (min <= max);\n}", "{\n    long max = l[0];\n    long min = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n      \
    \  {\n            max = l[i];\n        }\n        if(l[i] < min)\n        {\n\
    \            min = l[i];\n        }\n    }\n    return max >= min;\n}", "{\n \
    \   long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\
    \ {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n    int n = l.length;\n    if (n < 2)\
    \ return true;\n    long m = l[0];\n    for (int i = 1; i < n; ++i) {\n      \
    \  if (l[i] < m) return false;\n        m = l[i];\n    }\n    return true;\n}",
  "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\
    \t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max\
    \ = l[0];\n\tlong min = l[0];\n\tbool first = true;\n\tfor (int i = 1; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if\
    \ (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (first)\n\
    \t\t\t{\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n        {\n            min = l[i];\n        }\n        else if(l[i]\
    \ > max)\n        {\n            max = l[i];\n        }\n    }\n    return min\
    \ <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i\
    \ < l.length; i++) \n\t{\n\t\tif(l[i] < min) min = l[i];\n\t\tif(l[i] > max) max\
    \ = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n\
    \        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n\
    \    if(min > max)\n    {\n        result = false;\n    }\n    return result;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\t\
    for (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\
    \t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min ||\
    \ l[i] > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n  \
    \      }\n        if(l[i] > max)\n        {\n            max = l[i];\n       \
    \ }\n    }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    long prev = 0;\n    long curr = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n     \
    \   {\n            return false;\n        }\n        else if(l[i] > prev)\n  \
    \      {\n            return true;\n        }\n        prev = curr;\n        curr\
    \ = l[i];\n    }\n    return true;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i) {\n\t\tmax = max(max, l[i]);\n\t\tmin = min(min,\
    \ l[i]);\n\t}\n\treturn (max < min);\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i) {\n\
    \        if (l[i] < min) {\n            min = l[i];\n        }\n        if (l[i]\
    \ > max) {\n            max = l[i];\n        }\n    }\n    if (min > max) {\n\
    \        result = false;\n    }\n    return result;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\t\
    if (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong l = l[0];\n\
    \tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < l)\n\t\t\treturn false;\n\
    \t}\n\treturn true;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min\
    \ <= max);\n}", "{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tfor (int i = 1; i\
    \ < l.length; i++)\n\t{\n\t\tlong next = l[i];\n\t\tif (curr > next)\n\t\t{\n\t\
    \t\treturn false;\n\t\t}\n\t\telse if (curr < prev)\n\t\t{\n\t\t\treturn true;\n\
    \t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn false;\n}", "{\n\tlong\
    \ min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i =\
    \ 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\
    \tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tisMonotonic\
    \ = false;\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t\
    }\n\treturn isMonotonic;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor\
    \ (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\
    \t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (min <=\
    \ max);\n}", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1;\
    \ i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n  \
    \      }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n\
    \    return max < min;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor\
    \ (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax =\
    \ l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\t\
    return (max <= min);\n}", "{\n    long min = l[0];\n    long max = l[0];\n   \
    \ for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n         \
    \   min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return\
    \ min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    for(int\
    \ i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n    \
    \    if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}", "{\n\tlong\
    \ min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\t\
    if (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min\
    \ <= max);\n}", "{\n    int i = 0;\n    int j = 0;\n    bool result = true;\n\
    \    while(i < l.length && j < l.length) \n    {\n        if(l[i] < l[j]) \n \
    \       {\n            result = false;\n            break;\n        }\n      \
    \  else if(l[i] > l[j]) \n        {\n            result = true;\n            break;\n\
    \        }\n        i++;\n        j++;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c++,sorting,arrays |>\n<| c |>\nThis code is not working as expected.\
    \ `monotonic([1L, 2L, 4L, 20L])` returns `true` while it should be `false`.\n\
    <|/ c |>\n<| c |>\nI tested it on [onlinegdb](https://onlinegdb.com/Syw0Y9Y9C)\
    \ and it returns `false`. What compiler are you using?\n<|/ c |>\n<| c |>\nI'm\
    \ using Visual Studio 2019. Maybe it's an issue with my compiler.\n<|/ c |>\n\
    <| c |>\nIt works fine on [onlinegdb](https://onlinegdb.com/Syw0Y9Y9C). Maybe\
    \ you have a problem with your compiler. Try reinstalling it.\n<|/ c |>\n<| c\
    \ |>\nI tested it on [onlinegdb](https://onlinegdb.com/Syw0Y9Y9C) and it returns\
    \ `false`. Maybe it's an issue with my compiler.\n<|/ c |>\n<| a |>\n<code>",
  "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n\tlong\
    \ max=0;\n\tlong min=l[0];\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tif(l[i]>max)\n\
    \t\t\tmax=l[i];\n\t\tif(l[i]<min)\n\t\t\tmin=l[i];\n\t}\n\tif(max<min)\n\t\treturn\
    \ false;\n\treturn true;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool\
    \ isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\t\
    max = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max)\n\t\t{\n\t\t\tisMonotonic\
    \ = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n\tlong min = l[0];\n\t\
    long max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tbool result = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] <\
    \ min) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max) {\n\t\
    \t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long\
    \ max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n \
    \   {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return max >= min;\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i\
    \ < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min\
    \ = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max\
    \ = l[i];\n        }\n        else\n        {\n            result = false;\n \
    \       }\n    }\n    return result;\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\t\
    if(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong\
    \ max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i\
    \ < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif\
    \ (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (max < min) {\n\t\t\tresult\
    \ = false;\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t\
    {\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min < max)\n\t{\n\t\tisMonotonic =\
    \ false;\n\t}\n\treturn isMonotonic;\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        if(l[i] > max)\n     \
    \   {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}",
  "{\n    long last = l[0];\n    long curr = l[0];\n    for (int i = 1; i < l.length;\
    \ ++i) {\n        if (l[i] < last) {\n            return false;\n        }\n \
    \       if (l[i] > curr) {\n            return true;\n        }\n        last\
    \ = curr;\n        curr = l[i];\n    }\n    return true;\n}", "{\n\tlong min =\
    \ l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i <\
    \ l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\tisMonotonic\
    \ = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n        {\n            min = l[i];\n        }\n        else if(l[i]\
    \ > max)\n        {\n            max = l[i];\n        }\n    }\n    return min\
    \ <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    bool result\
    \ = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        else if (l[i] > max)\n\
    \        {\n            max = l[i];\n        }\n        else\n        {\n    \
    \        result = false;\n            break;\n        }\n    }\n    return result;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t\
    }\n\treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\t\
    for (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin\
    \ = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\t\
    return (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int\
    \ i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] >\
    \ max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\t\
    long max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong l = l[0];\n\tfor (int i = 1;\
    \ i < l.length; ++i)\n\t{\n\t\tif (l[i] < l)\n\t\t\treturn false;\n\t}\n\treturn\
    \ true;\n}", "{\n    long max = l[0];\n    long min = l[0];\n    bool result =\
    \ true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n\
    \        {\n            max = l[i];\n        }\n        else\n        {\n    \
    \        result = false;\n        }\n    }\n    return result;\n}", "{\n    long\
    \ max = l[0];\n    long min = l[0];\n    bool isMonotonic = true;\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n      \
    \      isMonotonic = false;\n            break;\n        }\n        if(l[i] >\
    \ max)\n        {\n            isMonotonic = false;\n            break;\n    \
    \    }\n    }\n    return isMonotonic;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\
    \t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max =\
    \ l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n\
    \        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}", "{\n \
    \   int n = l.length;\n    if (n < 2) return true;\n    long first = l[0];\n \
    \   long last = l[n-1];\n    long mid = first + (n-1)/2;\n    long mid2 = mid\
    \ + (n-1)/2;\n    long mid3 = mid2 + (n-1)/2;\n    long mid4 = mid3 + (n-1)/2;\n\
    \    long mid5 = mid4 + (n-1)/2;\n    long mid6 = mid5 + (n-1)/2;\n    long mid7\
    \ = mid6 + (n-1)/2;\n    long mid8 = mid7 + (n-1)/2;\n    long mid9 = mid8 + (n-1)/2;\n\
    \    long mid10 = mid9 + (n-1)/2;\n    long mid11 = mid10 + (n-1)/2;\n    long\
    \ mid12 = mid11 + (n-1)/2;\n    long mid13 = mid12 + (n-1)/2;\n    long mid14\
    \ = mid13 + (n-1)/2;\n    long mid15 = mid14 + (n-1)/2;\n    long mid16 = mid15\
    \ + (n-1)/2;\n    long mid17 = mid16 + (n-1)/2;\n    long mid18 = mid17 + (n-1)/2;\n\
    \    long mid19 = mid18 + (n-1)/2;\n    long mid20 = mid19 + (n-1)/2;\n    long\
    \ mid21 = mid20 + (n-1)/2;\n    long mid22 = mid21 + (n-1)/2;\n    long mid23\
    \ = mid22 + (n-1)/2;\n    long mid24 = mid23 + (n-1)/2;\n    long mid25 = mid24\
    \ + (n-1)/2;\n    long mid26 = mid25 + (n-1)/2;\n    long mid27 = mid26 + (n-1)/2;\n\
    \    long mid28 = mid27 + (n-1)/2;\n    long mid29 = mid28 + (n-1)/2;\n    long\
    \ mid30 = mid29 + (n-1)/2;\n    long mid31 = mid30 + (n-1)/2;\n    long mid32\
    \ = mid31 + (n-1)/2;\n    long mid33 = mid32 + (n-1)/2;\n    long mid34 = mid33\
    \ + (n-1)/2;\n    long mid35 = mid34 + (n-1)/2;\n    long mid36 = mid35 + (n-1)/2;\n\
    \    long mid37 = mid36 + (n-1)/2;\n    long mid38 = mid37 + (n-1)/2;\n    long\
    \ mid39 = ", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1;\
    \ i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n  \
    \      }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n\
    \    return max >= min;\n}\n/*\nReturn True is list elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    bool isMonotonic = true;\n    for (int i = 1; i < l.length; ++i) {\n    \
    \    if (l[i] < min) min = l[i];\n        if (l[i] > max) max = l[i];\n    }\n\
    \    if (isMonotonic) {\n        if (min < max) {\n            isMonotonic = false;\n\
    \        }\n    }\n    return isMonotonic;\n}", "{\n    long max = l[0];\n   \
    \ long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] >\
    \ max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n     \
    \       min = l[i];\n        }\n    }\n    return min < max;\n}", "{\n    long\
    \ prev = 0;\n    long curr = l[0];\n    for(int i = 1; i < l.length; ++i)\n  \
    \  {\n        if(curr < l[i])\n        {\n            return false;\n        }\n\
    \        else if(curr > l[i])\n        {\n            prev = curr;\n         \
    \   curr = l[i];\n        }\n    }\n    return true;\n}", "{\n    long prev =\
    \ 0;\n    long curr = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n  \
    \      if(l[i] < curr)\n        {\n            return false;\n        }\n    \
    \    else if(l[i] > curr)\n        {\n            return true;\n        }\n  \
    \      else if(l[i] == prev)\n        {\n            continue;\n        }\n  \
    \      else if(l[i] < prev)\n        {\n            return false;\n        }\n\
    \        prev = curr;\n        curr = l[i];\n    }\n    return true;\n}", "{\n\
    \    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn (min <= max);\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor\
    \ (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin =\
    \ l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\t\
    return (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min\
    \ <= max);\n}", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i\
    \ = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n\
    \        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n\
    }", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t\tif (l[i] < min)\n\t\t\
    \tmin = l[i];\n\t}\n\treturn (max <= min);\n}", "{\n\tlong max = l[0];\n\tlong\
    \ min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; i++)\n\t\
    {\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\t\
    if (l[i] > max)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic\
    \ = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\
    \t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n\
    }", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i]\
    \ < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max > min);\n}", "{\n\
    \    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n  \
    \      }\n        if(l[i] > max)\n        {\n            max = l[i];\n       \
    \ }\n    }\n    return min < max;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
