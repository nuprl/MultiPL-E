name: HumanEval_116_sort_array
language: jl
prompt: "\"\"\"\n    In this Kata, you have to sort an array of non-negative integers\
  \ according to\n    number of ones in their binary representation in ascending order.\n\
  \    For similar number of ones, sort based on decimal value.\n\n    It must be\
  \ implemented like this:\n                \"\"\"\nfunction sort_array(arr::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate([1,\
  \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\t@test(candidate([-2, -3, -4, -5, -6]) == [-4,\
  \ -2, -6, -5, -3])\n\t@test(candidate([1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
  \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\t@test(candidate([3, 6, 44, 12, 32, 5])\
  \ == [32, 3, 5, 6, 12, 44])\n\t@test(candidate([2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
  \ 32])\n\t@test(candidate([2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nend\n"
completions: ["    one_bin(n) = count_ones(bin(n))\n    sort(arr, by=one_bin)\nend",
  "end\n\"\"\"\n    So, let's see the examples:\n        sort_array([1,2,3,4,5,6,7,8,9,10])\
    \ == [1,2,4,8,3,5,6,7,9,10]\n        sort_array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])\
    \ ==\n            [1,2,4,8,16,3,5,6,7,9,10,12,14,11,13,15,17,18,19,20]\n     \
    \   sort_array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32])\
    \ ==\n            [1,2,4,8,16,32,3,5,6,7,9,10,12,14,11,13,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]\n\
    \        sort_array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50])\
    \ ==\n            [1,2,4,8,16,32,3,5,6,7,9,10,12,14,11,13,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]\n\
    \        sort_array([1,2,3,", "    # sort the array according to\n    # number\
    \ of ones in their binary representation\n    # for similar number of ones, sort\
    \ based on decimal value.\n    # sort!(arr, by = [x->bits(x), x->x])\n    # sort!(arr,\
    \ by = [x->bits(x), x->x])\n    sort!(arr, by = [x->bits(x)])\n    sort!(arr,\
    \ by = [x->x])\n    return arr\nend", "  #your code here\nend\n\"\"\"\nExamples:\n\
    sort_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \n#[0, 1, 2, 4, 8, 3, 5, 6, 7,\
    \ 9, 10]", "    arr_ones = [count_ones(x) for x in arr]\n    idx = sortperm(arr_ones)\n\
    \    return arr[idx]\nend", "    # put your codes here\n    return arr\nend",
  "    ones = Dict{Int64, Vector{Int64}}()\n    for i = 1:length(arr)\n        bin\
    \ = decimal_to_binary(arr[i])\n        ones[count_ones(bin)] = [arr[i]]\n    end\n\
    \    sort!(values(ones), rev=true)\n    collect(sort(keys(ones)))\nend", "   \
    \ sort(arr, by = (x) -> begin\n        ones(x) # the number of ones in its binary\
    \ representation\n        # x # in case of a tie, sort by the decimal value\n\
    \    end)\nend\n\"\"\"\n\"\"\"\n\"\"\"\n## Sort Array By Binary Digits:", "  #\
    \ sort it for the number of ones ascending\n  sorted_arr = sort(arr, by = x ->\
    \ count_ones(x))\n  # sort it for the number of ones ascending\n  sorted_arr =\
    \ sort(sorted_arr, by = x -> (count_ones(x), x))\n  return sorted_arr\nend", " \
    \   sorted_arr = sort(arr, by = x -> (count_ones(x), x))\n    return sorted_arr\n\
    end", "    @tidy arr |> _\nend", "    # Your code here!\nend", "    \"\"\"\n \
    \   return sorted array\n    \"\"\"\n    K = zeros(Int64, length(arr))\n    binarr\
    \ = zeros(Int64, length(arr))\n    newarr = zeros(Int64, length(arr))\n    for\
    \ i in 1:length(arr)\n        binarr[i] = binary(arr[i])\n        K[i] = count(x\
    \ -> x == '1', binarr[i])\n    end\n    for i in 1:length(arr)\n        newarr[i]\
    \ = minimum(arr[K .== i])\n        arr[arr .== newarr[i]] = 0\n    end\n    return\
    \ newarr\nend", "        return sort(arr, by = x -> (tuple(count_ones(x), x)))\n\
    \    end", "    return sort(collect(zip(arr, [sum(x) for x in bitstring.(arr)])),\
    \ by=x->x[2])[:,1]\nend", "    binary_representation = map(x -> bin(x)[2:end],\
    \ arr)\n    sort_matrix = map(x -> x[1], zip(binary_representation, arr))\n  \
    \  sort_matrix_ones = map(x -> (occurrences(x[1], '1'), x[2]), sort_matrix)\n\
    \    sort_matrix_ones_decimal = sort(sort_matrix_ones, lt = (x, y) -> \n     \
    \   x[1] < y[1] || x[1] == y[1] && x[2] < y[2])\n    return map(x -> x[2], sort_matrix_ones_decimal)\n\
    end", "    return sort(arr, by=a->(length(findall(match(r\"1\"), binary(a))),\
    \ a))\nend", "    sort(arr, by = item->(sum(digits(item, 2))*length(digits(Int(bitmax()),\
    \ 2)), item))\nend", "    # your code here\nend", "    # Sort array according\
    \ to number of ones and decimal value\n    return sort(arr, lt=(x,y) -> count_ones(x)\
    \ < count_ones(y) || (count_ones(x) == count_ones(y) && x < y))\nend", "    #\
    \ code goes here\nend\n\"\"\"\n    Note:", "    \"\"\"function to sort the array\
    \ based on the binary\n    representations of the array elements.", "    res =\
    \ Array{Tuple{Int64, Int64}}(length(arr))\n    for i = 1:length(arr)\n       \
    \ res[i] = (convert(Int64, count_one(string(binary(arr[i])))), arr[i])\n    end\n\
    \    sort!(res)\n    return [x[2] for x in res]\nend", "    ones = dict()\n  \
    \  for i in 1:length(arr)\n        n = count_ones(arr[i])\n        if haskey(ones,\
    \ n)\n            push!(ones[n], arr[i])\n        else\n            ones[n] =\
    \ [arr[i]]\n        end\n    end\n    sorted_keys = sort(collect(keys(ones)))\n\
    \    res = Int64[]\n    for i in 1:length(sorted_keys)\n        push!(res, sort(ones[sorted_keys[i]]))\n\
    \    end\n    return vec(res)\nend", "    return sort(arr, by = b -> (Base.one_count(b),\
    \ b))\nend", "    # Sort nums by binary rep numbers of 1s\n    return sort(arr,\
    \ by=n -> length(split(string(n, base=2), \"1\")), rev=true)\nend", "    qsort!(arr,\
    \ 1, length(arr))\n    return arr\nend", "    # Your code here\n    return arr[:]\n\
    end;\n ", "    # your code here\nend\n                \"\"\"\n    Test cases:\n\
    \        sort_array([0,1,3,2,4,5,7,6]) = [0,1,2,4,6,3,5,7]\n        sort_array([5,3,1,7,0,2,4,6])\
    \ = [0,1,2,4,6,3,5,7]\n        sort_array([11,12,13,14,15,16,17,18]) = [16,12,17,13,18,14,11,15]\n\
    \        sort_array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])\
    \ = [0,1,2,4,8,16,3,5,6,9,10,12,17,18,7,11,13,14,19,20,24,21,22,25,26,28,15,23,27,29,30,31]\n\
    \        sort_array([]) = []\n    \"\"\"", "   tmp = 0\n   for i = 1:length(arr)\n\
    \       for j = i:length(arr)\n           if bitcount(arr[i]) > bitcount(arr[j])\n\
    \              tmp = arr[i]\n              arr[i] = arr[j]\n              arr[j]\
    \ = tmp\n           elseif bitcount(arr[i]) == bitcount(arr[j])\n            \
    \  if arr[i] > arr[j]\n                 tmp = arr[i]\n                 arr[i]\
    \ = arr[j]\n                 arr[j] = tmp\n              end\n           end\n\
    \       end\n   end\n   return arr\nend\n\"\"\"", "    return sort(arr)\nend",
  "    return sort(arr, by = x -> (count_ones(x), x))\nend\n\"\"\"\n    Example:",
  "    \n    ones_vec = [] #initializing a vector for the number of ones in the binary\
    \ representation of each element in the input vector\n    sorted_ones_vec = []\
    \ #initializing a vector for the elements of the input vector after sorting\n\
    \    for i in 1:length(arr)\n        binary_vec = bitstring(arr[i]) #converting\
    \ each element of the input vector to binary\n        ones_vec = [ones_vec; count(x\
    \ -> x == '1', binary_vec)] #counting the number of ones in the binary representation\
    \ of each element\n    end\n    sorted_ones_vec = sortperm(ones_vec) #sorting\
    \ the number of ones in ascending order\n    for i in 1:length(arr)\n        arr[i]\
    \ = sorted_ones_vec[i] #converting the sorted vector back to the original input\
    \ vector\n    end\n    return arr\nend", "end\n                \"\"\"\n    Example:\n\
    \                \"\"\"\nsort_array([1,2,3,4,5,6,7,8,9,10]) = [1,2,4,8,3,5,6,7,9,10]\n\
    \                \"\"\"\n    And then sort them in ascending order:\n        \
    \        \"\"\"\nsort_array([1,2,4,8,3,5,6,7,9,10]) = [1,2,3,4,5,6,7,8,9,10]\n\
    \    # Convert to Binary (do not sort binary numbers):\n        n = 1 -> [1]\n\
    \        n = 2 -> [1,0]\n        n = 3 -> [1,1]\n        n = 4 -> [1,0,0]\n  \
    \      n = 5 -> [1,0,1]\n        n = 6 -> [1,1,0]\n        n = 7 -> [1,1,1]\n\
    \        n = 8 -> [1,0,0,0]\n        n = 9 -> [1,0,0,1]\n        n = 10 -> [1,0,1,0]\n\
    \    # for n = 2^k, then binary(n) = k 1's followed by k 0's.\n    # for n = 2^k\
    \ - 1, then binary(n) = k 1's.\n\"\"\"", "    sort(arr, by = x -> [sum(digits(x,\
    \ 2)), x])\nend", "    \"\"\"\n    In this Kata, you have to sort an array of\
    \ non-negative integers according to\n    number of ones in their binary representation\
    \ in ascending order.\n    For similar number of ones, sort based on decimal value.",
  "    return sort(arr, by = tuple -> [count_ones(tuple), tuple])\nend", "    # IMPLEMENT\
    \ ME\nend\n                \"\"\"\n    For example,", "    # Sort the array according\
    \ to binary representation\n    # For similar number of ones, sort based on decimal\
    \ value\n    # ... your code here ...\nend", "    # Your code here\nend\n\"\"\"\
    \n    Example:\n    sort_array([5, 3, 7, 10, 14])\n            # expected_output\
    \ = [3, 5, 10, 14, 7]", "    # Your code goes here\n    return sort(arr, by =\
    \ x -> [count_ones(x), x])\nend", "    ## Your solution here\n    end\nend\n##\
    \ The idea for this one was to take each element of the array and convert it\n\
    ## to a binary string, then count the number of ones in that string. Then i \n\
    ## sorted the array based on the number of ones in the binary string. Lastly,\n\
    ## i used a lambda function to sort the array based on the values if the \n##\
    \ number of ones was equal.", "    indexes = sortperm(count_ones.(arr), by = x\
    \ -> x[1])\n    sort(arr[indexes], by = x -> x[2])\nend\n ", "    length(arr)\
    \ == 0 && return arr\n    convert(Int64, count(x -> x == '1', string(x, base=2)))\
    \ for x in arr\n    sort(arr, by=x->(convert(Int64, count(x -> x == '1', string(x,\
    \ base=2))), x))\nend", "    x = sort(arr, by = countones)\n    return x\nend",
  "    return sortperm(arr, rev=true)\nend", "    \"\"\"\n    #using Statistics\n\
    \    #return sort(arr, by = (x -> Int(sum(digits(x, base=2))), identity))\n  \
    \  return sort(arr, by = (x -> count_ones(x), identity))\nend", "  # Sort by number\
    \ of ones, then numerical value\n  return sort(arr, by = x -> (count_ones(x),\
    \ x))\nend\nsort_array([1,2,3,4,5,6,7,8,9,10])", "    bits = [b\"$x\" for x in\
    \ arr]\n    ones = [sum(Int64.(b[:end-1])) for b in bits]\n    return sortperm(ones)[sort(arr[sortperm(ones)])]\n\
    end", "\nend", "    (i, x, y) = findmin(arr)\n    sorted = sort(collect(arr))\n\
    \    return sorted\nend\nsort_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n#sort_array([0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [0, 1, 2, 4, 8, 3, 5, 6, 9, 10, 7]", "  \
    \  binary_representation = []\n    for i = 1:length(arr)\n        binary_representation\
    \ = [binary_representation ; sum(digits(arr[i], base=2))]\n    end\n    return\
    \ sortperm(binary_representation)\nend\nsort_array([1,10,11,100,101,110,111])",
  '"""', "    # code here\nend\n                \"\"\"\nFor example:\n           \
    \     \"\"\"\nsort_array([2, 8, 5, 2, 6, 3]) = [2, 2, 3, 5, 6, 8]\n          \
    \      \"\"\"\n    because:", "    return sort(arr, by = x -> (count_ones(x),\
    \ x))\nend", "    (1:10) .+ 1 # this is a dummy operation, please implement the\
    \ logic here\nend", "    sort(arr, by=x->(sum(int(i=='1') for i in string(bitstring(x))),\
    \ x))\nend\n\"\"\"\n\"\"\"\n                \"\"\"\nTEST CASES:\n            \
    \    \"\"\"\n@testset \"sorted array\" begin\n    @test sort_array([0,1,2,3,4,5,6,7,8,9])\
    \ == [0,1,2,4,8,3,5,6,7,9]\n    @test sort_array([1024,512,256,128,64,32,16,8,4,2,1])\
    \ == [1,2,4,8,16,32,64,128,256,512,1024]\n    @test sort_array([10,100,1000,10000])\
    \ == [10,100,10000,1000]\n    @test sort_array([1,10,100,1000,10000]) == [1,10,100,10000,1000]\n\
    \    @test sort_array([1,2,100,12303479849857341718340192371,3084193741082937,3084193741082938,111,200])\
    \ == [1,2,100,200,111,3084193741082937,3084193741082938,12303479849857341718340192371]\n\
    end\n\"\"\"\n\"\"\"\n                \"\"\"\nHINTS:\n                \"\"\"\n\
    - Arrays with same number of ones can be sorted using str(x)[::-1].", "    # sort\
    \ on number of ones, then decimal value \n    return sort(arr, by=[(x -> count_ones(x)),\
    \ id])\nend", "    sort(arr, by = x -> (count_ones(x), x))\nend", "  k = length(arr)\n\
    \  s = sort(arr, by = x -> (count_ones(x), x))\n  return s\nend", "    # convert\
    \ arr to binary strings\n    s = Dict{Int64,String}()\n    for i in 1:length(arr)\n\
    \        s[arr[i]] = bits(arr[i])\n    end\n    # map binary string to number\
    \ of ones\n    m = Dict{String,Int64}()\n    for (k,v) in s\n        m[v] = sum(v\
    \ .== '1')\n    end\n    # sort by number of ones and then by value\n    sort!(arr,\
    \ by=x->(m[bits(x)],x))\n    return arr\nend", "    sort(arr, by=x->[1 - sum(digits(x,\
    \ 2)), x])\nend", "    \n    # let's first obtain a list of tuples with the binary\
    \ representation and its\n    # length for each number in the array.\n    bin_list\
    \ = map(x -> (x, length(Int(x))), arr)\n    \n    # now let's sort the list based\
    \ on the length of the binary representation of\n    # the number\n    bin_list\
    \ = sort(bin_list, by = x -> x[2])\n    \n    # now, let's obtain a list of tuples\
    \ with the binary representation and its\n    # decimal value for each number\
    \ in the array.\n    dec_list = map(x -> (x, bin2dec(x)), arr)\n    \n    # now,\
    \ let's sort this list based on the value of the binary representation of\n  \
    \  # the number\n    dec_list = sort(dec_list, by = x -> x[2])\n    \n    # now\
    \ let's loop through the dec_list and replace its values by the values from\n\
    \    # the sorted binary list\n    for i in 1:length(dec_list)\n        dec_list[i][1]\
    \ = bin_list[i][1]\n    end\n    \n    # now, let's obtain a list with the decimal\
    \ values from the dec_list\n    arr = map(x -> x[1], dec_list)\n    \n    return\
    \ arr\nend", "    #your code here\nend\n\"\"\"\n    Example:\n    sort_array([2,\
    \ 3, 8, 5, 6, 7, 1]) == [1, 2, 3, 5, 6, 7, 8]", "    return zero_one_list_sort(arr)\n\
    end", "    # your code here\nend\n                \"\"\"\n    You are guaranteed\
    \ that the input array is not empty and contains at least \n    1 element.", " \
    \   sort([x for x in arr], by=x->(count_ones(x), x))\nend", "   # your code here\n\
    end\n            \"\"\"\n    Like in the previous Kata, if there are some more\
    \ efficient methods, please\n    let me know.", "    return sort(arr, by = [ones,\
    \ identity])\nend", "    # Write your code here\n    b = [bin(x) for x in arr]\n\
    \    sort(arr, by = x -> (count(x -> x == '1', b[x]), arr[x]))\nend", "    \"\"\
    \"\n    This is the main function for sorting.\n    It sorts the input array by\
    \ 2 subfunctions.\n    \"\"\"\n    # Sort by count of one in the binary representation\
    \ of the number\n    binarr = sort(arr, by=nones)\n    # Sort by the number itself\n\
    \    # The sort function is stable, so elements with equal values of nones\n \
    \   #   will be in the same order as before\n    binarr = sort(binarr)\n    return\
    \ binarr\nend", "    return sort(arr, by = x -> (num_ones(x), x))\nend", "   \
    \ # This is the main method for this specific problem.\n    # \n    # IMPORTANT:\n\
    \    # this is a generic method that can be reused for other problems\n    # we\
    \ are sorting a Vector{Int64} by the number of ones in their binary representation\n\
    \    # \n    # the algorithm is as follows:\n    # 1. we convert each Int64 in\
    \ the array to binary, then we sum the number of ones\n    # 2. we create a 'dictionary'\
    \ (a Dict{Int64, Vector{Int64}} that maps the number of ones -> a Vector{Int64}\
    \ that contains the decimal Int64\n    # 3. we sort the keys of the dictionary\
    \ and loop over them, with the current key we loop over the Vector{Int64} that\
    \ is mapped\n    #    and add the Int64s to the result\n    # 4. return the result\
    \ array\n    \n    # create a dictionary to map the number of ones in binary ->\
    \ a Vector{Int64}\n    # this will have the format:\n    # key -> the number of\
    \ ones in binary\n    # value -> a Vector{Int64} with decimal numbers that have\
    \ that number of ones in binary\n    onesDict = Dict{Int64, Vector{Int64}}()\n\
    \    \n    # loop over the input array, for each Int64 we go through the following\
    \ steps:\n    # 1. convert to binary using the 'digits' function\n    # 2. count\
    \ the number of ones using 'count' and '=='\n    # 3. add the Int64 to the correct\
    \ Vector in the dictionary\n    for i in arr\n        numOnes = count(digits(i,\
    \ base=2) .== 1)\n        if numOnes in keys(onesDict)\n            push!(onesDict[numOnes],\
    \ i)\n        else\n            onesDict[numOnes] = [i]\n        end\n    end\n\
    \    \n    # sort the keys of the dictionary\n    keysArr = sort(collect(keys(onesDict)))\n\
    \    \n    # create the result array\n    result = Vector{Int64}()\n    \n   \
    \ # loop over the sorted array of keys, for each key we loop over the Vector{Int64}\n\
    \    # and push all the Int64s to the result array", "    new_sorted_arr = zeros(Int64,\
    \ length(arr))\n    for i = 1:length(arr)\n        new_sorted_arr[i] = countones(arr[i])\n\
    \    end\n    return new_sorted_arr\nend", "\nend\n                \"\"\"\n  \
    \  Example:\n    [3, 8, 4, 15] will be sorted as [3, 4, 8, 15] since 3 has only\
    \ one 1 in its binary representation,\n    4 has two 1s, 8 has three 1s and 15\
    \ has four 1s.", "    sorted(arr, by=x->(count_ones(x), x))\nend\n    \n    ",
  "    #your code here\nend\n    \"\"\"\n    so, the input should be a vector of integers,\
    \ sorted in place according to\n    the number of ones in the binary representation\
    \ of each number.\n    The output should be the sorted vector.", "    v = sort(arr,\
    \ by = x -> count_ones(x))\n    sort(v, by = x -> x)\nend", "    # do something\n\
    end\n\"\"\"\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] => [1, 2, 4, 8, 3, 5, 6, 7, 9,\
    \ 10]", "    # Enter code here.\n    return sort(arr, by = x -> (count_ones(x),\
    \ x))\nend", "  return sort(arr, by=x->(count_ones(x), x))\nend", "    # [<decimal>\
    \ <\"ones\">]\n    ones = [count_ones(x) for x in arr]\n    # sort based on number\
    \ of ones\n    idx = sortperm(ones)\n    # extract the sorting orders and apply\
    \ on original array\n    return arr[idx]\nend", "    \"\"\"\n    ...\n    \"\"\
    \"\n    # your code\nend", "    binary = [ [count_ones(i), i] for i in arr ]\n\
    \    sort!(binary, rev=true)\n    return [binary[i][2] for i in 1:length(binary)]\n\
    end", "    out = copy(arr)\n    let sort!(x,y) = \n        if bits(x)[2] > bits(y)[2]\n\
    \            return false\n        elseif bits(x)[2] < bits(y)[2]\n          \
    \  return true\n        else\n            return x > y\n        end\n    end\n\
    \    sort!(out, by=sort!)\n    return out\nend", "    #Your code here\nend\n \
    \               \"\"\"\n    \"\"\"\n    b = [Int(bin(x)[2:]) for x in arr]\n \
    \   c = [count(x, \"1\") for x in b]\n    d = sortperm(c, by=x->x[1])\n    e =\
    \ [b[x] for x in d]\n    g = [Int(x,2) for x in e]\n    return g\nend", "    \"\
    \"\"\n    insert function for sorting your array\n    \"\"\"\n    return sort(arr,\
    \ lt=(x,y) -> \n        length(matches(r\"1\", string(x, base=2))) < length(matches(r\"\
    1\", string(y, base=2))) ? true :\n        length(matches(r\"1\", string(x, base=2)))\
    \ > length(matches(r\"1\", string(y, base=2))) ? false :\n        x < y\n    )\n\
    end", "    return sort(arr, by = x -> (sum(digits(x, 2)), x))\nend", "    # sort\
    \ array according to number of ones\n    # and for similar number of ones, sort\
    \ based on decimal value.\n    # NOTE: We *must* sort `arr` from inside the function.\n\
    \    # NOTE: We *can't* create a global function and use sort.\n    # NOTE: We\
    \ *must* sort `arr` in place, inside the function.\n    # NOTE: We *can't* return\
    \ a new Array, only the argument!\n    # TODO: Write code to sort `arr` inside\
    \ the function.\n    # TODO: Don't forget to return `arr`!\n    n = length(arr)\n\
    \    sorted = false\n    while !sorted\n        sorted = true\n        for i in\
    \ 1:n-1\n            if dec_to_bin(arr[i]) > dec_to_bin(arr[i+1])\n          \
    \      arr[i], arr[i+1] = arr[i+1], arr[i]\n                sorted = false\n \
    \           end\n        end\n    end\n    return arr\nend", "    input = copy(arr)\n\
    \    non_zeros = input[input .!= 0]\n    zeros = ones(sum(input .== 0))\n    input\
    \ = filter(a -> a != 0, input)\n    input = sort([(sum(bits(i)), i) for i in input])\n\
    \    [i[2] for i in input]\n    # your code\nend", "    #your code here\nend\n\
    \"\"\"", "    return sort(arr, by=x->(sum(digits(x,2)),x))\nend", "   # remove\
    \ this and enter your solution\nend", "    sorted_arr = sort(arr, by=x->count_bits(x))\n\
    \    return sorted_arr\nend", "\nsort_array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \
    \ --> [1, 2, 4, 8, 3, 5, 6, 7, 9, 10]\nsort_array([1024, 512, 256, 128, 64, 32,\
    \ 16, 8, 4, 2, 1])  --> [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\nsort_array([1000,\
    \ 10000, 100, 10, 100000])  --> [10, 100, 1000, 10000, 100000]\n\"\"\"\n    ###############\n\
    \    # YOUR CODE HERE\n    ###############\n    \n    # check if the number is\
    \ negative, if so, move it to the end\n    # if not, find the binary representation\
    \ and calculate the number of 1s\n    # sort it, move negative number to the front\n\
    \    # return it\n    #\n    #\n    #\n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n\
    \    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n   ", "  \"\"\"\n  Sorts\
    \ the input `arr` in place.", "    arr = sort(arr)\n    return arr\nend", "  \
    \  return (\n      sort(arr, by=x->(count_ones(x), x))\n    )\nend", "    #your\
    \ code here\nend\narr = [1,0,10,9,1000,5,2,3,15,11,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "    #your code here\n    return sort(arr, by = x -> (Integer(count_ones(x), base\
    \ = 2), x))\nend", "    # your code\nend\n\"\"\"", "    return sort(arr, by =\
    \ x -> [count_ones(x), x])\nend\n# @test sort_array([7,2,3,9,9,9,8,8,7,7,7,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,",
  "    # your code here\nend\n\"\"\"\n    \n    For example:\n        sort_array([1,0,3,4,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0",
  "    #...\nend\n\"\"\"\n    For example, these are the binary representations of\
    \ the integers in the array:\n        \"\"\"\ni_to_bin(9) = \"1001\"\ni_to_bin(2)\
    \ = \"10\"\ni_to_bin(5) = \"101\"\ni_to_bin(8) = \"1000\"\ni_to_bin(3) = \"11\"\
    \ni_to_bin(7) = \"111\"\ni_to_bin(6) = \"110\"\ni_to_bin(4) = \"100\"\n\"\"\"\n\
    \    By applying sort_array to the above array,\n    you should get [2, 8, 4,\
    \ 3, 5, 6, 7, 9].\n\"\"\"\nsort_array([9, 2, 5, 8, 3, 7, 6, 4]) == [2, 8, 4, 3,\
    \ 5, 6, 7, 9]\n\"\"\"\n    The result should be:\n        \"\"\"\nsort_array([4,\
    \ 2, 9, 5, 8, 6, 7, 3]) == [2, 8, 4, 3, 5, 6, 7, 9]\n\"\"\"\n    It should be\
    \ sorted like this:\n        \"\"\"\nsort_array([4, 2, 9, 5, 8, 6, 7, 3]) == [2,\
    \ 8, 4, 3, 5, 6, 7, 9]\n\"\"\"\n    At last, the following should be true:\n \
    \       \"\"\"\nsort_array([9, 2, 5, 8, 3, 7, 6, 4]) == [2, 8, 4, 3, 5, 6, 7,\
    \ 9]\nsort_array([4, 2, 9, 5, 8, 6, 7, 3]) == [2, 8, 4, 3, 5, 6, 7, 9]\nsort_array([7,\
    \ 9, 2, 4, 2, 9, 5, 8, 3, 7, 6, 4, 1, 9, 5, 8, 3, 7, 6, 4]) ==\n    [2, 8, 4,\
    \ 3, 5, 6, 7, 9, 2, 8, 4, 3, 5, 6, 7, 9, 1, 8, 4, 3, 5, 6, 7, 9]\n\"\"\"\n\"\"\
    \"\n    If you", "    n = length(arr)\n    #creates an empty array to store binary\
    \ representation of numbers\n    bin_arr = zeros(Int64,n)\n    for i in 1:n\n\
    \        bin_arr[i] = integer(bits(arr[i]))\n    end\n    #we are merging two\
    \ arrays here\n    #bin_arr is our key array\n    #arr is our value array\n  \
    \  #we are using this merge sort implementation that takes two arrays as input\n\
    \    #so we can merge them simultaneously\n    merge_sort!(bin_arr,arr)\n    #I\
    \ am returning the value array here\n    return arr\nend", "    return sort(arr,\
    \ by = [x -> bits(x), id])\nend", "    return sort(arr, by = [numones, identity])\n\
    end", "    b = [bitstring(x) for x in arr]\n    function cmp(x, y)\n        if\
    \ sum(x) == sum(y)\n            return x < y\n        else\n            return\
    \ sum(x) < sum(y)\n        end\n    end\n    return sort(arr, cmp)\nend", "  \
    \  return sort([(count_ones(x), x) for x in arr])[:,2]\nend\n\"\"\"", "    # your\
    \ code here\nend\n                \"\"\"\n    \n    For example:\n        sort_array([1,\
    \ 4, 2, 4, 3, 5, 1, 0]) == [0, 1, 1, 2, 3, 4, 4, 5]\n\"\"\"", "    my_dict = Dict(arr[i]\
    \ => count_ones(arr[i]) for i in 1:length(arr))\n    #println(my_dict)\n    return\
    \ sort(collect(keys(my_dict)), lt=(x,y) -> (my_dict[x] < my_dict[y] || (my_dict[x]\
    \ == my_dict[y] && x < y)))\nend", "    tmp = []\n    for i in arr\n        for\
    \ j in arr\n            if bitcount(i) == bitcount(j)\n                tmp = [j]\n\
    \            end\n        end\n    end\n    sort(tmp)\nend", "    return sort(arr,\
    \ by = (x->zeros(Int,popcount(x))), rev=true)\nend\n\"\"\"", "    sorted_ones\
    \ = sort(arr, by = x -> (convert(Int64, count_ones(x)), x))\n    return sorted_ones\n\
    end", "    # Call bin_ones and store the ones count and index in a \n    # tuple\
    \ list, where the first value is the ones count, and the second\n    # is the\
    \ actual index.\n    tmp = [bin_ones(i) for i in arr]\n    # Sort the list by\
    \ the ones count, and sort the equal ones count\n    # by the decimal value\n\
    \    tmp = sort!(tmp, by = [x->x[1], x->x[2]])\n    # Swap the ones count and\
    \ the index\n    tmp = swap!(tmp, 1, 2)\n    # Get the sorted decimal values\n\
    \    tmp = [arr[i] for i in tmp]\n    return tmp\nend", "    res = sort(arr, by=bitcount,\
    \ rev=true)\n    sort(res, by=identity, rev=true)\nend", "    #binary = map(x\
    \ -> decimal_to_binary(x), arr)\n    binary = map(decimal_to_binary, arr)\n  \
    \  ordered = sort(zip(binary, arr), lt = (a, b) -> a[1] < b[1] || (a[1] == b[1]\
    \ && a[2] < b[2]))\n    return map(x -> x[2], ordered)\nend", "    return sort(arr)\
    \ do x, y\n        count_ones(x) == count_ones(y) ? x <=> y : count_ones(x) <=>\
    \ count_ones(y)\n    end\nend", "    # Sort the given array of non-negative integers\n\
    \    # according to binary representation of the numbers.\n    # If the number\
    \ of 1s in the binary represantation of a number is equal\n    # to that of another\
    \ number, then the number with the lower decimal\n    # value should be sorted\
    \ first.", "    # magic code\nend\n                \"\"\"", "    return sort(arr,\
    \ by=x->(count_ones(x), x))\nend", "    non_negative = [x > 0 for x in arr]\n\
    \    if any(non_negative)\n        non_negative_arr = arr[non_negative]\n    \
    \    arr = sort(non_negative_arr, by = x -> (count_ones(x), x))\n    end\n   \
    \ return arr\nend", "    bit_array = [bit_count(i) for i in arr]\n    sort!(bit_array,arr)\n\
    \    return arr\nend", "    #...\nend\"\"\"\n\"\"\"\n    Example 1:\n    sort_array([3,\
    \ 2, 1]) # => [1, 2, 3]\n    \n    (3=11, 2=10, 1=01)", "    sort(arr, by = x\
    \ -> (count_ones(x), x))\nend", "end\n                \"\"\"\n    For example:\n\
    \        sort_array([0,1,2,3,4,5,6,7,8,9]) == [0,1,2,4,8,3,5,6,7,9]\n\"\"\"",
  "    sort(arr, by=x->(count_ones(x), x))\nend", "    sort!(arr)\n    return arr\n\
    end", "    sort!(arr) do a, b\n        binA = count_ones(a)\n        binB = count_ones(b)\n\
    \        # Case A:\n        if binA < binB return true end\n        # Case B:\n\
    \        if binA > binB return false end\n        # Case C:\n        return a\
    \ < b\n    end\n    return arr\nend", "    # sort the array acc to 1s in its binary\
    \ in ascending order\n    # and in case of same no of 1s, sort acc to their decimal\
    \ value", "    @assert length(arr) >= 1 \"Array length must be greater than or\
    \ equal to 1\"\n    return sort(arr, by=bin_ones_dec_value)\nend", "    #Code\
    \ here\nend\n                \"\"\"\n    For example:\n                \"\"\"\n\
    sort_array([1, 0, 10, 12, 11]) == [0, 1, 10, 11, 12] # (1) -> (1) -> (10) -> (11)\
    \ -> (12)\nsort_array([1, 0, 10, 11, 12]) == [0, 1, 10, 11, 12] # (1) -> (1) ->\
    \ (10) -> (11) -> (12)\nsort_array([]) == []\n                \"\"\"\n    More\
    \ examples:\n                \"\"\"\nsort_array([512, 767, 1024, 3072, 1024, 2048,\
    \ 3072, 4096, 5120, 6144, 4096, 5120, 6144, 4096, 5120, 6144])\nsort_array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32])\n\
    sort_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\
    \ 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])\nsort_array([1024,2048,3072,4096,5120,6144,7168,8192,9216,10240,11264,12288,13312,14336,15360,16384,17408,18432,19456,20480,21504,22528,23552,24576,25600,26624,27648,28672,29696,30720,31744,32768,33792,34816,35840,36864,37888,38912,39936,40960,41984,43008,44032,45056,46080,47104,48128,49152,50176,51200,52224,53248,54272,55296,56320,57344,58368,59392,60416,61440,62464,63488,64512,",
  "    return sort(arr, by=x->[count_ones(x), x])\nend", "    idx_unsorted = sortperm(count_ones(x)\
    \ for x in arr);\n    new_arr = [sort(filter(x -> count_ones(x) == count_ones(arr[idx]),\
    \ arr)) for idx in idx_unsorted];\n    return reduce(vcat, new_arr);\nend", " \
    \   sz = length(arr)\n    tmp = []\n    for i in 1:sz\n        push!(tmp,(arr[i],i))\n\
    \    end\n    tmp = sort(tmp,by = (x -> (count_ones(x[1]), x[1])))\n    for i\
    \ in 1:sz\n        arr[i] = tmp[i][1]\n    end\n    return arr\nend\n\"\"\"\n\"\
    \"\"\n    Use the following array to test\n\"\"\"\ntest = [12, 8, 3, 2, 1, 4,\
    \ 11, 7, 6, 5, 10, 15, 9, 14, 13]", "    #your code\nend", "    @assert all(i\
    \ -> i >= 0, arr)\n    return sort(arr, by = [count_ones, id])\nend", "    arr\
    \ = reverse(sort(arr, by = x -> (nones(x), x)));\nend", "    println(\"$arr\"\
    )\n    arr=sort(arr, by=bin_ones)\n    println(\"$arr\")\n    return arr\nend",
  "    #return the sorted array\nend\n                \"\"\"\n    Test.assert_equals(sort_array([1,2,3,4,5,6,7,8,9]),\
    \ [1,2,4,8,3,5,6,7,9])\n    Test.assert_equals(sort_array([23,0,6,8,2,15,6,3,14]),\
    \ [0,2,3,6,8,6,14,15,23])\n\"\"\"", "    \n    j = 0\n    ones = []\n    for i\
    \ in arr\n        j = j + 1\n        # convert to binary\n        bin = Int(string(i,\
    \ base=2))\n        sum1 =  sum(digits(bin))\n        push!(ones, sum1)\n    end\n\
    \    \n    # sort based on ones in binary ascending order\n    sorted = sort(arr,\
    \ by=ones)", "    # Your code goes here\n    sorted_array = sort(arr, by=to_bin_str)\n\
    \    return sorted_array\nend", "    \"\"\"Returns the sorted array based on their\
    \ ones in binary\"\"\"\n    size = length(arr)\n    arr_ones = ones(size)\n  \
    \  arr_decimal = copy(arr)\n    for i in 1:size\n        arr_ones[i] = count_ones(arr[i])\n\
    \    end\n    sort(arr_ones, arr_decimal)\n    return arr_decimal\nend", "   \
    \ reverse = sort(arr, by = x -> count_ones(x), rev = true)\n    return reverse\n\
    end", "    return sort(arr, by=x->(count(digits(x, base=2)), x))\nend", "    #\
    \ ...\nend", "\"\"\"\n[7,3,9,6,0,1,8,10,4,2,5] -> [0,1,2,4,3,5,6,8,7,9,10]\n[7,3,9,6,0,1,8,10,4,2,5]\
    \ -> [0,1,2,4,3,5,6,8,7,9,10]\n[7,3,9,6,0,1,8,10,4,2,5] -> [0,1,2,4,3,5,6,8,7,9,10]\n\
    [7,3,9,6,0,1,8,10,4,2,5] -> [0,1,2,4,3,5,6,8,7,9,10]\n                \"\"\"",
  "  binary_onn_off = map(x -> convert(Int64,x->Binary(x)),arr)\n  sort(arr, by =\
    \ x -> (sum(collect(binary_onn_off[x])), x))\nend", "    size_arr = length(arr)\n\
    \    if size_arr == 0\n        return arr\n    end\n    ones = zeros(Int64, size_arr)\n\
    \    for i in 1:size_arr\n        temp = 0\n        while arr[i] > 0\n       \
    \     temp += arr[i] % 2\n            arr[i] /= 2\n        end\n        ones[i]\
    \ = temp\n    end\n    merged = Dict(arr[i] => ones[i] for i in 1:size_arr)\n\
    \    sorted_dict = sort(merged, by = (_[2]))\n    return collect(keys(sorted_dict))\n\
    end", "    return sort(arr, by = n->(sum(digits(n, 2)), n))\nend\nsort_array([1,2,3,4,5,6,7,8,9,10])",
  "    bin_vec = convert(Array{Int64,1}, convert(Array{Int64,1}, [sum(digits(Int(x),2))\
    \ for x in arr]))\n    #Sorting array based on number of ones in binary representation\n\
    \    bin_sort_vec = sortperm(bin_vec)\n    #Then sorting based on decimal value\n\
    \    dec_sort_vec = sortperm(arr)\n    #Creating empty array to fill with sorted\
    \ values\n    new_vec = Array{Int64,1}(undef,length(arr))\n    #Looping over previous\
    \ sorting arrays to assign values to new array\n    for i in 1:length(arr)\n \
    \       new_vec[bin_sort_vec[i]] = arr[dec_sort_vec[i]]\n    end\n    return new_vec\n\
    end\n\"\"\"", "    arr = sort(arr, rev=true)\n    return arr\nend", "  # Your\
    \ code\nend\n                \"\"\"\n    Test.assert_equals(sort_array([1,2,3,4,5,6,7,8,9]),\
    \ [1,2,4,8,3,5,6,7,9])\n    Test.assert_equals(sort_array([71,98,7,3,2,1,21,62,99,32,13,11,9,12,16,56,51,43,66,43,76,80,15,76,20,12,11,7,18,9,58,71,30,71,12,7,35,2,18,21,74,71,18,81,74,56,51,41,91,25,91,66,80,41,40,40,40,40,1,50,22,95,10,38,22,70,100,24,100,45,99,41,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,])\n\
    \    ,[1,1,2,2,3,3,4,4,5,5,6,6,7,7,7,7,8,8,9,9,10,10,11,11,11,11,12,12,12,12,13,13,14,14,15,15,16,16,17,17,18,18,18,18,19,",
  "    # Sort the input by number of ones in the binary representation\n    # For\
    \ equal number of ones, sort based on decimal value\n    # Good luck!\nend", " \
    \   return sort(arr, by = (x) -> (countones(x), x))\nend", "    #sort array by\
    \ binary representation\n    #sort by decimal value if number of ones are equal\n\
    \    #return result\nend", "    # your code here\nend\n\"\"\"", "    \n    # your\
    \ code here\n    \nend\n\"\"\"\n    For example:\n                \"\"\"\nsort_array([1,2,3,4,5,6,7,8,9,10])\
    \ == [1,2,4,8,3,5,6,7,9,10]", "    # sort by number of 1s in binary representation,\
    \ then value\n    sort(arr, by = [count_ones, identity])\nend", "    # YOUR CODE\
    \ HERE\nend\n\"\"\"", "    # your code here\nend\n                \"\"\"\n   \
    \ You can use bitstring function to get bitstring of an integer.\n    So, you\
    \ will have,\n                \"\"\"\nbitstring(0)  == \"0\"\nbitstring(1)  ==\
    \ \"1\"\nbitstring(2)  == \"10\"\nbitstring(3)  == \"11\"\nbitstring(4)  == \"\
    100\"\nbitstring(5)  == \"101\"\nbitstring(6)  == \"110\"\nbitstring(7)  == \"\
    111\"\n                \"\"\"\n    and so on\n    Test.describe(\"sort_array\"\
    )\n    Test.it(\"Basic tests\")\n    Test.assert_equals(sort_array([0,1,2,3,4,5,6,7,8,9]),[0,1,2,4,8,3,5,6,7,9])\n\
    \    Test.assert_equals(sort_array([0,1,2,4,8,16,32,64,128,256,512,1024]),[0,1,2,4,8,16,32,64,128,256,512,1024])\n\
    \    Test.assert_equals(sort_array([10000,10000]),[10000,10000])\n    Test.assert_equals(sort_array([2048,1024,512,256,128,64,32,16,8,4,2,1]),[1,2,4,8,16,32,64,128,256,512,1024,2048])\n\
    \    Test.assert_equals(sort_array([1,2,4,8,16,32,64,128,256,512,1024,2048]),[1,2,4,8,16,32,64,128,256,512,1024,2048])\n\
    \    Test.assert_equals(sort_array([42,32,0]),[0,32,42])\n                \"\"\
    \"", "    # your code\nend\n\"\"\"\n    Examples\n    sort_array([1,2,3,4,5,6,7,8,9,10])\n\
    \    # should return [1,2,4,8,3,5,6,7,9,10]", "    # sort by number of ones in\
    \ binary representation\n    # then by decimal value\n    n = length(arr)\n  \
    \  return sort(arr, by = x -> [count_ones(x), x])\nend", "    new_arr = []\n \
    \   for i in arr\n        binary = Base.bitstring(i)\n        ones = length(Base.bitcount(i))\n\
    \        push!(new_arr, (ones,i))\n    end\n    sorted_arr = sort(new_arr, by\
    \ = x -> x[1])\n    final_arr = map(x -> x[2], sorted_arr)\n    return final_arr\n\
    end\nsort_array([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,\
    \ 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\
    \ 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,\
    \ 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,\
    \ 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\
    \ 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,\
    \ 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,\
    \ 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215",
  "    # sort by number of ones in binary representation\n    arr = sort(arr, by =\
    \ x -> length(split(digits(x, 2), \"\")))", "    # sort array like this\nend\n\
    \    \"\"\"\n    Example:\n        sort_array([5,3,7,10,14]) == [3,5,10,14,7]\n\
    \    \n    Best Practices:\n        function sort_array(arr)\n            sort(arr,\
    \ by=x->(count(x->x=='1', string(digits(x, 2))), x))\n        end\n    \"\"\"",
  "    # convert to binary, sort, return decimal value\n    num = sort(int2bin(arr))\
    \ \n    for i = 1:length(num)\n        num[i] = bin2int(num[i])\n    end\n   \
    \ return num\nend", "    for i = 1:length(arr)\n        for j = i+1:length(arr)\n\
    \            binary_i = convert(String, digits(arr[i], 2))\n            binary_j\
    \ = convert(String, digits(arr[j], 2))\n            num_ones_i = count(binary_i,\
    \ '1')\n            num_ones_j = count(binary_j, '1')\n            if num_ones_i\
    \ == num_ones_j\n                if arr[i] > arr[j]\n                    arr[i],\
    \ arr[j] = arr[j], arr[i]\n                end\n            elseif num_ones_i\
    \ > num_ones_j\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n\
    \        end\n    end\n    return arr\nend", "end\n\"\"\"", "    \"\"\"sorts array\
    \ according to number of ones in their binary representation \n    in ascending\
    \ order. For similar number of ones, sort based on decimal value.\n    \"\"\"\n\
    \    for (i, elem) in enumerate(arr)\n        push!(arr, elem)\n    end\n    sort!(arr,\
    \ by=x->(count_ones(x), x))\n    return arr\nend", "  sort(arr, by=x->Base.bitcount(x,\
    \ Int64))\nend\n\"\"\"", "    # Get the number of ones in each integer\n    one_counts\
    \ = Dict{Int64, Int64}()\n    for i in arr\n        x = count_ones(i)\n      \
    \  if haskey(one_counts, x)\n            one_counts[x] = push!(one_counts[x],\
    \ i)\n        else\n            one_counts[x] = [i]\n        end\n    end\n  \
    \  # Sort each value based on its number of ones, and then its value\n    sorted_counts\
    \ = sort(collect(keys(one_counts)))\n    out = Int64[]\n    for k in sorted_counts\n\
    \        push!(out, sort(one_counts[k]))\n    end\n    return out\nend", "   \
    \ return sortperm(arr, by=x->(count_ones(x), x))\nend", "    \"\"\" input: a 1D\
    \ vector of non-negative integers\n       output: a 1D vector of non-negative\
    \ integers", "    #your code here\n    # push!(sorted_arr, vec[i])\nend", "  \
    \  #Sort according to the number of ones, if equal, sort decimally.\n    #your\
    \ code here\n    return sort(arr, by = [count_ones, identity])\nend", "    sort(arr,\
    \ by=x->(sum(bits(x)), x))\nend", "    order = sort(arr, by = x -> (count_bits(x),\
    \ x))\n    return order\nend", "    return sort(arr, by = x -> (count_ones(x),\
    \ x))\nend", "    \"\"\"\n        Takes an array of integers and sorts them based\
    \ on the number of 1's in their binary\n        representation.\n        \"\"\"\
    \n    return sort(arr, by=x->[count_ones(x), x])\nend", "end\n\"\"\"", "  # code\
    \ goes here\n  # Note: feel free to modify the return type of this function\n\
    \  return arr; \nendfunction\n\"\"\"\n##Example\nsort_array([3, 4, 1, 7, 5, 1,\
    \ 6, 9, 5, 11, 11, 9, 5, 0, 16, 1, 1, 5, 8, 9, 3, 3, 0, 17, 14, 15, 9, 12, 10,\
    \ 16, 9, 6, 15, 5, 9, 6, 17, 5, 9, 11, 16, 5, 15, 16, 0, 5, 9, 15, 11, 3, 16,\
    \ 11, 16, 5, 9, 6, 15, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 12, 16, 5, 9, 16, 0,\
    \ 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9,\
    \ 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16,\
    \ 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16,\
    \ 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11,\
    \ 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9,\
    \ 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0,\
    \ 5, 9, 15, 11, 3, 16, 11, 16, 5, 9, 16, 0, 5, 9, 15, 11, 3, 16, 11, 16, 5, 9,\
    \ 16, 0, 5, 9, 15, 11, 3, 16, 11,", "    #your code here \nend\n             \"\
    \"\"\n    Example:\n        sort_array([0,1,2,3,4,5,6,7,8,9]) == [0,1,2,4,8,3,5,6,7,9]\n\
    \        # [0,1,2,4,8,3,5,6,7,9] is the decimal equivalent of \n        # [0,1,10,100,1000,11,101,110,111,1001]",
  "    mask = 1\n    l = zeros(Int64,size(arr,1))\n    for i in 1:size(arr,1)\n  \
    \      while mask <= arr[i]\n            l[i] += arr[i] & mask != 0 ? 1 : 0\n\
    \            mask <<= 1\n        end\n        mask = 1\n    end\n    sortperm(l,1)\n\
    end", "    return sort(arr, by=sort_array_helper)\nend", end, "    return sort(arr,\
    \ by = x -> (count_ones(x), x))\nend", "    # your code goes here\nend\n     \
    \           \"\"\"\n    E.g. If a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    then\
    \ result = [1, 2, 4, 8, 3, 5, 6, 7, 9, 10]\n    because they are sorted according\
    \ to number of ones in\n    their binary representation.\n    \"\"\"\n    # Your\
    \ code here\n    return result\n\"\"\"", "    #\n    # TODO: implement me!!!\n\
    \    #\nend\n\"\"\"\n    The input is an Array of non-negative integers which\
    \ are sorted according to\n    number of ones in their binary representation in\
    \ ascending order.\n    For similar number of ones, sorted based on decimal value.",
  "    # your code here\nend\n\"\"\"\n    Examples\n            sort_array([0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9])\n            # [0, 1, 2, 4, 8, 3, 5, 6, 7, 9]\n   \
    \         \"\"\"", "    \"\"\"sort_array(arr)\n        Sort an array of non-negative\
    \ integers\n        according to number of ones in their binary representation\
    \ in ascending order.\"\"\"\n    sort_by(arr, x -> [count_ones(x), x])\nend",
  "  n = length(arr)\n  for i in 1:n-1\n    for j in i+1:n\n      if countones(arr[i])>countones(arr[j])\
    \ || (countones(arr[i])==countones(arr[j]) && arr[i]>arr[j])\n        t = arr[i]\n\
    \        arr[i] = arr[j]\n        arr[j] = t\n      end\n    end\n  end\n  return\
    \ arr\nend", "  # ...\nend\n                \"\"\"\n    Test.assert_equals(sort_array([1,2,3,4,5,6,7,8,9,10]),\
    \ [1,2,4,8,3,5,6,7,9,10])\n    Test.assert_equals(sort_array([1000,10000]), [1000,10000])\n\
    \    Test.assert_equals(sort_array([23,345,654,567,234,734,2345,4456,789,865]),\n\
    \    [23,345,567,2345,654,734,4456,789,865,234])\n    Test.assert_equals(sort_array([23,345,654,567,234,734,2345,4456,789,865]),\n\
    \    [23,345,567,2345,654,734,4456,789,865,234])\n    Test.assert_equals(sort_array([0,0,0,0,0,0,0,0,0,0]),\
    \ [0,0,0,0,0,0,0,0,0,0])\n    Test.assert_equals(sort_array([1,0,1,0,1,0,1,0,1,0]),\
    \ [0,0,0,0,0,1,1,1,1,1])\n    Test.assert_equals(sort_array([0,1,2,3,4,5,6,7,8,9]),\
    \ [0,1,2,4,8,3,5,6,7,9])\n    Test.assert_equals(sort_array([0,15,7,3,4,22,7,42,30,8]),\
    \ [0,3,4,7,7,8,15,22,30,42])\n    Test.assert_equals(sort_array([0,15,7,9,4,22,8,42,30,11]),\
    \ [0,4,8,11,7,9,15,22,30,42])\n    Test.assert_equals(sort_array([0,15,7,9,4,22,",
  "    # your code here\nend\n                                                   \
    \                                     \"\"\"\n                               \
    \                                                         )\n    @eval @test\n\
    \                                                                            \
    \            \"\"\"\n  sort_array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 4,\
    \ 8, 3, 5, 6, 7, 9, 10]\n  sort_array([1024, 512, 256, 128, 64, 32, 16, 8, 4,\
    \ 2, 1]) == [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n  sort_array([10000,\
    \ 10000]) == [10000, 10000]\n  sort_array([2, 3, 5, 7, 11, 13, 17, 19]) == [2,\
    \ 3, 5, 17, 7, 11, 13, 19]\n  sort_array([10, 100, 1000, 10000]) == [10, 100,\
    \ 10000, 1000]\n                                                             \
    \                           \"\"\"\n    function sort_array(arr::Vector{Int64})::Vector{Int64}\n\
    \        # your code here\n        # return Vector{Int64}(undef, length(arr))\n\
    \    end\n    sort_array(vec(1:10)) == vec(1:10) || throw(\"Fail test\")\n   \
    \ sort_array(vec(reverse(1:10))) == vec(reverse(1:10)) || throw(\"Fail test\"\
    )\n    true\nend", "  # Sort the array according to number of ones in the binary\
    \ representation\n  # of the values, then break ties by the decimal value\n  sort(arr,\
    \ by = x -> (join(split(string(bitstring(x)), \"1\")), x))\nend", "    arr[sortperm(count_ones.(arr),\
    \ arr)]\nend\n \n \nimport Pkg; Pkg.add(\"Test\")\nusing Test\n@testset \"Basic\
    \ Tests\" begin\n@test sort_array([]) == []\n@test sort_array([0]) == [0]\n@test\
    \ sort_array([1]) == [1]\n@test sort_array([1,0]) == [0,1]\n@test sort_array([1,1])\
    \ == [1,1]\n@test sort_array([0,1]) == [0,1]\n@test sort_array([0,0]) == [0,0]\n\
    @test sort_array([0,1,1]) == [0,1,1]\n@test sort_array([1,0,1]) == [0,1,1]\n@test\
    \ sort_array([1,1,0]) == [0,1,1]\n@test sort_array([1,1,1]) == [1,1,1]\n@test\
    \ sort_array([0,0,0]) == [0,0,0]\n@test sort_array([1,0,0]) == [0,0,1]\n@test\
    \ sort_array([0,1,0]) == [0,0,1]\n@test sort_array([0,0,1]) == [0,0,1]\n@test\
    \ sort_array([0,0,1,1]) == [0,0,1,1]\n@test sort_array([0,1,0,1]) == [0,0,1,1]\n\
    @test sort_array([0,1,1,0]) == [0,0,1,1]\n@test sort_array([1,0,0,1]) == [0,0,1,1]\n\
    @test sort_array([1,0,1,0]) == [0,0,1,1]\n@test sort_array([1,1,0,0]) == [0,0,1,1]\n\
    @test sort_array([0,0,0,0]) == [0,0,0,0]\n@test sort_array([1,1,1,1]) == [1,1",
  "    \n    b = ones(Int64, length(arr))\n    for i = 1:length(arr)\n        b[i]\
    \ = bin2dec(Int(reverse(string(bits(Int(arr[i]))))))\n    end\n    \n    a = ones(Int64,\
    \ length(arr))\n    for i = 1:length(arr)\n        a[i] = Int(bits(Int(arr[i])))\n\
    \    end\n    \n    function quicksort(arr::Vector{Int64}, a::Vector{Int64}, b::Vector{Int64})\n\
    \        if length(arr) < 2\n            return arr\n        end\n        pivot\
    \ = rand(1:length(arr))\n        less = [l for (i, l) in enumerate(arr) if l <\
    \ arr[pivot] || l == arr[pivot] && a[i] < a[pivot] || l == arr[pivot] && a[i]\
    \ == a[pivot] && b[i] < b[pivot]]\n        pivot_arr = [l for (i, l) in enumerate(arr)\
    \ if l == arr[pivot] && a[i] == a[pivot] && b[i] == b[pivot]]\n        greater\
    \ = [l for (i, l) in enumerate(arr) if l > arr[pivot] || l == arr[pivot] && a[i]\
    \ > a[pivot] || l == arr[pivot] && a[i] == a[pivot] && b[i] > b[pivot]]\n    \
    \    return [quicksort(less, a, b) pivot_arr quicksort(greater, a, b)]\n    end\n\
    \    \n    return quicksort(arr, a, b)\n    \nend", "    num_ones = [count_ones(x)\
    \ for x in arr]\n    @show num_ones\n    @show arr\n    return sortperm(num_ones)\n\
    end", "    # sort based on number of bits in binary representation\n    # then\
    \ sort based on decimal value\n    idx = sortperm(map(x -> count_ones(x), arr))\n\
    \    return(sort(arr[idx]))\nend", '    return sort(arr, by = x -> [count(split(Base.d']
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
