name: HumanEval_120_maximum
language: jl
prompt: "\"\"\"\n    Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n    \n    Example 2:\n\n    \n    Example 3:\n\n    \n    Note:\n      \
  \  1. The length of the array will be in the range of [1, 1000].\n        2. The\
  \ elements in the array will be in the range of [-1000, 1000].\n        3. 0 <=\
  \ k <= len(arr)\n    \"\"\"\nfunction maximum(arr::Vector{Int64}, k::Int64)::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = maximum;\n\t@test(candidate([-3,\
  \ -4, 5], 3) == [-4, -3, 5])\n\t@test(candidate([4, -4, 4], 2) == [4, 4])\n\t@test(candidate([-3,\
  \ 2, 1, 2, -1, -2, 1], 1) == [2])\n\t@test(candidate([123, -123, 20, 0, 1, 2, -3],\
  \ 3) == [2, 20, 123])\n\t@test(candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20])\n\t@test(candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5,\
  \ 15])\n\t@test(candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5])\n\t@test(candidate([1,\
  \ 0, 5, -7], 1) == [5])\n\t@test(candidate([4, -4], 2) == [-4, 4])\n\t@test(candidate([-10,\
  \ 10], 2) == [-10, 10])\n\t@test(candidate([1, 2, 3, -23, 243, -400, 0], 0) == Vector{Int64}([]))\n\
  end\n"
completions: ["    # sort the first k elements\n    sort!(arr[1:k])", "    # Fill\
    \ in the function\n    N = length(arr)\n    if k == 0\n        return []\n   \
    \ end\n    for i = 1:(N-1)\n        for j = i+1:N\n            if arr[i] < arr[j]\n\
    \                temp = arr[i]\n                arr[i] = arr[j]\n            \
    \    arr[j] = temp\n            end\n        end\n    end\n    return arr[1:k]\n\
    end", "    n = length(arr)\n    res = zeros(Int64, k)\n    for i in 1:k\n    \
    \    res[i] = arr[i]\n    end\n    for i in k+1:n\n        j = k\n        while\
    \ j > 0 && res[j] < arr[i]\n            res[j+1] = res[j]\n            j -= 1\n\
    \        end\n        res[j+1] = arr[i]\n    end\n    return res\nend", "    \n\
    end", "    arr_copy = copy(arr)\n    for i in 1:k\n        for j in i:length(arr_copy)\n\
    \            if arr_copy[j] > arr_copy[i]\n                arr_copy[i], arr_copy[j]\
    \ = arr_copy[j], arr_copy[i]\n            end\n        end\n    end\n    return\
    \ arr_copy[1:k]\nend", "    arr2 = Array{Int64}(undef, k)\n    for i in 1:k\n\
    \        arr2[i] = -10001\n    end\n    for i in 1:length(arr)\n        if arr[i]\
    \ > arr2[k]\n            arr2[k] = arr[i]\n            j = k\n            while\
    \ j > 1 && arr2[j] > arr2[j-1]\n                arr2[j], arr2[j-1] = arr2[j-1],\
    \ arr2[j]\n                j -= 1\n            end\n        end\n    end\n   \
    \ return arr2\nend", "    # sort the array\n    sorted_arr = sort(arr, rev=true)\n\
    \    # return k elements from the array\n    return sorted_arr[1:k]\nend", " \
    \   \"\"\"\n    # Step 1: \n    # keep replacing the min number in the current\
    \ k numbers with the next number in the array.\n    \"\"\"\n    max_k = arr[1:k]\n\
    \    for i in (k+1):length(arr)\n        if arr[i] > minimum(max_k)\n        \
    \    max_k[findmin(max_k)[2]] = arr[i]\n        end\n    end\n    sort(max_k)\n\
    end", "    n = length(arr)\n    arr[1:k] = sort(arr[1:k])\n    for i in k+1:n\n\
    \        if arr[i] > arr[1]\n            arr[1] = arr[i]\n            j = 1\n\
    \            while j <= k/2\n                l = 2j\n                r = l+1\n\
    \                if r <= k\n                    if arr[l] >= arr[r]\n        \
    \                temp = arr[j]\n                        arr[j] = arr[l]\n    \
    \                    arr[l] = temp\n                        j = l\n          \
    \          else\n                        temp = arr[j]\n                     \
    \   arr[j] = arr[r]\n                        arr[r] = temp\n                 \
    \       j = r\n                    end\n                else\n               \
    \     temp = arr[j]\n                    arr[j] = arr[l]\n                   \
    \ arr[l] = temp\n                    j = l\n                end\n            end\n\
    \        end\n    end\n    return arr[1:k]\nend", "    n = length(arr)\n    k\
    \ > n && return arr\n    for i in n:-1:n-k+1\n        @inbounds for j in 1:i-1\n\
    \            arr[j] > arr[j+1] && (arr[j], arr[j+1]) = (arr[j+1], arr[j])\n  \
    \      end\n    end\n    return arr[n-k+1:n]\nend", "    # Simple approach, sort\
    \ then pick the last k elements \n    sort(arr)[end-k+1:end]\nend", "    max_h\
    \ = MaxHeap(arr[1:k])\n    for i in k+1:length(arr)\n        push!(max_h, arr[i])\n\
    \        pop!(max_h)\n    end\n    res = Vector{Int64}(undef, k)\n    for i in\
    \ 1:k\n        res[i] = pop!(max_h)\n    end\n    return res\nend", "    heap\
    \ = PriorityQueue{Int64, MaxPrio}()\n    for i = 1:k\n        push!(heap, arr[i])\n\
    \    end\n    for i = k+1:length(arr)\n        if (arr[i] > heap.data[1])\n  \
    \          pop!(heap)\n            push!(heap, arr[i])\n        end\n    end\n\
    \    return sort!(collect(heap))\nend", "    if k == 0\n        return []\n  \
    \  end\n    if k == length(arr)\n        return sort(arr)\n    end\n    return\
    \ maximum(arr[1:k], k)\nend", "    n = length(arr)\n    return sort(arr[1:k],\
    \ rev=true)\nend", "    # your code goes here\n    n = length(arr)\n    sorted_arr\
    \ = sort(arr)\n    return sorted_arr[n-k+1:n]\nend", "    return sort(arr, rev=true)[1:k]\n\
    end", "    # Complete\n    if k > length(arr) \n        return arr\n    end\n\
    \    if k == length(arr)\n        return sort(arr)\n    end\n    if k == 1\n \
    \       return [maximum(arr)]\n    end\n    last_arr = maximum(arr[1:end-1], k-1)\n\
    \    if arr[end] > last_arr[end]\n        return last_arr[1:end-1] * [arr[end]]\n\
    \    elseif arr[end] < last_arr[end]\n        return last_arr\n    else\n    \
    \    return append!(last_arr[1:end-1], arr[end])\n    end\nend\n ", "    \"\"\"\
    \n    Return the maximum k numbers of arr, sorted in ascending order\n    \"\"\
    \"\n    arr_sort = sort(arr)\n    return arr_sort[end-k+1:end]\nend", "    max::Vector{Int64}\
    \ = zeros(Int64, k)\n    for i in 1:k\n        max[i] = Int64(maximum(arr))\n\
    \        arr = filter(x -> x != maximum(arr), arr)\n    end\n    return sort(max,\
    \ rev=true)\nend", "    # sort the array\n    # return a sorted array of length\
    \ k\n    sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n    pq = PriorityQueue()\n\
    \    for i in 1:n\n        push!(pq, arr[i])\n        if length(pq) > k\n    \
    \        pop!(pq)\n        end\n    end\n    return sort(collect(pq))\nend", " \
    \   # create a vector with the first k elements of arr\n    sub_arr = zeros(Int64,\
    \ k)\n    for i in 1:k\n        sub_arr[i] = arr[i]\n    end\n    heapify!(sub_arr)\n\
    \    # if value at index k is greater than value at the root of sub_arr\n    #\
    \ then delete the root of sub_arr and add value at index k to sub_arr\n    for\
    \ i in k+1:length(arr)\n        if arr[i] > sub_arr[1]\n            sub_arr[1]\
    \ = arr[i]\n            HeapTools.siftdown!(sub_arr, 1, k)\n        end\n    end\n\
    \    # sort sub_arr\n    sort!(sub_arr)\n    return sub_arr\nend", "    # Sort\
    \ the array, then take the first k values of it.\n    return sort(arr)[1:k]\n\
    end", "    # sort: O(nlog(n)) + O(k) = O(nlog(n))\n    # better would be to use\
    \ a min-heap to reduce to O(klog(n))\n    sorted = sort(arr, alg=MergeSort)\n\
    \    # reverse: O(k)\n    return reverse(sorted[1:k])\nend", "    # initialize\
    \ a vector of 0s\n    maximums = zeros(Int64, k)\n    # iterate to fill out the\
    \ maximums vector\n    for i in 1:k\n        maximums[i] = findmax(arr)\n    \
    \    arr = arr[arr .!= maximums[i]]\n    end\n    # return the list of maximums\n\
    \    return maximums\nend", "    n = length(arr)\n    if n < k\n        return\
    \ arr\n    end\n    heap = MinHeap(arr)\n    for i = k:n\n        if arr[i] >\
    \ heap.min()\n            heap.insert(arr[i])\n            heap.pop()\n      \
    \  end\n    end\n    return Vector(heap.heap)\nend", "    # return a sorted list\
    \ with the maximum k numbers of arr.\n    # @param arr: Vector{Int64}\n    # @param\
    \ k: Int64\n    # @return: Vector{Int64}", "    length_arr = length(arr)\n   \
    \ if length_arr <= k\n        return sort(arr)\n    end\n    return sort(arr)[length_arr-k+1:length_arr]\n\
    end", "    n = length(arr)\n    sorted = sort(arr, rev=true)\n    return sorted[1:k]\n\
    end", "  q = MaxHeap(arr)\n  return [pop!(q) for i in 1:k]\nend", "    \n    #\
    \ Variables to be used during the sorting process \n    arr_size = length(arr)\
    \ \n    result = Vector{Int64}(undef, k)\n    for i in 1:k \n        result[i]\
    \ = arr[i]\n    end\n    # Sorting the first k elements of the array \n    heapsort!(result)\n\
    \    \n    # Sorting the rest of the array\n    for i in k+1:arr_size \n     \
    \   # If next element is greater than result[0], the root node of heap\n     \
    \   if arr[i] > result[1] \n            result[1] = arr[i]\n            # Heapify\
    \ the root node \n            sink!(result, 1, k)\n        end\n    end\n    \n\
    \    # Sorting the array in descending order\n    reverse!(result)\n    return\
    \ result\nend", "    res = zeros(Int64, k)\n    for i in 1:k\n        max_val\
    \ = -Inf\n        max_idx = -1\n        for j in 1:length(arr)\n            if\
    \ arr[j] > max_val\n                max_val = arr[j]\n                max_idx\
    \ = j\n            end\n        end\n        res[i] = max_val\n        arr[max_idx]\
    \ = -Inf\n    end\n    return res\nend", "    if k < 1\n        return Vector{Int64}[]\n\
    \    end\n    if k == 1\n        return [maximum(arr)]\n    end\n    if k >= length(arr)\n\
    \        return sort(arr)\n    end\n    return sort(arr)[end-k+1:end]\nend", " \
    \   s = sort(arr, rev=true)\n    return s[1:k]\nend\narr = [1, 2, 3, 4, 5]\nk\
    \ = 2\n@assert maximum(arr, k) == [5, 4]", "    \n    # Make a heap\n    max_heap\
    \ = Heap{Tuple{Int64, Int64}}() # {value, index}\n    \n    # Populate the heap\
    \ with the first k elements\n    for i in 1:k\n        push!(max_heap, (-arr[i],\
    \ i))\n    end\n    \n    # For each element, see if it's greater than the root\n\
    \    for i in k+1:length(arr)\n        if arr[i] > peek(max_heap)[1] # If it's\
    \ greater, replace the root\n            pop!(max_heap)\n            push!(max_heap,\
    \ (-arr[i], i))\n        end\n    end\n    \n    # Return an array of the heap\
    \ values\n    return -sort!(collect(max_heap))\nend", "    sorted_arr = sort(arr)\n\
    \    return sorted_arr[end:-1:end-k+1]\nend", "    if k == 0\n        return [0]\n\
    \    end\n    heap = MaxHeap()\n    for n in arr[1:k]\n        push!(heap, n)\n\
    \    end\n    for n in arr[k+1:end]\n        if n > top(heap)\n            pop!(heap)\n\
    \            push!(heap, n)\n        end\n    end\n    return collect(heap)\n\
    end", "    quick_select!(arr, 1, length(arr), k)\n    return arr[1:k]\nend", " \
    \   \n    if k == 1\n        return [maximum(arr)]\n    end\n    \n    m = maximum(arr)\n\
    \    res = maximum(arr[arr .< m])\n    return [res, m]\n    \nend", "    k ==\
    \ 0 && return []\n    m = Maximum.new()\n    for i = 1:k\n        m.add(arr[i])\n\
    \    end\n    for i = k+1:length(arr)\n        m.add(arr[i])\n    end\n    return\
    \ m.get()\nend", "    res = Array{Int64}(k)\n    for i = 1:k\n        heap_push!(res,\
    \ arr[i])\n    end\n    for i = k+1:length(arr)\n        if arr[i] > res[1]\n\
    \            heap_pop!(res)\n            heap_push!(res, arr[i])\n        end\n\
    \    end\n    return sort(res)\nend", "    # sort desc\n    sort!(arr, rev=true)\n\
    \    return arr[1:k]\nend\nmaximum([1,2,3,4,5], 2)\nmaximum([1,2,3,4,5], 3)\n\
    maximum([1,2,3,4,5], 4)\nmaximum([1,2,3,4,5], 5)\nmaximum([1,2,3,4,5], 6)\nmaximum([1,2,3,4,5],\
    \ 1)\nmaximum([1,2,3,4,5], 0)", "    \"\"\"\n    This function takes an array\
    \ and returns the highest k elements\n    \"\"\"\n    # Create a min heap to store\
    \ the elements\n    # In the following we create a heap with all the elements\n\
    \    heap = BinaryHeap()\n    for elem in arr\n        push!(heap, elem)\n   \
    \ end\n    max_heap = BinaryHeap(reverse = true)\n    while length(heap) > 0 &&\
    \ length(max_heap) < k\n        push!(max_heap, pop!(heap))\n    end\n    # Since\
    \ the max heap is created, we can pop the elements\n    out = Vector{Int64}(k)\n\
    \    for i in 1:k\n        out[i] = pop!(max_heap)\n    end\n    return out\n\
    end", "    arr_cpy = copy(arr)\n    for i in k:length(arr_cpy)\n        deleteat!(arr_cpy,\
    \ indmax(arr_cpy))\n    end\n    return sort(arr_cpy, rev=true)\nend\nmaximum([1,2,3,4,5],\
    \ 3)", "    n = length(arr)\n    if n <= k\n        return sort(arr)\n    end\n\
    \    root = build_heap(arr[1:k])\n    for i in k+1:n\n        if arr[i] > root.val\n\
    \            root.val = arr[i]\n            root = heapify(root)\n        end\n\
    \    end\n    return (root.val for _ in 1:k)\nend", "    length = size(arr, 1)\n\
    \    if length == k\n        return arr\n    end\n    sorted_arr = sort(arr, rev=true)\n\
    \    return sorted_arr[1:k]\nend", "    \nend\narr = collect(1:10)\n@show maximum(arr,\
    \ 5)", "    \nend", "    output = Vector{Int64}()\n    for i in 1:k \n       \
    \ output = [maximum(arr)]\n        arr = deleteat!(arr, findmax(arr)[2])\n   \
    \ end\n    return output\nend", "    maxes = zeros(Int64, k)\n    for i = 1:k\n\
    \        maxes[i] = arr[i]\n    end\n    sort!(maxes)\n    for i = k+1:length(arr)\n\
    \        if arr[i] > maxes[1]\n            maxes[1] = arr[i]\n            sort!(maxes)\n\
    \        end\n    end\n    return maxes\nend", "    arr = sort(arr)\n    return\
    \ arr[end-k+1:end]\nend", "    if k == 0 \n        return []\n    end\n    if\
    \ k == 1\n        return maximum(arr)\n    end\n    if k == length(arr)\n    \
    \    return sort(arr)\n    end\n    if k > length(arr)\n        return sort(arr)\n\
    \    end\n    m = maximum(arr)\n    i = indmax(arr)\n    return vcat(m, maximum(deleteat!(arr,\
    \ i), k-1))\nend", "    q = pq = priority_queue{Int64, Vector{Int64}}(lt = max)\n\
    \    for i in arr\n        push!(pq, i)\n        if length(pq) > k\n         \
    \   pop!(pq)\n        end\n    end\n    out = Vector{Int64}(undef, k)\n    for\
    \ i in 1:k\n        out[i] = pop!(pq)\n    end\n    return out\nend", "    maximum(arr,\
    \ k, 1, length(arr))\nend", "    return sort(arr)[end:-1:end-k+1]\nend", "   \
    \ return sort(arr, rev=true)[1:k]\nend", "    n = length(arr)\n    @assert n >=\
    \ k", "    @assert length(arr) > 0 && 0 <= k <= length(arr) \"0 <= k <= len(arr)\"\
    \n    sorted_arr = sort(arr, rev=true)\n    return sorted_arr[1:k]\nend", "  \
    \  n = length(arr)\n    @assert n >= k\n    @assert k >= 0\n    @assert n <= 1000\n\
    \    @assert all(abs(elem) <= 1000 for elem in arr)\n    # TODO: Implement your\
    \ solution here!\n    # Hint: You can define additional functions and structs\
    \ to help\nend", "    # loop through the array\n    # get the maximum number in\
    \ the array\n    # add the number to result\n    # remove the number from the\
    \ array\n    n = length(arr)\n    if k > n return arr end\n    result = Int64[]\n\
    \    for i = 1:k\n        maximum = maximum(arr)\n        result = push!(result,\
    \ maximum)\n        idx = findall(arr .== maximum)\n        if isempty(idx) return\
    \ result end\n        arr = deleteat!(arr, idx)\n    end\n    return result\n\
    end", "    return sort(arr)[end-k+1:end]\nend", "    len = length(arr)\n    max_num\
    \ = Array{Int64, 1}(undef, k)\n    max_num[1] = arr[1]\n    max_num_index = zeros(Int64,\
    \ k)\n    max_num_index[1] = 1\n    max_num_top = 1\n    for i in 2:len\n    \
    \    if i <= k\n            max_num[i] = arr[i]\n            max_num_index[i]\
    \ = i\n            max_num_top = i\n            heapify(max_num, max_num_index,\
    \ max_num_top)\n        else\n            if arr[i] > max_num[1]\n           \
    \     max_num[1] = arr[i]\n                max_num_index[1] = i\n            \
    \    heapify(max_num, max_num_index, max_num_top)\n            end\n        end\n\
    \    end\n    return max_num\nend", "    output = Int64[]\n    max = -Inf\n  \
    \  for i in 1:length(arr)\n        while length(output) > 0 && output[end] < arr[i]\n\
    \            pop!(output)\n        end\n        push!(output, arr[i])\n      \
    \  if length(output) > k\n            popfirst!(output)\n        end\n    end\n\
    \    return output\nend", "    \nend", "    # Create a priority queue:\n    pq\
    \ = BinaryHeap{Int64}()\n    # For every item in the array:\n    for i in arr\n\
    \        # Push it into the queue if it has less than k elements:\n        if\
    \ length(pq) < k\n            push!(pq, i)\n        # If not, pop the minimum\
    \ element in the heap, and push the current item:\n        else\n            pop!(pq)\n\
    \            push!(pq, i)\n        end\n    end\n    # Return the heap sorted:\n\
    \    sort(pq)\nend", "    heap = Heap(arr, sort!=lt)\n    pop!(heap, n=size(arr,\
    \ 1)-k)\n    sort!(heap, sort!=lt)\n    return heap\nend", "    v = Vector{Int64}(undef,\
    \ k)\n    copy!(v, arr[1:k])\n    p = QuickSort.partition_right(v, 1, k)\n   \
    \ for i in k+1:length(arr)\n        if arr[i] > v[p]\n            v[p] = arr[i]\n\
    \            p = QuickSort.partition_right(v, 1, k)\n        end\n    end\n  \
    \  return v\nend", "    heap = MaxHeap()\n    for i in arr\n        if length(heap)\
    \ < k\n            push!(heap, i)\n        elseif i > heap[1]\n            pop!(heap)\n\
    \            push!(heap, i)\n        end\n    end\n    reverse(heap)\nend", " \
    \   \"\"\"\n    Returns the k maximum elements in arr in sorted order. \n    \"\
    \"\"\n    arr_length = length(arr)\n    if k == 0 \n        return Vector{Int64}()\n\
    \    elseif k == arr_length\n        return sort(arr)\n    else\n        # 1.\
    \ Slice array\n        # 2. Sort sliced array\n        # 3. Select last k values\n\
    \        return sort(arr)[end-k+1:end]\n    end\nend", "    \"\"\"\n    Function\
    \ which returns the maximum k elements in arr sorted in descending order.\n  \
    \  \"\"\"\n    return sort(arr; rev=true)[1:k]\nend", "    sort(arr[1:k], rev=true)\n\
    end", "    minimums = Vector{Int64}()\n    for i in 1:k\n        j = 1\n     \
    \   for j = 1:length(minimums)\n            if (minimums[j] > arr[i])\n      \
    \          minimums = minimums[1:j-1]\n                break\n            end\n\
    \        end\n        push!(minimums, arr[i])\n    end\n    for i in k+1:length(arr)\n\
    \        j = 1\n        if (arr[i] > minimums[k])\n            for j = 1:length(minimums)\n\
    \                if (minimums[j] > arr[i])\n                    minimums = minimums[1:j-1]\n\
    \                    break\n                end\n            end\n           \
    \ push!(minimums, arr[i])\n        end\n    end\n    return minimums\nend", " \
    \   s=0\n    for i=1:k-1 \n        for j=1:length(arr)-i\n            if arr[j]>arr[j+1]\n\
    \                s=arr[j]\n                arr[j]=arr[j+1]\n                arr[j+1]=s\n\
    \            end\n        end\n    end\n    return arr[length(arr)-k+1:length(arr)]\n\
    end", "    # Create and initialize min-heap\n    min_heap = MinHeap(k)", "   \
    \ arr[sortperm(arr)[end-k+1:end]]\nend", "    if k == 0\n        return []\n \
    \   end\n    # Maximize the end value of the vector\n    # It is equivalent to\
    \ minimizing the first k - 1 elements in the sorted list\n    # Since this step\
    \ needs to be done at most k - 1 times, the time complexity is O(k)\n    # Note:\
    \ The max_element function is a helper function. Its time complexity is O(1)\n\
    \    for i in 1:k - 1\n        pivot = max_element(arr)\n        arr[pivot] =\
    \ -Inf \n    end\n    # Sort the array for descending order\n    # Note: The sorted\
    \ function is a helper function. Its time complexity is O(n * log(n))\n    # The\
    \ time complexity of the whole algorithm is O(k + n * log(n)) = O(n * log(n))\n\
    \    sorted(arr, rev=true)[1:k]\nend", "    heap = []\n    for i in 1:k\n    \
    \    push!(heap, arr[i])\n    end\n    heapify!(heap)\n    for i in k+1:length(arr)\n\
    \        if arr[i] > first(heap)\n            pop!(heap)\n            push!(heap,\
    \ arr[i])\n            heapify!(heap)\n        end\n    end\n    return sort(heap,\
    \ rev=true)\nend", "    \n    if k == 1\n        return [maximum(arr)]\n    end\n\
    \    \n    # create a hash to store the frequency of each element\n    myDict\
    \ = Dict()\n    for i in arr\n        if haskey(myDict, i)\n            myDict[i]\
    \ += 1\n        else\n            myDict[i] = 1\n        end\n    end\n    \n\
    \    # find the maximum frequency\n    max_freq = 0\n    for i in keys(myDict)\n\
    \        max_freq = max(max_freq, myDict[i])\n    end\n    \n    # find the elements\
    \ with maximum frequency\n    max_elements = []\n    for i in keys(myDict)\n \
    \       if myDict[i] == max_freq\n            push!(max_elements, i)\n       \
    \ end\n    end\n    \n    # sort the array and return the first k elements\n \
    \   sort!(max_elements)\n    return max_elements[1:k]\n    \nend", "    queue\
    \ = push!(PriorityQueue{Int64, Tuple{Int64, Int64}}, (arr[1], 1))\n    j = 2\n\
    \    result = []\n    for i in 1:k\n        value, index = pop!(queue)\n     \
    \   push!(result, value)\n        if index == j\n            j += 1\n        else\n\
    \            push!(queue, (arr[j], j))\n            j += 1\n        end\n    end\n\
    \    return result\nend", "    n = length(arr)\n    quickselect!(arr, n - k +\
    \ 1)\n    return [arr[i] for i = (n - k + 1):n]\nend", "    \"\"\"\n    Given\
    \ an array arr of integers and a positive integer k, return a sorted list \n \
    \   of length k with the maximum k numbers in arr.", "    n = length(arr)\n  \
    \  if k < 1 || k > n\n        throw(ArgumentError(\"Invalid range\"))\n    end\n\
    \    res = arr[1:k]\n    sort!(res)\n    for i = k+1:n\n        if arr[i] > res[1]\n\
    \            deleteat!(res, 1)\n            push!(res, arr[i])\n            sort!(res)\n\
    \        end\n    end\n    return res\nend", "    if k == 0\n        return []\n\
    \    end\n    if k == 1\n        return [maximum(arr)]\n    end\n    if k == length(arr)\n\
    \        return sort(arr)\n    end\n    new_arr = copy(arr)\n    for i = 1:k\n\
    \        idx = findmax(new_arr)[2]\n        new_arr[idx] = minimum(new_arr)\n\
    \    end\n    return sort(new_arr)\nend", "    n = length(arr)\n    heap = BinaryHeap(k,\
    \ arr)\n    heap.build_max_heap()\n    for i = k + 1:n\n        if arr[i] > heap.a[1]\n\
    \            heap.a[1] = arr[i]\n            heap.max_heapify(1)\n        end\n\
    \    end\n    heap.a\nend", "    n = length(arr)\n    if k == n\n        return\
    \ sort(arr)\n    end\n    # Randomly select a pivot\n    function partition(arr::Vector{Int64},\
    \ start::Int64, end::Int64, pivot::Int64)::Int64\n        j = start\n        @inbounds\
    \ for i = start:end\n            if arr[i] < pivot\n                arr[i], arr[j]\
    \ = arr[j], arr[i]\n                j += 1\n            end\n        end\n   \
    \     return j\n    end\n    pivot = arr[1]\n    j = partition(arr, 1, n, pivot)\n\
    \    if j == k\n        return sort(arr[1:k])\n    elseif j > k\n        return\
    \ maximum(arr[1:j-1], k)\n    else\n        return maximum(arr[j:end], k-j)\n\
    \    end\nend", "    # TODO\nend", "    arr[1:k]\nend", "    n = length(arr)\n\
    \    h = maxheap(arr)\n    ret = Int64[]\n    for i = 1:k\n        heappush!(h,\
    \ pop!(h))\n    end\n    while length(h) > 0\n        push!(ret, pop!(h))\n  \
    \  end\n    return ret\nend", "    result = zeros(Int64, k)\n    for i in 1:k\n\
    \        result[i] = maximum(arr)\n        deleteat!(arr, argmax(arr))\n    end\n\
    \    return result\nend", "    heap = BHeap{Int64}()\n    for i = 1:k \n     \
    \   push!(heap, arr[i])\n    end\n    for i = k+1:length(arr)\n        push!(heap,\
    \ arr[i])\n        pop!(heap)\n    end\n    return sort(heap)\nend", "    function\
    \ compare(a::Int64, b::Int64)::Bool\n        if a > b\n            return true\n\
    \        else\n            return false\n        end\n    end\n    arr = sort(arr,\
    \ compare)\n    return arr[1:k]\nend", "    # local variables\n    n = length(arr)\n\
    \    # first, sort the array in place\n    sort!(arr)\n    # create a vector of\
    \ length k\n    solution = zeros(Int64, k)\n    # \n    for i in 1:k\n       \
    \ solution[i] = arr[n - i + 1]\n    end\n    return solution\nend", "    # Compare\
    \ each element in the vector with the elements in the `maximums` vector \n   \
    \ # by first adding it to the end of the vector, and then comparing and swapping\
    \ until \n    # the maximums vector is back in order. \n    maximums = [arr[1]]\n\
    \    for j in 2:k\n        push!(maximums, arr[j])\n        i = j\n        while\
    \ i > 1 && maximums[i] > maximums[i-1]\n            maximums[i], maximums[i-1]\
    \ = maximums[i-1], maximums[i]\n            i -= 1\n        end\n    end\n   \
    \ # For the rest of the elements of the vector, only add them to the `maximums`\
    \ vector \n    # and compare and swap if they are greater than the first element\
    \ of the `maximums` vector.\n    for i in k+1:length(arr)\n        if arr[i] >\
    \ maximums[1]\n            maximums[1] = arr[i]\n            j = 1\n         \
    \   while j*2 <= k\n                if j*2 == k || maximums[j*2] > maximums[j*2+1]\n\
    \                    if maximums[j] > maximums[j*2]\n                        break\n\
    \                    end\n                    maximums[j], maximums[j*2] = maximums[j*2],\
    \ maximums[j]\n                    j = j*2\n                else\n           \
    \         if maximums[j] > maximums[j*2+1]\n                        break\n  \
    \                  end\n                    maximums[j], maximums[j*2+1] = maximums[j*2+1],\
    \ maximums[j]\n                    j = j*2+1\n                end\n          \
    \  end\n        end\n    end\n    return maximums\nend", "    heap = Heap(max)\n\
    \    for i = 1:k\n        enqueue!(heap, -arr[i])\n    end\n    for i = k+1:length(arr)\n\
    \        if -arr[i] > minimum(heap)\n            dequeue!(heap)\n            enqueue!(heap,\
    \ -arr[i])\n        end\n    end\n    return sort(reverse(collect(heap)), rev=true)\n\
    end", "    res = Vector{Int64}()\n    for i = 1:k \n        s = argmax(arr)\n\
    \        push!(res, arr[s])\n        deleteat!(arr, s)\n    end\n    return res\n\
    end", "    if k > length(arr)\n        return arr\n    end\n    if k == 0\n  \
    \      return []\n    end\n    return sort(arr)[end-k+1:end]\nend", "    k = min(k,\
    \ length(arr))\n    keys = []\n    @inbounds for i in 1:k\n        push!(keys,\
    \ i)\n    end\n    heap = Vector{Int64}(undef, k)\n    @inbounds for i in 1:k\n\
    \        heap[i] = arr[i]\n    end\n    build_max_heap!(heap, keys)\n    @inbounds\
    \ for i in k+1:length(arr)\n        if arr[i] > heap[1]\n            heap[1] =\
    \ arr[i]\n            sink!(heap, keys, 1)\n        end\n    end\n    return heap\n\
    end", "    push!(arr, Inf)\n    s = [i for i in 1:length(arr)]\n    prev = 1\n\
    \    i = 1\n    while (i <= k)\n        push!(s, i)\n        i += 1\n    end\n\
    \    for i in k+1:length(arr)\n        if arr[s[1]] < arr[i]\n            prev\
    \ = s[1]\n            shift!(s)\n            push!(s, i)\n        elseif arr[s[end]]\
    \ >= arr[i] && arr[prev] >= arr[i]\n            s[end] = i\n        end\n    end\n\
    \    return [arr[i] for i in s]\nend\nmaximum([1,3,5,2,4], 3)", "    # n = length(arr)\n\
    \    # arr[n] = 0\n    # heap = Vector{Int64}(undef, k+1)\n    # for i in 1:k\n\
    \    #     heap[i] = arr[i]\n    # end\n    # # build heap\n    # for i in floor(Int64,\
    \ k/2):-1:1\n    #     heapify(heap, i, k)\n    # end\n    # for i in k+1:n\n\
    \    #     if arr[i] > heap[1]\n    #         heap[1] = arr[i]\n    #        \
    \ heapify(heap, 1, k)\n    #     end\n    # end\n    # return sort(heap, rev=true)[1:k]\n\
    \    \n    # @inline function lchild(i::Int64)::Int64\n    #     return 2*i\n\
    \    # end\n    # @inline function rchild(i::Int64)::Int64\n    #     return 2*i+1\n\
    \    # end\n    # @inline function parent(i::Int64)::Int64\n    #     return floor(Int64,\
    \ i/2)\n    # end\n    # @inline function heapify(heap::Vector{Int64}, i::Int64,\
    \ n::Int64)\n    #     l = lchild(i)\n    #     r = rchild(i)\n    #     large\
    \ = i\n    #     if l <= n && heap[l] > heap[i]\n    #         large = l\n   \
    \ #     end\n    #     if r <= n && heap[r] > heap[large]\n    #         large\
    \ = r\n    #     end\n    #     if large != i\n    #         heap[i], heap[large]\
    \ = heap[large], heap[i]\n    #         heapify(heap, large, n)\n    #     end\n\
    \    # end\n    # @inline function buildheap(heap::Vector{Int64}, n::Int64)\n\
    \    #     for i in floor(Int64, n/2):-1:1\n    #         heapify(heap, i, n)\n\
    \    #     end\n    #", "    \"\"\"\n    Given an array arr of integers and a\
    \ positive integer k, return a sorted list \n    of length k with the maximum\
    \ k numbers in arr.", "    n = length(arr)\n    if k >= n\n        return sort(arr)\n\
    \    end\n    q = MaxHeap()\n    for i in 1:k\n        push!(q, arr[i])\n    end\n\
    \    for i in k+1:n\n        if arr[i] < q.heap[1]\n            continue\n   \
    \     end\n        pop!(q)\n        push!(q, arr[i])\n    end\n    sort(q.heap)\n\
    end", "    function insert(arr::Vector{Int64}, value::Int64)::Vector{Int64}\n\
    \        \"\"\"\n        Insert the value into arr in the correct position.\n\
    \        \"\"\"\n        for i in eachindex(arr)\n            if value < arr[i]\n\
    \                break\n            end\n        end\n        push!(arr, value)\n\
    \        deleteat!(arr, i)\n        return arr\n    end\n    \n    result = []\n\
    \    for i in 1:k\n        if i == 1\n            push!(result, arr[i])\n    \
    \    else\n            insert(result, arr[i])\n        end\n    end\n    for i\
    \ in k+1:length(arr)\n        if arr[i] > result[1]\n            insert(result,\
    \ arr[i])\n        end\n    end\n    return result\nend", "    # sort array\n\
    \    n = length(arr)\n    for i in 1:n\n        for j in 1:n-i\n            if\
    \ arr[j] > arr[j+1]\n                temp = arr[j]\n                arr[j] = arr[j+1]\n\
    \                arr[j+1] = temp\n            end\n        end\n    end\n    return\
    \ arr[n-k+1:n]\nend", "    @assert(1 <= k <= length(arr))\n    n = length(arr)\n\
    \    a = Array{Int64}(undef, n)\n    for i = 1:n\n        a[i] = arr[i]\n    end\n\
    \    idx = sortperm(a)\n    p = Vector{Int64}(undef, k)\n    for i = 1:k\n   \
    \     p[i] = a[idx[i]]\n    end\n    return p\nend", "    # Py: heapq.nlargest(k,\
    \ arr)\n    # Vec{Int64}(sort(take(arr, k)))\n    # (k <= 0 ? [] : sort(take(arr,\
    \ k)))\n    # sort(take(arr, k), rev=true)\n    # sort(arr)[end - k + 1:end]\n\
    \    # sort(arr)[end - k:end]\n    # sort(arr)[end - k + 1:end]\n    sort(arr)[end\
    \ - k:end]\nend", "    # consider using static arrays instead of vectors\n   \
    \ # static arrays are faster because they avoid allocating memory every time\n\
    \    # a function is called.\n    arr = sort(arr)\n    return arr[end-k+1:end]\n\
    end", "    # Flatten the array, sort it, and reverse it.\n    flattened = sort(collect(Iterators.flatten(arr)))\n\
    \    reversed = reversed(flattened)\n    return reversed[1:k]\nend", "    \nend",
  "    if length(arr) < k\n        return sort(arr, rev=true)\n    end\n    k = min(k,\
    \ length(arr))\n    pivot = arr[k]\n    l = [x for x in arr if x < pivot]\n  \
    \  g = [x for x in arr if x > pivot]\n    s = [x for x in arr if x == pivot]\n\
    \    if length(l) >= k\n        return maximum(l, k)\n    elseif length(l) + length(s)\
    \ < k\n        return maximum(g, k - length(l) - length(s))\n    else\n      \
    \  return maximum(l, length(l)) + s + maximum(g, k - length(l) - length(s))\n\
    \    end\nend", "    result = Vector{Int64}(undef, k)\n    for i in 1:k\n    \
    \    max_index = findmax(arr)[2]\n        result[i] = arr[max_index]\n       \
    \ arr[max_index] = -Inf\n    end\n    return result\nend", "    if length(arr)\
    \ < k\n        return sort(arr)\n    end\n    res = []\n    push!(res, arr[1])\n\
    \    for i = 2:length(arr)\n        if arr[i] < res[end]\n            continue\n\
    \        end\n        while res != [] && arr[i] > res[end]\n            pop!(res)\n\
    \        end\n        push!(res, arr[i])\n        if length(res) > k\n       \
    \     popfirst!(res)\n        end\n    end\n    return res\nend", "    n = length(arr)\n\
    \    if n == k\n        return sort(arr)\n    end\n    if k == 1\n        return\
    \ [maximum(arr)]\n    end\n    pivot = maximum(arr)\n    small = maximum(filter(x\
    \ -> x < pivot, arr), k - 1)\n    big = maximum(filter(x -> x >= pivot, arr),\
    \ k - length(small))\n    return sort([small; big])\nend", "    # TODO\n    return\
    \ []\nend", "    if k == 0\n        return []\n    end\n    heap = MaxHeap()\n\
    \    for i in 1:k\n        push!(heap, arr[i])\n    end\n    for i in k+1:length(arr)\n\
    \        if arr[i] > top(heap)\n            pop!(heap)\n            push!(heap,\
    \ arr[i])\n        end\n    end\n    return sort(collect(heap), rev=true)\nend",
  "    \n    N = length(arr)\n    l = maximum(arr)\n    l = min(k, l)\n    r = minimum(arr)\n\
    \    r = max(r, -k)\n    K = k + 1\n    # Bucket sort, T = O(N), S = O(k)\n  \
    \  bucket = fill(0, K)\n    for i in 1:N\n        bucket[arr[i] - r + 1] += 1\n\
    \    end\n    # Get k elements from left to right, T = O(k)\n    res = zeros(Int64,\
    \ k)\n    for i in 1:K\n        for j in 1:bucket[i]\n            if i + r - 1\
    \ >= 0\n                k -= 1\n                res[k + 1] = i + r - 1\n     \
    \       end\n            if k == 0\n                return res\n            end\n\
    \        end\n    end\nend", "    out = zeros(Int64, k)\n    for i = 1:k\n   \
    \     max_ = -Inf\n        max_index = -1\n        for j = 1:length(arr)\n   \
    \         if arr[j] > max_\n                max_ = arr[j]\n                max_index\
    \ = j\n            end\n        end\n        out[i] = max_\n        arr[max_index]\
    \ = -Inf\n    end\n    return out\nend", "    heap = Heap()\n    for i in 1:k\n\
    \        push!(heap,arr[i])\n    end\n    for i in k+1:length(arr)\n        if\
    \ arr[i] > heap[1]\n            pop!(heap)\n            push!(heap,arr[i])\n \
    \       end\n    end\n    sort(collect(heap))\nend", "    l = length(arr)\n  \
    \  if l == 0\n        return []\n    end\n    left, right = 1, l\n    while left\
    \ < right\n        j = partition(arr, left, right)\n        if j == k\n      \
    \      break\n        elseif j < k\n            left = j + 1\n        else\n \
    \           right = j - 1\n        end\n    end\n    sort(arr[1:k])\nend", " \
    \   \n    if k == length(arr)\n        return sort(arr)\n    end\n    \n    max_idx\
    \ = []\n    for i in 1:k\n        push!(max_idx, i)\n    end\n    \n    for i\
    \ in k+1:length(arr)\n        min_idx = min(max_idx)\n        if arr[i] > arr[min_idx]\n\
    \            pop!(max_idx)\n            push!(max_idx, i)\n        end\n    end\n\
    \    \n    max_list = []\n    for i in max_idx\n        push!(max_list, arr[i])\n\
    \    end\n    \n    return sort(max_list)\nend", "    topk = []\n    for x in\
    \ arr\n        x\n    end\nend", "    N = length(arr)\n    mx = Vector{Int64}(undef,\
    \ 0)\n    for i = 1:N-k+1\n        push!(mx, maximum(arr[i:i+k-1]))\n    end\n\
    \    mx\nend", "    return sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n\
    \    # println(n)\n    res = zeros(Int64, k)\n    for i = 1:k \n        max_val\
    \ = arr[1]\n        max_ind = 1\n        for j = 1:n \n            if arr[j] >\
    \ max_val \n                max_val = arr[j]\n                max_ind = j\n  \
    \          end\n        end\n        res[i] = max_val\n        arr[max_ind] =\
    \ 0\n    end\n    return res\nend", "    n = length(arr)\n    k = min(k, n)\n\
    \    if k == 0\n        return []\n    end\n    if k == 1\n        return [maximum(arr)]\n\
    \    end\n    _maximum(arr, 1, n, k)\nend", '    res = Vector{Int64}(undef, k)',
  "    println(\"Done\")\nend\narr = [1,3,4,6,3,2,3,1,7,8,9,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,",
  "    arr[mergesort!(arr)[end-k+1:end]]\nend", "    n = length(arr)\n    res = Vector{Int64}(undef,\
    \ k)\n    for i in 1:k\n        idx = 1\n        for j in 2:n\n            if\
    \ arr[j] > arr[idx]\n                idx = j\n            end\n        end\n \
    \       res[i] = arr[idx]\n        arr[idx] = -Inf\n    end\n    return res\n\
    end", "    if k > length(arr)\n        return sort(arr)\n    end\n    heap = BinaryHeap()\n\
    \    for i = 1:k\n        push!(heap, -arr[i])\n    end\n    for i = k+1:length(arr)\n\
    \        if arr[i] > peek(heap)\n            pop!(heap)\n            push!(heap,\
    \ -arr[i])\n        end\n    end\n    sort(map(x -> -x, collect(heap)))\nend\n\
    \ ", "    n = length(arr)\n    left, right = 1, n\n    while left <= right\n \
    \       mid = (left + right) >> 1\n        cnt = sum(mid <= n for n in arr)\n\
    \        if cnt == mid\n            left = mid + 1\n        else\n           \
    \ right = mid - 1\n        end\n    end\n    res = Int64[]\n    for i in arr\n\
    \        if i >= right\n            push!(res, i)\n        end\n    end\n    sort!(res)\n\
    \    return res[1:k]\nend", "    # return a sorted array with the maximum k numbers\
    \ in arr. \n    arr[end-k+1:end]\nend", "    n = length(arr)\n    @assert n >=\
    \ 1 && n <= 1000\n    @assert k >= 0 && k <= n\n    m = maximum(arr)\n    @assert\
    \ m >= -1000 && m <= 1000\n    for i in 1:length(arr)\n        @assert arr[i]\
    \ >= -1000 && arr[i] <= 1000\n    end\n    d = Dict{Int64, Vector{Int64}}()\n\
    \    for i in 1:length(arr)\n        @assert arr[i] >= -1000 && arr[i] <= 1000\n\
    \        v = get(d, arr[i], [])::Vector{Int64}\n        v = push!(v, i)\n    \
    \    d[arr[i]] = v\n    end\n    l = sort(collect(keys(d)), rev=true)\n    kk\
    \ = k\n    res = Int64[]\n    for i in 1:length(l)\n        @assert l[i] >= -1000\
    \ && l[i] <= 1000\n        v = d[l[i]]\n        for j in 1:length(v)\n       \
    \     @assert v[j] >= 1 && v[j] <= 1000\n            if kk == 0\n            \
    \    break\n            end\n            push!(res, v[j])\n            kk -= 1\n\
    \        end\n        if kk == 0\n            break\n        end\n    end\n  \
    \  return res\nend", "    l = length(arr)\n    if l <= k\n        sort(arr)\n\
    \    else\n        heap = MaxHeap()\n        for i = 1:k\n            push!(heap,\
    \ arr[i])\n        end\n        for i = k+1:l\n            if arr[i] > top(heap)\n\
    \                pop!(heap)\n                push!(heap, arr[i])\n           \
    \ end\n        end\n        sort(collect(heap))\n    end\nend", "    # bubble\
    \ sort\n    for i in 1:k\n        for j in 1:k-i\n            if arr[j] > arr[j+1]\n\
    \                arr[j], arr[j+1] = arr[j+1], arr[j]\n            end\n      \
    \  end\n    end\n    return arr[end-k+1:end]\nend", "    selection_sort(arr, k)\n\
    end", "    n = length(arr)\n    @assert n >= k\n    @assert k >= 0\n    # sort\
    \ and return first k\n    sort!(arr)\n    return arr[n-k+1:n]\nend\n ", "    \n\
    \    #If k is bigger than the array, then return the array\n    if k > length(arr)\n\
    \        return sort(arr, rev=true)\n    end\n    \n    #Create an empty vector,\
    \ push the first value and then start the while loop\n    arr_temp = Vector{Int64}()\n\
    \    push!(arr_temp, arr[1])\n    i = 2\n    while i <= length(arr)\n        for\
    \ j in 1:length(arr_temp)\n            if arr[i] > arr_temp[j]\n             \
    \   insert!(arr_temp, j, arr[i])\n                break\n            end\n   \
    \         if j == length(arr_temp)\n                push!(arr_temp, arr[i])\n\
    \            end\n        end\n        if length(arr_temp) > k\n            popfirst!(arr_temp)\n\
    \        end\n        i += 1\n    end\n    return arr_temp\nend", "    n = length(arr)\n\
    \    k = max(1, min(k, n))\n    sort(vec(arr[end-k+1:end]))\nend", "    @assert\
    \ length(arr) >= k && k >= 0\n    q = MinHeap(arr[1:k])\n    for i = k+1:length(arr)\n\
    \        if arr[i] > q.q[1]\n            pop!(q)\n            push!(q, arr[i])\n\
    \        end\n    end\n    sort(collect(q.q))\nend", "    if k == 0\n        return\
    \ []\n    end\n    indices = maximum_index(arr, k)\n    sorted_max_k = [arr[i]\
    \ for i in indices]\n    return sorted_max_k\nend", "    # sort an array arr\n\
    \    arr = sort(arr, rev=true)\n    # create a new vector\n    new_arr = zeros(Int64,\
    \ k)\n    # loop through the array\n    for i=1:k\n        # add the element to\
    \ the new array\n        new_arr[i] = arr[i]\n    end\n    # return the new array\n\
    \    return new_arr\nend", "    ret = PriorityQueue{Int64, LessThan}()\n    for\
    \ i in arr\n        if length(ret) < k\n            push!(ret, i)\n        else\n\
    \            if ret.top < i\n                pop!(ret)\n                push!(ret,\
    \ i)\n            end\n        end\n    end\n    return ret.data\nend", "    p\
    \ = PriorityQueue(undef, MinInt)\n    results = []\n    for i in 1:length(arr)\n\
    \        if i <= k\n            push!(p, arr[i])\n        else\n            if\
    \ top(p) < arr[i]\n                pop!(p)\n                push!(p, arr[i])\n\
    \            end\n        end\n    end\n    while !isempty(p)\n        push!(results,\
    \ pop!(p))\n    end\n    return reverse(results)\nend", "    return sort(arr,\
    \ rev=true)[1:k]\nend", "    if length(arr) == 0 || k == 0\n        return Int64[]\n\
    \    end\n    if k >= length(arr)\n        return sort(arr)\n    end\n    q =\
    \ PriorityQueue{Int64, Int64}()\n    for i in 1:k\n        push!(q, arr[i])\n\
    \    end\n    for i in k+1:length(arr)\n        top = top!(q)\n        if arr[i]\
    \ > top\n            pop!(q)\n            push!(q, arr[i])\n        end\n    end\n\
    \    r = sort(collect(q))\n    return r\nend\narr1 = [1,2,3,4,5]\nk1 = 2\nr1 =\
    \ maximum(arr1, k1)\n@show r1", "    n = length(arr)\n    for i = 1:k\n      \
    \  for j = i+1:n\n            if arr[i] < arr[j]\n                swap!(arr, i,\
    \ j)\n            end\n        end\n    end\n    return arr[1:k]\nend", "    return\
    \ sort(arr, rev=true)[1:k]\nend", "    #We can use the heap sort algorithm to\
    \ obtain our solution.\n    #We need to have a way to keep track of our minimum\
    \ value so we know when to \n    #stop adding elements to our heap. We can use\
    \ a tuple to do this.\n    #A tuple is a collection of any number of objects,\
    \ denoted by (a, b, c, ...).\n    #We will use a tuple consisting of our minimum\
    \ value, and the length of our heap.\n    min_value = (arr[1], 0)", "    if k\
    \ == length(arr)\n        sort(arr)\n    else\n        res = Vector{Int64}(undef,\
    \ k)\n        min_n = minimum(arr)\n        max_n = maximum(arr)\n        for\
    \ i = 1:k\n            res[i] = max_n\n        end\n        for i = 1:length(arr)\n\
    \            for j = k:-1:2\n                if arr[i] > res[j]\n            \
    \        res[j] = arr[i]\n                    if res[j] > res[j-1]\n         \
    \               res[j], res[j-1] = res[j-1], res[j]\n                    end\n\
    \                end\n            end\n        end\n        res\n    end\nend",
  "    # Select the maximum n elements of arr. \n    n = length(arr)\n    if k > n\n\
    \        k = n\n    end\n    for i in 1:k\n        max_index = i\n        for\
    \ j in i:n\n            if arr[j] > arr[max_index]\n                max_index\
    \ = j\n            end\n        end\n        # swap\n        tmp = arr[i]\n  \
    \      arr[i] = arr[max_index]\n        arr[max_index] = tmp\n    end\n    return\
    \ arr[1:k]\nend", "    \"\"\"\n    Uses a heap to keep track of the k largest\
    \ elements.\n    \"\"\"\n    if k == 0 return [] end\n    heap = Vector{Int64}(undef,\
    \ k)\n    heap[1] = arr[1]\n    for i in 2:length(arr)\n        if arr[i] > heap[1]\n\
    \            heap[1] = arr[i]\n            heap = _siftdown(heap, 1)\n       \
    \ end\n    end\n    sort(heap)\nend", "    if length(arr) < k\n        return\
    \ arr\n    end\n    if length(arr) == k\n        return sort(arr, rev=true)\n\
    \    end\n    res = []\n    for i in 1:k\n        push!(res, maximum(arr))\n \
    \       deleteat!(arr, indmax(arr))\n    end\n    return sort(res, rev=true)\n\
    end\nmaximum([-1,0,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,",
  "    # This function runs in O(n log k) time, however, the \n    # average-case\
    \ is much faster if we start with a heap \n    # of size O(k), which is O(log\
    \ k) insertions. \n    # The total runtime is O(n + k log k) or O(n log k) \n\
    \    # because k <= n. \n    # This function requires O(k) space.\n    result\
    \ = Int64[]\n    h = MaxHeap{Int64}()\n    for (i, x) in enumerate(arr)\n    \
    \    if i <= k \n            heap_push!(h, x)\n        elseif x > heap_top(h)\n\
    \            heap_replace!(h, x)\n        end\n    end\n    while !isempty(h)\n\
    \        push!(result, heap_pop!(h))\n    end\n    return reverse(result)\nend",
  "    return sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n    result = [arr[i]\
    \ for i in 1:k]\n    #sort(result)\n    #println(result)\n    i = k + 1\n    while\
    \ i <= n\n        res_len = length(result)\n        j = 1\n        while j <=\
    \ res_len\n            if arr[i] > result[j]\n                result = result[1:j-1]\
    \ * [arr[i]] * result[j:end]\n                if length(result) > k\n        \
    \            result = result[1:k]\n                end\n                break\n\
    \            end\n            j += 1\n        end\n        i += 1\n    end\n \
    \   return result\nend", "    sorted = sort(arr)\n    sorted[end-k+1:end]\nend",
  "    # sort array in descending order\n    sort!(arr, rev=true)\n    # return the\
    \ first k elements\n    return arr[1:k]\nend", "    my_max_heap = Heap()\n   \
    \ for i = 1:length(arr)\n        if length(my_max_heap) < k\n            push!(my_max_heap,\
    \ arr[i])\n        else\n            #println(arr[i])\n            if my_max_heap[1]\
    \ < arr[i]\n                pop!(my_max_heap)\n                push!(my_max_heap,\
    \ arr[i])\n            end\n        end\n    end\n    reverse!(my_max_heap)\n\
    \    return my_max_heap\nend", "    # using maxheap to solve this problem\n  \
    \  h = MaxHeap(arr)\n    res = Vector{Int64}()\n    for i = 1:k\n        push!(res,pop!(h))\n\
    \    end\n    return res\nend", "    # Base case for recursion\n    if k == 1\n\
    \        return maximum(arr)\n    end\n    # set that will be returned\n    max_set\
    \ = Vector{Int64}(k)\n    # Set values\n    max_set[1] = maximum(arr)\n    i =\
    \ 2\n    j = 1\n    while i <= k\n        temp_arr = filter!(t -> t != arr[j],\
    \ arr)\n        max_set[i] = maximum(temp_arr)\n        i += 1\n        j += 1\n\
    \    end\n    return max_set\nend", "    # Base case \n    if k == 0 \n      \
    \  return []\n    end\n    \n    # Since array is sorted, if arr[k-1] > arr[k],\n\
    \    # return the first k elements.\n    if arr[k] < arr[k-1]\n        return\
    \ arr[1:k]\n    end\n    \n    return maximum(arr[k+1:end], k)\nend", "    # note\
    \ that the given array is in the range of [-1000, 1000]\n    arr_size = size(arr,\
    \ 1)\n    maximum_array = zeros(Int64, k)", "    m = arr[1:k]\n    for i in k+1:length(arr)\n\
    \        insert!(m, min(m))\n    end\n    return sort(m)\nend", "    if k == 0\n\
    \        return Int64[]\n    end\n    n = length(arr)\n    heap = MaxHeap(arr[1:k])\n\
    \    for i in k+1:n\n        if arr[i] > heap.arr[1]\n            heap.arr[1]\
    \ = arr[i]\n            heap.percolate_down(1)\n        end\n    end\n    sort(heap.arr)\n\
    end", "    @assert 1 <= k <= length(arr)\n    if k == length(arr)\n        return\
    \ sort(arr, rev=true)\n    end\n    res = Vector{Int64}(undef, k)\n    for i in\
    \ 1:k\n        res[i] = maximum(arr)\n        deleteat!(arr, argmax(arr))\n  \
    \  end\n    return sort(res, rev=true)\nend", "    sort(reverse(arr))[1:k]\nend",
  "    # iterative\n    # total length of array\n    length = length(arr)\n    # an\
    \ empty result array\n    result = Array{Int64}(undef, k)\n    # sort an array\
    \ as a heap\n    heap = Heap(arr)\n    # take first k elements of the heap\n \
    \   for i = 1:k\n        result[i] = pop!(heap)\n    end\n    return result\n\
    end", "    \n    heap = Heap{Int64}()\n    insert!(heap, arr[1])\n    for i in\
    \ 2:length(arr)\n        if length(heap) < k\n            insert!(heap, arr[i])\n\
    \        elseif (arr[i] > heap[1])\n            pop!(heap)\n            insert!(heap,\
    \ arr[i])\n        end\n    end\n    return sort(collect(heap))\nend", '    heap
    = heapinit()', "    function is_heap(arr::Vector{Int64}, k::Int64)\n        if\
    \ k == 1\n            return true\n        end\n        r = (k-1) >> 1\n     \
    \   if arr[k] > arr[r]\n            return false\n        end\n        return\
    \ is_heap(arr, r)\n    end\n    \n    function heapify(arr::Vector{Int64}, i::Int64)\n\
    \        l = i<<1\n        r = l+1\n        largest = i\n        if l <= k &&\
    \ arr[l] > arr[i]\n            largest = l\n        end\n        if r <= k &&\
    \ arr[r] > arr[largest]\n            largest = r\n        end\n        if largest\
    \ != i\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr,\
    \ largest)\n        end\n    end\n    \n    function build_heap(arr::Vector{Int64},\
    \ k::Int64)\n        for i in (k>>1):-1:1\n            heapify(arr, i)\n     \
    \   end\n    end\n    \n    function heap_sort(arr::Vector{Int64}, k::Int64)\n\
    \        build_heap(arr, k)\n        for i in k:length(arr)\n            if arr[1]\
    \ < arr[i]\n                arr[1], arr[i] = arr[i], arr[1]\n                heapify(arr,\
    \ 1)\n            end\n        end\n    end\n    \n    arr_tmp = copy(arr)\n \
    \   heap_sort(arr_tmp, k)\n    return arr_tmp[1:k]\nend", "    pqueue = PriorityQueue()\n\
    \    for i in arr\n        if size(pqueue) < k\n            push!(pqueue, i)\n\
    \        elseif i > peek(pqueue)\n            pop!(pqueue)\n            push!(pqueue,\
    \ i)\n        end\n    end\n    return sort(collect(pqueue))\nend", "    q = Vector{Int64}(undef,\
    \ k) \n    qs = 1 \n    qe = 1 \n    for (i, elem) in enumerate(arr) \n      \
    \  while qs <= qe && q[qs] < elem\n            qs += 1\n        end\n        if\
    \ qe < k \n            qe += 1\n        end\n        q[qs:qe] = [elem, q[qs:qe-1]]\n\
    \    end\n    return q[qs:qe]\nend\nmaximum([5, 6, 7, 2, 1, 3, 1, 2, 0, 6, 7,\
    \ -2, 1, 0, 5, 4, 6, 7, -1, -1, 0, 0, 5, 4, 6, 7, -5, -7, -2, -3, -1, 0, -4, -5,\
    \ 0, -4, -4, 3, -4, 1, 4, 5, 6, 7, 8, -1, -2, -3, -4, -5, -6, -7, -8, -1, -2,\
    \ -3, -4, -5, -6, -7, -8, -1, -2, -3, -4, -5, -6, -7, -8, -1, -2, -3, -4, -5,\
    \ -6, -7, -8, -1, -2, -3, -4, -5, -6, -7, -8, -1, -2, -3, -4, -5, -6, -7, -8,\
    \ -1, -2, -3, -4, -5, -6, -7, -8, -1, -2, -3, -4, -5, -6, -7, -8, -1, -2, -3,\
    \ -4, -5, -6, -7, -8, -1, -2, -3, -4, -5, -6, -7, -8, -1, -2, -3, -4, -5, -6,\
    \ -7, -8, -1, -2, -3, -4, -5, -", "    # sort(arr, rev=true)[1:k]\n    # If a\
    \ heap is used, O(NlogK) solution can be obtained. \n    # It is important to\
    \ note that insertion in a heap of size k takes O(logK) time.\n    arr = sort(arr,\
    \ rev=true)\n    return arr[1:k]\nend", "    n = length(arr)\n    return sort(arr,\
    \ rev=true)[1:k]\nend", "    @assert length(arr) in 1:1000 && minimum(arr) in\
    \ -1000:1000 && \n        maximum(arr) in -1000:1000 && k in 0:length(arr)\n \
    \   if k == 0\n        return []\n    end\n    q = PriorityQueue{Int64, Tuple{Int64,\
    \ Int64}}()\n    for i in 1:k\n        push!(q, (-arr[i], i))\n    end\n    result\
    \ = zeros(Int64, k)\n    j = 1\n    while length(q) > 0\n        result[j] = -top(q)[1]\n\
    \        j += 1\n        pop!(q)\n        if j <= length(arr)\n            push!(q,\
    \ (-arr[j], j))\n        end\n    end\n    return result\nend", "    len = length(arr)\n\
    \    if len == 0 \n        println(\"Error: Input length 0\")\n        return\
    \ []\n    end\n    if k <= 0 || k > len\n        println(\"Error: k < 0 or k >\
    \ len(arr)\")\n        return []\n    end\n    p = arr[1]\n    v = [p]\n    for\
    \ i = 2:len\n        if i <= k\n            push!(v, arr[i])\n            if arr[i]\
    \ > p\n                p = arr[i]\n            end\n        else\n           \
    \ if arr[i] > p\n                continue\n            else\n                for\
    \ j = 1:k\n                    if v[j] < p\n                        v[j] = arr[i]\n\
    \                        p = v[1]\n                        for l = 2:k\n     \
    \                       if v[l] > p\n                                p = v[l]\n\
    \                            end\n                        end\n              \
    \          break\n                    end\n                end\n            end\n\
    \        end\n    end\n    sort!(v)\n    return v\nend", "    @assert(k > 0 &&\
    \ k <= length(arr))\n    heap = MaxHeap{Int64}()\n    for i in 1:k\n        push!(heap,\
    \ arr[i])\n    end\n    for i in k+1:length(arr)\n        if heap[1] < arr[i]\n\
    \            pop!(heap)\n            push!(heap, arr[i])\n        end\n    end\n\
    \    return collect(heap)\nend", "    n = length(arr)\n    k = k <= n ? k : n\
    \ \n    maximum_helper(arr, 0, n - 1, k)\nend", "    if k == 0 \n        return\
    \ []\n    end\n    a = Vector{Int64}(undef, k)\n    a[1] = arr[1]\n    for i =\
    \ 2:k\n        if arr[i] > a[1]\n            a[1] = arr[i]\n        end\n    \
    \    a[i] = arr[i]\n    end\n    for i = k+1:length(arr)\n        if arr[i] >\
    \ a[1]\n            a[1] = arr[i]\n            for j = 2:k\n                if\
    \ a[j] < a[j-1]\n                    a[j], a[j-1] = a[j-1], a[j]\n           \
    \     else\n                    break\n                end\n            end\n\
    \        end\n    end\n    a\nend", "    current_max_index = []\n    res = []\n\
    \    for _ in 1:k\n        current_max = -Inf\n        current_max_index = []\n\
    \        for i in 1:length(arr)\n            if arr[i] > current_max\n       \
    \         current_max = arr[i]\n                current_max_index = [i]\n    \
    \        elseif arr[i] == current_max\n                push!(current_max_index,\
    \ i)\n            end\n        end\n        for i in current_max_index\n     \
    \       arr[i] = -Inf\n        end\n        push!(res, current_max)\n    end\n\
    \    return res\nend", "    ans = zeros(Int64, k)\n    i = 0\n    j = 0\n    while\
    \ i < k && j < length(arr)\n        if arr[j] > ans[i]\n            ans[i] = arr[j]\n\
    \            i += 1\n        end\n        j += 1\n    end\n    j = 0\n    i =\
    \ k - 1\n    while i >= 0 && j < length(arr)\n        if arr[j] > ans[i]\n   \
    \         ans[i] = arr[j]\n            i -= 1\n        end\n        j += 1\n \
    \   end\n    return ans\nend", "    # sort the array and then return the first\
    \ k elements\n    @show typeof(arr)\n    @show k\n    return sort(arr)[1:k]\n\
    end", "    sort(arr)[end-k+1:end]\nend", '    end', "    if length(arr) < k \n\
    \        return arr \n    end\n    max_heap = PriorityQueue{Tuple{Int64, Int64}}()\n\
    \    for i = 1:k \n        push!(max_heap, (-arr[i], i))\n    end\n    res = Vector{Int64}(undef,\
    \ k)\n    for i = k+1:length(arr)\n        (_, idx) = top!(max_heap)\n       \
    \ if -arr[i] > -arr[idx]\n            pop!(max_heap)\n            push!(max_heap,\
    \ (-arr[i], i))\n        end\n    end\n    for i = 1:k\n        (v, _) = top!(max_heap)\n\
    \        res[i] = -v\n        pop!(max_heap)\n    end\n    return res\nend", " \
    \   heap = maxheap(arr)\n    result = []\n    while k > 0\n        result = vcat(result,\
    \ pop!(heap))\n        k -= 1\n    end\n    return result\nend", "    new_arr\
    \ = []\n    for i = 1:k\n        max_index = findmax(arr)[2]\n        push!(new_arr,\
    \ arr[max_index])\n        deleteat!(arr, max_index)\n    end\n    return new_arr\n\
    end", "    \"\"\"\n    Precondition: arr is an array of integers and k is a positive\
    \ integer.\n    Postcondition: return a sorted list of length k with the maximum\
    \ k numbers in arr.\n    \"\"\"\n    n = length(arr)\n    if k == 0\n        return\
    \ []\n    elseif k == n\n        return sort(arr)\n    else\n        # sort arr\
    \ in descending order\n        sorted_arr = sort(arr, rev=true)\n        return\
    \ sorted_arr[1:k]\n    end\nend", "    res = Vector{Int64}()\n    for i in sort(arr,\
    \ rev=true)[1:k]\n        push!(res, i)\n    end\n    return res\nend", "    if\
    \ length(arr) == 0 || k == 0\n        return []\n    end\n    heap = Vector{Int64}(0)\n\
    \    push!(heap, -arr[1])\n    for i in 2:length(arr)\n        if i <= k\n   \
    \         push!(heap, -arr[i])\n        else\n            if -arr[i] > heap[1]\n\
    \                heap[1] = -arr[i]\n                Heapify(heap, 1)\n       \
    \     end\n        end\n    end\n    return -sort(heap, rev=true)\nend", "   \
    \ n = length(arr)\n    heap = Vector{Int64}(undef,k)\n    #Arreglo de tama\xF1\
    o k\n    for i in 1:k\n        heap[i] = arr[i]\n    end\n    build_max_heap!(heap)\n\
    \    #Se tienen k elementos, de aqu\xED en adelante solo se van a hacer swaps\n\
    \    for i in k+1:n\n        if arr[i]>heap[1]\n            heap[1] = arr[i]\n\
    \            heapify!(heap,1)\n        end\n    end\n    return heap\nend", " \
    \   # helper function to keep the array a max heap, returns the maximum value\
    \ in the heap\n    function helper(arr::Vector{Int64})::Int64\n        l = length(arr)\n\
    \        if l == 0\n            return 0\n        end\n        i = 1\n       \
    \ while 2*i <= l\n            i2 = 2*i\n            if i2+1 <= l && arr[i2+1]\
    \ > arr[i2]\n                i2 += 1\n            end\n            if arr[i] >=\
    \ arr[i2]\n                break\n            end\n            arr[i], arr[i2]\
    \ = arr[i2], arr[i]\n            i = i2\n        end\n        return arr[1]\n\
    \    end\n    # use a min heap to keep a sorted list of the max k values\n   \
    \ l = length(arr)\n    if l <= k\n        return sort(arr)\n    end\n    arrk\
    \ = arr[1:k]\n    heapify(arrk)\n    for i in k+1:l\n        if arr[i] > arrk[1]\n\
    \            arrk[1] = arr[i]\n            helper(arrk)\n        end\n    end\n\
    \    sort(arrk)\nend", "    # TODO\nend", "    # sort and return k\n    # sort\
    \ and split k\n    # apply min heap k\n    # apply max heap k\n    # apply quick-select\n\
    \    # apply quick-sort", "    # Sort the array in descending order\n    sort!(arr,\
    \ rev=true)\n    # Return k elements from arr\n    return arr[1:k]\nend", "  \
    \  n = length(arr)\n    q = MaxHeap{Int64}()\n    for i in 1:k\n        push!(q,\
    \ arr[i])\n    end\n    for i in k+1:n\n        if q.len > 0 && q.heap[1] < arr[i]\n\
    \            pop!(q)\n            push!(q, arr[i])\n        end\n    end\n   \
    \ s = collect(q)\n    reverse!(s)\n    return s\nend", "    \n    @assert 0 <=\
    \ k <= length(arr)\n    \n    quick_sort!(arr)\n    \n    arr[(length(arr)-k+1):end]\n\
    end", "    \nend\n    \narr = [1,4,3,2]\nk = 2", "    # Code\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
