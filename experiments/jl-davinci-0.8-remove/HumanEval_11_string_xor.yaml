name: HumanEval_11_string_xor
language: jl
prompt: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform\
  \ binary XOR on these inputs and return result also as a string.\n        \"\"\"\
  \nfunction string_xor(a::String, b::String)::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
  111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\
  \t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
completions: ["    c = \"\"\n    for i in 1:length(a)\n        c = c * xor(a[i], b[i])\n\
    \    end\n    return c\nend", "    #convert string to bits representation\n  \
    \  a_bits = parse(Int, a, base=2)\n    b_bits = parse(Int, b, base=2)\n    #perform\
    \ xor operation\n    result = xor(a_bits, b_bits)\n    #convert bits to string\
    \ representation\n    return string(result, base=2)\nend", "    if length(a) !=\
    \ length(b)\n        println(\"The input strings should be of equal length\")\n\
    \        return\n    end\n    c = [ if a[i] != b[i] '1' else '0' for i in 1:length(a)\
    \ ]\n    return join(c)\nend", "    if length(a) != length(b)\n        error(\"\
    The two strings must have equal length\")\n    end\n    res = String(length(a))\n\
    \    for i = 1:length(a)\n        if a[i] == b[i]\n            res[i] = '0'\n\
    \        else\n            res[i] = '1'\n        end\n    end\n    return res\n\
    end", "    if length(a) != length(b)\n        println(\"ERROR: a and b have different\
    \ length\")\n        return \"ERROR\"\n    end\n    result = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            result = result * \"0\"\n\
    \        else\n            result = result * \"1\"\n        end\n    end\n   \
    \ return result\nend", "    len_a = length(a)\n    len_b = length(b)\n    if len_a\
    \ >= len_b\n        # The strings are not of equal length.\n        # Maybe we\
    \ should check for that, but for now it's ok.\n        c = copy(a)\n        for\
    \ i in 1:len_b\n            if a[i] != b[i]\n                c[i] = \"1\"\n  \
    \          else\n                c[i] = \"0\"\n            end\n        end\n\
    \    else\n        c = copy(b)\n        for i in 1:len_a\n            if a[i]\
    \ != b[i]\n                c[i] = \"1\"\n            else\n                c[i]\
    \ = \"0\"\n            end\n        end\n    end\n    return c\nend", "    nums\
    \ = [parse(Int, x) for x in a]\n    nums2 = [parse(Int, x) for x in b]\n    nums3\
    \ = [bxor(nums[i], nums2[i]) for i in 1:length(nums)]\n    return join(nums3)\n\
    end", "    return join(convert.(Int, [a[i] != b[i] for i in 1:length(a)]),\"\"\
    )\nend", "    b = b[1:end]\n    a = a[1:end]\n    L = length(a)\n    out = \"\"\
    \n    for i = 1:L\n        if (a[i] == b[i])\n            out = out * \"0\"\n\
    \        else\n            out = out * \"1\"\n        end\n    end\n    return\
    \ out\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"The\
    \ strings are not of the same length!\"))\n    end\n    str = \"\"\n    for i\
    \ = 1:length(a)\n        str = str * (string(Int(a[i]) \u22BB Int(b[i])))\n  \
    \  end\n    return str\nend", "    if length(a) != length(b)\n        return(\"\
    error: length not equal\")\n    end\n    n = length(a)\n    res = \"\"\n    for\
    \ i in 1:n\n        if a[i] == b[i]\n            res = res * \"0\"\n        else\n\
    \            res = res * \"1\"\n        end\n    end\n    return(res)\nend", " \
    \   # Output string for result\n    out_str = \"\"\n    for i in 1:length(a)\n\
    \        # XOR each digit, convert to string and append to out_str\n        out_str\
    \ *= string( a[i] == b[i] ? 0 : 1 )\n    end\n    # Return result\n    return\
    \ out_str\nend", "    return string(Int.(a).-Int.(b)+2)\nend", "    c = String()\n\
    \    if length(a)==length(b)\n        for i in 1:length(a)\n            if a[i]==b[i]\n\
    \                push!(c, '0')\n            else\n                push!(c, '1')\n\
    \            end\n        end\n    else\n        println(\"Error: unequal string\
    \ lengths\")\n    end\n    return c\nend", "    c = \"\"\n    @assert length(a)\
    \ == length(b)\n    for i = 1:length(a)\n        c = c * string( parse(Int,a[i])\
    \ \u22BB parse(Int,b[i]) )\n    end\n    return c\nend\n \n \n\"\"\" Given two\
    \ strings a and b of equal length,\n    if a[i] == b[i] then remove the character\
    \ at position i from both strings\n    else return a and b unchanged.\n      \
    \  \"\"\"", "    \"\"\"\n    Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    \"\"\"\n    n = length(a)\n    result = \"\"\n    for i in 1:n\n\
    \        a_i = parse(Int,a[i])\n        b_i = parse(Int,b[i])\n        result\
    \ = result * string(xor(a_i,b_i))\n    end\n    return result\nend", "    len_a\
    \ = length(a)\n    len_b = length(b)\n    if len_a != len_b\n        throw(ArgumentError(\"\
    Arguments to string_xor must be of equal length.\"))\n    end\n    xor_result\
    \ = \"\"\n    for i in 1:len_a\n        a_i = parse(Int, a[i])\n        b_i =\
    \ parse(Int, b[i])\n        if xor(a_i, b_i) == 1\n            xor_result *= \"\
    1\"\n        else\n            xor_result *= \"0\"\n        end\n    end\n   \
    \ return xor_result\nend\n \nx = \"1001\"\ny = \"1011\"\nstring_xor(x, y)", " \
    \   a_bin = parse(Int, a, base=2)\n    b_bin = parse(Int, b, base=2)\n    bin_xor\
    \ = xor(a_bin, b_bin)\n    string_xor = decimal_to_binary(bin_xor)\n    return\
    \ string_xor\nend", "    c=\"\"\n    for i in 1:length(a)\n        if a[i]=='1'\
    \ && b[i]=='1'\n            c=c*\"0\"\n        elseif a[i]=='0' && b[i]=='0'\n\
    \            c=c*\"0\"\n        else\n            c=c*\"1\"\n        end\n   \
    \ end\n    return c\nend", "    l = length(a)\n    s = \"\"\n    for i = 1:l\n\
    \        append!(s,string(int(a[i])+int(b[i]) % 2))\n    end\n    return s\nend",
  "    c = \"\" \n    for i = 1:length(a) \n        if a[i] == b[i] \n           \
    \ c = c * \"0\" \n        else \n            c = c * \"1\" \n        end \n  \
    \  end \n    return c \nend ", "    c = \"\"\n    for i in 1:length(a)\n     \
    \   c = c * string(int(a[i]) \u22BB int(b[i]))\n    end\n    return c\nend", " \
    \   res = String[]\n    for i = 1:length(a)\n        if a[i] != b[i]\n       \
    \     push!(res, \"1\")\n        else\n            push!(res, \"0\")\n       \
    \ end\n    end\n    return join(res)\nend", "    total_length = max(length(a),\
    \ length(b))\n    output = \"\"\n    for i in 1:total_length\n        output =\
    \ xor(a[i], b[i])*10^(total_length-i) + output\n    end\n    return string(output)\n\
    end", "    if length(a) != length(b)\n        error(\"Inputs of different lengths!\
    \ a = $a, b = $b\")\n    end\n    result = String(undef, length(a))\n    @inbounds\
    \ for i in 1:length(a)\n        if a[i] == b[i]\n            result[i] = '0'\n\
    \        else\n            result[i] = '1'\n        end\n    end\n    return result\n\
    end", "    n = length(a)\n    i = 1\n    res = \"\"\n    while i <= n\n      \
    \  if a[i] == b[i]\n            res = string(res, \"0\")\n        else\n     \
    \       res = string(res, \"1\")\n        end\n        i += 1\n    end\n    return\
    \ res\nend", "    return join(map(x-> x=='1' ? '0' : '1', zip(a,b)))\nend\n\"\"\
    \" Encrypt an integer with a given key.\n        \"\"\"", "    x = parse(Int,\
    \ a, base=2)\n    y = parse(Int, b, base=2)\n    return string(x \u22BB y, base=2)\n\
    end", "    a = Int.(a .- '0')\n    b = Int.(b .- '0')\n    xor = xor(a, b)\n \
    \   xor = map(x -> x == 1 ? '1' : '0', xor)\n    return join(xor)\nend", "   \
    \ \"\"\" Compute XOR of two strings of equal length \"\"\"\n    if length(a) !=\
    \ length(b)\n        error(\"string_xor input strings must be of equal length\"\
    )\n    end\n    return join([string(int(a[i]) \u22BB int(b[i])) for i in 1:length(a)])\n\
    end", "    a = convert(Vector{Int64},a)\n    b = convert(Vector{Int64},b)\n  \
    \  return join(string.(xor.(a,b)))\nend", "    result_length = length(a)\n   \
    \ result = String(\"0\"^result_length)\n    for i in 1:result_length\n       \
    \ if a[i] == b[i]\n            result[i] = \"0\"\n        else\n            result[i]\
    \ = \"1\"\n        end\n    end\n    return result\nend", "    \"\"\" Output the\
    \ XOR function of the input bits a and b. \"\"\"\n    if length(a) != length(b)\n\
    \        error(\"Input strings must be the same length\")\n    end\n    return\
    \ join([(x == y) ? \"0\" : \"1\" for (x, y) in zip(a, b)])\nend", "    res = \"\
    \"\n    for i in 1:length(a)\n        res = res * string(int(a[i])^int(b[i]))\n\
    \    end\n    return res\nend\n \nenc = encode(\"HelloWorld\")\nprintln(enc)",
  "    r = \"\"\n    for i in range(1, max(length(a), length(b)))\n        if a[i]\
    \ == b[i]\n            r = r * \"0\"\n        else\n            r = r * \"1\"\n\
    \        end\n    end\n    return r\nend", "    l = length(a)\n    assert(l ==\
    \ length(b))\n    # This converts the input strings to individual characters of\
    \ type Char\n    a_char = [Char(a[i]) for i in 1:l]\n    b_char = [Char(b[i])\
    \ for i in 1:l]\n    # XOR them together\n    c_char = xor(a_char, b_char)\n \
    \   # Convert back to string\n    c = string(c_char)\n    return c\nend", "  \
    \  c = \"\"\n    for i = 1:length(a)\n        c = c * xor(parse(Int,a[i]),parse(Int,b[i]))\n\
    \    end\n    return c\nend", "    c=String[]\n    for i in eachindex(a)\n   \
    \     x=xor(parse(Int,a[i]),parse(Int,b[i]))\n        c=push!(c,string(x))\n \
    \   end\n    c=join(c)\n    return c\nend", "    \"\"\" Input are two strings\
    \ a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs\
    \ and return result also as a string.\n        \"\"\"\n    \n    result = \"\"\
    \n    i = 1\n    while i <= length(a)\n        if a[i] == b[i]\n            result\
    \ = result * \"0\"\n        else\n            result = result * \"1\"\n      \
    \  end\n        i += 1\n    end\n    return result\nend", "    char_a = collect(a)\n\
    \    char_b = collect(b)\n    res = \"\"\n    for i in 1:length(char_a)\n    \
    \    if char_a[i] == char_b[i]\n            res = res * \"0\"\n        else\n\
    \            res = res * \"1\"\n        end\n    end\n    return res\nend", " \
    \   return parse(Int, a, base=2) \u22BB parse(Int, b, base=2) |> string\nend",
  "    \"\"\" Compute XOR operation on two binary strings.\n    \"\"\"\n    output\
    \ = \"\"\n    for i = 1:length(a)\n        A = convert(Int64, a[i])\n        B\
    \ = convert(Int64, b[i])\n        if (A == 1 && B == 1) || (A == 0 && B == 0)\n\
    \            push!(output, \"0\")\n        else\n            push!(output, \"\
    1\")\n        end\n    end\n    return output\nend", "    result = \"\"\n    for\
    \ i in 1:min(length(a), length(b))\n        if (a[i] == '1' && b[i] == '1') ||\
    \ (a[i] == '0' && b[i] == '0')\n            result = result * \"0\"\n        else\n\
    \            result = result * \"1\"\n        end\n    end\n    return result\n\
    end", "    if length(a) != length(b)\n        print(\"Input strings have different\
    \ lengths!\")\n        return \"\"\n    end\n    s = String(\"\")\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            s = s * \"0\"\n        else\n\
    \            s = s * \"1\"\n        end\n    end\n    return s\nend", "    function\
    \ XOR(a::Int, b::Int)::Int\n        a = parse(Int, a)\n        b = parse(Int,\
    \ b)\n        if (a == 1 && b == 1) || (a == 0 && b == 0)\n            return\
    \ 0\n        else\n            return 1\n        end\n    end\n    c = \"\"\n\
    \    for i in 1:length(a)\n        c = string(c, XOR(a[i], b[i]))\n    end\n \
    \   return c\nend", "    \n    ca = collect(a)\n    cb = collect(b)\n    \n  \
    \  result = []\n    \n    for i = 1:length(ca)\n        if ca[i] == cb[i]\n  \
    \          push!(result, '0')\n        else\n            push!(result, '1')\n\
    \        end\n    end\n    \n    return join(result)\nend", "    c = \"\"\n  \
    \  for i in 1:length(a)\n        c = c * string(xor(a[i], b[i]))\n    end\n  \
    \  return c\nend", "    length = length(a)\n    # Check that the two inputs are\
    \ of the same length\n    if length(b) != length\n        error(\"Inputs must\
    \ be of the same length\")\n    end\n    # Check that the strings are composed\
    \ of only 1s and 0s\n    # (in any case)\n    if a =~ r\"[^01]\" || b =~ r\"[^01]\"\
    \n        error(\"The inputs must be composed of only 1s and 0s\")\n    end\n\
    \    # Convert input to arrays of 1s and 0s\n    a_array = [parse(Int, i) for\
    \ i in a]\n    b_array = [parse(Int, i) for i in b]\n    # Compute XOR of input\
    \ strings\n    c_array = [a_array[i] \u22BB b_array[i] for i in 1:length]\n  \
    \  # Convert array of 1s and 0s to string\n    c = join(c_array)\n    return c\n\
    end\n \n# Example\nstring_xor(\"1010\", \"0100\") # \"1110\"", "    a = parse(Int,\
    \ a, base=2)\n    b = parse(Int, b, base=2)\n    out = a \u22BB b\n    return\
    \ string(out, base=2)\nend", "    output = \"\"\n    for i in 1:length(a)\n  \
    \      if a[i] == '1'\n            if b[i] == '1'\n                output = output\
    \ * \"0\"\n            else\n                output = output * \"1\"\n       \
    \     end\n        else\n            if b[i] == '1'\n                output =\
    \ output * \"1\"\n            else\n                output = output * \"0\"\n\
    \            end\n        end\n    end\n    return output\nend\n \n \n \n\"\"\"\
    \ Input is a string consisting only of 1s and 0s.\n    Return a string that results\
    \ from applying the bitwise not (NOT) operation to the input string.\n       \
    \ \"\"\"", "    new_string = String(undef, length(a))\n    for i = 1:length(a)\n\
    \        if (a[i] == '1' && b[i] == '0') || (a[i] == '0' && b[i] == '1')\n   \
    \         new_string[i] = '1'\n        else\n            new_string[i] = '0'\n\
    \        end\n    end\n    return new_string\nend", "    # Generate an empty string\
    \ that is the same length as our inputs.\n    result = String(\"0\"*(length(a)))\n\
    \    # Loop through each character in the string\n    for i in 1:length(a)\n \
    \       # If the two character values are different, insert a 1\n        if a[i]\
    \ != b[i]\n            result[i] = \"1\"\n        end\n    end\n    return result\n\
    end", "    total = String[]\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            append!(total, \"0\")\n        else\n            append!(total, \"\
    1\")\n        end\n    end\n    return join(total)\nend", "  a=string(a)\n  b=string(b)\n\
    \    val=zero(Int8)\n    if length(a)>length(b)\n      b=rpad(b,length(a)-length(b),\"\
    0\")\n    elseif length(a)<length(b)\n      a=rpad(a,length(b)-length(a),\"0\"\
    )\n    end\n    for i=1:length(a)\n      if a[i]==b[i]\n        val=val*10\n \
    \     else\n        val=val*10+1\n      end\n    end\n    val\nend", "    a_v\
    \ = [parse(Int, i) for i in a]\n    b_v = [parse(Int, i) for i in b]\n    return\
    \ [string(mod(a_v[i] + b_v[i], 2)) for i in 1:length(a_v)] |> String\nend", " \
    \   N = length(a)\n    out = \"\"\n    for i in 1:N\n        out = out * string(parse(Int,\
    \ a[i])^parse(Int, b[i]))\n    end\n    return out\nend", "    z = 0\n    for\
    \ i = 1:length(a)\n        a[i] == b[i] ? (z += 0) : (z += 1)\n    end\n    return\
    \ string(z)\nend", "    out = String[]\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            push!(out, \"0\")\n        else\n            push!(out,\
    \ \"1\")\n        end\n    end\n    return join(out)\nend", "    result = \"\"\
    \n    len1 = length(a)\n    len2 = length(b)\n    if len1 == len2\n        for\
    \ i = 1:len1\n            if a[i] != b[i]\n                result = result * \"\
    1\"\n            else\n                result = result * \"0\"\n            end\n\
    \        end\n    else\n        error(\"Input strings of differing lengths.\"\
    )\n    end\n    return result\nend", "    if length(a) != length(b) \n       \
    \ return \"Error, the two binary sequences are not of the same length\"\n    end\n\
    \    n = length(a)\n    result = \"\"\n    for i in 1:n\n        if a[i] == b[i]\n\
    \            result = result * \"0\"\n        else\n            result = result\
    \ * \"1\"\n        end\n    end\n    return result\nend", "    \"\"\"\n    XORs\
    \ two binary strings (a and b) and returns the result as a string\n    \"\"\"\n\
    \    xor_array = Array{Char}(length(a))\n    for i in 1:length(a)\n        if\
    \ (a[i] == b[i])\n            xor_array[i] = '0'\n        else \n            xor_array[i]\
    \ = '1'\n        end\n    end\n    return join(xor_array)\nend", "    if length(a)\
    \ != length(b) \n        println(\"Error: inputs of different length\")\n    \
    \    return\n    end\n    c = \"\"\n    for i in 1:length(a)\n        c *= string(int(a[i])\
    \ \u22BB int(b[i]))\n    end\n    return c\nend", "    # first convert the strings\
    \ into a series of bits\n    # not sure how to do this yet\n    \n    a_array\
    \ = [a...]\n    b_array = [b...]\n    \n    # array_length = length(a_array)\n\
    \    # array_length = length(b_array)\n    \n    # create an array to store the\
    \ results\n    c_array = zeros(Int64, length(a_array))\n    \n    # loop through\
    \ the array of strings\n    for i = 1:length(a_array)\n        if(a_array[i] ==\
    \ \"1\" && b_array[i] == \"1\")\n            c_array[i] = \"0\"\n        elseif(a_array[i]\
    \ == \"0\" && b_array[i] == \"0\")\n            c_array[i] = \"0\"\n        elseif(a_array[i]\
    \ == \"1\" && b_array[i] == \"0\")\n            c_array[i] = \"1\"\n        elseif(a_array[i]\
    \ == \"0\" && b_array[i] == \"1\")\n            c_array[i] = \"1\"\n        end\n\
    \    end\n    \n    # convert the array back into a string\n    string_c = join(c_array,\
    \ \"\")\n    \n    return string_c\n    \nend", "    if length(a) != length(b)\n\
    \        error(\"a and b should be of same length\")\n    end\n    out = \"\"\n\
    \    for i in 1:length(a)\n        if a[i] != b[i]\n            out = out * \"\
    1\"\n        else\n            out = out * \"0\"\n        end\n    end\n    return\
    \ out\nend", "    c=\"\"\n    for (x,y) in zip(a,b)\n        if x==y\n       \
    \     push!(c,'0')\n        else\n            push!(c,'1')\n        end\n    end\n\
    \    return c\nend", "    # create function string_xor\n    \n    # Base case\n\
    \    if a == \"\" # if string a is empty\n        return b # then return string\
    \ b\n    elseif b == \"\" # else if string b is empty\n        return a # then\
    \ return string a\n    else # else there is a string in a and a string in b\n\
    \        na = parse(Int, a[1]) # parse integer value of first element in string\
    \ a\n        nb = parse(Int, b[1]) # parse integer value of first element in string\
    \ b\n        return string(xor(na, nb)) * string_xor(a[2:end], b[2:end])\n   \
    \     # return string(xor of first element of a and first element of b)\n    \
    \    # * string_xor(strings a and b without first elements)\n    end\nend", " \
    \   c = \"\"\n    for i in 1:length(a)\n        c = c * string(convert(Int64,\
    \ a[i]) \u22BB convert(Int64, b[i]))\n    end\n    return c\nend", "    result\
    \ = \"\"\n    for i = 1:min(length(a), length(b))\n        result *= string(parse(Int,a[i])\
    \ \u22BB parse(Int,b[i]))\n    end\n    return result\nend", "    if length(a)\
    \ != length(b) \n        error(\"Unequal lengths\")\n    end\n    result = Array{Char}(length(a))\n\
    \    for i in 1:length(a)\n        if a[i] == b[i]\n            result[i] = '0'\n\
    \        else\n            result[i] = '1'\n        end\n    end\n    return string(result)\n\
    end", "    a = parse(Int, a, base=2)\n    b = parse(Int, b, base=2)\n    y = bitxor(a,\
    \ b)\n    y = Int2String(y)\n    return y\nend\n# Test input\n# string_xor(\"\
    100100\", \"100100\")", "    c = \"\"\n    for i in 1:length(a)\n        c = c\
    \ * (a[i] == b[i] ? \"0\" : \"1\")\n    end\n    return c\nend", "    a_bin =\
    \ parse(a, base=2)\n    b_bin = parse(b, base=2)\n    xor_bin = xor(a_bin, b_bin)\n\
    \    return string(xor_bin)\nend", "    (length(a) == length(b)) || throw(ArgumentError(\"\
    Arguments must be of the same length.\"))\n    # convert to bit array for efficient\
    \ XOR\n    u = bitarray(a)\n    v = bitarray(b)\n    return string(u \u22BB v)\n\
    end", "    a, b = check_same_length(a, b)\n    arr_a = [Int(i) for i in a]\n \
    \   arr_b = [Int(i) for i in b]\n    result = [xor(i, j) for (i, j) in zip(arr_a,\
    \ arr_b)]\n    return string(result)\nend", "    n = length(a)\n    m = length(b)\n\
    \    if n != m\n        return \"Error: Strings must be of same length\"\n   \
    \ end\n    l = min(n,m)\n    s = \"\"\n    for i in 1:l\n        if a[i] != b[i]\n\
    \            s = s * \"1\"\n        else\n            s = s * \"0\"\n        end\n\
    \    end\n    return s\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    a and b must be of equal length.\"))\n    end\n    ret = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            ret *= \"0\"\n        else\n           \
    \ ret *= \"1\"\n        end\n    end\n    return ret\nend", "    n = length(a)\n\
    \    m = length(b)\n    if n != m\n        return \"bad input\"\n    end\n   \
    \ s = \"\"\n    for i in 1:n\n        if a[i] == b[i]\n            s = s * \"\
    0\"\n        else\n            s = s * \"1\"\n        end\n    end\n    return\
    \ s\nend", "    c = \"\"\n    for (i,j) in zip(a,b)\n        c = string(c, string(int(i)\u22BB\
    int(j)))\n    end\n    return c\nend", "    if length(a) != length(b)\n      \
    \  error(\"mismatched lengths of input strings\")\n    end\n    s = \"\"\n   \
    \ for i = 1:length(a)\n        if a[i] == b[i]\n            s *= \"0\"\n     \
    \   else\n            s *= \"1\"\n        end\n    end\n    return s\nend\n  \
    \  ", "    \n    # check that input strings are of the same length\n    @assert\
    \ length(a) == length(b)\n    \n    # convert the string characters to integers\n\
    \    a_int = convert(Vector{Int}, a)\n    b_int = convert(Vector{Int}, b)\n  \
    \  \n    # initialize an empty vector to store the binary XOR sum\n    c_int =\
    \ Int[]\n    \n    # go through each element of the vectors and do XOR\n    for\
    \ i in eachindex(a_int)\n        c_int = push!(c_int, xor(a_int[i], b_int[i]))\n\
    \    end\n    \n    # convert integer vector to a string vector\n    c_str = string.(c_int)\n\
    \    \n    # return the full string\n    return join(c_str)\nend", "  for i =\
    \ 1:length(a)\n    if a[i] == '1' && b[i] == '1'\n      a[i] = '0'\n    elseif\
    \ a[i] == '0' && b[i] == '0'\n      a[i] = '0'\n    elseif a[i] == '1' && b[i]\
    \ == '0'\n      a[i] = '1'\n    elseif a[i] == '0' && b[i] == '1'\n      a[i]\
    \ = '1'\n    end\n  end\n  return a\nend", "    if length(a) != length(b)\n  \
    \      throw(ArgumentError(\"Inputs must be of the same length.\"))\n    end\n\
    \    binary_result = [a[i] != b[i] for i in 1:length(a)]\n    join(string.(binary_result))\n\
    end", "    \"\"\" xor for hex strings \"\"\"\n    return hex(parse(Int,a,base=16)\
    \ \u22BB parse(Int,b,base=16))[2:end]\nend", "    if length(a) != length(b) \n\
    \        error(\"Input strings must be of same length.\")\n    end\n    result\
    \ = \"\"\n    for i in 1:length(a)\n        if a[i] != b[i]\n            result\
    \ *= \"1\"\n        else\n            result *= \"0\"\n        end\n    end\n\
    \    return result\nend", "    ...\nend", "    \"\"\" Perform XOR on the two strings.\n\
    \    The two strings must be of equal length and consist only of 1s and 0s.\n\
    \    \"\"\"\n    if length(a) != length(b)\n        println(\"Error! The two inputs\
    \ must be of equal length!\")\n        return \"\";\n    end\n    if ! (all(ch\
    \ in (\"0\", \"1\") for ch in a) && all(ch in (\"0\", \"1\") for ch in b))\n \
    \       println(\"Error! The two inputs must contain only 1s and 0s!\")\n    \
    \    return \"\";\n    end\n    output = \"\"\n    for i = 1:length(a)\n     \
    \   if a[i] == b[i]\n            output = output * \"0\"\n        else\n     \
    \       output = output * \"1\"\n        end\n    end\n    return output\nend",
  "    # convert inputs to integer arrays for binary XOR\n    A = int(a, 2)\n    B\
    \ = int(b, 2)\n    # binary XOR\n    C = bitstring(A \u22BB B)\n    # convert\
    \ bitstring to string\n    return convert(String, C)\nend", "    a_arr = str2arr(a)\n\
    \    b_arr = str2arr(b)\n    c_arr = zeros(Int, length(a_arr))\n    for i in 1:length(a_arr)\n\
    \        c_arr[i] = xor(a_arr[i], b_arr[i])\n    end\n    return arr2str(c_arr)\n\
    end", "    a_arr = convert(Array{Int8}, a)\n    b_arr = convert(Array{Int8}, b)\n\
    \    xor_arr = xor(a_arr, b_arr)\n    join(string.(xor_arr))\nend\n```", "   \
    \ if length(a) != length(b)\n        println(\"length mismatch\")\n        return\
    \ \"NaN\"\n    end\n    out = \"\"\n    for i = 1:length(a)\n        if a[i] ==\
    \ b[i]\n            push!(out, \"0\")\n        else\n            push!(out, \"\
    1\")\n        end\n    end\n    return out\nend", "    z = \"\"\n    for (i, j)\
    \ in zip(a, b)\n        z = z * string(xor(parse(Int, i), parse(Int, j)))\n  \
    \  end\n    return z\nend", "    tmp = a.==0x30;\n    tmp = xor(tmp, b.==0x30);\n\
    \    tmp = tmp.==false;\n    return string(tmp .+ 0x30);\nend", "    # convert\
    \ to integer\n    a_int = int(a, 2)\n    b_int = int(b, 2)\n    c_int = a_int\
    \ \u22BB b_int\n    # convert back to string\n    c = Base.digits(Int, c_int,\
    \ 2)\n    return c\nend", "    return string(map(xor, a, b)...)\nend", "    if\
    \ length(a) != length(b)\n        error(\"Lengths of strings are not the same!\"\
    )\n    end\n    n = length(a)\n    c = Array{Char}(n)\n    for i in 1:n\n    \
    \    if a[i] == b[i]\n            c[i] = '0'\n        else\n            c[i] =\
    \ '1'\n        end\n    end\n    return join(c)\nend", "    xor(parse(Int, a,\
    \ base=2), parse(Int, b, base=2)) |> Int \n    |> string \n    |> x -> join(x[2:length(x)])\n\
    end", "    return [string(Int(a[i])^Int(b[i])) for i in 1:length(a)]\nend", " \
    \   if a == \"0\"\n        return b\n    elseif b == \"0\"\n        return a\n\
    \    else\n        return \"0\"\n    end\nend", "    arr_a = String(a)\n    arr_b\
    \ = String(b)\n    arr_c = String[]\n    for i in 1:length(arr_a)\n        if\
    \ (arr_a[i] == '1' && arr_b[i] == '1') || (arr_a[i] == '0' && arr_b[i] == '0')\n\
    \            append!(arr_c, '0')\n        else\n            append!(arr_c, '1')\n\
    \        end\n    end\n    return join(arr_c)\nend", "    if length(a) > length(b)\n\
    \        b = string(\"0\", b)\n    elseif length(a) < length(b)\n        a = string(\"\
    0\", a)\n    end\n    result = String[]\n    for i in a\n        if i == b[i]\n\
    \            push!(result, \"0\")\n        else\n            push!(result, \"\
    1\")\n        end\n    end\n    return join(result)\nend", "    s = \"\"\n   \
    \ for i in 1:length(a)\n        if a[i] == b[i]\n            s = s * \"0\"\n \
    \       else\n            s = s * \"1\"\n        end\n    end\n    return s\n\
    end", "    @assert length(a) == length(b)\n    result = \"\"\n    for i in 1:length(a)\n\
    \        if a[i] == b[i]\n            result *= \"0\"\n        else\n        \
    \    result *= \"1\"\n        end\n    end\n    return result\nend", "    if(length(a)\
    \ != length(b))\n        print(\"Strings not of equal length\")\n        return\n\
    \    end\n    c::String = \"\"\n    for i=1:length(a)\n        if(a[i] == b[i])\n\
    \            push!(c, '0')\n        else\n            push!(c, '1')\n        end\n\
    \    end\n    return c\nend", "    chr(parse(Int, a, base=2) \u22BB parse(Int,\
    \ b, base=2))\nend", "    results = []\n    for i in eachindex(a)\n        push!(results,\
    \ XOR(parse(Int, a[i]), parse(Int, b[i])))\n    end\n    results = convert(String,\
    \ results)\n    return results\nend", "    return join(xor.(a .- '0', b .- '0')\
    \ .+ '0')\nend", "    b1 = (a .== '1')\n    b2 = (b .== '1')\n    bin = b1 !=\
    \ b2\n    out = \"\".*(bin .+ '0')\n    return(out)\nend", "    n = max(length(a),\
    \ length(b))\n    a = \"0\" * (n - length(a)) * a\n    b = \"0\" * (n - length(b))\
    \ * b\n    s = \"\"\n    for i = 1:n\n        if a[i] == b[i]\n            s *=\
    \ \"0\"\n        else\n            s *= \"1\"\n        end\n    end\n    return\
    \ s\nend", "    p = []\n    if length(a) > length(b)\n        b = repeat(\"0\"\
    ,length(a)-length(b))*b\n    elseif length(a) < length(b)\n        a = repeat(\"\
    0\",length(b)-length(a))*a\n    end\n    for (i,c) in enumerate(a)\n        if\
    \ c == b[i]\n            push!(p,\"0\")\n        else\n            push!(p,\"\
    1\")\n        end\n    end\n    return join(p)\nend", "    N = length(a)\n   \
    \ for i in 1:N\n        if a[i] == b[i]\n            a[i] = '0'\n        else\n\
    \            a[i] = '1'\n        end\n    end\n    return a\nend", "    if length(a)\
    \ != length(b)\n        error(\"Arguments need to be of the same length\")\n \
    \   end\n    out = String[]\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            push!(out, \"0\")\n        else\n            push!(out, \"1\")\n\
    \        end\n    end\n    return join(out)\nend", "    new_string = String(length(a))\n\
    \    for i in 1:length(a)\n        a_int = parse(Int,a[i])\n        b_int = parse(Int,b[i])\n\
    \        new_string[i] = Int(xor(a_int,b_int))\n    end\n    return new_string\n\
    end", "    if a == \"\" || b == \"\" \n        error(\"arguments must be non-empty\
    \ strings.\")\n    end\n    if length(a) != length(b)\n        error(\"arguments\
    \ must be of the same length.\")\n    end\n    a_as_int = parse(Int, a, base=2)\n\
    \    b_as_int = parse(Int, b, base=2)\n    return(string(a_as_int \u22BB b_as_int,\
    \ base=2))\nend", "    # convert strings to arrays of bits\n    a_bits = [parse(Int,\
    \ char) for char in a]\n    b_bits = [parse(Int, char) for char in b]\n    # make\
    \ sure that the arrays have equal length\n    n_bits = max(length(a_bits), length(b_bits))\n\
    \    if length(a_bits) < n_bits\n        a_bits = [0 for i in 1:n_bits-length(a_bits)]\
    \ .+ a_bits\n    end\n    if length(b_bits) < n_bits\n        b_bits = [0 for\
    \ i in 1:n_bits-length(b_bits)] .+ b_bits\n    end\n    # perform XOR\n    result_bits\
    \ = xor.(a_bits, b_bits)\n    # convert bits to a string\n    result = join(string.(result_bits))\n\
    \    return result\nend", "    out = \"\"\n    len_a = length(a)\n    len_b =\
    \ length(b)\n    if len_a == len_b\n        for i in 1:len_a\n            if a[i]\
    \ == b[i]\n                out = out * \"0\"\n            else\n             \
    \   out = out * \"1\"\n            end\n        end\n    else\n        throw(ArgumentError(\"\
    Strings have different lengths.\"))\n    end\n    return out\nend", "    c = \"\
    \"\n    for i in zip(a, b)\n        c *= bitxor(int(i[1]), int(i[2]))\n    end\n\
    \    return c\nend", "    if length(a) != length(b)\n        throw(ArgumentError(\"\
    length of string inputs do not match!\"))\n    end\n    s = \"\"\n    for i in\
    \ 1:length(a)\n        if a[i] == b[i]\n            s = s * \"0\"\n        else\n\
    \            s = s * \"1\"\n        end\n    end\n    return s\nend", "    a =\
    \ bits(Int(a,2))\n    b = bits(Int(b,2))\n    c = a \u22BB b\n    return string(c)\n\
    end", "    # if a and b have different length: make them equal by padding the\
    \ shorter one with 0s\n    if length(a) != length(b)\n        if length(a) > length(b)\n\
    \            b = repeat('0', length(a) - length(b)) * b\n        else\n      \
    \      a = repeat('0', length(b) - length(a)) * a\n        end\n    end\n    return\
    \ join([xor(parse(Int, a[i]), parse(Int, b[i])) for i = 1:length(a)])\nend", " \
    \   b1 = bytearray(a)\n    b2 = bytearray(b)\n    b3 = bytearray(length(b1))\n\
    \    @inbounds for i in 1:length(b1)\n        b3[i] = b1[i] \u22BB b2[i]\n   \
    \ end\n    return(String(b3))\nend", "    c = \"\"\n    for i = 1:length(a)\n\
    \        c = c * XOR(parse(Int,a[i]),parse(Int,b[i]))\n    end\n    return c\n\
    end;\n\"\"\" Input are two arrays a and b consisting only of 1s and 0s.\n    Perform\
    \ binary XOR on these inputs and return result also as an array.\n        \"\"\
    \"", "    if length(a) < length(b)\n        for i in 1:length(b)-length(a)\n \
    \           push!(a,\"0\")\n        end\n    elseif length(a) > length(b)\n  \
    \      for i in 1:length(a)-length(b)\n            push!(b,\"0\")\n        end\n\
    \    end\n    c = \"0\"\n    res = \"\"\n    for i in 1:length(a)\n        if\
    \ a[i] == \"0\"\n            if b[i] == \"0\"\n                push!(res,\"0\"\
    )\n            else\n                push!(res,\"1\")\n            end\n     \
    \   else\n            if b[i] == \"0\"\n                push!(res,\"1\")\n   \
    \         else\n                push!(res,\"0\")\n            end\n        end\n\
    \    end\n    while res[end] == \"0\"\n        pop!(res)\n    end\n    return\
    \ res\nend", "    # Convert the two inputs to decimal\n    a_dec = parse(Int,\
    \ a, base=2)\n    b_dec = parse(Int, b, base=2)\n    # Take the XOR of the inputs\n\
    \    xor_result = bitxor(a_dec, b_dec)\n    # Convert the XOR result back to binary\
    \ and return\n    return string(xor_result, base=2)\nend", "    if length(a) !=\
    \ length(b)\n        error(\"XOR defined only for equal length strings!\")\n \
    \   end\n    m = length(a)\n    out = String(m)\n    for i = 1:m\n        a_i\
    \ = parse(Int, a[i])\n        b_i = parse(Int, b[i])\n        if (a_i == 0 &&\
    \ b_i == 0) || (a_i == 1 && b_i == 1)\n            out[i] = \"0\"\n        else\n\
    \            out[i] = \"1\"\n        end\n    end\n    return out\nend", "   \
    \ _len = min(length(a), length(b))\n    res = \"\"\n    for i = 1:_len\n     \
    \   res = res * string(xor(parse(Int,a[i]), parse(Int,b[i])))\n    end\n    return\
    \ res\nend", "    a, b = map(parse, (a, b))\n    xor = [a[i] ^ b[i] for i in 1:length(a)]\n\
    \    join(xor)\nend", "    c = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            c = c * \"0\"\n        else\n            c = c * \"1\"\n\
    \        end\n    end\n    return c\nend", "    n = length(a)\n    assert(length(b)\
    \ == n)\n    c = String(fill(' ', n))\n    for i in 1:n\n        if a[i] == b[i]\n\
    \            c[i] = '0'\n        else\n            c[i] = '1'\n        end\n \
    \   end\n    return c\nend", "    if (length(a) != length(b))\n        return\
    \ \"a and b must be of the same length!\"\n    end\n    c = \"\"\n    for i =\
    \ 1:length(a)\n        c = c * (a[i] \u2260 b[i] ? \"1\" : \"0\")\n    end\n \
    \   return c\nend", "    c = \"\"\n    if length(a)==length(b)\n        for i=1:length(a)\n\
    \            if a[i] == b[i]\n                c = c * \"0\"\n            else\n\
    \                c = c * \"1\"\n            end\n        end\n    else\n     \
    \   println(\"Inputs are of unequal length.\")\n    end\n    return c\nend", " \
    \   if a == b\n        return \"0\"\n    else\n        return \"1\"\n    end\n\
    end", "    a = parse(Int, a, base=2)\n    b = parse(Int, b, base=2)\n    res =\
    \ bitstring(a \u22BB b)\n    return res\nend", "    if (a == \"\") return \"\"\
    \n    else return string(Int(a[1]) \u22BB Int(b[1])) * string_xor(a[2:end], b[2:end])\n\
    end", "    # Your code here\n    return \"0000\"\nend", "    a_bytes = bytearray(a)\n\
    \    b_bytes = bytearray(b)\n    a_int = parse(UInt128, a_bytes)\n    b_int =\
    \ parse(UInt128, b_bytes)\n    c_int = a_int \u22BB b_int\n    return string(join(c_int))\n\
    end", "    if length(a) != length(b)\n        throw(DomainError(\"Inputs are not\
    \ of the same length\"))\n    end\n    i = 1\n    result = []\n    for i in eachindex(a)\n\
    \        if a[i] == '1' && b[i] == '1'\n            push!(result, '0')\n     \
    \   elseif a[i] == '0' && b[i] == '0'\n            push!(result, '0')\n      \
    \  else\n            push!(result, '1')\n        end\n    end\n    return string(result)\n\
    end", "    _result = 0 \n    for _i = 1:min(length(a), length(b))\n        _result\
    \ = _result + (parse(Int, a[_i]) + parse(Int, b[_i])) % 2 \n    end\n    _result\
    \ = string(_result)\n    for _i = min(length(a), length(b)) + 1:max(length(a),\
    \ length(b))\n        if length(a) > length(b)\n            _result = _result\
    \ * 10 + parse(Int, a[_i])\n        else\n            _result = _result * 10 +\
    \ parse(Int, b[_i])\n        end\n    end\n    return string(_result)\nend", " \
    \   # make sure the two strings are of the same length\n    if length(a) != length(b)\n\
    \        error(\"The two inputs must be of the same length.\")\n    end\n    if\
    \ length(a) == 0\n        return \"\"\n    end\n    # initialize the output string\
    \ \n    output = \"\"\n    # loop over each character of the input strings\n \
    \   for i in eachindex(a)\n        if a[i] == '0' && b[i] == '0'\n           \
    \ push!(output, '0')\n        elseif a[i] == '1' && b[i] == '1'\n            push!(output,\
    \ '0')\n        elseif a[i] == '0' && b[i] == '1'\n            push!(output, '1')\n\
    \        elseif a[i] == '1' && b[i] == '0'\n            push!(output, '1')\n \
    \       end\n    end\n    return output\nend", "    if length(a) != length(b)\
    \ \n        return \"\"\n    end\n    a = string2bin(a)\n    b = string2bin(b)\n\
    \    return bin2string(xor(a, b))\nend", "    a_int = parse(Int, a, base=2)\n\
    \    b_int = parse(Int, b, base=2)\n    return (a_int ^ b_int) |> int2bin |> reverse\
    \ |> trim0\nend", "    if length(a) != length(b)\n        println(\"Different\
    \ length of inputs\")\n        return \n    end \n    out = copy(a)\n    for (i,\
    \ char) in enumerate(a)\n        out[i] = int(a[i]) ^ int(b[i])\n    end\n   \
    \ out = join(map(string, out))\n    return out\nend\na = \"1011101\"\nb = \"00101110111101010100010001000001\"\
    \nstring_xor(a, b)", "    length(a) == length(b) || throw(ArgumentError(\"Strings\
    \ have to be of same length\"))\n    out = \"\"\n    for (i, j) in zip(a, b)\n\
    \        i == j && (a = '0') || (a = '1')\n        push!(out, a)\n    end\n  \
    \  return out\nend", "    \"\"\" Input are two strings a and b consisting only\
    \ of 1s and 0s.\n    Perform binary XOR on these inputs and return result also\
    \ as a string.\n        \"\"\"\n    if length(a) != length(b)\n        println(\"\
    Length of a and b are not the same\")\n        return \"\"\n    end\n    result\
    \ = String[]\n    for i in 1:length(a)\n        if (a[i] == '1' && b[i] == '0')\
    \ || (a[i] == '0' && b[i] == '1')\n            push!(result, '1')\n        elseif\
    \ a[i] == '0' && b[i] == '0'\n            push!(result, '0')\n        elseif a[i]\
    \ == '1' && b[i] == '1'\n            push!(result, '0')\n        end\n    end\n\
    \    return join(result)\nend", "    c = \"\"\n    for (i, j) in zip(a, b)\n \
    \       if i == j\n            c *= \"0\"\n        else\n            c *= \"1\"\
    \n        end\n    end\n    return c\nend", "    \"\"\" Perform XOR on two strings\
    \ `a` and `b` that contain 1s and 0s only.\n    Return result as a string.\n \
    \   \"\"\"\n    # check if the strings a and b have the same length\n    if length(a)\
    \ != length(b)\n        throw(ArgumentError(\"Strings should have the same length.\"\
    ))\n    end\n    # create a new string for the result of XOR\n    result = \"\"\
    \n    # iterate over all characters in the input strings and xor them\n    for\
    \ i in 1:length(a)\n        result = result * xor(parse(Int, a[i]), parse(Int,\
    \ b[i]))\n    end\n    return result\nend", "    if length(a) != length(b)\n \
    \       throw(ArgumentError(\"Strings must be of equal length\"))\n    end\n \
    \   c = String[]\n    for i in eachindex(a)\n        if a[i] == b[i]\n       \
    \     push!(c, \"0\")\n        else\n            push!(c, \"1\")\n        end\n\
    \    end\n    return join(c)\nend", "    a = parse(Int, a, base=2)\n    b = parse(Int,\
    \ b, base=2)\n    c = xor(a, b)\n    c = string(c, base=2)\n    return c\nend",
  "    len_a = length(a)\n    len_b = length(b)\n    if (len_a != len_b)\n       \
    \ throw(ArgumentError(\"Lengths are different\"))\n    end\n    a = parse(Int,\
    \ a, base=2)\n    b = parse(Int, b, base=2)\n    xor_result = xor(a, b)\n    return\
    \ string(xor_result, base=2)\nend", "    # your code here\nend", "    a_int =\
    \ parse(Int, a, base=2)\n    b_int = parse(Int, b, base=2)\n    c_int = xor(a_int,\
    \ b_int)\n    return string(c_int, base=2)\nend", "    return \"\".join([xor(a[i],\
    \ b[i]) for i in 1:length(a)])\nend", "    c = String[]\n    for i in a\n    \
    \    append!(c,string(parse(Int,i) \u22BB parse(Int, b[i])))\n    end\n    return\
    \ join(c)\nend", "    if length(a) != length(b)\n        throw(DomainError())\n\
    \    end\n    r = String[]\n    for i in 1:length(a)\n        if a[i] == b[i]\n\
    \            push!(r, \"0\")\n        else\n            push!(r, \"1\")\n    \
    \    end\n    end\n    return join(r)\nend", "    \"\"\" Perform XOR operation\
    \ on two strings\n    \"\"\"\n    c = String(length(a))\n    for i in 1:length(a)\n\
    \        c[i] = xor(parse(Int64, a[i]), parse(Int64, b[i]))\n    end\n    return(c)\n\
    end", "    out = \"\"\n    for i in 1:length(a)\n        a_digit = parse(Int,a[i])\n\
    \        b_digit = parse(Int,b[i])\n        if a_digit == b_digit\n          \
    \  out = out * \"0\"\n        else\n            out = out * \"1\"\n        end\n\
    \    end\n    return out\nend", "    \n    #Check if the strings are of equal\
    \ length\n    if length(a) != length(b)\n        error(\"Input strings must be\
    \ of equal length.\")\n    end\n    \n    #Create an empty string to store the\
    \ result\n    result = \"\"\n    \n    #Loop through each character of the string\n\
    \    for i in 1:length(a)\n        #Use the conditional xor operation to check\
    \ the values at a certain position\n        xor_result = (a[i] == '1') \u2260\
    \ (b[i] == '1')\n        #Convert the xor_result to a string to be added to the\
    \ result\n        append!(result, string(xor_result))\n    end\n    \n    return\
    \ result\nend", "    c = \"\"\n    if length(a) != length(b)\n        return \"\
    Invalid input\"\n    end\n    for i = 1:length(a)\n        if a[i] == b[i]\n \
    \           c = c * \"0\"\n        else\n            c = c * \"1\"\n        end\n\
    \    end\n    return c\nend", "    bits = [i == j ? '0' : '1' for (i, j) in zip(a,\
    \ b)]\n    return join(bits)\nend", "    # check if both strings have the same\
    \ length\n    if length(a) != length(b)\n        throw(DomainError(\"length of\
    \ both strings must be equal\"))\n    end\n    # initialise result to empty string\n\
    \    result = \"\"\n    # loop over each character and perform XOR\n    for i\
    \ in 1:length(a)\n        ai = parse(Int, a[i])\n        bi = parse(Int, b[i])\n\
    \        if (ai == 1 && bi == 1) || (ai == 0 && bi == 0)\n            result =\
    \ string(result, \"0\")\n        else\n            result = string(result, \"\
    1\")\n        end\n    end\n    return result\nend", "    if(length(a) != length(b))\n\
    \        error(\"Inputs have different lengths\")\n    end\n    res = String(\"\
    \")\n    for i in 1:length(a)\n        res = string(res, XOR(parse(Int, a[i]),\
    \ parse(Int, b[i])))\n    end\n    return res\nend", "    XOR(parse(Int, a, base=2),\
    \ parse(Int, b, base=2))\nend", "    c = \"\"\n    for i in 1:length(a)\n    \
    \    c = c * string(parse(Int64,a[i]) \u22BB parse(Int64,b[i]))\n    end\n   \
    \ return c\nend", "    uinta = parse(UInt64, a, base=2)\n    uintb = parse(UInt64,\
    \ b, base=2)\n    uintxor = bitxor(uinta, uintb)\n    return string(uintxor, base=2)\n\
    end", "    y = string(zeros(Int, length(a)))\n    for i in 1:length(a)\n     \
    \   y[i] = Int(a[i]) \u22BB Int(b[i])\n    end\n    return y\nend", "    \"\"\"\
    \ Returns binary XOR result as a string\n        \"\"\"\n    a_num = parse(a,\
    \ base=2)\n    b_num = parse(b, base=2)\n    xor_num = xor(a_num, b_num)\n   \
    \ return(string(xor_num, base=2))\nend", "    a = parse(Int, a, base=2) #base=2\
    \ is important here!\n    b = parse(Int, b, base=2)\n    c = a \u22BB b\n    return\
    \ string(c, base=2)\nend", "    \n    a_lst = [i == '1' for i in a]\n    b_lst\
    \ = [i == '1' for i in b]\n    \n    res = [a_lst[i] != b_lst[i] for i in 1:length(a_lst)]\n\
    \    \n    res_str = [ifelse(res[i], '1', '0') for i in 1:length(res)]\n    \n\
    \    res_str = join(res_str, \"\")\n    \n    return res_str\nend", "    if length(a)\
    \ != length(b)\n        error(\"Inputs must be of the same length\")\n    end\n\
    \    # convert string inputs to integer arrays\n    a = [ parse(Int, x) for x\
    \ in split(a) ]\n    b = [ parse(Int, x) for x in split(b) ]\n    # xor the integer\
    \ arrays\n    n = length(a)\n    o = zeros(Int, n)\n    for i = 1:n\n        o[i]\
    \ = xor(a[i], b[i])\n    end\n    # convert integer array to string\n    return\
    \ join(o, \"\")\nend", "    \"\"\" A function to perform bitwise XOR on two strings.\
    \ \"\"\"\n    # Converting input to bitarrays.\n    x, y = bitarray(a), bitarray(b)\n\
    \    # Allocating a bitarray of correct size.\n    z = bitarray(max(size(x), size(y)))\n\
    \    # Performing XOR on each bit.\n    for i in 1:max(size(x), size(y))\n   \
    \     z[i] = x[i] \u2260 y[i]\n    end\n    # Converting and returning result.\n\
    \    return string(z)\nend", "    a_int = parse(Int, a, base=2)\n    b_int = parse(Int,\
    \ b, base=2)\n    c_int = xor(a_int, b_int)\n    c = string(c_int, base=2)\n \
    \   return c\nend", "    s = zeros(Int, length(a))\n    for i = 1:length(a)\n\
    \        s[i] = parse(Int, a[i]) \u22BB parse(Int, b[i])\n    end\n    string(s)\n\
    end", "    if length(a) != length(b)\n        error(\"Both inputs must be the\
    \ same length.\")\n    end\n    # Create a new string and populate with chars\
    \ from a and b\n    new_string = \"\"\n    for i in 1:length(a)\n        if a[i]\
    \ == b[i]\n            new_string = new_string * \"0\"\n        else\n       \
    \     new_string = new_string * \"1\"\n        end\n    end\n    return new_string\n\
    end", "  \"\"\" XOR two strings bit by bit (character by character). \"\"\"\n\
    \  \"\"\" The code assumes that the strings are bit strings represented by characters\
    \ '0' and '1' only. \"\"\"\n  assert(length(a) == length(b))\n  c = Array{Char}(length(a))\n\
    \  for i in 1:length(a)\n      if a[i] == b[i]\n          c[i] = '0'\n      else\n\
    \          c[i] = '1'\n      end\n  end\n  return string(c)\nend", "    res =\
    \ String(length(a))\n    for i = 1:length(a)\n        if (a[i] == b[i])\n    \
    \        res[i] = '0'\n        else\n            res[i] = '1'\n        end\n \
    \   end\n    return res\nend", "    \"\"\" Perform binary XOR on two binary strings.\n\
    \        Both inputs must be same length.\n        \"\"\"\n    result = \"\"\n\
    \    for i in 1:length(a)\n        ai = parse(Int,a[i])\n        bi = parse(Int,b[i])\n\
    \        ci = xor(ai,bi)\n        ci = string(ci)\n        result = string(result,ci)\n\
    \    end\n    return result\nend", "    result = \"\"\n    for i in 1:length(a)\n\
    \        result *= (parse(Int,a[i])!=parse(Int,b[i])) ? \"1\" : \"0\"\n    end\n\
    \    return result\nend", "    sa = (a .== '1').data\n    sb = (b .== '1').data\n\
    \    c = (sa .!= sb)\n    c = string(c)\n    c = replace(c, 'true', '1')\n   \
    \ c = replace(c, 'false', '0')\n    return c\nend", "    return string( (a-0b0)\
    \ \u22BB (b-0b0) )\nend", "    if length(a) != length(b)\n        throw(DimensionMismatch(\"\
    inputs must be of equal length\"))\n    end\n    result = zeros(Char, length(a))\n\
    \    for i in 1:length(a)\n        if a[i] == b[i]\n            result[i] = '0'\n\
    \        else\n            result[i] = '1'\n        end\n    end\n    return string(result)\n\
    end", "    result = zeros(String, length(a))\n    for i in 1:length(a)\n     \
    \   result[i] = xor(a[i], b[i])\n    end\n    return result\nend", "    if length(a)\
    \ != length(b)\n        error(\"arguments must be of the same length\")\n    end\n\
    \    # Initialize output string as empty\n    c = \"\"\n    for i in 1:length(a)\n\
    \        # For each bit a[i] get corresponding bit from b[i]\n        if (a[i]\
    \ == b[i])\n            # and perform logical XOR operation\n            c = c\
    \ * \"0\"\n        else\n            c = c * \"1\"\n        end\n    end\n   \
    \ return c\nend", "    a_int = 0;\n    b_int = 0;\n    c_int = 0;\n    c = \"\"\
    \n    for i in eachindex(a)\n        a_int += parse(Int,a[i])*10^(i-1)\n    end\n\
    \    for i in eachindex(b)\n        b_int += parse(Int,b[i])*10^(i-1)\n    end\n\
    \    c_int = bitxor(a_int,b_int)\n    for i in 1:length(a)\n        if c_int>=10^(i-1)\n\
    \            c = string(c,mod(c_int,10^i))\n            c_int = c_int - 10^(i-1)\n\
    \        else\n            c = string(c,\"0\")\n        end\n    end\n    return\
    \ c\nend", "    # Make sure the strings are of equal length\n    if length(a)\
    \ != length(b)\n        throw(ArgumentError(\"Expecting input arguments to be\
    \ of equal length.\"))\n    end\n    # Convert them to integer vectors\n    a\
    \ = parse(Int, x) for x in a\n    b = parse(Int, x) for x in b\n    # XOR\n  \
    \  r = xor(a, b)\n    # Convert back to string\n    return join(string.(r))\n\
    end", "    xor_result = \"\"\n    for i = 1:length(a)\n        if a[i] == '1'\
    \ && b[i] == '1'\n            xor_result = xor_result * \"0\"\n        elseif\
    \ a[i] == '0' && b[i] == '0'\n            xor_result = xor_result * \"0\"\n  \
    \      else\n            xor_result = xor_result * \"1\"\n        end\n    end\n\
    \    return xor_result\nend", "    c = \"\"\n    for i in 1:length(a)\n      \
    \  if a[i] != b[i]\n            c = c * \"1\"\n        else\n            c = c\
    \ * \"0\"\n        end\n    end\n    return c\nend", "    result = \"\"\n    for\
    \ i in 1:min(length(a), length(b))\n        if a[i] == b[i]\n            result\
    \ *= \"0\"\n        else\n            result *= \"1\"\n        end\n    end\n\
    \    return result\nend", "    return string(Int.(a .== b) .- 0.5)\nend", "  \
    \  c = \"\"\n    for i in 1:length(a)\n        c = c * string(int(a[i]) xor int(b[i]))\n\
    \    end\n    return c\nend", "    c = String[]\n    for (i,j) in zip(a,b)\n \
    \       push!(c, xor(parse(Int,i), parse(Int,j)))\n    end\n    return join(c)\n\
    end", "    \n    # Convert input strings to integers.\n    a = parse(Int, a, base=2)\n\
    \    b = parse(Int, b, base=2)\n    \n    # XOR the inputs together.\n    c =\
    \ xor(a, b)\n    \n    # Convert the result back to a string.\n    c = string(c,\
    \ base=2)\n    \n    return c\nend", "    c = \"\"\n    for i = 1:length(a)\n\
    \        if a[i] == b[i]\n            c = c * \"0\"\n        else\n          \
    \  c = c * \"1\"\n        end\n    end\n    return c\nend", "    a = parse(Int,\
    \ a, base=2)\n    b = parse(Int, b, base=2)\n    c = a \u22BB b\n    c = string(c,\
    \ base=2)\n    return c\nend", "    c = \"\"\n    for i in 1:length(a)\n     \
    \   if a[i] != b[i]\n            c = c * \"1\"\n        else\n            c =\
    \ c * \"0\"\n        end\n    end\n    return c\nend", "    len_a = length(a)\n\
    \    len_b = length(b)\n    if len_a != len_b\n        println(\"ERROR in string_xor:\
    \ Strings must be of equal length!\")\n        return \n    end\n    result =\
    \ \"\"\n    for i = 1:len_a\n        if a[i] == '1'\n            if b[i] == '1'\n\
    \                result = result * \"0\"\n            else\n                result\
    \ = result * \"1\"\n            end\n        else\n            if b[i] == '1'\n\
    \                result = result * \"1\"\n            else\n                result\
    \ = result * \"0\"\n            end\n        end\n    end\n    return result\n\
    end", "    if length(a) != length(b)\n        throw(DomainError(\"The two strings\
    \ must have the same length.\"))\n    end\n    xor = Array{Int64}(length(a))\n\
    \    for i in 1:length(a)\n        if a[i] == '1' && b[i] == '1'\n           \
    \ xor[i] = 0\n        elseif a[i] == '0' && b[i] == '0'\n            xor[i] =\
    \ 0\n        else\n            xor[i] = 1\n        end\n    end\n    string(xor)\n\
    end", "    c=[] # c will hold the bits of result\n    for i=1:length(a)\n    \
    \    if (a[i]=='1' && b[i]=='1') || (a[i]=='0' && b[i]=='0')\n            push!(c,'0')\n\
    \        else\n            push!(c,'1')\n        end\n    end\n    return join(c)\n\
    end\nstring_xor(\"1001101011\", \"0110101100\")", "    (length(a)==length(b))\
    \ || error(\"The strings are not of equal length\")\n    result=\"\"\n    for\
    \ (x,y) in zip(a,b)\n        if x==y\n            result=result*\"0\"\n      \
    \  else\n            result=result*\"1\"\n        end\n    end\n    return result\n\
    end", "    return string(parse(Int, a) \u22BB parse(Int, b))\nend", "    \"\"\"\
    \n    Converts the input string to an array of bits (0 and 1) which can be operated\
    \ by bitwise\n    operations. And then convert the result back to a string.\n\
    \    \"\"\"\n    if length(a) != length(b)\n        println(\"Length of the two\
    \ strings should be equal.\")\n        return 0\n    end\n    if sum(x in \"01\"\
    \ for x in a) != length(a) || sum(x in \"01\" for x in b) != length(b)\n     \
    \   println(\"Input strings should only contain 0s and 1s.\")\n        return\
    \ 0\n    end\n    array1 = [parse(Int, x) for x in a]\n    array2 = [parse(Int,\
    \ x) for x in b]\n    result = [xor(x, y) for (x, y) in zip(array1, array2)]\n\
    \    output = join(string.(result))\n    return output\nend", "    a_ind = 1\n\
    \    b_ind = 1\n    ind = 1\n    res = \"\"\n    while ind <= length(a) && ind\
    \ <= length(b)\n        if parse(Int,a[ind]) == 1\n            if parse(Int,b[ind])\
    \ == 1\n                res = \"0\" * res\n            else\n                res\
    \ = \"1\" * res\n            end\n        else\n            if parse(Int,b[ind])\
    \ == 1\n                res = \"1\" * res\n            else\n                res\
    \ = \"0\" * res\n            end\n        end\n        ind += 1\n    end\n   \
    \ res\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
