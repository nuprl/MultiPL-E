name: HumanEval_6_parse_nested_parens
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is\
  \ a string represented multiple groups for nested parentheses separated by spaces.\n\
  // For each of the group, output the deepest level of nesting of parentheses.\n\
  // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
  \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
  \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
  \ paren_string) {\n"
tests: "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
  (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
  \ (std::vector<long>({(long)4})));\n}\n"
completions: ["    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string item;\n    while (std::getline(ss, item,\
    \ ' ')) {\n        long max_depth = 0;\n        long depth = 0;\n        for (char\
    \ c : item) {\n            if (c == '(') {\n                depth++;\n       \
    \         max_depth = std::max(max_depth, depth);\n            } else if (c ==\
    \ ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string item;\n    while (std::getline(ss, item,\
    \ ' ')) {\n        long max_nesting = 0;\n        long current_nesting = 0;\n\
    \        for (char c : item) {\n            if (c == '(') {\n                current_nesting++;\n\
    \                max_nesting = std::max(max_nesting, current_nesting);\n     \
    \       } else if (c == ')') {\n                current_nesting--;\n         \
    \   }\n        }\n        result.push_back(max_nesting);\n    }\n    return result;",
  "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ token;\n    while (std::getline(ss, token, ' ')) {\n        long max_nesting\
    \ = 0;\n        long current_nesting = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                current_nesting++;\n             \
    \   max_nesting = std::max(max_nesting, current_nesting);\n            } else\
    \ if (c == ')') {\n                current_nesting--;\n            }\n       \
    \ }\n        result.push_back(max_nesting);\n    }\n    return result;", "   \
    \ std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ paren_group;\n    while (std::getline(ss, paren_group, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : paren_group)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        assert(current_nesting == 0);\n        result.push_back(max_nesting);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string item;\n    while (std::getline(ss, item,\
    \ ' ')) {\n        long max_nesting = 0;\n        long nesting = 0;\n        for\
    \ (char c : item) {\n            if (c == '(') {\n                nesting++;\n\
    \                max_nesting = std::max(max_nesting, nesting);\n            }\
    \ else if (c == ')') {\n                nesting--;\n            }\n        }\n\
    \        result.push_back(max_nesting);\n    }\n    return result;", "    std::vector<long>\
    \ result;\n    std::stringstream ss(paren_string);\n    std::string token;\n \
    \   while (std::getline(ss, token, ' ')) {\n        long max_nesting = 0;\n  \
    \      long current_nesting = 0;\n        for (char c : token) {\n           \
    \ if (c == '(') {\n                current_nesting++;\n                max_nesting\
    \ = std::max(max_nesting, current_nesting);\n            } else if (c == ')')\
    \ {\n                current_nesting--;\n            }\n        }\n        result.push_back(max_nesting);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string token;\n    while (std::getline(ss, token,\
    \ ' ')) {\n        long max_depth = 0;\n        long current_depth = 0;\n    \
    \    for (char c : token) {\n            if (c == '(') {\n                current_depth++;\n\
    \                max_depth = std::max(max_depth, current_depth);\n           \
    \ } else if (c == ')') {\n                current_depth--;\n            }\n  \
    \      }\n        result.push_back(max_depth);\n    }\n    return result;", " \
    \   std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char> stk;\n\
    \        long max_depth = 0;\n        for (char c : item) {\n            if (c\
    \ == '(') {\n                stk.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)stk.size());\n            } else if (c == ')') {\n                stk.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;", "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_level = 0;\n        long current_level = 0;\n        for\
    \ (char c : paren_group) {\n            if (c == '(') {\n                current_level++;\n\
    \                max_level = std::max(max_level, current_level);\n           \
    \ } else if (c == ')') {\n                current_level--;\n            }\n  \
    \      }\n        result.push_back(max_level);\n    }\n    return result;", " \
    \   std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char> st;\n\
    \        long max_depth = 0;\n        for (auto c : item) {\n            if (c\
    \ == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;", "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string token;\n    while (std::getline(ss, token,\
    \ ' ')) {\n        long max_depth = 0;\n        long depth = 0;\n        for (char\
    \ c : token) {\n            if (c == '(') {\n                depth++;\n      \
    \          max_depth = std::max(max_depth, depth);\n            } else if (c ==\
    \ ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string token;\n    while (std::getline(ss, token,\
    \ ' ')) {\n        long max_level = 0;\n        long level = 0;\n        for (char\
    \ c : token) {\n            if (c == '(') {\n                level++;\n      \
    \          max_level = std::max(max_level, level);\n            } else if (c ==\
    \ ')') {\n                level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string item;\n    while (std::getline(ss, item,\
    \ ' ')) {\n        long max_nesting = 0;\n        long curr_nesting = 0;\n   \
    \     for (char c : item) {\n            if (c == '(') {\n                curr_nesting++;\n\
    \                max_nesting = std::max(max_nesting, curr_nesting);\n        \
    \    } else if (c == ')') {\n                curr_nesting--;\n            }\n\
    \        }\n        result.push_back(max_nesting);\n    }\n    return result;",
  "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ paren_group;\n    while (std::getline(ss, paren_group, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : paren_group)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;",
  "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string\
    \ item;\n    while (std::getline(ss, item, ' ')) {\n        long max_depth = 0;\n\
    \        long depth = 0;\n        for (char c : item) {\n            if (c ==\
    \ '(') {\n                depth++;\n                max_depth = std::max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth--;\n    \
    \        }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;", "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for (auto c\
    \ : paren_group) {\n            if (c == '(') {\n                depth++;\n  \
    \              max_depth = std::max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;", "    std::vector<long> result;\n    std::stringstream\
    \ ss(paren_string);\n    std::string token;\n    while (std::getline(ss, token,\
    \ ' ')) {\n        long max_nesting = 0;\n        long current_nesting = 0;\n\
    \        for (char c : token) {\n            if (c == '(') {\n               \
    \ current_nesting++;\n                max_nesting = std::max(max_nesting, current_nesting);\n\
    \            } else if (c == ')') {\n                current_nesting--;\n    \
    \        }\n        }\n        result.push_back(max_nesting);\n    }\n    return\
    \ result;", "    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;"]
stop_tokens:
- "\n}"
