language: cpp
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int i=0;\n    while(i<n-1)\n    {\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==n-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<n-1)\n    {\n        if(arr[j]>arr[j+1])\n      \
    \      return false;\n        j++;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkwobkvwt.cpp: In function 'int main()':\n/tmp/tmpkwobkvwt.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkwobkvwt.cpp:2:\n/tmp/tmpkwobkvwt.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpkwobkvwt.cpp:51:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpkwobkvwt.cpp:51:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpkwobkvwt.cpp:51:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpkwobkvwt.cpp:51:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpkwobkvwt.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkwobkvwt.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min = arr[0];\n    for(long i=1;i<arr.size();i++){\n        if(arr[i]<min)\n\
    \            return false;\n        min = std::min(min,arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzwltvq55.cpp: In function 'int main()':\n/tmp/tmpzwltvq55.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzwltvq55.cpp:2:\n/tmp/tmpzwltvq55.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpzwltvq55.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpzwltvq55.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzwltvq55.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpzwltvq55.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpzwltvq55.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzwltvq55.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()==0)\n\
    \        return true;\n    std::vector<long> temp = arr;\n    std::sort(temp.begin(),\
    \ temp.end());\n    int count = 0;\n    for(int i=0; i<arr.size(); i++){\n   \
    \     if(arr[i]!=temp[i])\n            count++;\n    }\n    if(count==1)\n   \
    \     return true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ffslk44.cpp: In function 'int main()':\n/tmp/tmp8ffslk44.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ffslk44.cpp:2:\n/tmp/tmp8ffslk44.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp8ffslk44.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp8ffslk44.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8ffslk44.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp8ffslk44.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8ffslk44.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ffslk44.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        if(arr[i]>min)\n            min=arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplbs3l8gc.cpp: In function 'int main()':\n/tmp/tmplbs3l8gc.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplbs3l8gc.cpp:2:\n/tmp/tmplbs3l8gc.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmplbs3l8gc.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmplbs3l8gc.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmplbs3l8gc.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmplbs3l8gc.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmplbs3l8gc.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplbs3l8gc.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_y2tqzht.cpp: In function 'int main()':\n/tmp/tmp_y2tqzht.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_y2tqzht.cpp:2:\n/tmp/tmp_y2tqzht.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp_y2tqzht.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp_y2tqzht.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp_y2tqzht.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp_y2tqzht.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp_y2tqzht.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_y2tqzht.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        if(arr[i]>min)\n            min=arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplbs3l8gc.cpp: In function 'int main()':\n/tmp/tmplbs3l8gc.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplbs3l8gc.cpp:2:\n/tmp/tmplbs3l8gc.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmplbs3l8gc.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmplbs3l8gc.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmplbs3l8gc.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmplbs3l8gc.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmplbs3l8gc.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplbs3l8gc.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int min_idx = 0;\n    for(int i = 1; i < n; i++)\n\
    \    {\n        if(arr[i] < arr[min_idx])\n            min_idx = i;\n    }\n \
    \   if(min_idx == 0)\n        return true;\n    if(min_idx == n-1)\n        return\
    \ false;\n    for(int i = min_idx+1; i < n; i++)\n    {\n        if(arr[i] < arr[i-1])\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5dqnn_jm.cpp: In function 'int main()':\n/tmp/tmp5dqnn_jm.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5dqnn_jm.cpp:2:\n/tmp/tmp5dqnn_jm.cpp:50:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp5dqnn_jm.cpp:50:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp5dqnn_jm.cpp:50:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5dqnn_jm.cpp:50:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5dqnn_jm.cpp:50:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5dqnn_jm.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5dqnn_jm.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0) return\
    \ true;\n    int max_index = 0;\n    for(int i=1;i<n;i++){\n        if(arr[i]>arr[max_index]){\n\
    \            max_index = i;\n        }\n    }\n    if(max_index==0) return true;\n\
    \    for(int i=0;i<max_index;i++){\n        if(arr[i]>arr[i+1]) return false;\n\
    \    }\n    for(int i=max_index;i<n-1;i++){\n        if(arr[i]>arr[i+1]) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaktvphv4.cpp: In function 'int main()':\n/tmp/tmpaktvphv4.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaktvphv4.cpp:2:\n/tmp/tmpaktvphv4.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpaktvphv4.cpp:47:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpaktvphv4.cpp:47:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpaktvphv4.cpp:47:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpaktvphv4.cpp:47:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpaktvphv4.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaktvphv4.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0) return true;\n\
    \    std::vector<long> v(arr.size());\n    std::copy(arr.begin(),arr.end(),v.begin());\n\
    \    std::sort(v.begin(),v.end());\n    int i=0;\n    while(i<arr.size()){\n \
    \       if(arr[i]!=v[i]){\n            int j=i+1;\n            while(j<arr.size()){\n\
    \                if(arr[j]==v[i]){\n                    std::rotate(arr.begin()+i,arr.begin()+j,arr.begin()+j+1);\n\
    \                    break;\n                }\n                j++;\n       \
    \     }\n            if(j==arr.size()) return false;\n        }\n        i++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptkq_rox5.cpp: In function 'int main()':\n/tmp/tmptkq_rox5.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptkq_rox5.cpp:2:\n/tmp/tmptkq_rox5.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmptkq_rox5.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmptkq_rox5.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmptkq_rox5.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmptkq_rox5.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmptkq_rox5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptkq_rox5.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int count=0;\n    for(int i=0;i<n-1;i++)\n    {\n\
    \        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count>1)\n \
    \       return false;\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaz1z9qvl.cpp: In function 'int main()':\n/tmp/tmpaz1z9qvl.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaz1z9qvl.cpp:2:\n/tmp/tmpaz1z9qvl.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpaz1z9qvl.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpaz1z9qvl.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpaz1z9qvl.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpaz1z9qvl.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpaz1z9qvl.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaz1z9qvl.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\
    \    int i = 0;\n    while(i < arr.size() && arr[i] == sorted_arr[i]) i++;\n \
    \   if(i == arr.size()) return true;\n    int j = i + 1;\n    while(j < arr.size()\
    \ && arr[j] == sorted_arr[j]) j++;\n    if(j == arr.size()) return true;\n   \
    \ if(arr[i] == sorted_arr[j] && arr[j] == sorted_arr[i]) return true;\n    return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsqep__i6.cpp: In function 'int main()':\n/tmp/tmpsqep__i6.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsqep__i6.cpp:2:\n/tmp/tmpsqep__i6.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpsqep__i6.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpsqep__i6.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpsqep__i6.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpsqep__i6.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsqep__i6.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsqep__i6.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()==0)\n\
    \        return true;\n    int n=arr.size();\n    int i=0;\n    int j=n-1;\n \
    \   while(i<j){\n        if(arr[i]<arr[j]){\n            i++;\n            j--;\n\
    \        }\n        else{\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxb_i7kgn.cpp: In function 'int main()':\n/tmp/tmpxb_i7kgn.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb_i7kgn.cpp:2:\n/tmp/tmpxb_i7kgn.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpxb_i7kgn.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpxb_i7kgn.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpxb_i7kgn.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpxb_i7kgn.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpxb_i7kgn.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxb_i7kgn.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr(arr);\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        if(arr[i] != sorted_arr[i])\n            count++;\n    }\n    if(count\
    \ > 2)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiih33gmf.cpp: In function 'int main()':\n/tmp/tmpiih33gmf.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiih33gmf.cpp:2:\n/tmp/tmpiih33gmf.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpiih33gmf.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpiih33gmf.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpiih33gmf.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpiih33gmf.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpiih33gmf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiih33gmf.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = arr[i];\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnv3l3a0j.cpp: In function 'int main()':\n/tmp/tmpnv3l3a0j.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2:\n/tmp/tmpnv3l3a0j.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnv3l3a0j.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnv3l3a0j.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpnv3l3a0j.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    long max = arr[0];\n    for(int i = 1; i < arr.size();\
    \ i++){\n        if(arr[i] < min)\n            min = arr[i];\n        if(arr[i]\
    \ > max)\n            max = arr[i];\n    }\n    if(max - min == arr.size() - 1)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb77p9ps1.cpp: In function 'int main()':\n/tmp/tmpb77p9ps1.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb77p9ps1.cpp:2:\n/tmp/tmpb77p9ps1.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpb77p9ps1.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpb77p9ps1.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpb77p9ps1.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpb77p9ps1.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpb77p9ps1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb77p9ps1.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0)\n        return true;\n    int min_index = 0;\n    for(int i = 1; i < n;\
    \ i++) {\n        if(arr[i] < arr[min_index])\n            min_index = i;\n  \
    \  }\n    if(min_index == 0)\n        return true;\n    for(int i = 1; i < n;\
    \ i++) {\n        if(arr[i] < arr[i-1])\n            return false;\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyux495k9.cpp: In function 'int main()':\n/tmp/tmpyux495k9.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyux495k9.cpp:2:\n/tmp/tmpyux495k9.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpyux495k9.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpyux495k9.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyux495k9.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyux495k9.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpyux495k9.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyux495k9.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    int max = arr[0];\n    int i;\n    for(i = 1; i < arr.size(); i++)\n\
    \    {\n        if(arr[i] < max)\n            break;\n        max = arr[i];\n\
    \    }\n    if(i == arr.size())\n        return true;\n    int min = arr[arr.size()\
    \ - 1];\n    for(i = arr.size() - 2; i >= 0; i--)\n    {\n        if(arr[i] >\
    \ min)\n            break;\n        min = arr[i];\n    }\n    if(i == -1)\n  \
    \      return true;\n    return false;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprqd_4inb.cpp: In function 'int main()':\n/tmp/tmprqd_4inb.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprqd_4inb.cpp:2:\n/tmp/tmprqd_4inb.cpp:53:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmprqd_4inb.cpp:53:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmprqd_4inb.cpp:53:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmprqd_4inb.cpp:53:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmprqd_4inb.cpp:53:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmprqd_4inb.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprqd_4inb.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        max = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0krlomc9.cpp: In function 'int main()':\n/tmp/tmp0krlomc9.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0krlomc9.cpp:2:\n/tmp/tmp0krlomc9.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp0krlomc9.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp0krlomc9.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0krlomc9.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp0krlomc9.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp0krlomc9.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0krlomc9.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    int j=1;\n    while(j<arr.size()){\n        if(arr[i]>arr[j]){\n\
    \            return false;\n        }\n        i++;\n        j++;\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcbeuhkpa.cpp: In function 'int main()':\n/tmp/tmpcbeuhkpa.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcbeuhkpa.cpp:2:\n/tmp/tmpcbeuhkpa.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpcbeuhkpa.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpcbeuhkpa.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpcbeuhkpa.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpcbeuhkpa.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpcbeuhkpa.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcbeuhkpa.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n     \
    \       break;\n        i++;\n    }\n    if(i==arr.size()-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<arr.size()-1){\n        if(arr[j]<arr[j+1])\n   \
    \         return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr6pa8smb.cpp: In function 'int main()':\n/tmp/tmpr6pa8smb.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr6pa8smb.cpp:2:\n/tmp/tmpr6pa8smb.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpr6pa8smb.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpr6pa8smb.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpr6pa8smb.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpr6pa8smb.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpr6pa8smb.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr6pa8smb.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)\n        return\
    \ true;\n    int i=0;\n    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==arr.size()-1)\n        return\
    \ true;\n    int j=i+1;\n    while(j<arr.size()-1){\n        if(arr[j]<arr[j+1])\n\
    \            return false;\n        j++;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9e9hf9w9.cpp: In function 'int main()':\n/tmp/tmp9e9hf9w9.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9e9hf9w9.cpp:2:\n/tmp/tmp9e9hf9w9.cpp:45:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp9e9hf9w9.cpp:45:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp9e9hf9w9.cpp:45:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp9e9hf9w9.cpp:45:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp9e9hf9w9.cpp:45:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp9e9hf9w9.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9e9hf9w9.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        if(arr[i] != sorted_arr[i])\n            count++;\n    }\n    if(count\
    \ > 2)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxhhwrvq0.cpp: In function 'int main()':\n/tmp/tmpxhhwrvq0.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxhhwrvq0.cpp:2:\n/tmp/tmpxhhwrvq0.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpxhhwrvq0.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpxhhwrvq0.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpxhhwrvq0.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpxhhwrvq0.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpxhhwrvq0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxhhwrvq0.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa0a20vy3.cpp: In function 'int main()':\n/tmp/tmpa0a20vy3.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa0a20vy3.cpp:2:\n/tmp/tmpa0a20vy3.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpa0a20vy3.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpa0a20vy3.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpa0a20vy3.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpa0a20vy3.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpa0a20vy3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa0a20vy3.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> temp = arr;\n    std::sort(temp.begin(), temp.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != temp[i])\n            count++;\n    }\n    if(count > 2)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo4o9i9xe.cpp: In function 'int main()':\n/tmp/tmpo4o9i9xe.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpo4o9i9xe.cpp:2:\n/tmp/tmpo4o9i9xe.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpo4o9i9xe.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpo4o9i9xe.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpo4o9i9xe.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpo4o9i9xe.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpo4o9i9xe.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpo4o9i9xe.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    std::vector<long> temp = arr;\n    std::sort(temp.begin(), temp.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != temp[i])\n            count++;\n    }\n    if(count > 2)\n        return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmporynvp3x.cpp: In function 'int main()':\n/tmp/tmporynvp3x.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmporynvp3x.cpp:2:\n/tmp/tmporynvp3x.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmporynvp3x.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmporynvp3x.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmporynvp3x.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmporynvp3x.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmporynvp3x.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmporynvp3x.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int min=arr[0];\n    int min_index=0;\n    for(int\
    \ i=1;i<n;i++){\n        if(arr[i]<min){\n            min=arr[i];\n          \
    \  min_index=i;\n        }\n    }\n    if(min_index==0)\n        return true;\n\
    \    else\n        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp212i1x04.cpp: In function 'int main()':\n/tmp/tmp212i1x04.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp212i1x04.cpp:2:\n/tmp/tmp212i1x04.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp212i1x04.cpp:46:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp212i1x04.cpp:46:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp212i1x04.cpp:46:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp212i1x04.cpp:46:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp212i1x04.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp212i1x04.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> v;\n    for(int i = 0; i < arr.size(); i++)\n \
    \       v.push_back(arr[i]);\n    std::sort(v.begin(), v.end());\n    int count\
    \ = 0;\n    for(int i = 0; i < arr.size(); i++)\n    {\n        if(arr[i] != v[i])\n\
    \            count++;\n    }\n    if(count == 1)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpezpr40gc.cpp: In function 'int main()':\n/tmp/tmpezpr40gc.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpezpr40gc.cpp:2:\n/tmp/tmpezpr40gc.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpezpr40gc.cpp:47:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpezpr40gc.cpp:47:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpezpr40gc.cpp:47:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpezpr40gc.cpp:47:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpezpr40gc.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpezpr40gc.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    int n = arr.size();\n    int i = 0;\n    while(i < n - 1) {\n        if(arr[i]\
    \ > arr[i + 1]) {\n            int j = i + 1;\n            while(j < n - 1 &&\
    \ arr[j] > arr[j + 1]) j++;\n            if(j == n - 1) return false;\n      \
    \      else {\n                i = j;\n            }\n        }\n        i++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2s60iix7.cpp: In function 'int main()':\n/tmp/tmp2s60iix7.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2s60iix7.cpp:2:\n/tmp/tmp2s60iix7.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp2s60iix7.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp2s60iix7.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2s60iix7.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp2s60iix7.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2s60iix7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2s60iix7.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ == sorted[i]) count++;\n    }\n    if(count == arr.size()) return true;\n  \
    \  return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe60qdv9v.cpp: In function 'int main()':\n/tmp/tmpe60qdv9v.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe60qdv9v.cpp:2:\n/tmp/tmpe60qdv9v.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpe60qdv9v.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpe60qdv9v.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpe60qdv9v.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpe60qdv9v.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpe60qdv9v.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe60qdv9v.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i +\
    \ 1]) {\n            std::rotate(arr.begin(), arr.begin() + i + 1, arr.end());\n\
    \            i = 0;\n        } else {\n            i++;\n        }\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpna9lk8qu.cpp: In function 'int main()':\n/tmp/tmpna9lk8qu.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpna9lk8qu.cpp:2:\n/tmp/tmpna9lk8qu.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpna9lk8qu.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpna9lk8qu.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpna9lk8qu.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpna9lk8qu.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpna9lk8qu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpna9lk8qu.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    int n = arr.size();\n    std::vector<int> dp(n, 1);\n    for(int i = 1; i\
    \ < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[i] >=\
    \ arr[j]) {\n                dp[i] = std::max(dp[i], dp[j] + 1);\n           \
    \ }\n        }\n    }\n    return dp[n - 1] == n;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgwio3v9t.cpp: In function 'int main()':\n/tmp/tmpgwio3v9t.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgwio3v9t.cpp:2:\n/tmp/tmpgwio3v9t.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpgwio3v9t.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpgwio3v9t.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgwio3v9t.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpgwio3v9t.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgwio3v9t.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgwio3v9t.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n        return\
    \ true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if(arr[i]\
    \ == i+1)\n            count++;\n    }\n    if(count == n)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwrmf5dw_.cpp: In function 'int main()':\n/tmp/tmpwrmf5dw_.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwrmf5dw_.cpp:2:\n/tmp/tmpwrmf5dw_.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpwrmf5dw_.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpwrmf5dw_.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpwrmf5dw_.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpwrmf5dw_.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpwrmf5dw_.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwrmf5dw_.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr(arr);\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    long count = 0;\n    for(long i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] != sorted_arr[i]) {\n            count++;\n      \
    \  }\n    }\n    if(count > 1)\n        return false;\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpohkwdknj.cpp: In function 'int main()':\n/tmp/tmpohkwdknj.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpohkwdknj.cpp:2:\n/tmp/tmpohkwdknj.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpohkwdknj.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpohkwdknj.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpohkwdknj.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpohkwdknj.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpohkwdknj.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpohkwdknj.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ == sorted[0]) {\n            count++;\n        }\n    }\n    if(count == 1)\
    \ return true;\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdee3hrqz.cpp: In function 'int main()':\n/tmp/tmpdee3hrqz.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdee3hrqz.cpp:2:\n/tmp/tmpdee3hrqz.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpdee3hrqz.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpdee3hrqz.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpdee3hrqz.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpdee3hrqz.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpdee3hrqz.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdee3hrqz.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int min_index = 0;\n    for(int i = 1; i < n; i++)\n\
    \    {\n        if(arr[i] < arr[min_index])\n            min_index = i;\n    }\n\
    \    if(min_index == 0)\n        return true;\n    else if(min_index == n-1)\n\
    \        return false;\n    else\n    {\n        for(int i = min_index; i < n-1;\
    \ i++)\n        {\n            if(arr[i] > arr[i+1])\n                return false;\n\
    \        }\n        return true;\n    }\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp35u_2ft0.cpp: In function 'int main()':\n/tmp/tmp35u_2ft0.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp35u_2ft0.cpp:2:\n/tmp/tmp35u_2ft0.cpp:53:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp35u_2ft0.cpp:53:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp35u_2ft0.cpp:53:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp35u_2ft0.cpp:53:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp35u_2ft0.cpp:53:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp35u_2ft0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp35u_2ft0.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int n = arr.size();\n    int min = arr[0];\n    int min_index = 0;\n    for(int\
    \ i = 1; i < n; i++){\n        if(arr[i] < min){\n            min = arr[i];\n\
    \            min_index = i;\n        }\n    }\n    if(min_index == 0)\n      \
    \  return true;\n    if(min_index == n-1)\n        return false;\n    for(int\
    \ i = min_index+1; i < n; i++){\n        if(arr[i] < min)\n            return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptbdnqhb7.cpp: In function 'int main()':\n/tmp/tmptbdnqhb7.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptbdnqhb7.cpp:2:\n/tmp/tmptbdnqhb7.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmptbdnqhb7.cpp:51:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmptbdnqhb7.cpp:51:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmptbdnqhb7.cpp:51:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmptbdnqhb7.cpp:51:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmptbdnqhb7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptbdnqhb7.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0)\n    \
    \    return true;\n    int count = 0;\n    for(int i=0;i<n-1;i++){\n        if(arr[i]>arr[i+1])\n\
    \            count++;\n    }\n    if(count>1)\n        return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp36dcqe2x.cpp: In function 'int main()':\n/tmp/tmp36dcqe2x.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp36dcqe2x.cpp:2:\n/tmp/tmp36dcqe2x.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp36dcqe2x.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp36dcqe2x.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp36dcqe2x.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp36dcqe2x.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp36dcqe2x.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp36dcqe2x.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfswbk7iu.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmpfswbk7iu.cpp:34:35: error: no matching function for call to\
    \ 'min(int&, long int&)'\n         min = std::min(min, arr[i]);\n            \
    \                       ^\n/tmp/tmpfswbk7iu.cpp:34:35: note: candidates are:\n\
    In file included from /usr/include/c++/4.8.2/algorithm:61:0,\n               \
    \  from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n       \
    \          from /tmp/tmpfswbk7iu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note: template<class _Tp> const _Tp& std::min(const _Tp&, const _Tp&)\n    \
    \ min(const _Tp& __a, const _Tp& __b)\n     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpfswbk7iu.cpp:34:35:\
    \ note:   deduced conflicting types for parameter 'const _Tp' ('int' and 'long\
    \ int')\n         min = std::min(min, arr[i]);\n                             \
    \      ^\nIn file included from /usr/include/c++/4.8.2/algorithm:61:0,\n     \
    \            from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmpfswbk7iu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5:\
    \ note: template<class _Tp, class _Compare> const _Tp& std::min(const _Tp&, const\
    \ _Tp&, _Compare)\n     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n\
    \     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpfswbk7iu.cpp:34:35: note:   deduced\
    \ conflicting types for parameter 'const _Tp' ('int' and 'long int')\n       \
    \  min = std::min(min, arr[i]);\n                                   ^\n/tmp/tmpfswbk7iu.cpp:\
    \ In function 'int main()':\n/tmp/tmpfswbk7iu.cpp:39:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = move_one_ball;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfswbk7iu.cpp:2:\n/tmp/tmpfswbk7iu.cpp:40:40: warning:\
    \ extended initializ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n    {\n        return\
    \ true;\n    }\n    std::vector<long> arr1;\n    for(int i=0;i<arr.size();i++)\n\
    \    {\n        arr1.push_back(arr[i]);\n    }\n    std::sort(arr1.begin(),arr1.end());\n\
    \    int count=0;\n    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=arr1[i])\n\
    \        {\n            count++;\n        }\n    }\n    if(count>2)\n    {\n \
    \       return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjwiwhlwk.cpp: In function 'int main()':\n/tmp/tmpjwiwhlwk.cpp:53:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwiwhlwk.cpp:2:\n/tmp/tmpjwiwhlwk.cpp:54:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpjwiwhlwk.cpp:54:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpjwiwhlwk.cpp:54:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpjwiwhlwk.cpp:54:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpjwiwhlwk.cpp:54:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpjwiwhlwk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwiwhlwk.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0u4cxr9e.cpp: In function 'int main()':\n/tmp/tmp0u4cxr9e.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2:\n/tmp/tmp0u4cxr9e.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp0u4cxr9e.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0u4cxr9e.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp0u4cxr9e.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min) return false;\n        min = std::min(min, arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6_3ewyg1.cpp: In function 'int main()':\n/tmp/tmp6_3ewyg1.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_3ewyg1.cpp:2:\n/tmp/tmp6_3ewyg1.cpp:35:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp6_3ewyg1.cpp:35:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp6_3ewyg1.cpp:35:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp6_3ewyg1.cpp:35:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp6_3ewyg1.cpp:35:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp6_3ewyg1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_3ewyg1.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int i = 0;\n    while(i < n - 1) {\n        if(arr[i] > arr[i + 1])\
    \ {\n            int j = i + 1;\n            while(j < n - 1 && arr[j] > arr[j\
    \ + 1]) j++;\n            if(j == n - 1) return false;\n            else {\n \
    \               i = j;\n            }\n        }\n        i++;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2i1z2d2s.cpp: In function 'int main()':\n/tmp/tmp2i1z2d2s.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2i1z2d2s.cpp:2:\n/tmp/tmp2i1z2d2s.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp2i1z2d2s.cpp:46:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp2i1z2d2s.cpp:46:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2i1z2d2s.cpp:46:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp2i1z2d2s.cpp:46:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2i1z2d2s.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2i1z2d2s.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int max_val = arr[0];\n    for(int i = 1; i < n; i++) {\n       \
    \ if(arr[i] < max_val) return false;\n        max_val = std::max(max_val, arr[i]);\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi6m70dyw.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmpi6m70dyw.cpp:33:43: error: no matching function for call to\
    \ 'max(int&, long int&)'\n         max_val = std::max(max_val, arr[i]);\n    \
    \                                       ^\n/tmp/tmpi6m70dyw.cpp:33:43: note: candidates\
    \ are:\nIn file included from /usr/include/c++/4.8.2/algorithm:61:0,\n       \
    \          from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmpi6m70dyw.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:216:5:\
    \ note: template<class _Tp> const _Tp& std::max(const _Tp&, const _Tp&)\n    \
    \ max(const _Tp& __a, const _Tp& __b)\n     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:216:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi6m70dyw.cpp:33:43:\
    \ note:   deduced conflicting types for parameter 'const _Tp' ('int' and 'long\
    \ int')\n         max_val = std::max(max_val, arr[i]);\n                     \
    \                      ^\nIn file included from /usr/include/c++/4.8.2/algorithm:61:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmpi6m70dyw.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:260:5:\
    \ note: template<class _Tp, class _Compare> const _Tp& std::max(const _Tp&, const\
    \ _Tp&, _Compare)\n     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n\
    \     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:260:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpi6m70dyw.cpp:33:43: note:   deduced\
    \ conflicting types for parameter 'const _Tp' ('int' and 'long int')\n       \
    \  max_val = std::max(max_val, arr[i]);\n                                    \
    \       ^\n/tmp/tmpi6m70dyw.cpp: In function 'int main()':\n/tmp/tmpi6m70dyw.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi6m70dyw.cpp:2:\n/tmp/tm"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    if(arr.size() == 1)\n        return true;\n    int i = 0;\n    int\
    \ j = arr.size() - 1;\n    while(i < j){\n        if(arr[i] > arr[i+1]){\n   \
    \         if(arr[i+1] < arr[j]){\n                return false;\n            }\n\
    \            else{\n                i++;\n            }\n        }\n        else{\n\
    \            i++;\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoxzp89_a.cpp: In function 'int main()':\n/tmp/tmpoxzp89_a.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoxzp89_a.cpp:2:\n/tmp/tmpoxzp89_a.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpoxzp89_a.cpp:51:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpoxzp89_a.cpp:51:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpoxzp89_a.cpp:51:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpoxzp89_a.cpp:51:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpoxzp89_a.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoxzp89_a.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int i = 0;\n    while(i < arr.size() && arr[i] == sorted_arr[i])\n\
    \        i++;\n    if(i == arr.size())\n        return true;\n    int j = i;\n\
    \    while(j < arr.size() && arr[j] != sorted_arr[i])\n        j++;\n    if(j\
    \ == arr.size())\n        return false;\n    while(j < arr.size() && arr[j] ==\
    \ sorted_arr[i])\n        j++;\n    if(j == arr.size())\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6j93gka5.cpp: In function 'int main()':\n/tmp/tmp6j93gka5.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6j93gka5.cpp:2:\n/tmp/tmp6j93gka5.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp6j93gka5.cpp:47:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp6j93gka5.cpp:47:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp6j93gka5.cpp:47:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp6j93gka5.cpp:47:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp6j93gka5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6j93gka5.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n  \
    \      if(arr[i] < min)\n            return false;\n        if(arr[i] > min)\n\
    \            min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptdij7kfy.cpp: In function 'int main()':\n/tmp/tmptdij7kfy.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptdij7kfy.cpp:2:\n/tmp/tmptdij7kfy.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmptdij7kfy.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmptdij7kfy.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmptdij7kfy.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmptdij7kfy.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmptdij7kfy.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptdij7kfy.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = arr[i];\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnv3l3a0j.cpp: In function 'int main()':\n/tmp/tmpnv3l3a0j.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2:\n/tmp/tmpnv3l3a0j.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnv3l3a0j.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnv3l3a0j.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpnv3l3a0j.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> arr1 = arr;\n    std::sort(arr1.begin(), arr1.end());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] != arr1[i])\n  \
    \          return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpij_0wp62.cpp: In function 'int main()':\n/tmp/tmpij_0wp62.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpij_0wp62.cpp:2:\n/tmp/tmpij_0wp62.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpij_0wp62.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpij_0wp62.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpij_0wp62.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpij_0wp62.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpij_0wp62.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpij_0wp62.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != sorted_arr[i]) count++;\n    }\n    if(count > 2) return false;\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpohke3ge2.cpp: In function 'int main()':\n/tmp/tmpohke3ge2.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpohke3ge2.cpp:2:\n/tmp/tmpohke3ge2.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpohke3ge2.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpohke3ge2.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpohke3ge2.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpohke3ge2.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpohke3ge2.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpohke3ge2.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] != sorted_arr[i])\
    \ {\n            if(arr[i] == sorted_arr[0]) {\n                std::rotate(arr.begin(),\
    \ arr.begin() + 1, arr.end());\n                i--;\n            } else {\n \
    \               return false;\n            }\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6de3tkgz.cpp: In function 'int main()':\n/tmp/tmp6de3tkgz.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6de3tkgz.cpp:2:\n/tmp/tmp6de3tkgz.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp6de3tkgz.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp6de3tkgz.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp6de3tkgz.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp6de3tkgz.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp6de3tkgz.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6de3tkgz.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    int max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n   \
    \     if(arr[i] < max)\n            return false;\n        max = arr[i];\n   \
    \ }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2z50hxlk.cpp: In function 'int main()':\n/tmp/tmp2z50hxlk.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2z50hxlk.cpp:2:\n/tmp/tmp2z50hxlk.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp2z50hxlk.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp2z50hxlk.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2z50hxlk.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp2z50hxlk.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2z50hxlk.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2z50hxlk.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5d_2vxge.cpp: In function 'int main()':\n/tmp/tmp5d_2vxge.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d_2vxge.cpp:2:\n/tmp/tmp5d_2vxge.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp5d_2vxge.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp5d_2vxge.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5d_2vxge.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5d_2vxge.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5d_2vxge.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d_2vxge.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int n = arr.size();\n    int i = 0;\n    while(i < n - 1) {\n   \
    \     if(arr[i] > arr[i + 1])\n            break;\n        i++;\n    }\n    if(i\
    \ == n - 1)\n        return true;\n    int j = i + 1;\n    while(j < n - 1) {\n\
    \        if(arr[j] < arr[j + 1])\n            return false;\n        j++;\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphl7zlkma.cpp: In function 'int main()':\n/tmp/tmphl7zlkma.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphl7zlkma.cpp:2:\n/tmp/tmphl7zlkma.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmphl7zlkma.cpp:46:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmphl7zlkma.cpp:46:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmphl7zlkma.cpp:46:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmphl7zlkma.cpp:46:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmphl7zlkma.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphl7zlkma.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> temp = arr;\n    std::sort(temp.begin(), temp.end());\n\
    \    if(temp == arr)\n        return true;\n    for(int i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] == temp[0]) {\n            std::rotate(arr.begin(),\
    \ arr.begin() + i, arr.end());\n            break;\n        }\n    }\n    if(arr\
    \ == temp)\n        return true;\n    return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3mu3khzu.cpp: In function 'int main()':\n/tmp/tmp3mu3khzu.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3mu3khzu.cpp:2:\n/tmp/tmp3mu3khzu.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp3mu3khzu.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp3mu3khzu.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3mu3khzu.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp3mu3khzu.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp3mu3khzu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3mu3khzu.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)\n        return\
    \ true;\n    int n=arr.size();\n    int count=0;\n    for(int i=0;i<n-1;i++){\n\
    \        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count>1)\n \
    \       return false;\n    else\n        return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphtf1kkg1.cpp: In function 'int main()':\n/tmp/tmphtf1kkg1.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphtf1kkg1.cpp:2:\n/tmp/tmphtf1kkg1.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmphtf1kkg1.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmphtf1kkg1.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmphtf1kkg1.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmphtf1kkg1.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmphtf1kkg1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphtf1kkg1.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int i = 0;\n\
    \    while(i < arr.size() - 1) {\n        if(arr[i] > arr[i + 1]) {\n        \
    \    int j = i + 1;\n            while(j < arr.size() - 1 && arr[j] > arr[j +\
    \ 1]) {\n                j++;\n            }\n            if(j == arr.size() -\
    \ 1) return false;\n            else {\n                int temp = arr[j];\n \
    \               for(int k = j; k > i; k--) {\n                    arr[k] = arr[k\
    \ - 1];\n                }\n                arr[i] = temp;\n            }\n  \
    \      }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp80pwolgw.cpp: In function 'int main()':\n/tmp/tmp80pwolgw.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp80pwolgw.cpp:2:\n/tmp/tmp80pwolgw.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp80pwolgw.cpp:51:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp80pwolgw.cpp:51:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp80pwolgw.cpp:51:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp80pwolgw.cpp:51:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp80pwolgw.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp80pwolgw.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0u4cxr9e.cpp: In function 'int main()':\n/tmp/tmp0u4cxr9e.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2:\n/tmp/tmp0u4cxr9e.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp0u4cxr9e.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0u4cxr9e.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp0u4cxr9e.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int i = 0;\n    while(i < arr.size() - 1){\n        if(arr[i] > arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i == arr.size() - 1)\n      \
    \  return true;\n    int j = i + 1;\n    while(j < arr.size() - 1){\n        if(arr[j]\
    \ < arr[j+1])\n            return false;\n        j++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp09pt9sh3.cpp: In function 'int main()':\n/tmp/tmp09pt9sh3.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp09pt9sh3.cpp:2:\n/tmp/tmp09pt9sh3.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp09pt9sh3.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp09pt9sh3.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp09pt9sh3.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp09pt9sh3.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp09pt9sh3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp09pt9sh3.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp54wwpe43.cpp: In function 'int main()':\n/tmp/tmp54wwpe43.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp54wwpe43.cpp:2:\n/tmp/tmp54wwpe43.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp54wwpe43.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp54wwpe43.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp54wwpe43.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp54wwpe43.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp54wwpe43.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp54wwpe43.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0){\n        return true;\n\
    \    }\n    int n=arr.size();\n    int count=0;\n    for(int i=0;i<n-1;i++){\n\
    \        if(arr[i]>arr[i+1]){\n            count++;\n        }\n    }\n    if(count>1){\n\
    \        return false;\n    }\n    else{\n        return true;\n    }\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgi8j57pf.cpp: In function 'int main()':\n/tmp/tmpgi8j57pf.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgi8j57pf.cpp:2:\n/tmp/tmpgi8j57pf.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpgi8j57pf.cpp:47:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpgi8j57pf.cpp:47:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgi8j57pf.cpp:47:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpgi8j57pf.cpp:47:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgi8j57pf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgi8j57pf.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int max=arr[0];\n    int min=arr[0];\n    int max_index=0;\n\
    \    int min_index=0;\n    for(int i=1;i<n;i++){\n        if(arr[i]>max){\n  \
    \          max=arr[i];\n            max_index=i;\n        }\n        if(arr[i]<min){\n\
    \            min=arr[i];\n            min_index=i;\n        }\n    }\n    if(max_index==0)\n\
    \        return true;\n    else if(min_index==n-1)\n        return false;\n  \
    \  else if(max_index>min_index)\n        return true;\n    else\n        return\
    \ false;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdry3832_.cpp: In function 'int main()':\n/tmp/tmpdry3832_.cpp:55:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdry3832_.cpp:2:\n/tmp/tmpdry3832_.cpp:56:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpdry3832_.cpp:56:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpdry3832_.cpp:56:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpdry3832_.cpp:56:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpdry3832_.cpp:56:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpdry3832_.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdry3832_.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> arr_copy = arr;\n    std::sort(arr_copy.begin(), arr_copy.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != arr_copy[i]) {\n            count++;\n        }\n    }\n    if(count > 1)\
    \ return false;\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd05ne2l0.cpp: In function 'int main()':\n/tmp/tmpd05ne2l0.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd05ne2l0.cpp:2:\n/tmp/tmpd05ne2l0.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpd05ne2l0.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpd05ne2l0.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpd05ne2l0.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpd05ne2l0.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpd05ne2l0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd05ne2l0.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n    int\
    \ i = 0;\n    while(i < arr.size() - 1){\n        if(arr[i] > arr[i+1]){\n   \
    \         arr.push_back(arr[0]);\n            arr.erase(arr.begin());\n      \
    \      i = 0;\n        }\n        else\n            i++;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy5dt6dat.cpp: In function 'int main()':\n/tmp/tmpy5dt6dat.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy5dt6dat.cpp:2:\n/tmp/tmpy5dt6dat.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpy5dt6dat.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpy5dt6dat.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpy5dt6dat.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpy5dt6dat.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpy5dt6dat.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy5dt6dat.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0)\n        return true;\n    long min = arr[0];\n    for(long i = 1; i <\
    \ arr.size(); i++){\n        if(arr[i] < min)\n            return false;\n   \
    \     min = std::min(min, arr[i]);\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8f18s5pf.cpp: In function 'int main()':\n/tmp/tmp8f18s5pf.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8f18s5pf.cpp:2:\n/tmp/tmp8f18s5pf.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp8f18s5pf.cpp:38:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp8f18s5pf.cpp:38:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8f18s5pf.cpp:38:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp8f18s5pf.cpp:38:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8f18s5pf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8f18s5pf.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int i=0;\n    int j=arr.size()-1;\n    while(i<j){\n        if(arr[i]>arr[j])\n\
    \            return false;\n        i++;\n        j--;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg_v7dg_3.cpp: In function 'int main()':\n/tmp/tmpg_v7dg_3.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg_v7dg_3.cpp:2:\n/tmp/tmpg_v7dg_3.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpg_v7dg_3.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpg_v7dg_3.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpg_v7dg_3.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpg_v7dg_3.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpg_v7dg_3.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg_v7dg_3.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min) return false;\n        min = std::min(min, arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6_3ewyg1.cpp: In function 'int main()':\n/tmp/tmp6_3ewyg1.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_3ewyg1.cpp:2:\n/tmp/tmp6_3ewyg1.cpp:35:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp6_3ewyg1.cpp:35:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp6_3ewyg1.cpp:35:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp6_3ewyg1.cpp:35:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp6_3ewyg1.cpp:35:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp6_3ewyg1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_3ewyg1.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int n = arr.size();\n    int min_index = 0;\n    for(int i = 1; i\
    \ < n; i++) {\n        if(arr[i] < arr[min_index])\n            min_index = i;\n\
    \    }\n    if(min_index == 0)\n        return true;\n    int count = 0;\n   \
    \ for(int i = min_index; i < n; i++) {\n        if(arr[i] < arr[i-1])\n      \
    \      count++;\n    }\n    if(count > 1)\n        return false;\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7g1bhtx7.cpp: In function 'int main()':\n/tmp/tmp7g1bhtx7.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7g1bhtx7.cpp:2:\n/tmp/tmp7g1bhtx7.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp7g1bhtx7.cpp:46:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp7g1bhtx7.cpp:46:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp7g1bhtx7.cpp:46:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp7g1bhtx7.cpp:46:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp7g1bhtx7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7g1bhtx7.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfswbk7iu.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmpfswbk7iu.cpp:34:35: error: no matching function for call to\
    \ 'min(int&, long int&)'\n         min = std::min(min, arr[i]);\n            \
    \                       ^\n/tmp/tmpfswbk7iu.cpp:34:35: note: candidates are:\n\
    In file included from /usr/include/c++/4.8.2/algorithm:61:0,\n               \
    \  from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n       \
    \          from /tmp/tmpfswbk7iu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note: template<class _Tp> const _Tp& std::min(const _Tp&, const _Tp&)\n    \
    \ min(const _Tp& __a, const _Tp& __b)\n     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpfswbk7iu.cpp:34:35:\
    \ note:   deduced conflicting types for parameter 'const _Tp' ('int' and 'long\
    \ int')\n         min = std::min(min, arr[i]);\n                             \
    \      ^\nIn file included from /usr/include/c++/4.8.2/algorithm:61:0,\n     \
    \            from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmpfswbk7iu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5:\
    \ note: template<class _Tp, class _Compare> const _Tp& std::min(const _Tp&, const\
    \ _Tp&, _Compare)\n     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n\
    \     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpfswbk7iu.cpp:34:35: note:   deduced\
    \ conflicting types for parameter 'const _Tp' ('int' and 'long int')\n       \
    \  min = std::min(min, arr[i]);\n                                   ^\n/tmp/tmpfswbk7iu.cpp:\
    \ In function 'int main()':\n/tmp/tmpfswbk7iu.cpp:39:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = move_one_ball;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfswbk7iu.cpp:2:\n/tmp/tmpfswbk7iu.cpp:40:40: warning:\
    \ extended initializ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int count=0;\n    for(int i=0;i<n-1;i++)\n    {\n\
    \        if(arr[i]>arr[i+1])\n            count++;\n    }\n    if(count>1)\n \
    \       return false;\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaz1z9qvl.cpp: In function 'int main()':\n/tmp/tmpaz1z9qvl.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaz1z9qvl.cpp:2:\n/tmp/tmpaz1z9qvl.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpaz1z9qvl.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpaz1z9qvl.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpaz1z9qvl.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpaz1z9qvl.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpaz1z9qvl.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaz1z9qvl.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i]\
    \ < min) {\n            return false;\n        }\n        min = arr[i];\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpopcb67x0.cpp: In function 'int main()':\n/tmp/tmpopcb67x0.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpopcb67x0.cpp:2:\n/tmp/tmpopcb67x0.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpopcb67x0.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpopcb67x0.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpopcb67x0.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpopcb67x0.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpopcb67x0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpopcb67x0.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n  \
    \      if(arr[i] < min)\n            return false;\n        min = arr[i];\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq4jfk63b.cpp: In function 'int main()':\n/tmp/tmpq4jfk63b.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq4jfk63b.cpp:2:\n/tmp/tmpq4jfk63b.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpq4jfk63b.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpq4jfk63b.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpq4jfk63b.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpq4jfk63b.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpq4jfk63b.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq4jfk63b.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int i = 0;\n    while(i < arr.size() - 1) {\n        if(arr[i] >\
    \ arr[i + 1]) {\n            int j = i + 1;\n            while(j < arr.size()\
    \ - 1 && arr[j] > arr[j + 1])\n                j++;\n            if(arr[j] > arr[0])\n\
    \                return false;\n            i = j;\n        }\n        i++;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl3hzby97.cpp: In function 'int main()':\n/tmp/tmpl3hzby97.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl3hzby97.cpp:2:\n/tmp/tmpl3hzby97.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpl3hzby97.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpl3hzby97.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpl3hzby97.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpl3hzby97.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpl3hzby97.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl3hzby97.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    int min_index = 0;\n    for(int i = 1; i < arr.size();\
    \ i++){\n        if(arr[i] < min){\n            min = arr[i];\n            min_index\
    \ = i;\n        }\n    }\n    if(min_index == 0)\n        return true;\n    for(int\
    \ i = min_index; i < arr.size() - 1; i++){\n        if(arr[i] > arr[i + 1])\n\
    \            return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpet6wtg_q.cpp: In function 'int main()':\n/tmp/tmpet6wtg_q.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpet6wtg_q.cpp:2:\n/tmp/tmpet6wtg_q.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpet6wtg_q.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpet6wtg_q.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpet6wtg_q.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpet6wtg_q.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpet6wtg_q.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpet6wtg_q.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    for(int i = 0; i < arr.size() - 1; i++) {\n        if(arr[i] > arr[i + 1])\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp59nhwb7b.cpp: In function 'int main()':\n/tmp/tmp59nhwb7b.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp59nhwb7b.cpp:2:\n/tmp/tmp59nhwb7b.cpp:33:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp59nhwb7b.cpp:33:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp59nhwb7b.cpp:33:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp59nhwb7b.cpp:33:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp59nhwb7b.cpp:33:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp59nhwb7b.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp59nhwb7b.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuihloh97.cpp: In function 'int main()':\n/tmp/tmpuihloh97.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuihloh97.cpp:2:\n/tmp/tmpuihloh97.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpuihloh97.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpuihloh97.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuihloh97.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpuihloh97.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpuihloh97.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuihloh97.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        if(arr[i] != sorted_arr[i])\n            count++;\n    }\n    if(count\
    \ > 2)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxhhwrvq0.cpp: In function 'int main()':\n/tmp/tmpxhhwrvq0.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxhhwrvq0.cpp:2:\n/tmp/tmpxhhwrvq0.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpxhhwrvq0.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpxhhwrvq0.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpxhhwrvq0.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpxhhwrvq0.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpxhhwrvq0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxhhwrvq0.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = arr[i];\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnv3l3a0j.cpp: In function 'int main()':\n/tmp/tmpnv3l3a0j.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2:\n/tmp/tmpnv3l3a0j.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnv3l3a0j.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnv3l3a0j.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpnv3l3a0j.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0) return\
    \ true;\n    int min = arr[0];\n    for(int i = 1; i < n; i++){\n        if(arr[i]\
    \ < min) return false;\n        if(arr[i] > min) min = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprw4_oo3z.cpp: In function 'int main()':\n/tmp/tmprw4_oo3z.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprw4_oo3z.cpp:2:\n/tmp/tmprw4_oo3z.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmprw4_oo3z.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmprw4_oo3z.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmprw4_oo3z.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmprw4_oo3z.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmprw4_oo3z.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprw4_oo3z.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != sorted_arr[i]) count++;\n    }\n    return count <= 1;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyp1xolhh.cpp: In function 'int main()':\n/tmp/tmpyp1xolhh.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyp1xolhh.cpp:2:\n/tmp/tmpyp1xolhh.cpp:36:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpyp1xolhh.cpp:36:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpyp1xolhh.cpp:36:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyp1xolhh.cpp:36:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyp1xolhh.cpp:36:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpyp1xolhh.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyp1xolhh.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    int n = arr.size();\n    int max_index = 0;\n    for(int i = 1; i\
    \ < n; i++)\n    {\n        if(arr[i] > arr[max_index])\n            max_index\
    \ = i;\n    }\n    if(max_index == n-1)\n        return true;\n    int min_index\
    \ = max_index;\n    for(int i = max_index; i < n; i++)\n    {\n        if(arr[i]\
    \ < arr[min_index])\n            min_index = i;\n    }\n    if(min_index == max_index)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5jjm7bp5.cpp: In function 'int main()':\n/tmp/tmp5jjm7bp5.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5jjm7bp5.cpp:2:\n/tmp/tmp5jjm7bp5.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp5jjm7bp5.cpp:51:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp5jjm7bp5.cpp:51:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5jjm7bp5.cpp:51:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5jjm7bp5.cpp:51:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5jjm7bp5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5jjm7bp5.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\
    \    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != sorted_arr[i]) count++;\n    }\n    return count <= 1;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyp1xolhh.cpp: In function 'int main()':\n/tmp/tmpyp1xolhh.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyp1xolhh.cpp:2:\n/tmp/tmpyp1xolhh.cpp:36:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpyp1xolhh.cpp:36:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpyp1xolhh.cpp:36:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyp1xolhh.cpp:36:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyp1xolhh.cpp:36:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpyp1xolhh.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyp1xolhh.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n        return\
    \ true;\n    if(n == 1)\n        return true;\n    int i = 0;\n    int j = n-1;\n\
    \    while(i < j){\n        if(arr[i] > arr[i+1]){\n            break;\n     \
    \   }\n        i++;\n    }\n    while(j > i){\n        if(arr[j] < arr[j-1]){\n\
    \            break;\n        }\n        j--;\n    }\n    if(i == j)\n        return\
    \ true;\n    if(i == j-1)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuv7z0i8k.cpp: In function 'int main()':\n/tmp/tmpuv7z0i8k.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuv7z0i8k.cpp:2:\n/tmp/tmpuv7z0i8k.cpp:55:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpuv7z0i8k.cpp:55:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpuv7z0i8k.cpp:55:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuv7z0i8k.cpp:55:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpuv7z0i8k.cpp:55:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpuv7z0i8k.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuv7z0i8k.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuihloh97.cpp: In function 'int main()':\n/tmp/tmpuihloh97.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuihloh97.cpp:2:\n/tmp/tmpuihloh97.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpuihloh97.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpuihloh97.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuihloh97.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpuihloh97.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpuihloh97.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuihloh97.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] == sorted[0]) {\n\
    \            std::vector<long> temp = arr;\n            std::rotate(temp.begin(),\
    \ temp.begin() + i, temp.end());\n            if(temp == sorted) return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjwps99im.cpp: In function 'int main()':\n/tmp/tmpjwps99im.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwps99im.cpp:2:\n/tmp/tmpjwps99im.cpp:39:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpjwps99im.cpp:39:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpjwps99im.cpp:39:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpjwps99im.cpp:39:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpjwps99im.cpp:39:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpjwps99im.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwps99im.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    long\
    \ min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] <\
    \ min) return false;\n        min = std::min(min, arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplc7hei3x.cpp: In function 'int main()':\n/tmp/tmplc7hei3x.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplc7hei3x.cpp:2:\n/tmp/tmplc7hei3x.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmplc7hei3x.cpp:38:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmplc7hei3x.cpp:38:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmplc7hei3x.cpp:38:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmplc7hei3x.cpp:38:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmplc7hei3x.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplc7hei3x.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl1phz85d.cpp: In function 'int main()':\n/tmp/tmpl1phz85d.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl1phz85d.cpp:2:\n/tmp/tmpl1phz85d.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpl1phz85d.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpl1phz85d.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpl1phz85d.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpl1phz85d.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpl1phz85d.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl1phz85d.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = arr[i];\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnv3l3a0j.cpp: In function 'int main()':\n/tmp/tmpnv3l3a0j.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2:\n/tmp/tmpnv3l3a0j.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnv3l3a0j.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnv3l3a0j.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpnv3l3a0j.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for(int i = 0; i < arr.size(); i++)\
    \ {\n        if(arr[i] != sorted_arr[i])\n            count++;\n    }\n    if(count\
    \ > 2)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxhhwrvq0.cpp: In function 'int main()':\n/tmp/tmpxhhwrvq0.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxhhwrvq0.cpp:2:\n/tmp/tmpxhhwrvq0.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpxhhwrvq0.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpxhhwrvq0.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpxhhwrvq0.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpxhhwrvq0.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpxhhwrvq0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxhhwrvq0.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5d_2vxge.cpp: In function 'int main()':\n/tmp/tmp5d_2vxge.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d_2vxge.cpp:2:\n/tmp/tmp5d_2vxge.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp5d_2vxge.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp5d_2vxge.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5d_2vxge.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5d_2vxge.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5d_2vxge.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d_2vxge.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0)\n        return true;\n    int min = arr[0];\n    for(int i = 1; i < arr.size();\
    \ i++){\n        if(arr[i] < min)\n            return false;\n        min = arr[i];\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgkl8x318.cpp: In function 'int main()':\n/tmp/tmpgkl8x318.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgkl8x318.cpp:2:\n/tmp/tmpgkl8x318.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpgkl8x318.cpp:38:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpgkl8x318.cpp:38:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgkl8x318.cpp:38:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpgkl8x318.cpp:38:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgkl8x318.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgkl8x318.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoltxvonj.cpp: In function 'int main()':\n/tmp/tmpoltxvonj.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoltxvonj.cpp:2:\n/tmp/tmpoltxvonj.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpoltxvonj.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpoltxvonj.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpoltxvonj.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpoltxvonj.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpoltxvonj.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoltxvonj.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0){\n        return\
    \ true;\n    }\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    int count = 0;\n    for(int i = 0; i < arr.size(); i++){\n\
    \        if(arr[i] != sorted_arr[i]){\n            count++;\n        }\n    }\n\
    \    if(count == 1){\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2d4nw8no.cpp: In function 'int main()':\n/tmp/tmp2d4nw8no.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2d4nw8no.cpp:2:\n/tmp/tmp2d4nw8no.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp2d4nw8no.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp2d4nw8no.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2d4nw8no.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp2d4nw8no.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2d4nw8no.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2d4nw8no.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n    int\
    \ max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] <\
    \ max) return false;\n        if(arr[i] > max) max = arr[i];\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp99yyx_8v.cpp: In function 'int main()':\n/tmp/tmp99yyx_8v.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp99yyx_8v.cpp:2:\n/tmp/tmp99yyx_8v.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp99yyx_8v.cpp:38:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp99yyx_8v.cpp:38:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp99yyx_8v.cpp:38:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp99yyx_8v.cpp:38:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp99yyx_8v.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp99yyx_8v.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n\t// Write your code here\n\t// To print\
    \ results to the standard output you can use std::cout\n\t// Example: std::cout\
    \ << \"Hello world!\";\n\tif (arr.size() == 0)\n\t\treturn true;\n\tlong min =\
    \ arr[0];\n\tfor (int i = 1; i < arr.size(); i++) {\n\t\tif (arr[i] < min)\n\t\
    \t\treturn false;\n\t\tmin = std::min(min, arr[i]);\n\t}\n\treturn true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5nn34u98.cpp: In function 'int main()':\n/tmp/tmp5nn34u98.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5nn34u98.cpp:2:\n/tmp/tmp5nn34u98.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp5nn34u98.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp5nn34u98.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5nn34u98.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5nn34u98.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5nn34u98.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5nn34u98.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long max=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<max)\n\
    \            return false;\n        else\n            max=arr[i];\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu5ueeq86.cpp: In function 'int main()':\n/tmp/tmpu5ueeq86.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu5ueeq86.cpp:2:\n/tmp/tmpu5ueeq86.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpu5ueeq86.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpu5ueeq86.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu5ueeq86.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu5ueeq86.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpu5ueeq86.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu5ueeq86.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    int n = arr.size();\n    int count = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        if(arr[i] == i+1)\n            count++;\n    }\n    if(count\
    \ == n)\n        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpycjnyw75.cpp: In function 'int main()':\n/tmp/tmpycjnyw75.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpycjnyw75.cpp:2:\n/tmp/tmpycjnyw75.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpycjnyw75.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpycjnyw75.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpycjnyw75.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpycjnyw75.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpycjnyw75.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpycjnyw75.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0) return true;\n    int i = 0;\n    while(i < n - 1) {\n        if(arr[i] >\
    \ arr[i + 1]) {\n            int j = i + 1;\n            while(j < n - 1 && arr[j]\
    \ > arr[j + 1]) {\n                j++;\n            }\n            if(j == n\
    \ - 1) return false;\n            else {\n                i = j;\n           \
    \ }\n        }\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp39wkxlms.cpp: In function 'int main()':\n/tmp/tmp39wkxlms.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp39wkxlms.cpp:2:\n/tmp/tmp39wkxlms.cpp:45:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp39wkxlms.cpp:45:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp39wkxlms.cpp:45:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp39wkxlms.cpp:45:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp39wkxlms.cpp:45:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp39wkxlms.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp39wkxlms.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    std::vector<long> sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\
    \    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] == sorted[0]) {\n\
    \            std::rotate(arr.begin(), arr.begin() + i, arr.end());\n         \
    \   break;\n        }\n    }\n    for(int i = 0; i < arr.size(); i++) {\n    \
    \    if(arr[i] != sorted[i]) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgchzagm7.cpp: In function 'int main()':\n/tmp/tmpgchzagm7.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgchzagm7.cpp:2:\n/tmp/tmpgchzagm7.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpgchzagm7.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpgchzagm7.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgchzagm7.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpgchzagm7.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgchzagm7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgchzagm7.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        if(arr[i] > min)\n            min\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp79lcbb9h.cpp: In function 'int main()':\n/tmp/tmp79lcbb9h.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp79lcbb9h.cpp:2:\n/tmp/tmp79lcbb9h.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp79lcbb9h.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp79lcbb9h.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp79lcbb9h.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp79lcbb9h.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp79lcbb9h.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp79lcbb9h.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    std::vector<long> arr2(arr.size());\n    for(int i=0;i<arr.size();i++)\n\
    \        arr2[i]=arr[i];\n    std::sort(arr2.begin(),arr2.end());\n    int count=0;\n\
    \    for(int i=0;i<arr.size();i++)\n    {\n        if(arr[i]!=arr2[i])\n     \
    \       count++;\n    }\n    if(count==1)\n        return true;\n    else\n  \
    \      return false;\n}\nint main() {\n    auto candidate = move_one_ball;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8nz971ai.cpp: In function 'int main()':\n/tmp/tmp8nz971ai.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8nz971ai.cpp:2:\n/tmp/tmp8nz971ai.cpp:47:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp8nz971ai.cpp:47:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp8nz971ai.cpp:47:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp8nz971ai.cpp:47:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp8nz971ai.cpp:47:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp8nz971ai.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8nz971ai.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = arr[i];\n \
    \   }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnv3l3a0j.cpp: In function 'int main()':\n/tmp/tmpnv3l3a0j.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2:\n/tmp/tmpnv3l3a0j.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnv3l3a0j.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnv3l3a0j.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnv3l3a0j.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpnv3l3a0j.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnv3l3a0j.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size()\
    \ == 0)\n        return true;\n    int min_index = 0;\n    for(int i = 1; i <\
    \ arr.size(); i++)\n        if(arr[i] < arr[min_index])\n            min_index\
    \ = i;\n    if(min_index == 0)\n        return true;\n    for(int i = 1; i < min_index;\
    \ i++)\n        if(arr[i] < arr[i-1])\n            return false;\n    for(int\
    \ i = min_index + 1; i < arr.size(); i++)\n        if(arr[i] < arr[i-1])\n   \
    \         return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphi89ftdo.cpp: In function 'int main()':\n/tmp/tmphi89ftdo.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphi89ftdo.cpp:2:\n/tmp/tmphi89ftdo.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmphi89ftdo.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmphi89ftdo.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmphi89ftdo.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmphi89ftdo.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmphi89ftdo.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphi89ftdo.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==n-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<n-1){\n        if(arr[j]<arr[j+1])\n            break;\n\
    \        j++;\n    }\n    if(j==n-1)\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiqk29rwt.cpp: In function 'int main()':\n/tmp/tmpiqk29rwt.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiqk29rwt.cpp:2:\n/tmp/tmpiqk29rwt.cpp:51:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpiqk29rwt.cpp:51:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpiqk29rwt.cpp:51:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpiqk29rwt.cpp:51:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpiqk29rwt.cpp:51:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpiqk29rwt.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiqk29rwt.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n == 0)\n  \
    \      return true;\n    int count = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        if(arr[i] == i+1)\n            count++;\n    }\n    if(count == n)\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_eraygbo.cpp: In function 'int main()':\n/tmp/tmp_eraygbo.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_eraygbo.cpp:2:\n/tmp/tmp_eraygbo.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp_eraygbo.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp_eraygbo.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp_eraygbo.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp_eraygbo.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp_eraygbo.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_eraygbo.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = std::min(min,\
    \ arr[i]);\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp21mxkk7m.cpp: In function 'int main()':\n/tmp/tmp21mxkk7m.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp21mxkk7m.cpp:2:\n/tmp/tmp21mxkk7m.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp21mxkk7m.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp21mxkk7m.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp21mxkk7m.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp21mxkk7m.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp21mxkk7m.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp21mxkk7m.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int n=arr.size();\n    int i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==n-1)\n        return true;\n\
    \    i++;\n    while(i<n-1){\n        if(arr[i]<arr[i+1])\n            return\
    \ false;\n        i++;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_7168__.cpp: In function 'int main()':\n/tmp/tmpq_7168__.cpp:48:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_7168__.cpp:2:\n/tmp/tmpq_7168__.cpp:49:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpq_7168__.cpp:49:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpq_7168__.cpp:49:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpq_7168__.cpp:49:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpq_7168__.cpp:49:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpq_7168__.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_7168__.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        if(arr[i] < arr[i-1])\n         \
    \   min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3ldgoj31.cpp: In function 'int main()':\n/tmp/tmp3ldgoj31.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3ldgoj31.cpp:2:\n/tmp/tmp3ldgoj31.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp3ldgoj31.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp3ldgoj31.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp3ldgoj31.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp3ldgoj31.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp3ldgoj31.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3ldgoj31.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0u4cxr9e.cpp: In function 'int main()':\n/tmp/tmp0u4cxr9e.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2:\n/tmp/tmp0u4cxr9e.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp0u4cxr9e.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0u4cxr9e.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp0u4cxr9e.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if(n ==\
    \ 0) return true;\n    int max_index = 0;\n    for(int i = 1; i < n; i++) {\n\
    \        if(arr[i] > arr[max_index]) {\n            max_index = i;\n        }\n\
    \    }\n    if(max_index == n - 1) return true;\n    for(int i = max_index + 1;\
    \ i < n; i++) {\n        if(arr[i] < arr[max_index]) return false;\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl161ol_c.cpp: In function 'int main()':\n/tmp/tmpl161ol_c.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl161ol_c.cpp:2:\n/tmp/tmpl161ol_c.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpl161ol_c.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpl161ol_c.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpl161ol_c.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpl161ol_c.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpl161ol_c.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl161ol_c.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbk7tcyvu.cpp: In function 'int main()':\n/tmp/tmpbk7tcyvu.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbk7tcyvu.cpp:2:\n/tmp/tmpbk7tcyvu.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpbk7tcyvu.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpbk7tcyvu.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpbk7tcyvu.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpbk7tcyvu.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpbk7tcyvu.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbk7tcyvu.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> sorted_arr = arr;\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    long count = 0;\n    for(long i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] != sorted_arr[i])\n            count++;\n    }\n \
    \   if(count > 2)\n        return false;\n    return true;\n}\nint main() {\n\
    \    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6_p844c7.cpp: In function 'int main()':\n/tmp/tmp6_p844c7.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_p844c7.cpp:2:\n/tmp/tmp6_p844c7.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp6_p844c7.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp6_p844c7.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp6_p844c7.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp6_p844c7.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp6_p844c7.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_p844c7.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::sort(arr.begin(), arr.end());\n    for(int i = 0; i < arr.size()\
    \ - 1; i++) {\n        if(arr[i] + 1 != arr[i + 1])\n            return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgo5lc1nf.cpp: In function 'int main()':\n/tmp/tmpgo5lc1nf.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgo5lc1nf.cpp:2:\n/tmp/tmpgo5lc1nf.cpp:36:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpgo5lc1nf.cpp:36:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpgo5lc1nf.cpp:36:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgo5lc1nf.cpp:36:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpgo5lc1nf.cpp:36:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgo5lc1nf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgo5lc1nf.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    int\
    \ n = arr.size();\n    if(n == 0) return true;\n    int i = 0;\n    while(i <\
    \ n-1){\n        if(arr[i] > arr[i+1]){\n            int j = i+1;\n          \
    \  while(j < n-1 && arr[j] > arr[j+1]) j++;\n            if(j == n-1) return false;\n\
    \            i = j;\n        }\n        i++;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpesdppwck.cpp: In function 'int main()':\n/tmp/tmpesdppwck.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpesdppwck.cpp:2:\n/tmp/tmpesdppwck.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpesdppwck.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpesdppwck.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpesdppwck.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpesdppwck.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpesdppwck.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpesdppwck.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int n = arr.size();\n    int max_index = 0;\n    for(int i = 1; i\
    \ < n; i++) {\n        if(arr[i] > arr[max_index])\n            max_index = i;\n\
    \    }\n    int index = max_index;\n    for(int i = 0; i < n; i++) {\n       \
    \ if(arr[index] < arr[(index + 1) % n])\n            return false;\n        index\
    \ = (index + 1) % n;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbhjhqcdf.cpp: In function 'int main()':\n/tmp/tmpbhjhqcdf.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbhjhqcdf.cpp:2:\n/tmp/tmpbhjhqcdf.cpp:43:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpbhjhqcdf.cpp:43:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpbhjhqcdf.cpp:43:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpbhjhqcdf.cpp:43:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpbhjhqcdf.cpp:43:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpbhjhqcdf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbhjhqcdf.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    std::vector<long> arr_copy = arr;\n    std::sort(arr_copy.begin(),\
    \ arr_copy.end());\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ != arr_copy[i])\n            return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsdj9ywqr.cpp: In function 'int main()':\n/tmp/tmpsdj9ywqr.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsdj9ywqr.cpp:2:\n/tmp/tmpsdj9ywqr.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpsdj9ywqr.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpsdj9ywqr.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpsdj9ywqr.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpsdj9ywqr.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpsdj9ywqr.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsdj9ywqr.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    int n = arr.size();\n    int max = arr[0];\n    int count = 0;\n\
    \    for(int i = 1; i < n; i++) {\n        if(arr[i] < max) {\n            count++;\n\
    \        }\n        else {\n            max = arr[i];\n        }\n    }\n    if(count\
    \ > 1)\n        return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprhqf1y5o.cpp: In function 'int main()':\n/tmp/tmprhqf1y5o.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprhqf1y5o.cpp:2:\n/tmp/tmprhqf1y5o.cpp:44:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmprhqf1y5o.cpp:44:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmprhqf1y5o.cpp:44:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmprhqf1y5o.cpp:44:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmprhqf1y5o.cpp:44:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmprhqf1y5o.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprhqf1y5o.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return\
    \ true;\n    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n \
    \       if(arr[i] < min)\n            return false;\n        min = std::min(min,\
    \ arr[i]);\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp21mxkk7m.cpp: In function 'int main()':\n/tmp/tmp21mxkk7m.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp21mxkk7m.cpp:2:\n/tmp/tmp21mxkk7m.cpp:37:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp21mxkk7m.cpp:37:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp21mxkk7m.cpp:37:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp21mxkk7m.cpp:37:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp21mxkk7m.cpp:37:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp21mxkk7m.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp21mxkk7m.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n    int\
    \ n = arr.size();\n    int max = arr[0];\n    for(int i = 1; i < n; i++){\n  \
    \      if(arr[i] < max)\n            return false;\n        if(arr[i] > max)\n\
    \            max = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpotxckoh5.cpp: In function 'int main()':\n/tmp/tmpotxckoh5.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpotxckoh5.cpp:2:\n/tmp/tmpotxckoh5.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpotxckoh5.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpotxckoh5.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpotxckoh5.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpotxckoh5.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpotxckoh5.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpotxckoh5.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        min=arr[i];\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0u4cxr9e.cpp: In function 'int main()':\n/tmp/tmp0u4cxr9e.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2:\n/tmp/tmp0u4cxr9e.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp0u4cxr9e.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp0u4cxr9e.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp0u4cxr9e.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp0u4cxr9e.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0u4cxr9e.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    std::vector<long> v;\n    v.push_back(arr[0]);\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]>=v[v.size()-1])\n            v.push_back(arr[i]);\n       \
    \ else{\n            int j=0;\n            while(j<v.size() && arr[i]<v[j])\n\
    \                j++;\n            if(j==v.size())\n                return false;\n\
    \            v.insert(v.begin()+j,arr[i]);\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1h5nvwdv.cpp: In function 'int main()':\n/tmp/tmp1h5nvwdv.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1h5nvwdv.cpp:2:\n/tmp/tmp1h5nvwdv.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp1h5nvwdv.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp1h5nvwdv.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1h5nvwdv.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp1h5nvwdv.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1h5nvwdv.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1h5nvwdv.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    int i = 0;\n    int j = arr.size() - 1;\n    while(i < j){\n    \
    \    if(arr[i] > arr[i+1]){\n            if(arr[i] > arr[j]){\n              \
    \  return false;\n            }\n            else{\n                i++;\n   \
    \         }\n        }\n        else{\n            i++;\n        }\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu2pru67k.cpp: In function 'int main()':\n/tmp/tmpu2pru67k.cpp:48:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu2pru67k.cpp:2:\n/tmp/tmpu2pru67k.cpp:49:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpu2pru67k.cpp:49:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpu2pru67k.cpp:49:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu2pru67k.cpp:49:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu2pru67k.cpp:49:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpu2pru67k.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu2pru67k.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0) return true;\n \
    \   long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min) return false;\n        min = std::min(min, arr[i]);\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnzwcqn8t.cpp: In function 'int main()':\n/tmp/tmpnzwcqn8t.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnzwcqn8t.cpp:2:\n/tmp/tmpnzwcqn8t.cpp:38:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpnzwcqn8t.cpp:38:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpnzwcqn8t.cpp:38:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnzwcqn8t.cpp:38:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnzwcqn8t.cpp:38:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpnzwcqn8t.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnzwcqn8t.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n    int min=arr[0];\n\
    \    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n          \
    \  return false;\n        min=arr[i];\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcspj634w.cpp: In function 'int main()':\n/tmp/tmpcspj634w.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcspj634w.cpp:2:\n/tmp/tmpcspj634w.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpcspj634w.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpcspj634w.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpcspj634w.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpcspj634w.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpcspj634w.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcspj634w.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size()==0)\n        return\
    \ true;\n    int n=arr.size();\n    int i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==n-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<n-1){\n        if(arr[j]<arr[j+1])\n            return\
    \ false;\n        j++;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuohnz2ve.cpp: In function 'int main()':\n/tmp/tmpuohnz2ve.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuohnz2ve.cpp:2:\n/tmp/tmpuohnz2ve.cpp:46:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpuohnz2ve.cpp:46:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpuohnz2ve.cpp:46:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuohnz2ve.cpp:46:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpuohnz2ve.cpp:46:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpuohnz2ve.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuohnz2ve.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < min)\n            return false;\n        min = std::min(min, arr[i]);\n  \
    \  }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5d_2vxge.cpp: In function 'int main()':\n/tmp/tmp5d_2vxge.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d_2vxge.cpp:2:\n/tmp/tmp5d_2vxge.cpp:40:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp5d_2vxge.cpp:40:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp5d_2vxge.cpp:40:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp5d_2vxge.cpp:40:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp5d_2vxge.cpp:40:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp5d_2vxge.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d_2vxge.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0) return true;\n\
    \    int n = arr.size();\n    int min = arr[0];\n    for(int i = 1; i < n; i++)\
    \ {\n        if(arr[i] < min) return false;\n        min = std::min(min, arr[i]);\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8pw50t5i.cpp: In function 'bool move_one_ball(std::vector<long\
    \ int>)':\n/tmp/tmp8pw50t5i.cpp:30:35: error: no matching function for call to\
    \ 'min(int&, long int&)'\n         min = std::min(min, arr[i]);\n            \
    \                       ^\n/tmp/tmp8pw50t5i.cpp:30:35: note: candidates are:\n\
    In file included from /usr/include/c++/4.8.2/algorithm:61:0,\n               \
    \  from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n       \
    \          from /tmp/tmp8pw50t5i.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note: template<class _Tp> const _Tp& std::min(const _Tp&, const _Tp&)\n    \
    \ min(const _Tp& __a, const _Tp& __b)\n     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp8pw50t5i.cpp:30:35:\
    \ note:   deduced conflicting types for parameter 'const _Tp' ('int' and 'long\
    \ int')\n         min = std::min(min, arr[i]);\n                             \
    \      ^\nIn file included from /usr/include/c++/4.8.2/algorithm:61:0,\n     \
    \            from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \                 from /tmp/tmp8pw50t5i.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5:\
    \ note: template<class _Tp, class _Compare> const _Tp& std::min(const _Tp&, const\
    \ _Tp&, _Compare)\n     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n\
    \     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp8pw50t5i.cpp:30:35: note:   deduced\
    \ conflicting types for parameter 'const _Tp' ('int' and 'long int')\n       \
    \  min = std::min(min, arr[i]);\n                                   ^\n/tmp/tmp8pw50t5i.cpp:\
    \ In function 'int main()':\n/tmp/tmp8pw50t5i.cpp:35:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = move_one_ball;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8pw50t5i.cpp:2:\n/tmp/tmp8pw50t5i.cpp:36:40: warning:\
    \ extended initializ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return true;\n\
    \    long max = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i]\
    \ < max)\n            return false;\n        if(arr[i] > max)\n            max\
    \ = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1,\
    \ (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5,\
    \ (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzkmx6fkf.cpp: In function 'int main()':\n/tmp/tmpzkmx6fkf.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzkmx6fkf.cpp:2:\n/tmp/tmpzkmx6fkf.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpzkmx6fkf.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpzkmx6fkf.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzkmx6fkf.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpzkmx6fkf.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpzkmx6fkf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzkmx6fkf.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use cout\n    // Example: cout\
    \ << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n    int i=0;\n\
    \    while(i<arr.size()-1){\n        if(arr[i]>arr[i+1])\n            break;\n\
    \        i++;\n    }\n    if(i==arr.size()-1)\n        return true;\n    int j=i+1;\n\
    \    while(j<arr.size()-1){\n        if(arr[j]<arr[j+1])\n            return false;\n\
    \        j++;\n    }\n    return true;\n}\nint main() {\n    auto candidate =\
    \ move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1mfmie3c.cpp: In function 'int main()':\n/tmp/tmp1mfmie3c.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1mfmie3c.cpp:2:\n/tmp/tmp1mfmie3c.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp1mfmie3c.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp1mfmie3c.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp1mfmie3c.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp1mfmie3c.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp1mfmie3c.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1mfmie3c.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    long min=arr[0];\n    for(int i=1;i<arr.size();i++)\n    {\n        if(arr[i]<min)\n\
    \            return false;\n        else\n            min=arr[i];\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftebdr6o.cpp: In function 'int main()':\n/tmp/tmpftebdr6o.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftebdr6o.cpp:2:\n/tmp/tmpftebdr6o.cpp:42:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpftebdr6o.cpp:42:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpftebdr6o.cpp:42:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpftebdr6o.cpp:42:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpftebdr6o.cpp:42:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpftebdr6o.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftebdr6o.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size() == 0)\n        return\
    \ true;\n    int min = arr[0];\n    for(int i = 1; i < arr.size(); i++){\n   \
    \     if(arr[i] < min)\n            return false;\n        if(arr[i] > min)\n\
    \            min = arr[i];\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2ajfb20j.cpp: In function 'int main()':\n/tmp/tmp2ajfb20j.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ajfb20j.cpp:2:\n/tmp/tmp2ajfb20j.cpp:41:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmp2ajfb20j.cpp:41:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmp2ajfb20j.cpp:41:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2ajfb20j.cpp:41:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp2ajfb20j.cpp:41:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2ajfb20j.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ajfb20j.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use std::cout\n    // Example:\
    \ std::cout << \"Hello world!\";\n    int n = arr.size();\n    if(n==0)\n    \
    \    return true;\n    int i=0;\n    while(i<n-1){\n        if(arr[i]>arr[i+1])\n\
    \            break;\n        i++;\n    }\n    if(i==n-1)\n        return true;\n\
    \    int j=i+1;\n    while(j<n-1){\n        if(arr[j]<arr[j+1])\n            return\
    \ false;\n        j++;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4,\
    \ (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgjqpwdjm.cpp: In function 'int main()':\n/tmp/tmpgjqpwdjm.cpp:48:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgjqpwdjm.cpp:2:\n/tmp/tmpgjqpwdjm.cpp:49:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpgjqpwdjm.cpp:49:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpgjqpwdjm.cpp:49:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgjqpwdjm.cpp:49:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpgjqpwdjm.cpp:49:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpgjqpwdjm.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgjqpwdjm.cpp:2"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr'\
    \ of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will\
    \ be randomly ordered. Your task is to determine if\n// it is possible to get\
    \ a vector sorted in non-decreasing order by performing \n// the following operation\
    \ on the given vector:\n// You are allowed to perform right shift operation any\
    \ number of times.\n// One right shift operation means shifting all elements of\
    \ the vector by one\n// position in the right direction. The last element of the\
    \ vector will be moved to\n// the starting position in the vector i.e. 0th index.\
    \ \n// If it is possible to obtain the sorted vector by performing the above operation\n\
    // then return true else return false.\n// If the given vector is empty then return\
    \ true.\n// Note: The given vector is guaranteed to have unique elements.\n//\
    \ For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n// be achieved for the given vector.\n\
    // >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n\
    // (false)\n// Explanation:It is not possible to get non-decreasing order for\
    \ the given\n// vector by performing any number of right shift operations.\nbool\
    \ move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    //\
    \ To print results to the standard output you can use the cout stream\n    //\
    \ Example: cout << \"Hello world!\";\n    if(arr.size()==0)\n        return true;\n\
    \    int min=arr[0];\n    int min_index=0;\n    for(int i=1;i<arr.size();i++){\n\
    \        if(arr[i]<min){\n            min=arr[i];\n            min_index=i;\n\
    \        }\n    }\n    if(min_index==0)\n        return true;\n    for(int i=0;i<min_index;i++){\n\
    \        if(arr[i]>min)\n            return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>()))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzhvruqra.cpp: In function 'int main()':\n/tmp/tmpzhvruqra.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = move_one_ball;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzhvruqra.cpp:2:\n/tmp/tmpzhvruqra.cpp:48:40: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::vector<long>({(long)3, (long)4, (long)5,\
    \ (long)1, (long)2}))) == (true));\n                                        ^\n\
    /tmp/tmpzhvruqra.cpp:48:86: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     assert(candidate((std::vector<long>({(long)3,\
    \ (long)4, (long)5, (long)1, (long)2}))) == (true));\n                       \
    \                                                               ^\n/tmp/tmpzhvruqra.cpp:48:86:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzhvruqra.cpp:48:86: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpzhvruqra.cpp:48:86: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpzhvruqra.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzhvruqra.cpp:2"
  stdout: ''
