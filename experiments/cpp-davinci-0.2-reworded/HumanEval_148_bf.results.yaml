language: cpp
name: HumanEval_148_bf
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 > p2) std::swap(p1, p2);\n    for (int i = p1\
    \ + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 > p2) std::swap(p1, p2);\n    for (int i = p1 +\
    \ 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint index1 = -1;\n\tint index2 = -1;\n\
    \tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\
    \t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tindex2 = i;\n\
    \t\t}\n\t}\n\tif (index1 == -1 || index2 == -1) {\n\t\treturn result;\n\t}\n\t\
    if (index1 < index2) {\n\t\tfor (int i = index1 + 1; i < index2; i++) {\n\t\t\t\
    result.push_back(planets[i]);\n\t\t}\n\t} else {\n\t\tfor (int i = index2 + 1;\
    \ i < index1; i++) {\n\t\t\tresult.push_back(planets[i]);\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i\
    \ < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"\n    };\n    std::vector<std::string> res;\n    int p1 = -1, p2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            p1 = i;\n        }\n        if (planets[i] == planet2)\
    \ {\n            p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n\
    \        return res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n\
    \    }\n    for (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 < index2) {\n        for\
    \ (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < 8; i++) {\n        if (planets[i] == planet1) p1 = i;\n        if\
    \ (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 == -1) return\
    \ result;\n    if (p1 > p2) {\n        int tmp = p1;\n        p1 = p2;\n     \
    \   p2 = tmp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = 0;\n    int index2\
    \ = 0;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == 0 ||\
    \ index2 == 0) {\n        return result;\n    }\n    if (index1 > index2) {\n\
    \        for (int i = index2; i < index1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index1; i < index2; i++) {\n  \
    \          result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpvkmkec76: /tmp/tmpvkmkec76.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        int temp = p1;\n        p1 = p2;\n\
    \        p2 = temp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    if (std::find(planets.begin(), planets.end(),\
    \ planet1) == planets.end() || std::find(planets.begin(), planets.end(), planet2)\
    \ == planets.end()) {\n        return result;\n    }\n    auto it1 = std::find(planets.begin(),\
    \ planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(),\
    \ planet2);\n    if (it1 > it2) {\n        std::swap(it1, it2);\n    }\n    std::copy(it1\
    \ + 1, it2, std::back_inserter(result));\n    return result;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (p1 == 8 || p2 == 8) {\n\
    \        return result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n\
    \    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 || end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdugd0zqe: /tmp/tmpdugd0zqe.cpp:48: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int tmp = start;\n\
    \        start = end;\n        end = tmp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++) {\n\
    \            res.push_back(planets[i]);\n        }\n    } else {\n        for\
    \ (int i = p2 + 1; i < p1; i++) {\n            res.push_back(planets[i]);\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    } else {\n\
    \        for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i\
    \ < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int tmp = start;\n\
    \        start = end;\n        end = tmp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (p1 == 8 || p2 == 8) {\n\
    \        return result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n\
    \    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (p1 == 8 || p2 == 8) {\n\
    \        return result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n\
    \    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (p1 == 8 || p2 == 8) {\n\
    \        return result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n\
    \    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n      \
    \  \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\
    \n    };\n    std::vector<std::string> result;\n    int p1 = -1;\n    int p2 =\
    \ -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            p1 = i;\n        }\n        if (planets[i] == planet2)\
    \ {\n            p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n\
    \        return result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n\
    \    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++) {\n\
    \            res.push_back(planets[i]);\n        }\n    } else {\n        for\
    \ (int i = p2 + 1; i < p1; i++) {\n            res.push_back(planets[i]);\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int index1 = -1, index2 = -1;\n   \
    \ for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            index1 = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            index2 = i;\n        }\n    }\n    if (index1 == -1 || index2 ==\
    \ -1) {\n        return res;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int first = 0;\n    int second =\
    \ 0;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] ==\
    \ planet1) {\n            first = i;\n        }\n        if (planets[i] == planet2)\
    \ {\n            second = i;\n        }\n    }\n    if (first == 0 || second ==\
    \ 0) {\n        return result;\n    }\n    if (first < second) {\n        for\
    \ (int i = first + 1; i < second; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = second + 1; i < first; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp_7d898z6: /tmp/tmp_7d898z6.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i1 = 0, i2 = 0;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          i1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    i2 = i;\n        }\n    }\n    if (i1 == 0 || i2 == 0) {\n        return\
    \ result;\n    }\n    if (i1 > i2) {\n        std::swap(i1, i2);\n    }\n    for\
    \ (int i = i1 + 1; i < i2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpjd3jj0do: /tmp/tmpjd3jj0do.cpp:45: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i\
    \ < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet1_index = -1;\n    int\
    \ planet2_index = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            planet1_index = i;\n        }\n \
    \       if (planets[i] == planet2) {\n            planet2_index = i;\n       \
    \ }\n    }\n    if (planet1_index == -1 || planet2_index == -1) {\n        return\
    \ result;\n    }\n    if (planet1_index < planet2_index) {\n        for (int i\
    \ = planet1_index + 1; i < planet2_index; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = planet2_index + 1; i < planet1_index;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> result;\n\tint index1 = 0;\n\tint index2 = 0;\n\
    \tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\
    \t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tindex2 = i;\n\
    \t\t}\n\t}\n\tif (index1 == 0 || index2 == 0) {\n\t\treturn result;\n\t}\n\tif\
    \ (index1 < index2) {\n\t\tfor (int i = index1 + 1; i < index2; i++) {\n\t\t\t\
    result.push_back(planets[i]);\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = index2 +\
    \ 1; i < index1; i++) {\n\t\t\tresult.push_back(planets[i]);\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpb8afizj0: /tmp/tmpb8afizj0.cpp:50: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        for (int k = j +\
    \ 1; k < i; k++) {\n            result.push_back(planets[k]);\n        }\n   \
    \ } else {\n        for (int k = i + 1; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpugav6lh1: /tmp/tmpugav6lh1.cpp:51: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> result;\n  int i1 = -1, i2 = -1;\n  for (int i\
    \ = 0; i < planets.size(); i++) {\n    if (planets[i] == planet1) {\n      i1\
    \ = i;\n    }\n    if (planets[i] == planet2) {\n      i2 = i;\n    }\n  }\n \
    \ if (i1 == -1 || i2 == -1) {\n    return result;\n  }\n  if (i1 < i2) {\n   \
    \ for (int i = i1 + 1; i < i2; i++) {\n      result.push_back(planets[i]);\n \
    \   }\n  } else {\n    for (int i = i2 + 1; i < i1; i++) {\n      result.push_back(planets[i]);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = bf;\n   \
    \ assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    while (planets[i]\
    \ != planet1) {\n        i++;\n    }\n    int j = 0;\n    while (planets[j] !=\
    \ planet2) {\n        j++;\n    }\n    if (i > j) {\n        for (int k = j; k\
    \ < i; k++) {\n            result.push_back(planets[k]);\n        }\n    } else\
    \ {\n        for (int k = i; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp4g8nl0_d: /tmp/tmp4g8nl0_d.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        std::swap(i, j);\n\
    \    }\n    for (int k = i + 1; k < j; k++) {\n        result.push_back(planets[k]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmprx6zzimi: /tmp/tmprx6zzimi.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++) {\n\
    \            res.push_back(planets[i]);\n        }\n    } else {\n        for\
    \ (int i = p2 + 1; i < p1; i++) {\n            res.push_back(planets[i]);\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int pos1 = -1, pos2 = -1;\n    for\
    \ (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n\
    \            pos1 = i;\n        }\n        if (planets[i] == planet2) {\n    \
    \        pos2 = i;\n        }\n    }\n    if (pos1 == -1 || pos2 == -1) {\n  \
    \      return result;\n    }\n    if (pos1 < pos2) {\n        for (int i = pos1\
    \ + 1; i < pos2; i++) {\n            result.push_back(planets[i]);\n        }\n\
    \    } else {\n        for (int i = pos2 + 1; i < pos1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 > p2) {\n        int tmp = p1;\n        p1 = p2;\n\
    \        p2 = tmp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 > p2) {\n        int tmp = p1;\n        p1 = p2;\n\
    \        p2 = tmp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint p1 = -1, p2 = -1;\n\tfor (int i\
    \ = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tp1\
    \ = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tp2 = i;\n\t\t}\n\t}\n\t\
    if (p1 == -1 || p2 == -1) {\n\t\treturn result;\n\t}\n\tif (p1 > p2) {\n\t\tint\
    \ temp = p1;\n\t\tp1 = p2;\n\t\tp2 = temp;\n\t}\n\tfor (int i = p1 + 1; i < p2;\
    \ i++) {\n\t\tresult.push_back(planets[i]);\n\t}\n\treturn result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 && end == 0) {\n \
    \       return res;\n    }\n    if (start > end) {\n        std::swap(start, end);\n\
    \    }\n    for (int i = start + 1; i < end; i++) {\n        res.push_back(planets[i]);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp3js1m1o3: /tmp/tmp3js1m1o3.cpp:51: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == planets.size()\
    \ || index2 == planets.size()) {\n        return result;\n    }\n    if (index1\
    \ > index2) {\n        std::swap(index1, index2);\n    }\n    for (int i = index1\
    \ + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    while (planets[i]\
    \ != planet1) {\n        i++;\n    }\n    int j = 0;\n    while (planets[j] !=\
    \ planet2) {\n        j++;\n    }\n    if (i > j) {\n        for (int k = j; k\
    \ < i; k++) {\n            result.push_back(planets[k]);\n        }\n    } else\
    \ {\n        for (int k = i; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp4g8nl0_d: /tmp/tmp4g8nl0_d.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet1_index = -1;\n    int\
    \ planet2_index = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            planet1_index = i;\n        }\n \
    \       if (planets[i] == planet2) {\n            planet2_index = i;\n       \
    \ }\n    }\n    if (planet1_index == -1 || planet2_index == -1) {\n        return\
    \ result;\n    }\n    if (planet1_index < planet2_index) {\n        for (int i\
    \ = planet1_index + 1; i < planet2_index; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = planet2_index + 1; i < planet1_index;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 > p2) std::swap(p1, p2);\n    for (int i = p1 +\
    \ 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = 0;\n    int index2\
    \ = 0;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == 0 ||\
    \ index2 == 0) {\n        return result;\n    }\n    if (index1 < index2) {\n\
    \        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpw3rnl9v5: /tmp/tmpw3rnl9v5.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i1 = -1, i2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) i1 = i;\n\
    \        if (planets[i] == planet2) i2 = i;\n    }\n    if (i1 == -1 || i2 ==\
    \ -1) return result;\n    if (i1 > i2) std::swap(i1, i2);\n    for (int i = i1\
    \ + 1; i < i2; i++) {\n        result.push_back(planets[i]);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            res.push_back(planets[i]);\n        }\n    } else {\n       \
    \ for (int i = p2 + 1; i < p1; i++) {\n            res.push_back(planets[i]);\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 && end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmps3zj7bye: /tmp/tmps3zj7bye.cpp:53: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n      \
    \  \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\
    \n    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n\
    \    for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        std::swap(i, j);\n\
    \    }\n    for (int k = i + 1; k < j; k++) {\n        result.push_back(planets[k]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpyjfqe_kp: /tmp/tmpyjfqe_kp.cpp:57: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n\
    \            break;\n        }\n    }\n    for (j = 0; j < planets.size(); j++)\
    \ {\n        if (planets[j] == planet2) {\n            break;\n        }\n   \
    \ }\n    if (i == planets.size() || j == planets.size()) {\n        return result;\n\
    \    }\n    if (i < j) {\n        for (int k = i + 1; k < j; k++) {\n        \
    \    result.push_back(planets[k]);\n        }\n    } else {\n        for (int\
    \ k = j + 1; k < i; k++) {\n            result.push_back(planets[k]);\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n \
    \   assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int pos1 = -1, pos2 = -1;\n    for\
    \ (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n\
    \            pos1 = i;\n        }\n        if (planets[i] == planet2) {\n    \
    \        pos2 = i;\n        }\n    }\n    if (pos1 == -1 || pos2 == -1) {\n  \
    \      return result;\n    }\n    if (pos1 > pos2) {\n        std::swap(pos1,\
    \ pos2);\n    }\n    for (int i = pos1 + 1; i < pos2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 && end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        for (int i = end;\
    \ i < start; i++) {\n            result.push_back(planets[i]);\n        }\n  \
    \  } else {\n        for (int i = start; i < end; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpxv2u_kjg: /tmp/tmpxv2u_kjg.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int i1 = -1, i2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          i1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    i2 = i;\n        }\n    }\n    if (i1 == -1 || i2 == -1) {\n        return\
    \ res;\n    }\n    if (i1 > i2) {\n        std::swap(i1, i2);\n    }\n    for\
    \ (int i = i1 + 1; i < i2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 || end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpzyzxlm6z: /tmp/tmpzyzxlm6z.cpp:46: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        std::swap(start,\
    \ end);\n    }\n    for (int i = start + 1; i < end; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet1_index = -1;\n    int\
    \ planet2_index = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            planet1_index = i;\n        }\n \
    \       if (planets[i] == planet2) {\n            planet2_index = i;\n       \
    \ }\n    }\n    if (planet1_index == -1 || planet2_index == -1) {\n        return\
    \ result;\n    }\n    if (planet1_index > planet2_index) {\n        int temp =\
    \ planet1_index;\n        planet1_index = planet2_index;\n        planet2_index\
    \ = temp;\n    }\n    for (int i = planet1_index + 1; i < planet2_index; i++)\
    \ {\n        result.push_back(planets[i]);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 > p2) std::swap(p1, p2);\n    for (int i = p1 +\
    \ 1; i < p2; i++) res.push_back(planets[i]);\n    return res;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> result;\n\tint p1 = -1, p2 = -1;\n\tfor (int\
    \ i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\t\
    p1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tp2 = i;\n\t\t}\n\t}\n\t\
    if (p1 == -1 || p2 == -1) {\n\t\treturn result;\n\t}\n\tif (p1 > p2) {\n\t\tstd::swap(p1,\
    \ p2);\n\t}\n\tfor (int i = p1 + 1; i < p2; i++) {\n\t\tresult.push_back(planets[i]);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int i = 0;\n    while (planets[i] !=\
    \ planet1) {\n        i++;\n    }\n    int j = 0;\n    while (planets[j] != planet2)\
    \ {\n        j++;\n    }\n    if (i > j) {\n        for (int k = j; k < i; k++)\
    \ {\n            res.push_back(planets[k]);\n        }\n    } else {\n       \
    \ for (int k = i; k < j; k++) {\n            res.push_back(planets[k]);\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpsl7rzqpp: /tmp/tmpsl7rzqpp.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i\
    \ < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int i = 0;\n    while (planets[i] !=\
    \ planet1) {\n        i++;\n    }\n    int j = 0;\n    while (planets[j] != planet2)\
    \ {\n        j++;\n    }\n    if (i > j) {\n        std::swap(i, j);\n    }\n\
    \    for (int k = i + 1; k < j; k++) {\n        res.push_back(planets[k]);\n \
    \   }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        for (int k = j;\
    \ k < i; k++) {\n            result.push_back(planets[k]);\n        }\n    } else\
    \ {\n        for (int k = i; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpri0actla: /tmp/tmpri0actla.cpp:45: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        std::swap(index1, index2);\n    }\n    for (int i = index1 + 1; i\
    \ < index2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int i = 0;\n    while (i < planets.size()\
    \ && planets[i] != planet1) {\n        i++;\n    }\n    if (i == planets.size())\
    \ {\n        return res;\n    }\n    int j = i;\n    while (j < planets.size()\
    \ && planets[j] != planet2) {\n        j++;\n    }\n    if (j == planets.size())\
    \ {\n        return res;\n    }\n    for (int k = i + 1; k < j; k++) {\n     \
    \   res.push_back(planets[k]);\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmps49bp_bc: /tmp/tmps49bp_bc.cpp:44: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 > p2) {\n        int tmp = p1;\n        p1 =\
    \ p2;\n        p2 = tmp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n   \
    \     result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet1_index = -1;\n    int\
    \ planet2_index = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            planet1_index = i;\n        }\n \
    \       if (planets[i] == planet2) {\n            planet2_index = i;\n       \
    \ }\n    }\n    if (planet1_index == -1 || planet2_index == -1) {\n        return\
    \ result;\n    }\n    if (planet1_index < planet2_index) {\n        for (int i\
    \ = planet1_index + 1; i < planet2_index; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = planet2_index + 1; i < planet1_index;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    } else {\n\
    \        for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++) {\n\
    \            res.push_back(planets[i]);\n        }\n    } else {\n        for\
    \ (int i = p2 + 1; i < p1; i++) {\n            res.push_back(planets[i]);\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ res;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> result;\n  int p1 = -1, p2 = -1;\n  for (int i\
    \ = 0; i < planets.size(); i++) {\n    if (planets[i] == planet1) {\n      p1\
    \ = i;\n    }\n    if (planets[i] == planet2) {\n      p2 = i;\n    }\n  }\n \
    \ if (p1 == -1 || p2 == -1) {\n    return result;\n  }\n  if (p1 > p2) {\n   \
    \ std::swap(p1, p2);\n  }\n  for (int i = p1 + 1; i < p2; i++) {\n    result.push_back(planets[i]);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int pos1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int pos2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (pos1 == 8 || pos2 == 8)\
    \ {\n        return result;\n    }\n    if (pos1 > pos2) {\n        std::swap(pos1,\
    \ pos2);\n    }\n    for (int i = pos1 + 1; i < pos2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet1_index = -1;\n    int\
    \ planet2_index = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            planet1_index = i;\n        }\n \
    \       if (planets[i] == planet2) {\n            planet2_index = i;\n       \
    \ }\n    }\n    if (planet1_index == -1 || planet2_index == -1) {\n        return\
    \ result;\n    }\n    if (planet1_index < planet2_index) {\n        for (int i\
    \ = planet1_index + 1; i < planet2_index; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = planet2_index + 1; i < planet1_index;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 > p2) {\n        int temp = p1;\n        p1 =\
    \ p2;\n        p2 = temp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n  \
    \      result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        for (int k = j +\
    \ 1; k < i; k++) {\n            result.push_back(planets[k]);\n        }\n   \
    \ } else {\n        for (int k = i + 1; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpugav6lh1: /tmp/tmpugav6lh1.cpp:51: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint start = 0;\n\tint end = 0;\n\tfor\
    \ (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\
    \t\tstart = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tend = i;\n\t\t\
    }\n\t}\n\tif (start == 0 || end == 0) {\n\t\treturn result;\n\t}\n\tif (start\
    \ > end) {\n\t\tfor (int i = end; i < start; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t} else {\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp00k6_ucr: /tmp/tmp00k6_ucr.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = 0;\n    int index2\
    \ = 0;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == 0 ||\
    \ index2 == 0) {\n        return result;\n    }\n    if (index1 < index2) {\n\
    \        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpw3rnl9v5: /tmp/tmpw3rnl9v5.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 || end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdugd0zqe: /tmp/tmpdugd0zqe.cpp:48: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 || end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdugd0zqe: /tmp/tmpdugd0zqe.cpp:48: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int p2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (p1 == planets.size() ||\
    \ p2 == planets.size()) {\n        return result;\n    }\n    if (p1 > p2) {\n\
    \        std::swap(p1, p2);\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n\
    \        result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> res;\n  int p1 = -1, p2 = -1;\n  for (int i = 0;\
    \ i < planets.size(); i++) {\n    if (planets[i] == planet1) p1 = i;\n    if (planets[i]\
    \ == planet2) p2 = i;\n  }\n  if (p1 == -1 || p2 == -1) return res;\n  if (p1\
    \ > p2) std::swap(p1, p2);\n  for (int i = p1 + 1; i < p2; i++) {\n    res.push_back(planets[i]);\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> result;\n\tint pos1 = -1, pos2 = -1;\n\tfor (int\
    \ i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\t\
    pos1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tpos2 = i;\n\t\t}\n\t\
    }\n\tif (pos1 == -1 || pos2 == -1) {\n\t\treturn result;\n\t}\n\tif (pos1 < pos2)\
    \ {\n\t\tfor (int i = pos1 + 1; i < pos2; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t}\n\telse {\n\t\tfor (int i = pos2 + 1; i < pos1; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint index1 = -1;\n\tint index2 = -1;\n\
    \tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\
    \t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tindex2 = i;\n\
    \t\t}\n\t}\n\tif (index1 == -1 || index2 == -1) {\n\t\treturn result;\n\t}\n\t\
    if (index1 > index2) {\n\t\tfor (int i = index2; i < index1; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t} else {\n\t\tfor (int i = index1; i < index2; i++) {\n\t\t\tresult.push_back(planets[i]);\n\
    \t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmphxraaoo2: /tmp/tmphxraaoo2.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        for (int k = j;\
    \ k < i; k++) {\n            result.push_back(planets[k]);\n        }\n    } else\
    \ {\n        for (int k = i; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpri0actla: /tmp/tmpri0actla.cpp:45: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n  std::vector<std::string> result;\n  int index1 = -1;\n  int index2 = -1;\n\
    \  for (int i = 0; i < planets.size(); i++) {\n    if (planets[i] == planet1)\
    \ {\n      index1 = i;\n    }\n    if (planets[i] == planet2) {\n      index2\
    \ = i;\n    }\n  }\n  if (index1 == -1 || index2 == -1) {\n    return result;\n\
    \  }\n  if (index1 < index2) {\n    for (int i = index1 + 1; i < index2; i++)\
    \ {\n      result.push_back(planets[i]);\n    }\n  } else {\n    for (int i =\
    \ index2 + 1; i < index1; i++) {\n      result.push_back(planets[i]);\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (auto planet : planets) {\n        if (planet == planet1) {\n          \
    \  i = std::distance(planets.begin(), std::find(planets.begin(), planets.end(),\
    \ planet));\n        }\n        if (planet == planet2) {\n            j = std::distance(planets.begin(),\
    \ std::find(planets.begin(), planets.end(), planet));\n        }\n    }\n    if\
    \ (i == 0 || j == 0) {\n        return result;\n    }\n    if (i > j) {\n    \
    \    std::swap(i, j);\n    }\n    for (int k = i + 1; k < j; k++) {\n        result.push_back(planets[k]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp7nxi6u4g: /tmp/tmp7nxi6u4g.cpp:46: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int first = -1;\n    int second\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            first = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            second = i;\n        }\n    }\n    if (first == -1 ||\
    \ second == -1) {\n        return result;\n    }\n    if (first < second) {\n\
    \        for (int i = first + 1; i < second; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = second + 1; i < first; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        int temp = p1;\n        p1 = p2;\n\
    \        p2 = temp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = 0;\n    int index2\
    \ = 0;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == 0 ||\
    \ index2 == 0) {\n        return result;\n    }\n    if (index1 < index2) {\n\
    \        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpw3rnl9v5: /tmp/tmpw3rnl9v5.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = 0;\n    int index2\
    \ = 0;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == 0 ||\
    \ index2 == 0) {\n        return result;\n    }\n    if (index1 > index2) {\n\
    \        for (int i = index2 + 1; i < index1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index1 + 1; i < index2; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpdl876nuq: /tmp/tmpdl876nuq.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057259
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    while (planets[i]\
    \ != planet1) {\n        i++;\n    }\n    int j = 0;\n    while (planets[j] !=\
    \ planet2) {\n        j++;\n    }\n    if (i > j) {\n        for (int k = j; k\
    \ < i; k++) {\n            result.push_back(planets[k]);\n        }\n    } else\
    \ {\n        for (int k = i; k < j; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp4g8nl0_d: /tmp/tmp4g8nl0_d.cpp:43: int main(): Assertion `candidate(("Jupiter"),
    ("Neptune")) == (std::vector<std::string>({(std::string)"Saturn", (std::string)"Uranus"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return result;\n    }\n    if (start > end) {\n        int temp = start;\n\
    \        start = end;\n        end = temp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\n        \"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"\n    };\n    std::vector<std::string> result;\n    int start = -1;\n\
    \    int end = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if\
    \ (planets[i] == planet1) {\n            start = i;\n        }\n        if (planets[i]\
    \ == planet2) {\n            end = i;\n        }\n    }\n    if (start == -1 ||\
    \ end == -1) {\n        return result;\n    }\n    if (start > end) {\n      \
    \  std::swap(start, end);\n    }\n    for (int i = start + 1; i < end; i++) {\n\
    \        result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2; i++)\
    \ {\n            result.push_back(planets[i]);\n        }\n    } else {\n    \
    \    for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> res;\n\tint i1 = -1, i2 = -1;\n\tfor (int i = 0;\
    \ i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) i1 = i;\n\t\tif (planets[i]\
    \ == planet2) i2 = i;\n\t}\n\tif (i1 == -1 || i2 == -1) return res;\n\tif (i1\
    \ > i2) std::swap(i1, i2);\n\tfor (int i = i1 + 1; i < i2; i++) {\n\t\tres.push_back(planets[i]);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057260
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint index1 = -1;\n\tint index2 = -1;\n\
    \tfor (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\
    \t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tindex2 = i;\n\
    \t\t}\n\t}\n\tif (index1 == -1 || index2 == -1) {\n\t\treturn result;\n\t}\n\t\
    if (index1 < index2) {\n\t\tfor (int i = index1 + 1; i < index2; i++) {\n\t\t\t\
    result.push_back(planets[i]);\n\t\t}\n\t} else {\n\t\tfor (int i = index2 + 1;\
    \ i < index1; i++) {\n\t\t\tresult.push_back(planets[i]);\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int pos1 = -1, pos2 = -1;\n    for\
    \ (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n\
    \            pos1 = i;\n        }\n        if (planets[i] == planet2) {\n    \
    \        pos2 = i;\n        }\n    }\n    if (pos1 == -1 || pos2 == -1) {\n  \
    \      return result;\n    }\n    if (pos1 > pos2) {\n        std::swap(pos1,\
    \ pos2);\n    }\n    for (int i = pos1 + 1; i < pos2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == planets.size()\
    \ || index2 == planets.size()) {\n        return result;\n    }\n    if (index1\
    \ < index2) {\n        for (int i = index1 + 1; i < index2; i++) {\n         \
    \   result.push_back(planets[i]);\n        }\n    } else {\n        for (int i\
    \ = index2 + 1; i < index1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057260
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> result;\n\tint start = 0;\n\tint end = 0;\n\tfor\
    \ (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\
    \t\tstart = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tend = i;\n\t\t\
    }\n\t}\n\tif (start == 0 && end == 0) {\n\t\treturn result;\n\t}\n\tif (start\
    \ > end) {\n\t\tint temp = start;\n\t\tstart = end;\n\t\tend = temp;\n\t}\n\t\
    for (int i = start + 1; i < end; i++) {\n\t\tresult.push_back(planets[i]);\n\t\
    }\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp16evtqbn: /tmp/tmp16evtqbn.cpp:53: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 || end == 0) {\n \
    \       return res;\n    }\n    if (start > end) {\n        int tmp = start;\n\
    \        start = end;\n        end = tmp;\n    }\n    for (int i = start + 1;\
    \ i < end; i++) {\n        res.push_back(planets[i]);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmpieui3tg6: /tmp/tmpieui3tg6.cpp:48: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = 0, p2 = 0;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 > p2) {\n        for (int i = p2 +\
    \ 1; i < p1; i++) {\n            result.push_back(planets[i]);\n        }\n  \
    \  } else {\n        for (int i = p1 + 1; i < p2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmpuajr52ee: /tmp/tmpuajr52ee.cpp:50: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int planet1_index = -1;\n    int\
    \ planet2_index = -1;\n    for (int i = 0; i < planets.size(); i++) {\n      \
    \  if (planets[i] == planet1) {\n            planet1_index = i;\n        }\n \
    \       if (planets[i] == planet2) {\n            planet2_index = i;\n       \
    \ }\n    }\n    if (planet1_index == -1 || planet2_index == -1) {\n        return\
    \ result;\n    }\n    if (planet1_index < planet2_index) {\n        for (int i\
    \ = planet1_index + 1; i < planet2_index; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = planet2_index + 1; i < planet1_index;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    while (i < planets.size()\
    \ && planets[i] != planet1) {\n        i++;\n    }\n    if (i == planets.size())\
    \ {\n        return result;\n    }\n    int j = 0;\n    while (j < planets.size()\
    \ && planets[j] != planet2) {\n        j++;\n    }\n    if (j == planets.size())\
    \ {\n        return result;\n    }\n    if (i < j) {\n        for (int k = i +\
    \ 1; k < j; k++) {\n            result.push_back(planets[k]);\n        }\n   \
    \ } else {\n        for (int k = j + 1; k < i; k++) {\n            result.push_back(planets[k]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057260
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int start = -1;\n    int end = -1;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == -1 || end == -1) {\n\
    \        return res;\n    }\n    for (int i = start + 1; i < end; i++) {\n   \
    \     res.push_back(planets[i]);\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: Exception
  stderr: 'tmp1k8kdxwp: /tmp/tmp1k8kdxwp.cpp:43: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057260
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> res;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return res;\n    if (p1 > p2) std::swap(p1, p2);\n    for (int i = p1 +\
    \ 1; i < p2; i++) {\n        res.push_back(planets[i]);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int i = 0;\n    int j = 0;\n   \
    \ for (int k = 0; k < planets.size(); k++) {\n        if (planets[k] == planet1)\
    \ {\n            i = k;\n        }\n        if (planets[k] == planet2) {\n   \
    \         j = k;\n        }\n    }\n    if (i > j) {\n        std::swap(i, j);\n\
    \    }\n    for (int k = i + 1; k < j; k++) {\n        result.push_back(planets[k]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmprx6zzimi: /tmp/tmprx6zzimi.cpp:48: int main(): Assertion `candidate(("Jupiter"),
    ("Makemake")) == (std::vector<std::string>())'' failed.

    '
  stdout: ''
  timestamp: 1660057258
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 < p2) {\n        for (int i = p1 + 1; i < p2;\
    \ i++) {\n            result.push_back(planets[i]);\n        }\n    } else {\n\
    \        for (int i = p2 + 1; i < p1; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for\
    \ (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 > index2)\
    \ {\n        int temp = index1;\n        index1 = index2;\n        index2 = temp;\n\
    \    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> result;\n\tint index1 = -1, index2 = -1;\n\t\
    for (int i = 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\
    \t\t\tindex1 = i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tindex2 = i;\n\
    \t\t}\n\t}\n\tif (index1 == -1 || index2 == -1) {\n\t\treturn result;\n\t}\n\t\
    if (index1 < index2) {\n\t\tfor (int i = index1 + 1; i < index2; i++) {\n\t\t\t\
    result.push_back(planets[i]);\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = index2 +\
    \ 1; i < index1; i++) {\n\t\t\tresult.push_back(planets[i]);\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057260
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n\tstd::vector<std::string> res;\n\tint p1 = -1, p2 = -1;\n\tfor (int i = 0;\
    \ i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) p1 = i;\n\t\tif (planets[i]\
    \ == planet2) p2 = i;\n\t}\n\tif (p1 == -1 || p2 == -1) return res;\n\tif (p1\
    \ > p2) {\n\t\tint tmp = p1;\n\t\tp1 = p2;\n\t\tp2 = tmp;\n\t}\n\tfor (int i =\
    \ p1 + 1; i < p2; i++) {\n\t\tres.push_back(planets[i]);\n\t}\n\treturn res;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057260
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int start = 0;\n    int end = 0;\n\
    \    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1)\
    \ {\n            start = i;\n        }\n        if (planets[i] == planet2) {\n\
    \            end = i;\n        }\n    }\n    if (start == 0 || end == 0) {\n \
    \       return result;\n    }\n    if (start > end) {\n        for (int i = end\
    \ + 1; i < start; i++) {\n            result.push_back(planets[i]);\n        }\n\
    \    } else {\n        for (int i = start + 1; i < end; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"\
    Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"\
    Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: Exception
  stderr: 'tmp7zirlkwz: /tmp/tmp7zirlkwz.cpp:49: int main(): Assertion `candidate(("Earth"),
    ("Mercury")) == (std::vector<std::string>({(std::string)"Venus"}))'' failed.

    '
  stdout: ''
  timestamp: 1660057260
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = -1;\n    int index2\
    \ = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i]\
    \ == planet1) {\n            index1 = i;\n        }\n        if (planets[i] ==\
    \ planet2) {\n            index2 = i;\n        }\n    }\n    if (index1 == -1\
    \ || index2 == -1) {\n        return result;\n    }\n    if (index1 < index2)\
    \ {\n        for (int i = index1 + 1; i < index2; i++) {\n            result.push_back(planets[i]);\n\
    \        }\n    } else {\n        for (int i = index2 + 1; i < index1; i++) {\n\
    \            result.push_back(planets[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"\
    Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) p1 = i;\n\
    \        if (planets[i] == planet2) p2 = i;\n    }\n    if (p1 == -1 || p2 ==\
    \ -1) return result;\n    if (p1 > p2) {\n        int tmp = p1;\n        p1 =\
    \ p2;\n        p2 = tmp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n   \
    \     result.push_back(planets[i]);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"\
    })));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"\
    Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\"\
    )) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\"\
    , (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057259
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int index1 = std::find(planets.begin(),\
    \ planets.end(), planet1) - planets.begin();\n    int index2 = std::find(planets.begin(),\
    \ planets.end(), planet2) - planets.begin();\n    if (index1 == 8 || index2 ==\
    \ 8) {\n        return result;\n    }\n    if (index1 > index2) {\n        std::swap(index1,\
    \ index2);\n    }\n    for (int i = index1 + 1; i < index2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::vector<std::string> planets = { \"Mercury\",\
    \ \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ };\n\tstd::vector<std::string> res;\n\tint p1 = -1, p2 = -1;\n\tfor (int i =\
    \ 0; i < planets.size(); i++) {\n\t\tif (planets[i] == planet1) {\n\t\t\tp1 =\
    \ i;\n\t\t}\n\t\tif (planets[i] == planet2) {\n\t\t\tp2 = i;\n\t\t}\n\t}\n\tif\
    \ (p1 == -1 || p2 == -1) {\n\t\treturn res;\n\t}\n\tif (p1 > p2) {\n\t\tstd::swap(p1,\
    \ p2);\n\t}\n\tfor (int i = p1 + 1; i < p2; i++) {\n\t\tres.push_back(planets[i]);\n\
    \t}\n\treturn res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057261
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"\
    Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"\
    Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"\
    Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\"\
    , (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int\
    \ i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n  \
    \          p1 = i;\n        }\n        if (planets[i] == planet2) {\n        \
    \    p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return\
    \ result;\n    }\n    if (p1 > p2) {\n        int temp = p1;\n        p1 = p2;\n\
    \        p2 = temp;\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\"\
    )) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\"\
    , (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"\
    Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"\
    Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"\
    , (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\"))\
    \ == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"\
    Makemake\")) == (std::vector<std::string>()));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660057257
